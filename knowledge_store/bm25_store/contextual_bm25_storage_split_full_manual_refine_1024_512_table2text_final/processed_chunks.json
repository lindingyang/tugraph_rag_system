[
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_1.md",
        "chunks": [
            {
                "content": "# 可视化操作手册\n\n> 此文档主要介绍 TuGraph Browser 的使用和操作方法。\n\n## 1.简介\n\nTuGraph Browser（以下简称Browser）是一款功能强大的产品可视化开发工具，它以直观的可视化方式呈现图数据，使用户可以轻松地管理、维护和查看数据库运行状态。此工具不仅支持图数据的管理和可视化，还支持对系统账户的管理，为用户提供了全面的操作和管理体验，让用户能够更加高效地管理和利用图数据库。\n\nTuGraph DB BROWSER 是 TuGraph 图数据库的可视化平台。可以完成图谱、模型、数据等的创建和导入。同时可用使用 TuGraph Cypher 进行数据的操作。\n\n## 2.操作指南\n\n### 2.1.访问\n\n当用户完成图数据库的安装后，可以通过浏览器访问Browser。用户只需要在浏览器地址栏输入：TuGraph 所在服务器的 IP:Port。默认的端口使用的是 7070。\n\n- 例如：127.0.0.1:7070。\n- 推荐使用Chrome。\n\n### 2.2.登录\n\n- 浏览器成功访问Browser后，首先进入的是登录页面（如上图所示），用户需要填写账号和密码进行登录。\n- 数据库地址格式为：ip:bolt_port。\n- 默认账号：admin。\n- 默认密码：73@TuGraph。\n- 用户首次登录后，会跳转至修改密码页面，密码修改成功后，使用新密码重新登录即可使用。\n\n### 2.3.快速上手\n\n对于首次使用TuGraph的用户，可以通过产品内置的demo数据快速构建一个图项目，快速上手图数据项目。\n\n#### 2.3.1.创建图项目\n\n在`图项目`首页的选项卡中，点击`新建图项目`创建新的图项目。\n\n选择一个产品内置的demo数据，点击`下一步`按钮。\n\n在`填写配置`界面输入图项目信息，demo数据量都相对较小，`最大存储空间`设置为1G即可。输入完图项目信息后，点击`创建`按钮后，系统会自动创建demo数据的图模型、导入图数据。\n\n#### 2.3.2.开始图项目\n\ndemo数据的图项目创建完成后，可以在`图项目`的选项卡中找到相应的图项目，可以点击`图查询`查询图数据。\n\n执行默认的查询语句，浏览demo里的图数据。\n\n### 2.4.图项目\n\n该文档介绍了TuGraph Browser的使用及操作指南，主要包括Browser的简介、访问与登录方法以及快速上手指导。文中详细说明了如何创建和管理图项目，特别是在图数据可视化与操作方面的功能。"
            },
            {
                "content": "- 浏览器成功访问Browser后，首先进入的是登录页面（如上图所示），用户需要填写账号和密码进行登录。\n- 数据库地址格式为：ip:bolt_port。\n- 默认账号：admin。\n- 默认密码：73@TuGraph。\n- 用户首次登录后，会跳转至修改密码页面，密码修改成功后，使用新密码重新登录即可使用。\n\n### 2.3.快速上手\n\n对于首次使用TuGraph的用户，可以通过产品内置的demo数据快速构建一个图项目，快速上手图数据项目。\n\n#### 2.3.1.创建图项目\n\n在`图项目`首页的选项卡中，点击`新建图项目`创建新的图项目。\n\n选择一个产品内置的demo数据，点击`下一步`按钮。\n\n在`填写配置`界面输入图项目信息，demo数据量都相对较小，`最大存储空间`设置为1G即可。输入完图项目信息后，点击`创建`按钮后，系统会自动创建demo数据的图模型、导入图数据。\n\n#### 2.3.2.开始图项目\n\ndemo数据的图项目创建完成后，可以在`图项目`的选项卡中找到相应的图项目，可以点击`图查询`查询图数据。\n\n执行默认的查询语句，浏览demo里的图数据。\n\n### 2.4.图项目\n\n`图项目`提供可视化的图项目管理和图数据研发功能，它为用户提供了一系列便捷的图数据可视化操作，包括图项目的创建、修改、删除等管理操作，以及图数据的查询、点边统计等操作。此外，它也支持图模型的管理，使用户可以更加方便地进行图数据的管理和维护。\n\n#### 2.4.1.图项目管理\n\n在`图项目`界面，可以看到当前图数据库中的图项目。\n\n##### 2.4.1.1.新建图项目\n\n在`图项目`界面，点击`新建图项目`按钮创建一个新的图项目。\n\n新建图项目需要通过`选择模板`和`填写配置`两个页面完成图项目的创建。\n\n- __选择模板__：产品提供空模板和demo模板两类模板。\n    - 空模板：全新的图项目，用户需要自己创建图模型和导入图数据，一般用于正式项目开发。\n    - demo模板：产品内置的demo数据，图项目创建成功后，系统会自动创建demo图模型并导入demo图数据，一般用于试用和学习。\n\n该段落位于操作指南部分，主要介绍用户在成功访问TuGraph Browser后需要进行的登录步骤及之后的快速上手操作，包括创建图项目和查询图数据的基本流程。这对首次使用TuGraph的用户尤其重要，有助于引导他们快速熟悉系统的使用。"
            },
            {
                "content": "demo数据的图项目创建完成后，可以在`图项目`的选项卡中找到相应的图项目，可以点击`图查询`查询图数据。\n\n执行默认的查询语句，浏览demo里的图数据。\n\n### 2.4.图项目\n\n`图项目`提供可视化的图项目管理和图数据研发功能，它为用户提供了一系列便捷的图数据可视化操作，包括图项目的创建、修改、删除等管理操作，以及图数据的查询、点边统计等操作。此外，它也支持图模型的管理，使用户可以更加方便地进行图数据的管理和维护。\n\n#### 2.4.1.图项目管理\n\n在`图项目`界面，可以看到当前图数据库中的图项目。\n\n##### 2.4.1.1.新建图项目\n\n在`图项目`界面，点击`新建图项目`按钮创建一个新的图项目。\n\n新建图项目需要通过`选择模板`和`填写配置`两个页面完成图项目的创建。\n\n- __选择模板__：产品提供空模板和demo模板两类模板。\n    - 空模板：全新的图项目，用户需要自己创建图模型和导入图数据，一般用于正式项目开发。\n    - demo模板：产品内置的demo数据，图项目创建成功后，系统会自动创建demo图模型并导入demo图数据，一般用于试用和学习。\n\n- __填写配置__：用户需要填写图项目基本信息，并点击`创建`按钮创建图项目。\n    - 图名称：新建图项目的名称，同时作为该图项目的唯一主键。支持中文、字母、数字以及下划线，不支持空格以及其他特殊符号。\n    - 图描述：新建图项目的描述，可用于详细说明该项目的背景和目标。\n    - 高级配置-最大存储空间：设置图项目最大可占用的存储空间，实际并不会提前占用物理存储空间，实际数据量达到最大存储空间阈值后不可再写入数据。\n\n创建成功后，可在`图项目`页面的图项目选项卡中查看。\n\n##### 2.4.1.2.编辑图项目\n\n在`图项目`界面，点击图项目选项卡中的`编辑`按钮（笔形图标），编辑对应图项目的基础信息。\n\n编辑图项目功能可以修改`图描述`和`最大存储空间`。\n\n##### 2.4.1.3.删除图项目\n\n在`图项目`界面，点击图项目选项卡中的`删除`按钮（垃圾桶图标），删除对应的图项目。\n\n_需要注意：图项目删除后无法恢复_。\n\n##### 2.4.1.4.点边统计\n\n在`图项目`界面，点击图项目选项卡中的`点边统计`按钮（刷新图标），统计对应图项目当前时间节点的点边数量。\n\n该chunk位于文档的第2.4节“图项目”中，主要介绍了图项目的创建、管理、编辑、删除以及点边统计等操作，是TuGraph Browser的核心功能模块之一，旨在帮助用户高效管理和查询图数据。"
            },
            {
                "content": "- __填写配置__：用户需要填写图项目基本信息，并点击`创建`按钮创建图项目。\n    - 图名称：新建图项目的名称，同时作为该图项目的唯一主键。支持中文、字母、数字以及下划线，不支持空格以及其他特殊符号。\n    - 图描述：新建图项目的描述，可用于详细说明该项目的背景和目标。\n    - 高级配置-最大存储空间：设置图项目最大可占用的存储空间，实际并不会提前占用物理存储空间，实际数据量达到最大存储空间阈值后不可再写入数据。\n\n创建成功后，可在`图项目`页面的图项目选项卡中查看。\n\n##### 2.4.1.2.编辑图项目\n\n在`图项目`界面，点击图项目选项卡中的`编辑`按钮（笔形图标），编辑对应图项目的基础信息。\n\n编辑图项目功能可以修改`图描述`和`最大存储空间`。\n\n##### 2.4.1.3.删除图项目\n\n在`图项目`界面，点击图项目选项卡中的`删除`按钮（垃圾桶图标），删除对应的图项目。\n\n_需要注意：图项目删除后无法恢复_。\n\n##### 2.4.1.4.点边统计\n\n在`图项目`界面，点击图项目选项卡中的`点边统计`按钮（刷新图标），统计对应图项目当前时间节点的点边数量。\n\n统计结果将展示在图项目选项卡上，已经统计过点边数据的图项目再次统计需要点击`刷新`按钮。\n\n##### 2.4.1.5.存储过程\n\n在`图项目`界面，点击图项目选项卡中的`存储过程`按钮（卡片最右侧图标），跳转到操作存储过程的图页面。\n\n在`存储过程`页面，可以新建存储过程，新建时需要填写\"存储过程名称\"、\"存储过程类型\"、\"存储过程描述\"，然后选择\"版本\"和\"执行时是否修改数据库\"\n\n#### 2.4.2.图构建\n\nBrowser的`图构建`功能主要用于图项目的模型定义和数据导入。在`图项目`页面中，点击图项目选项卡中的`图构建`按钮。\n\n##### 2.4.2.1.模型定义\n\nBrowser提供可视化的方式创建和维护图模型。\n\n- 也可用通过`cypher`工具和`lgraph_import`工具创建和维护图模型。\n\n###### a.浏览图模型\n\n在`模型定义`界面可以查看详细的图模型设置，支持列表和画布方式查看图模型，支持列表展示点类型的属性和索引、边类型的属性和起点/终点类型。\n\n该段落位于操作指南的图项目管理部分，详细描述了创建、编辑、删除和统计图项目的操作步骤和注意事项，以及存储过程的管理。它为用户提供了图项目基本信息的填写要求和后续操作的指导，旨在帮助用户高效地管理其图数据项目。"
            },
            {
                "content": "在`图项目`界面，点击图项目选项卡中的`点边统计`按钮（刷新图标），统计对应图项目当前时间节点的点边数量。\n\n统计结果将展示在图项目选项卡上，已经统计过点边数据的图项目再次统计需要点击`刷新`按钮。\n\n##### 2.4.1.5.存储过程\n\n在`图项目`界面，点击图项目选项卡中的`存储过程`按钮（卡片最右侧图标），跳转到操作存储过程的图页面。\n\n在`存储过程`页面，可以新建存储过程，新建时需要填写\"存储过程名称\"、\"存储过程类型\"、\"存储过程描述\"，然后选择\"版本\"和\"执行时是否修改数据库\"\n\n#### 2.4.2.图构建\n\nBrowser的`图构建`功能主要用于图项目的模型定义和数据导入。在`图项目`页面中，点击图项目选项卡中的`图构建`按钮。\n\n##### 2.4.2.1.模型定义\n\nBrowser提供可视化的方式创建和维护图模型。\n\n- 也可用通过`cypher`工具和`lgraph_import`工具创建和维护图模型。\n\n###### a.浏览图模型\n\n在`模型定义`界面可以查看详细的图模型设置，支持列表和画布方式查看图模型，支持列表展示点类型的属性和索引、边类型的属性和起点/终点类型。\n\n\n- 支持列表查看点类型和边类型。\n    - 支持点类型和边类型的个数展示，在点类型或边类型页签中展示对应的点或边数量。\n    - 支持点类型和边类型的名称关键字搜索，在`搜索框`输入关键字可展示对应的点或边。\n    - 支持点类型和边类型的名称复制，点击`复制`按钮可以复制点或边的名称至粘贴板。\n    - 支持点类型和边类型的删除，点击`删除`按钮可以删除对应的点或边。\n- 支持画布方式查看点类型和边类型。\n- 在列表或画布中点击相应的点类型或边类型，可以展示模型详情。\n\n###### b.添加点\n\n在`模型定义`界面点击`添加点`按钮，在右侧滑动窗口中添加点类型。\n\n此文本块位于操作指南的\"图项目\"部分，具体涵盖了点边统计和存储过程的功能说明，紧接着介绍了图构建的相关内容，主要包括模型定义和点类型的添加方法。这部分内容旨在帮助用户理解如何进行图项目的数据统计和模型管理。"
            },
            {
                "content": "##### 2.4.2.1.模型定义\n\nBrowser提供可视化的方式创建和维护图模型。\n\n- 也可用通过`cypher`工具和`lgraph_import`工具创建和维护图模型。\n\n###### a.浏览图模型\n\n在`模型定义`界面可以查看详细的图模型设置，支持列表和画布方式查看图模型，支持列表展示点类型的属性和索引、边类型的属性和起点/终点类型。\n\n\n- 支持列表查看点类型和边类型。\n    - 支持点类型和边类型的个数展示，在点类型或边类型页签中展示对应的点或边数量。\n    - 支持点类型和边类型的名称关键字搜索，在`搜索框`输入关键字可展示对应的点或边。\n    - 支持点类型和边类型的名称复制，点击`复制`按钮可以复制点或边的名称至粘贴板。\n    - 支持点类型和边类型的删除，点击`删除`按钮可以删除对应的点或边。\n- 支持画布方式查看点类型和边类型。\n- 在列表或画布中点击相应的点类型或边类型，可以展示模型详情。\n\n###### b.添加点\n\n在`模型定义`界面点击`添加点`按钮，在右侧滑动窗口中添加点类型。\n\n用户需要输入点类型名称、属性和索引，点击`完成`按钮完成点类型的创建。\n- 点类型名称：点的名称，也是该点的唯一标识。\n- 属性：点的属性，需要一个属性作为主键。\n    - 数据类型：属性字段的数据类型，支持INT、STRING、DOUBLE、DATE、DATETIME、BLOB、BOOL等类型。\n    - 选填：该属性是否可以为空值。\n    - 删除：在创建点时可以任意删除属性。\n- 索引：点的索引属性，需要先创建属性再设置该属性为索引，索引创建成功后无法修改。\n    - 属性：需要配置索引的属性。\n    - 唯一：设置该属性字段为唯一值。\n    - 主键：对应属性是否为主键，选择`是`后`唯一`选项必须为`是`。\n    - 删除：在创建点时可以任意删除索引。\n- 编辑点：可以增加点的属性和修改已有属性的数据类型，新增或删除索引。需要对每个新增或修改的属性点击`保存`按钮才可以生效。\n_注：主键字段的属性创建后无修改_\n\n\n###### c.添加边\n\n在`模型定义`界面点击`添加边`按钮，在右侧滑动窗口中添加边类型。\n\n该chunk位于可视化操作手册的“图构建”部分，具体涵盖了“模型定义”功能的详细说明，包括浏览、添加点和添加边的步骤与注意事项。此部分为用户提供了如何创建和维护图模型的具体操作指导。"
            },
            {
                "content": "在`模型定义`界面点击`添加点`按钮，在右侧滑动窗口中添加点类型。\n\n用户需要输入点类型名称、属性和索引，点击`完成`按钮完成点类型的创建。\n- 点类型名称：点的名称，也是该点的唯一标识。\n- 属性：点的属性，需要一个属性作为主键。\n    - 数据类型：属性字段的数据类型，支持INT、STRING、DOUBLE、DATE、DATETIME、BLOB、BOOL等类型。\n    - 选填：该属性是否可以为空值。\n    - 删除：在创建点时可以任意删除属性。\n- 索引：点的索引属性，需要先创建属性再设置该属性为索引，索引创建成功后无法修改。\n    - 属性：需要配置索引的属性。\n    - 唯一：设置该属性字段为唯一值。\n    - 主键：对应属性是否为主键，选择`是`后`唯一`选项必须为`是`。\n    - 删除：在创建点时可以任意删除索引。\n- 编辑点：可以增加点的属性和修改已有属性的数据类型，新增或删除索引。需要对每个新增或修改的属性点击`保存`按钮才可以生效。\n_注：主键字段的属性创建后无修改_\n\n\n###### c.添加边\n\n在`模型定义`界面点击`添加边`按钮，在右侧滑动窗口中添加边类型。\n\n\n用户需要输入边类型名称、属性、选择起点类型和终点类型，点击`完成`按钮完成边类型的创建。\n- 边类型名称：边的名称，也是该边的唯一标识。\n- 属性：边的属性，边上可以没有属性。\n    - 数据类型：属性字段的数据类型，支持INT、STRING、DOUBLE、DATE、DATETIME、BLOB、BOOL等类型。\n    - 选填：该属性是否可以为空值。\n    - 删除：在创建边时可以任意删除属性。\n- 选择起点类型和终点类型：设置边的起点点类型和终点点类型，支持多个起点类型和终点类型。\n    - 起点：选择起点的点类型。\n    - 终点：选择终点的点类型。\n    - 需要提前创建至少一个点类型才能设置边的起点类型和终点。\n    - 如果不选择则表示起点和终点可以为任意点类型，同时画布上不展示对应的边，需要在左侧列表查看边类型。\n- 编辑边：可以增加边的属性和修改已有属性的数据类型。需要对每个新增或修改的属性点击`保存`按钮才可以生效。\n\n\n###### d.导入模型\n\n在`模型定义`界面点击`导入模型`按钮，可以上传模型文件快速创建模型。\n\n该块内容位于文档的“图构建”部分，具体在“模型定义”小节中，介绍了如何添加点类型和边类型的详细步骤和相关属性设置。这部分内容旨在指导用户在TuGraph Browser中进行图模型的创建与管理。"
            },
            {
                "content": "用户需要输入边类型名称、属性、选择起点类型和终点类型，点击`完成`按钮完成边类型的创建。\n- 边类型名称：边的名称，也是该边的唯一标识。\n- 属性：边的属性，边上可以没有属性。\n    - 数据类型：属性字段的数据类型，支持INT、STRING、DOUBLE、DATE、DATETIME、BLOB、BOOL等类型。\n    - 选填：该属性是否可以为空值。\n    - 删除：在创建边时可以任意删除属性。\n- 选择起点类型和终点类型：设置边的起点点类型和终点点类型，支持多个起点类型和终点类型。\n    - 起点：选择起点的点类型。\n    - 终点：选择终点的点类型。\n    - 需要提前创建至少一个点类型才能设置边的起点类型和终点。\n    - 如果不选择则表示起点和终点可以为任意点类型，同时画布上不展示对应的边，需要在左侧列表查看边类型。\n- 编辑边：可以增加边的属性和修改已有属性的数据类型。需要对每个新增或修改的属性点击`保存`按钮才可以生效。\n\n\n###### d.导入模型\n\n在`模型定义`界面点击`导入模型`按钮，可以上传模型文件快速创建模型。\n\n在`导入模型`界面点击`上传文件`按钮，上传模型文件成功后，点击确定可以导入图模型。\n\n- 覆盖当前画布中的模型：选中该选项，导入时会先清空已有图模型再导入模型文件中的图模型；不选择，会导入模型文件中新增的点类型和边类型，但不会修改已有的点类型和边类型。\n\n###### e.导出模型\n\n在`模型定义`界面点击`导出模型`按钮，可以将当前图项目中的图模型导出成json文件。\n\n模型文件为json格式，不建议手动修改。\n\n##### 2.4.2.2.数据导入\n\n完成`模型定义`之后，点击`数据导入`按钮进入数据导入页面。\n\n###### a.数据准备\n\n在数据导入前需要提前准备数据，当前Browser支持CSV文件的上传，需要保证数据文件后缀为csv。\n- 不强制要求包含表头。\n- 支持文本限定符，文本限定符为双引号。\n\n###### b.上传文件\n\n在`数据导入`页面上传需要导入的数据文件，将数据导入到图项目中。\n\n- 分隔符：数据文件的列分隔符。\n- 文件上传：支持上传多个文件。\n    - 支持弹窗中选择多个上传文件。\n    - 支持将文件拖拽至页面中上传。\n    - 支持同时上传点文件和边文件。\n\n###### c.数据映射\n\n该部分内容位于操作指南的图构建部分，主要讲述如何在TuGraph Browser中定义边类型，包括边类型的名称、属性设置、起点和终点类型的选择，以及边的编辑操作。此外，还提及了模型导入和导出功能，为用户提供了模型创建与管理的相关信息。"
            },
            {
                "content": "- 覆盖当前画布中的模型：选中该选项，导入时会先清空已有图模型再导入模型文件中的图模型；不选择，会导入模型文件中新增的点类型和边类型，但不会修改已有的点类型和边类型。\n\n###### e.导出模型\n\n在`模型定义`界面点击`导出模型`按钮，可以将当前图项目中的图模型导出成json文件。\n\n模型文件为json格式，不建议手动修改。\n\n##### 2.4.2.2.数据导入\n\n完成`模型定义`之后，点击`数据导入`按钮进入数据导入页面。\n\n###### a.数据准备\n\n在数据导入前需要提前准备数据，当前Browser支持CSV文件的上传，需要保证数据文件后缀为csv。\n- 不强制要求包含表头。\n- 支持文本限定符，文本限定符为双引号。\n\n###### b.上传文件\n\n在`数据导入`页面上传需要导入的数据文件，将数据导入到图项目中。\n\n- 分隔符：数据文件的列分隔符。\n- 文件上传：支持上传多个文件。\n    - 支持弹窗中选择多个上传文件。\n    - 支持将文件拖拽至页面中上传。\n    - 支持同时上传点文件和边文件。\n\n###### c.数据映射\n\n文件上传成功后，需要在`数据导入`页面设置`数据对应表`，将数据文件中的数据列和目标点/边、对应属性建立映射关系。\n\n- 数据对应表：展示已经上传的数据问题。\n    - 文件名称：上传的数据文件名称。\n    - 文件大小：上传的数据文件大小。\n    - 读取结果：数据文件上传结果，success为读取成功。\n    - 删除：在页面中删除，不会删除本地文件。\n- 数据文件映射：每个已上传的数据文件都需要配置映射关系。\n    - 标签：选择该文件对应的点或边类型，只能选择一类点或一类边。\n    - 从第N行，开始：从第N行开始读取数据，系统默认从第0行开始读取数据，如需跳过表头可输入1。\n    - 属性映射：下拉选择数据列对应的属性字段。\n    - 数据预览：系统会预读数据文件的前5行。\n\n文件上传成功后，可以点击`继续导入`按钮继续导入其他数据，或者点击`前往图查询`按钮在`图查询`页面查询已导入的数据。\n\n#### 2.4.3.图查询\n\n在`图项目`界面点击图项目选项卡中的`图查询`按钮，可以查询和访问图项目中的图数据，产品提供`语句查询`、`路径查询`、`点查询`等多种模式查询图数据，支持切换图项目和查询结果展示。\n\n该块内容位于文档的第二部分“操作指南”中，主要涉及图模型的导入和导出功能，包括覆盖导入模型和数据文件上传、映射设置等步骤，属于图数据管理和数据导入的具体操作指南。"
            },
            {
                "content": "- 数据对应表：展示已经上传的数据问题。\n    - 文件名称：上传的数据文件名称。\n    - 文件大小：上传的数据文件大小。\n    - 读取结果：数据文件上传结果，success为读取成功。\n    - 删除：在页面中删除，不会删除本地文件。\n- 数据文件映射：每个已上传的数据文件都需要配置映射关系。\n    - 标签：选择该文件对应的点或边类型，只能选择一类点或一类边。\n    - 从第N行，开始：从第N行开始读取数据，系统默认从第0行开始读取数据，如需跳过表头可输入1。\n    - 属性映射：下拉选择数据列对应的属性字段。\n    - 数据预览：系统会预读数据文件的前5行。\n\n文件上传成功后，可以点击`继续导入`按钮继续导入其他数据，或者点击`前往图查询`按钮在`图查询`页面查询已导入的数据。\n\n#### 2.4.3.图查询\n\n在`图项目`界面点击图项目选项卡中的`图查询`按钮，可以查询和访问图项目中的图数据，产品提供`语句查询`、`路径查询`、`点查询`等多种模式查询图数据，支持切换图项目和查询结果展示。\n\n##### 2.4.3.1.切换图项目\n\n`图查询`功能只能访问一个图项目数据，用户可以在`切换图项目`下拉框中选择并切换至其他图数据。\n\n##### 2.4.3.2.语句查询\n\nBrowser提供可视化方式开发和调试图查询语句，用户可以输入图查询语句、执行并返回结果，支持收藏语句和查看图模型。\n\n###### a.语句查询窗口\n\n用户在`语句查询窗口`输入图查询语句，点击`执行`按钮可以运行对应语句，并在`执行结果页签`展示结果。\n\n- 切换查询语言：提供不同图查询语言模式的切换。_当前只支持Cypher语法_\n\n- 语句查询窗口：提供当前查询语言的语法提示。\n\n- 执行：点击`执行`按钮，发送输入的查询语句至后台运行。\n\n- 收藏：点击`收藏`按钮，将当前语句查询窗口的内容保存成模板，以便下次使用。\n\n- 下载：点击`下载`按钮，将当前语句查询窗口的内容保存成文本文件并下载至本地，以便下次使用。\n\n###### b.收藏列表\n\n以列表方式展示已经收藏的查询语句，点击列表中的收藏模板可以使用其中的语句。支持关键字搜索、名称修改以及删除。\n\n###### c.查看图模型\n\n该文档介绍了TuGraph Browser的功能和操作，其中这一段落主要讲述了在数据导入环节中，用户上传数据文件后需要配置的数据对应表和数据映射，接着引入了图查询功能，说明用户如何查询和访问已导入的图数据。"
            },
            {
                "content": "##### 2.4.3.1.切换图项目\n\n`图查询`功能只能访问一个图项目数据，用户可以在`切换图项目`下拉框中选择并切换至其他图数据。\n\n##### 2.4.3.2.语句查询\n\nBrowser提供可视化方式开发和调试图查询语句，用户可以输入图查询语句、执行并返回结果，支持收藏语句和查看图模型。\n\n###### a.语句查询窗口\n\n用户在`语句查询窗口`输入图查询语句，点击`执行`按钮可以运行对应语句，并在`执行结果页签`展示结果。\n\n- 切换查询语言：提供不同图查询语言模式的切换。_当前只支持Cypher语法_\n\n- 语句查询窗口：提供当前查询语言的语法提示。\n\n- 执行：点击`执行`按钮，发送输入的查询语句至后台运行。\n\n- 收藏：点击`收藏`按钮，将当前语句查询窗口的内容保存成模板，以便下次使用。\n\n- 下载：点击`下载`按钮，将当前语句查询窗口的内容保存成文本文件并下载至本地，以便下次使用。\n\n###### b.收藏列表\n\n以列表方式展示已经收藏的查询语句，点击列表中的收藏模板可以使用其中的语句。支持关键字搜索、名称修改以及删除。\n\n###### c.查看图模型\n\nBrowser提供当前图项目中的图模型查询，方便用户清晰点边类型模型，支持列表展示和画布图谱展示方式，支持隐藏查看图模型窗口。\n\n##### 2.4.3.3.路径查询\n\nBrowser提供`路径查询`模板，用户可以通过选择路径的方式，查找图项目中的图数据是否存在相应的路径。\n\n- 路径：在路径选择下拉框内选择需要查找的路径。\n    - 选择路径：根据图模型的定义，系统会自动匹配出对应的一度关系路径；再次点击路径下拉框会，系统会根据路径终点的点类型自动匹配下一度关系路径。\n    - 执行：点击`执行`按钮返回图项目中匹配的路径。\n    - 高级配置：设置扫描的路径数目，默认为100条路径。\n\n_注：需要图模型中的边设置起点和终点，如果图项目中的边均未设置起点和终点，下拉选项无结果_\n\n##### 2.4.3.4.点查询\n\nBrowser提供`点查询`模板，用户可以通过选择点属性进行查询，查找图项目中的点数据。\n\n##### 2.4.3.5.执行结果页签\n\nBrowser提供表格文本、点边视图等多种方式展示图查询结果，支持结果下载、插入数据、全屏展示。\n\n###### a.表格文本\n\nBrowser提供以表格文本方式展示查询结果。\n\n该段落位于操作指南的“图项目”部分，具体介绍了图查询功能的相关操作，包括切换图项目、语句查询、路径查询和点查询。它详细说明了如何使用浏览器提供的工具进行图数据的查询和展示，同时描述了查询结果的多种显示方式。"
            },
            {
                "content": "##### 2.4.3.3.路径查询\n\nBrowser提供`路径查询`模板，用户可以通过选择路径的方式，查找图项目中的图数据是否存在相应的路径。\n\n- 路径：在路径选择下拉框内选择需要查找的路径。\n    - 选择路径：根据图模型的定义，系统会自动匹配出对应的一度关系路径；再次点击路径下拉框会，系统会根据路径终点的点类型自动匹配下一度关系路径。\n    - 执行：点击`执行`按钮返回图项目中匹配的路径。\n    - 高级配置：设置扫描的路径数目，默认为100条路径。\n\n_注：需要图模型中的边设置起点和终点，如果图项目中的边均未设置起点和终点，下拉选项无结果_\n\n##### 2.4.3.4.点查询\n\nBrowser提供`点查询`模板，用户可以通过选择点属性进行查询，查找图项目中的点数据。\n\n##### 2.4.3.5.执行结果页签\n\nBrowser提供表格文本、点边视图等多种方式展示图查询结果，支持结果下载、插入数据、全屏展示。\n\n###### a.表格文本\n\nBrowser提供以表格文本方式展示查询结果。\n\n###### b.点边视图\n\nBrowser提供以画布方式展示查询结果。\n\n###### c.插入数据\n\nBrowser提供可视化方式在对应图项目中插入点或边数据。点击`插入数据`按钮，在`插入数据`页签选择点类型或边类型，输入属性值，点击确定完成数据插入。\n\n###### d.下载执行结果\n\nBrowser提供图查询结果导出成文本文件功能。点击`下载执行结果`按钮，系统会自动将结果保存成文本文件并下载至本地。\n\n###### e.全屏展示\n\nBrowser提供全屏方式展示图查询结果，点击`全屏显示`按钮全屏展示结果，点击`退出全屏`按钮退出全屏展示。\n\n#### 2.4.4.图分析\n\n在`图项目`界面点击图项目选项卡中的`图分析`按钮，可以在画布中展示和分析图数据，产品提供`语句查询`和`配置查询`将图项目中的数据查询并加载至画布，支持画布数据的筛选、布局样式调整以及画布操作。\n\n如下图所示，图分析功能主要包括：\n\n该内容块属于文档的第2.4.3节“图查询”中的子节，具体介绍了Browser的路径查询和点查询功能，并详细描述了执行查询后结果的展示方式，包括表格文本、点边视图、数据插入、结果下载和全屏展示等操作。这段内容为用户提供了关于如何查询图数据及处理查询结果的具体指导。"
            },
            {
                "content": "Browser提供表格文本、点边视图等多种方式展示图查询结果，支持结果下载、插入数据、全屏展示。\n\n###### a.表格文本\n\nBrowser提供以表格文本方式展示查询结果。\n\n###### b.点边视图\n\nBrowser提供以画布方式展示查询结果。\n\n###### c.插入数据\n\nBrowser提供可视化方式在对应图项目中插入点或边数据。点击`插入数据`按钮，在`插入数据`页签选择点类型或边类型，输入属性值，点击确定完成数据插入。\n\n###### d.下载执行结果\n\nBrowser提供图查询结果导出成文本文件功能。点击`下载执行结果`按钮，系统会自动将结果保存成文本文件并下载至本地。\n\n###### e.全屏展示\n\nBrowser提供全屏方式展示图查询结果，点击`全屏显示`按钮全屏展示结果，点击`退出全屏`按钮退出全屏展示。\n\n#### 2.4.4.图分析\n\n在`图项目`界面点击图项目选项卡中的`图分析`按钮，可以在画布中展示和分析图数据，产品提供`语句查询`和`配置查询`将图项目中的数据查询并加载至画布，支持画布数据的筛选、布局样式调整以及画布操作。\n\n如下图所示，图分析功能主要包括：\n\n  1、操作栏：图分析主要操作功能，包括布局切换、查询过滤、布局、样式以及画布操作；\n  2、左边栏：查询、筛选、外观功能操作区域；\n  3、画布区域：展示图数据的区域，展示点和边数据，支持点扩展查询、收起节点、固定节点、删除节点、画布图数据统计、缩放、居中等功能；\n  4、右边栏：选中一个点数据或边数据后，会展示对应的属性信息；\n  5、布局切换：标签布局和卡片布局的切换。\n\n##### 2.4.4.1.语句查询\n\n在`语句查询`功能中，用户可以输入查询语句来查询图数据，并加载数据至画布区域进行展示。\n- 语法说明：TuGraph的[查询语言及语法说明文档](../8.query/1.cypher.md)。\n- 清空画布数据：未选择此按钮，每次执行查询的结果会追加至画布区域；选择此按钮，每次执行查询前会先清空画布。\n\n\n##### 2.4.4.2.配置查询\n\n在`配置查询`功能中，用户可以选择节点类型和输入属性条件来查询图数据，并加载数据至画布区域进行展示。\n- 清空画布数据：未选择此按钮，每次执行查询的结果会追加至画布区域；选择此按钮，每次执行查询前会先清空画布。\n\n##### 2.4.4.3.画布分析\n\n该块内容位于文档的\"图查询\"部分，具体涉及Browser如何展示查询结果，包括表格文本和点边视图的方式，以及如何插入数据、下载执行结果和全屏展示功能。此外，还引入了“图分析”功能，进一步说明如何在画布中展示和分析图数据。"
            },
            {
                "content": "##### 2.4.4.1.语句查询\n\n在`语句查询`功能中，用户可以输入查询语句来查询图数据，并加载数据至画布区域进行展示。\n- 语法说明：TuGraph的[查询语言及语法说明文档](../8.query/1.cypher.md)。\n- 清空画布数据：未选择此按钮，每次执行查询的结果会追加至画布区域；选择此按钮，每次执行查询前会先清空画布。\n\n\n##### 2.4.4.2.配置查询\n\n在`配置查询`功能中，用户可以选择节点类型和输入属性条件来查询图数据，并加载数据至画布区域进行展示。\n- 清空画布数据：未选择此按钮，每次执行查询的结果会追加至画布区域；选择此按钮，每次执行查询前会先清空画布。\n\n##### 2.4.4.3.画布分析\n\n在`画布分析`功能中，用户可以对画布中的节点或边数据进行操作和分析，主要包括：选中节点进行扩展查询、收起/展开节点、固定节点，清空画布，套索，点/边检索，画布图例等。画布上的最基础操作是拖拽点数据，鼠标左键选住一个节点并移动鼠标，可以完成点数据位置的移动。\n\n###### a.扩展查询\n\n在`画布`区域右键点击一个节点数据，弹出操作悬窗，鼠标移至`扩展查询`处弹出二级悬窗，点击对应的扩展度数进行查询。\n- 一度查询：双向扩展一度关系。\n- 二度查询：双向扩展二度关系。\n- 三度查询：双向扩展三度关系。\n\n###### b.收起/展开节点\n\n在`画布`区域右键点击一个节点数据，弹出操作悬窗，点击`收起节点`会隐藏所选节点的一度关系节点；再次右键已`收起节点`的点数据可以进行`展开节点`操作，展示已隐藏的一度关系节点。\n\n###### c.删除节点\n\n在`画布`区域右键点击一个节点数据，弹出操作悬窗，点击`删除节点`会将所选节点移出画布。\n\n###### d.清空画布\n\n在`操作栏`区域点击`清空画布`按钮，会清除所有画布中的数据。\n\n###### e.点/边检索\n\n在`点/边检索`窗口选择点或边，并输入关键字，会模糊检索画布中的属性数据，检索后可定位至数据位置。\n\n###### f.画布图例\n\n在`画布`区域的图例位置，会展示画布中的点类型，点击点类型可以选中对应的点数据，点击更多按钮可以展示统计情况，支持列表或图表方式展示点或边的数量。\n\n###### g.缩放/居中\n\n可以使用鼠标滚轮和缩放按钮进行缩放。\n\n##### 2.4.4.4.属性筛选\n\n该内容位于TuGraph Browser的操作指南部分，具体涉及图分析功能的子章节，包括语句查询、配置查询和画布分析等内容，帮助用户在可视化界面中操作和分析图数据。"
            },
            {
                "content": "###### b.收起/展开节点\n\n在`画布`区域右键点击一个节点数据，弹出操作悬窗，点击`收起节点`会隐藏所选节点的一度关系节点；再次右键已`收起节点`的点数据可以进行`展开节点`操作，展示已隐藏的一度关系节点。\n\n###### c.删除节点\n\n在`画布`区域右键点击一个节点数据，弹出操作悬窗，点击`删除节点`会将所选节点移出画布。\n\n###### d.清空画布\n\n在`操作栏`区域点击`清空画布`按钮，会清除所有画布中的数据。\n\n###### e.点/边检索\n\n在`点/边检索`窗口选择点或边，并输入关键字，会模糊检索画布中的属性数据，检索后可定位至数据位置。\n\n###### f.画布图例\n\n在`画布`区域的图例位置，会展示画布中的点类型，点击点类型可以选中对应的点数据，点击更多按钮可以展示统计情况，支持列表或图表方式展示点或边的数量。\n\n###### g.缩放/居中\n\n可以使用鼠标滚轮和缩放按钮进行缩放。\n\n##### 2.4.4.4.属性筛选\n\n在`操作栏`区域点击`筛选`按钮，在`左边栏`点击`属性筛选`进行筛选过滤。用户可以选择要筛选的点或边类型，以及对应的属性值进行设置，检索到筛选组条件的数据后会在画布上高亮选中对应的点或边数据。\n- 请选择点/边类型：选择需要检索的点类型或边类型。\n- 属性条件：设置需要检索的属性条件，可以设置多组，取并集筛选结果。\n- 添加筛选组：可以多组筛选条件，取并集筛选结果。\n- 重置：可以清空筛选条件。\n\n##### 2.4.4.5.统计筛选\n\n在`操作栏`区域点击`筛选`按钮，在`左边栏`点击`统计筛选`进行画布数据统计。用户可以选择要统计的点或边类型，以及对应的属性值进行设置，系统会自动根据用户选择的点/边类型和属性进行分组统计，支持按照图表和列表两种方式展示结果，同时点击图表或列表区域的数值可以高亮选中画布中的数据。\n\n##### 2.4.4.6.点边布局\n\n在`操作栏`区域点击`布局`按钮，选择对应的布局方式会将画布中的数据进行重新排布，支持力导向布局、同心圆布局、圆形布局、辐射布局、Dagre布局以及网格布局，每种布局方式均有不同布局参数，调整参数后画布中的数据会进行重新排布。\n\n详细布局参数可参考[AntV-G6](https://g6.antv.antgroup.com/api/graph-layout/guide)。\n\n该片段位于文档的第2.4.4节“图分析”中，介绍了在图项目的画布区域进行节点操作的功能，包括节点的收起/展开、删除节点、清空画布、点/边检索、画布图例展示及缩放功能。此外，还涵盖了属性筛选、统计筛选和点边布局等相关操作。"
            },
            {
                "content": "##### 2.4.4.5.统计筛选\n\n在`操作栏`区域点击`筛选`按钮，在`左边栏`点击`统计筛选`进行画布数据统计。用户可以选择要统计的点或边类型，以及对应的属性值进行设置，系统会自动根据用户选择的点/边类型和属性进行分组统计，支持按照图表和列表两种方式展示结果，同时点击图表或列表区域的数值可以高亮选中画布中的数据。\n\n##### 2.4.4.6.点边布局\n\n在`操作栏`区域点击`布局`按钮，选择对应的布局方式会将画布中的数据进行重新排布，支持力导向布局、同心圆布局、圆形布局、辐射布局、Dagre布局以及网格布局，每种布局方式均有不同布局参数，调整参数后画布中的数据会进行重新排布。\n\n详细布局参数可参考[AntV-G6](https://g6.antv.antgroup.com/api/graph-layout/guide)。\n\n##### 2.4.4.7.外观样式\n\n在`操作栏`区域点击`外观`按钮，在`左边栏`点击`点样式`或`边样式`进行外观样式配置。\n- 点样式\n    - 应用点类型：设置对应点类型的展示样式，支持同时配置多个点类型外观。\n    - 大小：对应点类型的展示大小。\n    - 颜色：对应点类型的展示颜色。\n    - 图标：对应点类型的图标样式。\n    - 显示文本：对应点类型显示的文本内容，默认为id。\n    - 高级配置：根据设置的条件标记对应的点数据。\n- 边样式\n    - 应用边类型：设置对应边类型的展示样式。\n    - 颜色：对应点类型的展示颜色。\n    - 边宽：对应边类型的展示宽度。\n    - 显示文本：对应边类型显示的文本内容，默认不显示。\n    - 高级配置：根据设置的条件按颜色展示对应的边数据，支持同时配置多个边类型外观。\n\n##### 2.4.4.8.视图切换\n\n图分析中支持2D图谱视图、列表视图以及JSON视图。\n\n##### 2.4.4.9.标签/卡片布局切换\n\n图分析支持标签布局和卡片布局。\n\n### 2.5.控制台\n\n此部分内容位于文档的第2.4节，主要介绍了图分析功能的操作，包括统计筛选、点边布局、外观样式配置以及视图切换等。它为用户提供了在图分析过程中进行数据统计、布局调整和样式设置的方法，并支持不同的展示视图，帮助用户更好地分析和展示图数据。"
            },
            {
                "content": "##### 2.4.4.7.外观样式\n\n在`操作栏`区域点击`外观`按钮，在`左边栏`点击`点样式`或`边样式`进行外观样式配置。\n- 点样式\n    - 应用点类型：设置对应点类型的展示样式，支持同时配置多个点类型外观。\n    - 大小：对应点类型的展示大小。\n    - 颜色：对应点类型的展示颜色。\n    - 图标：对应点类型的图标样式。\n    - 显示文本：对应点类型显示的文本内容，默认为id。\n    - 高级配置：根据设置的条件标记对应的点数据。\n- 边样式\n    - 应用边类型：设置对应边类型的展示样式。\n    - 颜色：对应点类型的展示颜色。\n    - 边宽：对应边类型的展示宽度。\n    - 显示文本：对应边类型显示的文本内容，默认不显示。\n    - 高级配置：根据设置的条件按颜色展示对应的边数据，支持同时配置多个边类型外观。\n\n##### 2.4.4.8.视图切换\n\n图分析中支持2D图谱视图、列表视图以及JSON视图。\n\n##### 2.4.4.9.标签/卡片布局切换\n\n图分析支持标签布局和卡片布局。\n\n### 2.5.控制台\n\n`控制台`提供可视化的的账户管理和数据库信息查看功能，它为用户提供了全面的账户和角色管理功能，包括账户的增删改查以及禁用，角色的增删改查以及禁用。此外，它也为用户提供了便捷的数据库信息查看功能，让用户可以轻松地查看图数据库的基础信息和配置信息。其中，基础信息主要包括版本号、运行时间、CPP编译版本号等，而数据库配置信息则包括端口号、系统功能参数配置等。\n\n#### 2.5.1.账户管理\n\n##### 2.5.1.1.账户管理\n\n###### a.添加账户\n\n在`账户管理`界面点击`添加`按钮创建新的账户，用户需要输入账户名称、账户描述、账户密码以及相关角色。\n\n- 账户名称：支持中文、字母、数字以及下划线，不支持空格以及其他特殊符号。\n- 相关角色：新建账户时必须要选择一个角色，在账户添加成功后，系统会自动生成一个与账户名称一样的角色。\n\n###### b.编辑账户\n\n在`账户管理`界面点击`添加`按钮创建新的账户，用户可以编辑账户描述、账户密码以及相关角色。\n\n###### c.禁用账户\n\n在`账户管理`界面点击`禁用`按钮禁止对应的账户登录和访问，点击`启用`按钮开启对应的账户登录和访问权限。\n\n###### d.删除账户\n\n该块内容位于文档的第2.4.4节\"图分析\"中，主要介绍了图分析功能的外观样式配置、视图切换和布局切换相关的操作细节，是有关图数据可视化展示的重要部分。"
            },
            {
                "content": "#### 2.5.1.账户管理\n\n##### 2.5.1.1.账户管理\n\n###### a.添加账户\n\n在`账户管理`界面点击`添加`按钮创建新的账户，用户需要输入账户名称、账户描述、账户密码以及相关角色。\n\n- 账户名称：支持中文、字母、数字以及下划线，不支持空格以及其他特殊符号。\n- 相关角色：新建账户时必须要选择一个角色，在账户添加成功后，系统会自动生成一个与账户名称一样的角色。\n\n###### b.编辑账户\n\n在`账户管理`界面点击`添加`按钮创建新的账户，用户可以编辑账户描述、账户密码以及相关角色。\n\n###### c.禁用账户\n\n在`账户管理`界面点击`禁用`按钮禁止对应的账户登录和访问，点击`启用`按钮开启对应的账户登录和访问权限。\n\n###### d.删除账户\n\n在`账户管理`界面点击`删除`按钮删除对应的账户。\n\n##### 2.5.1.2.角色管理\n\n###### a.添加角色\n\n在`角色管理`界面点击`添加`按钮创建新的角色，用户需要输入角色名称、角色描述以及图权限。\n\n- 角色名称：支持中文、字母、数字以及下划线，不支持空格以及其他特殊符号。\n- 图权限：browser支持全部、读、写和无共四类图权限配置。\n    - 全部：对应图的读和写权限，包含编辑图模型权限（schema）。\n    - 读写：对应图的写权限，不包含编辑图模型权限（schema）。\n    - 只读：对应图的读权限。\n    - 无：无法访问和操作对应图。\n- 角色冲突：当两个角色对同一个图有不同图权限，同时对一个账户授权了这两个角色，该账户对该图的图权限为两个角色的并集。\n\n###### b.编辑角色\n\n在`角色管理`界面点击`编辑`按钮编辑已有角色，用户可以编辑角色描述以及图权限。\n\n###### c.禁用角色\n\n在`角色管理`界面点击`禁用`按钮禁止对应的角色，点击`启用`按钮开启对应的角色。禁用角色后，对应角色图访问权限失效。\n\n- 禁用角色：禁用之后，对应角色图访问权限失效。\n    - 当一个用户拥有两个角色对同一个图有操作权限时，当禁用其中一个角色时，另一个角色权限同样有效。\n\n###### d.删除角色\n\n在`角色管理`界面点击`删除`按钮删除对应的角色。\n\n#### 2.5.2.数据库信息\n\n##### 2.5.2.1.基础信息\n\n`基础信息`获取当前系统运行的状态，并展示关键信息。\n\n该文段位于可视化操作手册中，主要介绍了TuGraph Browser的账户和角色管理功能，包括如何添加、编辑、禁用和删除账户及角色，强调了与权限相关的细节，进一步阐述了数据库信息的基本获取与展示。"
            },
            {
                "content": "###### b.编辑角色\n\n在`角色管理`界面点击`编辑`按钮编辑已有角色，用户可以编辑角色描述以及图权限。\n\n###### c.禁用角色\n\n在`角色管理`界面点击`禁用`按钮禁止对应的角色，点击`启用`按钮开启对应的角色。禁用角色后，对应角色图访问权限失效。\n\n- 禁用角色：禁用之后，对应角色图访问权限失效。\n    - 当一个用户拥有两个角色对同一个图有操作权限时，当禁用其中一个角色时，另一个角色权限同样有效。\n\n###### d.删除角色\n\n在`角色管理`界面点击`删除`按钮删除对应的角色。\n\n#### 2.5.2.数据库信息\n\n##### 2.5.2.1.基础信息\n\n`基础信息`获取当前系统运行的状态，并展示关键信息。\n\n|参数    |含义    |\n|-------|--------|\n|TuGraph版本号|当前TuGraph的版本号，x.x.x|\n|运行时间|TuGraph服务启动到现在的时间|\n|服务器代码版本|tugraph-db仓库的当前commit|\n|前端代码版本|tugraph-web仓库的当前commit|\n|CPP编译器版本号|编译TuGraph时的CPP版本号|\n|Python版本号|编译TuGraph时的Python版本号|\n|CPP编译器ID|编译TuGraph时的CPP类型|\n表格内容描述如下：\n\n该表格包含了两个列名，分别是“参数”和“含义”。 \n\n逐行描述表格中的数据内容：\n1. “TuGraph版本号”表示当前TuGraph的版本号，格式为x.x.x。\n2. “运行时间”指的是TuGraph服务启动到当前的时间。\n3. “服务器代码版本”记录了tugraph-db仓库的当前commit信息。\n4. “前端代码版本”记录了tugraph-web仓库的当前commit信息。\n5. “CPP编译器版本号”标示编译TuGraph时所使用的CPP版本号。\n6. “Python版本号”记录了编译TuGraph时使用的Python版本号。\n7. “CPP编译器ID”指编译TuGraph时使用的CPP类型。\n\n总结：该表格提供了TuGraph系统的多个重要参数和技术细节，包括版本号、运行时间、以及相关编译环境的信息。这些参数有助于用户准确了解当前TuGraph实例的技术状态和环境配置。\n\n也可以通过命令获取当前系统运行状态。\n\n该块内容位于文档的第2.5节“控制台”下，具体涉及角色管理，包括编辑、禁用和删除角色的操作说明。接下来的内容则是关于数据库信息的基础信息部分，展示了系统运行状态及关键参数。"
            },
            {
                "content": "该表格包含了两个列名，分别是“参数”和“含义”。 \n\n逐行描述表格中的数据内容：\n1. “TuGraph版本号”表示当前TuGraph的版本号，格式为x.x.x。\n2. “运行时间”指的是TuGraph服务启动到当前的时间。\n3. “服务器代码版本”记录了tugraph-db仓库的当前commit信息。\n4. “前端代码版本”记录了tugraph-web仓库的当前commit信息。\n5. “CPP编译器版本号”标示编译TuGraph时所使用的CPP版本号。\n6. “Python版本号”记录了编译TuGraph时使用的Python版本号。\n7. “CPP编译器ID”指编译TuGraph时使用的CPP类型。\n\n总结：该表格提供了TuGraph系统的多个重要参数和技术细节，包括版本号、运行时间、以及相关编译环境的信息。这些参数有助于用户准确了解当前TuGraph实例的技术状态和环境配置。\n\n也可以通过命令获取当前系统运行状态。\n\n```\nCALL dbms.system.info()\n```\n\n##### 2.5.2.2.数据库配置信息\n\n`数据库配置信息`获取当前系统运行的配置参数，并展示关键信息。\n\n该块内容位于文档的“2.5.2.1.基础信息”部分，主要介绍TuGraph系统的相关参数和技术细节，包括版本号、运行时间等信息，帮助用户了解当前系统的技术状态和环境配置。此外，还提供了一条命令用于获取当前系统的运行状态。紧接着是“2.5.2.2.数据库配置信息”部分，涉及当前系统的配置参数和相关信息。"
            },
            {
                "content": "| 参数                          | 含义                                 |\n|-----------------------------|------------------------------------|\n| bind_host                   | 系统启动时设置的host，一般为0.0.0.0            |\n| browser.credential_timeout                   | 浏览器缓存的用户名和密码过期时间                   |\n| browser.retain_connection_credentials                   | 浏览器是否缓存用户名和密码                      |\n| disable_auth                | 是否关闭token认证的定期更新，如为true则token可以永久使用 |\n| durable                     | 是否开启存储底层持久化，如为false，数据异步更新到磁盘      |\n| enable_audit_log            | 是否开启审计日志                           |\n| enable_backup_log           | 是否开启实时增量备份                         |\n| enable_fulltext_index       | 是否开启全文索引                           |\n| enable_ha       | 是否开启高可用                            |\n| enable_ip_check             | 是否开启IP白名单                          |\n| enable_rpc                  | 是否开启RPC端口                          |\n| enable_ssl                  | 是否开启ssl加密传输                        |\n\n此表格位于文档第二部分“数据库配置信息”下，详细列出了TuGraph系统的关键配置参数及其含义，涵盖了网络、认证、安全、数据持久性等方面的设置，为用户提供了对数据库运行状态和配置的全面了解。"
            },
            {
                "content": "| enable_audit_log            | 是否开启审计日志                           |\n| enable_backup_log           | 是否开启实时增量备份                         |\n| enable_fulltext_index       | 是否开启全文索引                           |\n| enable_ha       | 是否开启高可用                            |\n| enable_ip_check             | 是否开启IP白名单                          |\n| enable_rpc                  | 是否开启RPC端口                          |\n| enable_ssl                  | 是否开启ssl加密传输                        |\n| optimistic_txn              | 是否开启乐观多线程写入事务                      |\n| port                        | 当前系统的REST访问端口                      |\n| rpc_port                    | RPC 及 HA 服务所用端口                    |\n| subprocess_max_idle_seconds | 自进程最大空闲时间，线程池参数                    |\n| thread_limit                | 服务端同时使用的最大线程数                      |\n| verbose                     | 日志输出信息的详细程度。可设为 0，1，2，值越大则输出信息越详细  |\n表格内容描述:\n\n该块内容位于\"数据库配置信息\"部分，详细列出了TuGraph系统中各类配置参数及其含义，旨在为用户提供系统配置的参考信息。"
            },
            {
                "content": "该表格包含了两个列名，分别是“参数”和“含义”。 \n\n1. **bind_host**：系统启动时设置的host，通常为0.0.0.0，用于绑定所有网络接口。\n2. **browser.credential_timeout**：浏览器缓存的用户名和密码过期时间。\n3. **browser.retain_connection_credentials**：表示浏览器是否缓存用户名和密码。\n4. **disable_auth**：控制token认证的定期更新，如果设为true，则token可以永久使用。\n5. **durable**：决定是否开启存储底层持久化，如果设为false，则数据会异步更新到磁盘。\n6. **enable_audit_log**：表示是否启用审计日志。\n7. **enable_backup_log**：表示是否启用实时增量备份。\n8. **enable_fulltext_index**：表示是否开启全文索引功能。\n9. **enable_ha**：表示是否启用高可用性。\n10. **enable_ip_check**：控制是否启用IP白名单。\n11. **enable_rpc**：表示是否开启RPC端口。\n12. **enable_ssl**：控制是否启用SSL加密传输。\n13. **optimistic_txn**：表示是否启用乐观多线程写入事务。\n14. **port**：当前系统的REST访问端口。\n15. **rpc_port**：RPC及HA服务所使用的端口。\n16. **subprocess_max_idle_seconds**：自进程最大空闲时间，作为线程池的参数。\n17. **thread_limit**：服务端可以同时使用的最大线程数。\n18. **verbose**：日志输出信息的详细程度，设为0、1、2，数值越高输出的信息越详细。\n\n总结：该表格列出了多个系统参数及其含义，涵盖了网络配置、安全认证、数据持久性、可用性、日志管理和性能等方面，提供了对系统配置与优化的重要参考信息。\n\n该内容位于文档的“数据库配置信息”部分，详细描述了系统配置参数及其含义，包括网络设置、安全认证以及性能相关的选项，帮助用户了解与优化TuGraph数据库的配置。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_2.md",
        "chunks": [
            {
                "content": "# 白屏部署\n\n> 介绍如何在 Docker 容器里面启动 GeaFlow Console 平台，提交流图计算作业。\n\n\n## 准备工作\n1. 下载安装Docker(https://docs.docker.com/engine/install/)，调整Docker服务资源配置（Dashboard-Settings-Resources）后启动Docker服务。\n2. 拉取GeaFlow Console镜像\n\n执行以下命令拉取远程geaflow console镜像:\n\nx86架构拉取x86镜像：\n```shell\ndocker pull tugraph/geaflow-console:0.1\n```\n\n如果是arm架构，拉取arm镜像：\n```shell\ndocker pull tugraph/geaflow-console-arm:0.1\n```\n\n如果遇到网络问题导致拉取失败，也可以通过下面命令直接构建镜像(构建镜像之前需要先启动docker容器,构建脚本根据机器类型build对应类型的镜像):\n\n\n```shell\ngit clone https://github.com/TuGraph-family/tugraph-analytics.git\ncd tugraph-analytics/\nbash ./build.sh --all\n\n```\n\n\n整个编译过程可能持续一段时间，请耐心等待。镜像编译成功后，通过以下命令查看镜像：\n```shell\ndocker images\n```\n远程拉取的镜像名称为：**tugraph/geaflow-console:0.1**(x86架构) 或者**tugraph/geaflow-console-arm:0.1**(arm架构)\n。本地镜像名称为：**geaflow-console:0.1**，只需选择一种方式构建镜像即可。\n\n## Docker容器运行GeaFlow作业\n下面介绍在docker容器里面运行前面本地模式运行介绍的流图作业。\n\n1. 启动GeaFlow Console平台服务。\n\n* 远程镜像启动方式如下：\n\n**x86架构**\n```\ndocker run -d --name geaflow-console -p 8888:8888 tugraph/geaflow-console:0.1\n```\n\n此文档主要介绍如何在Docker容器中部署和使用GeaFlow Console平台，包括准备工作、镜像拉取、容器运行以及图计算作业的创建和提交。在这一部分中，详细说明了准备工作步骤，特别是如何下载安装Docker并拉取或构建GeaFlow Console镜像，为后续的Docker容器操作奠定基础。"
            },
            {
                "content": "```\n\n\n整个编译过程可能持续一段时间，请耐心等待。镜像编译成功后，通过以下命令查看镜像：\n```shell\ndocker images\n```\n远程拉取的镜像名称为：**tugraph/geaflow-console:0.1**(x86架构) 或者**tugraph/geaflow-console-arm:0.1**(arm架构)\n。本地镜像名称为：**geaflow-console:0.1**，只需选择一种方式构建镜像即可。\n\n## Docker容器运行GeaFlow作业\n下面介绍在docker容器里面运行前面本地模式运行介绍的流图作业。\n\n1. 启动GeaFlow Console平台服务。\n\n* 远程镜像启动方式如下：\n\n**x86架构**\n```\ndocker run -d --name geaflow-console -p 8888:8888 tugraph/geaflow-console:0.1\n```\n\n**arm架构**\n```\ndocker run -d --name geaflow-console -p 8888:8888 tugraph/geaflow-console-arm:0.1\n```\n通过**uname -a**命令可以查看机器架构类型.\n\n* 本地镜像启动方式如下：\n```\ndocker run -d --name geaflow-console -p 8888:8888 geaflow-console:0.1\n```\n**注意**: 远程拉取镜像和本地镜像tag名称不同，启动命令有所区别。\n\n进入容器等待Java进程启动完成后，访问 http://localhost:8888 进入GeaFlow Console平台页面。\n\n\n```shell\n> docker exec -it geaflow-console tailf /tmp/logs/geaflow/app-default.log\n\n# wait the logs below and open url http://localhost:8888\nGeaflowApplication:61   - Started GeaflowApplication in 11.437 seconds (JVM running for 13.475)\n```\n\n2. 注册用户\n\n该段落主要介绍了在Docker容器中运行GeaFlow Console的平台服务，包括镜像的拉取与构建、启动命令、访问方式以及用户注册的步骤，是文档中关于Docker容器部署GeaFlow作业的具体操作指南。"
            },
            {
                "content": "* 本地镜像启动方式如下：\n```\ndocker run -d --name geaflow-console -p 8888:8888 geaflow-console:0.1\n```\n**注意**: 远程拉取镜像和本地镜像tag名称不同，启动命令有所区别。\n\n进入容器等待Java进程启动完成后，访问 http://localhost:8888 进入GeaFlow Console平台页面。\n\n\n```shell\n> docker exec -it geaflow-console tailf /tmp/logs/geaflow/app-default.log\n\n# wait the logs below and open url http://localhost:8888\nGeaflowApplication:61   - Started GeaflowApplication in 11.437 seconds (JVM running for 13.475)\n```\n\n2. 注册用户\n\n首位注册用户将默认被设置为管理员，以管理员身份登录，通过一键安装功能开始系统初始化。\n\n\n3. 配置运行时环境\n\nGeaFlow首次运行需要配置运行时环境相关的配置，包括集群配置、运行时配置、数据存储配置以及文件存储配置。\n\n3.1 集群配置\n\n使用默认Container模式，即本地容器运行。\n\n3.2 运行时配置\n\n本地运行模式下可以跳过这一步配置，使用系统默认配置，直接点下一步。\n\n3.3 数据存储配置\n\n选择图数据存储位置，本地模式下选择LOCAL,填写一个本地目录。默认不需填写，直接点下一步。\n\n3.4 文件存储配置\n\n该配置为GeaFlow引擎JAR、用户JAR文件的持久化存储，比如HDFS等。本地运行模式下和数据存储配置相同，选择LOCAL模式，填写一个本地目录。默认不需填写，直接点下一步。\n\n配置完成后点击一键安装按钮，安装成功后，管理员会自动切换到个人租户下的默认实例，并可以直接创建发布图计算任务。\n\n4. 创建图计算任务\n\n进入图研发页面，选择左侧图任务Tab栏，点击右上角新增按钮，新建一个DSL作业。\n\n分别填写任务名称、任务描述和DSL内容。其中DSL内容和前面本地运行作业介绍的一样，只需修改DSL,**将tbl_source和tbl_result表的${your.host.ip}替换成本机ip**即可。\n\n该段落位于文档的中间部分，详细介绍了如何在本地模式下启动GeaFlow Console，并进行用户注册、配置运行时环境及创建图计算任务的步骤。"
            },
            {
                "content": "3.1 集群配置\n\n使用默认Container模式，即本地容器运行。\n\n3.2 运行时配置\n\n本地运行模式下可以跳过这一步配置，使用系统默认配置，直接点下一步。\n\n3.3 数据存储配置\n\n选择图数据存储位置，本地模式下选择LOCAL,填写一个本地目录。默认不需填写，直接点下一步。\n\n3.4 文件存储配置\n\n该配置为GeaFlow引擎JAR、用户JAR文件的持久化存储，比如HDFS等。本地运行模式下和数据存储配置相同，选择LOCAL模式，填写一个本地目录。默认不需填写，直接点下一步。\n\n配置完成后点击一键安装按钮，安装成功后，管理员会自动切换到个人租户下的默认实例，并可以直接创建发布图计算任务。\n\n4. 创建图计算任务\n\n进入图研发页面，选择左侧图任务Tab栏，点击右上角新增按钮，新建一个DSL作业。\n\n分别填写任务名称、任务描述和DSL内容。其中DSL内容和前面本地运行作业介绍的一样，只需修改DSL,**将tbl_source和tbl_result表的${your.host.ip}替换成本机ip**即可。\n\n```sql\nset geaflow.dsl.window.size = 1;\nset geaflow.dsl.ignore.exception = true;\n\nCREATE GRAPH IF NOT EXISTS dy_modern (\n  Vertex person (\n    id bigint ID,\n    name varchar\n  ),\n  Edge knows (\n    srcId bigint SOURCE ID,\n    targetId bigint DESTINATION ID,\n    weight double\n  )\n) WITH (\n  storeType='rocksdb',\n  shardCount = 1\n);\n\nCREATE TABLE IF NOT EXISTS tbl_source (\n  text varchar\n) WITH (\n  type='socket',\n  `geaflow.dsl.column.separator` = '#',\n  `geaflow.dsl.socket.host` = '${your.host.ip}',\n  `geaflow.dsl.socket.port` = 9003\n);\n\n该内容块位于《白屏部署》文档中，主要介绍了GeaFlow Console平台的集群配置、运行时配置、数据存储配置和文件存储配置的步骤，以及如何创建图计算任务。这部分是用户在成功启动GeaFlow Console后进行系统配置和任务创建的关键步骤。"
            },
            {
                "content": "CREATE GRAPH IF NOT EXISTS dy_modern (\n  Vertex person (\n    id bigint ID,\n    name varchar\n  ),\n  Edge knows (\n    srcId bigint SOURCE ID,\n    targetId bigint DESTINATION ID,\n    weight double\n  )\n) WITH (\n  storeType='rocksdb',\n  shardCount = 1\n);\n\nCREATE TABLE IF NOT EXISTS tbl_source (\n  text varchar\n) WITH (\n  type='socket',\n  `geaflow.dsl.column.separator` = '#',\n  `geaflow.dsl.socket.host` = '${your.host.ip}',\n  `geaflow.dsl.socket.port` = 9003\n);\n\nCREATE TABLE IF NOT EXISTS tbl_result (\n  a_id bigint,\n  b_id bigint,\n  c_id bigint,\n  d_id bigint,\n  a1_id bigint\n) WITH (\n  type='socket',\n    `geaflow.dsl.column.separator` = ',',\n    `geaflow.dsl.socket.host` = '${your.host.ip}',\n    `geaflow.dsl.socket.port` = 9003\n);\n\nUSE GRAPH dy_modern;\n\nINSERT INTO dy_modern.person(id, name)\nSELECT\ncast(split_ex(t1, ',', 0) as bigint),\nsplit_ex(t1, ',', 1)\nFROM (\n  Select trim(substr(text, 2)) as t1\n  FROM tbl_source\n  WHERE substr(text, 1, 1) = '.'\n);\n\n该代码块位于文档中关于创建图计算任务的部分，具体描述了如何使用DSL（领域特定语言）定义图模型、创建数据表以及插入数据，以便在GeaFlow平台上进行实时图计算作业。"
            },
            {
                "content": "CREATE TABLE IF NOT EXISTS tbl_result (\n  a_id bigint,\n  b_id bigint,\n  c_id bigint,\n  d_id bigint,\n  a1_id bigint\n) WITH (\n  type='socket',\n    `geaflow.dsl.column.separator` = ',',\n    `geaflow.dsl.socket.host` = '${your.host.ip}',\n    `geaflow.dsl.socket.port` = 9003\n);\n\nUSE GRAPH dy_modern;\n\nINSERT INTO dy_modern.person(id, name)\nSELECT\ncast(split_ex(t1, ',', 0) as bigint),\nsplit_ex(t1, ',', 1)\nFROM (\n  Select trim(substr(text, 2)) as t1\n  FROM tbl_source\n  WHERE substr(text, 1, 1) = '.'\n);\n\nINSERT INTO dy_modern.knows\nSELECT\n cast(split_ex(t1, ',', 0) as bigint),\n cast(split_ex(t1, ',', 1) as bigint),\n cast(split_ex(t1, ',', 2) as double)\nFROM (\n  Select trim(substr(text, 2)) as t1\n  FROM tbl_source\n  WHERE substr(text, 1, 1) = '-'\n);\n\n该代码块位于文档中关于创建图计算任务的部分，主要展示了如何在GeaFlow中定义和插入数据到结果表（tbl_result）和图（dy_modern）中的相关SQL语句，帮助用户理解如何设置图计算作业和相应的数据流。"
            },
            {
                "content": "USE GRAPH dy_modern;\n\nINSERT INTO dy_modern.person(id, name)\nSELECT\ncast(split_ex(t1, ',', 0) as bigint),\nsplit_ex(t1, ',', 1)\nFROM (\n  Select trim(substr(text, 2)) as t1\n  FROM tbl_source\n  WHERE substr(text, 1, 1) = '.'\n);\n\nINSERT INTO dy_modern.knows\nSELECT\n cast(split_ex(t1, ',', 0) as bigint),\n cast(split_ex(t1, ',', 1) as bigint),\n cast(split_ex(t1, ',', 2) as double)\nFROM (\n  Select trim(substr(text, 2)) as t1\n  FROM tbl_source\n  WHERE substr(text, 1, 1) = '-'\n);\n\nINSERT INTO tbl_result\nSELECT DISTINCT\n  a_id,\n  b_id,\n  c_id,\n  d_id,\n  a1_id\nFROM (\n  MATCH (a:person) -[:knows]->(b:person) -[:knows]-> (c:person)\n   -[:knows]-> (d:person) -> (a:person)\n  RETURN a.id as a_id, b.id as b_id, c.id as c_id, d.id as d_id, a.id as a1_id\n);\n```\n本机ip获取方式如下，执行命令：\n\n```shell\nifconfig\n```\n找到eth0或者en0的网卡，其中ipv4的地址即为你本机的ip地址。\n\n创建完成作业后，点击发布按钮发布作业。\n\n然后进入作业管理页面，点击提交按钮提交作业执行。\n\n5. 启动socket服务输入数据\n\n进入GeaFlow项目路径，执行如下命令启动socket服务(启动socket服务前需要先提前编译一次GeaFlow工程，如果前面编译过则忽略)\n\n该代码块位于文档中的创建图计算任务部分，具体描述了如何在GeaFlow中使用DSL语言定义图结构和数据插入操作，包括向图中插入节点和边，以及从图中查询数据的SQL语句。此块位于用户完成任务创建后至启动数据输入服务之间，提供了具体的操作示例和步骤。"
            },
            {
                "content": "INSERT INTO tbl_result\nSELECT DISTINCT\n  a_id,\n  b_id,\n  c_id,\n  d_id,\n  a1_id\nFROM (\n  MATCH (a:person) -[:knows]->(b:person) -[:knows]-> (c:person)\n   -[:knows]-> (d:person) -> (a:person)\n  RETURN a.id as a_id, b.id as b_id, c.id as c_id, d.id as d_id, a.id as a1_id\n);\n```\n本机ip获取方式如下，执行命令：\n\n```shell\nifconfig\n```\n找到eth0或者en0的网卡，其中ipv4的地址即为你本机的ip地址。\n\n创建完成作业后，点击发布按钮发布作业。\n\n然后进入作业管理页面，点击提交按钮提交作业执行。\n\n5. 启动socket服务输入数据\n\n进入GeaFlow项目路径，执行如下命令启动socket服务(启动socket服务前需要先提前编译一次GeaFlow工程，如果前面编译过则忽略)\n\n```shell\nbin/socket.sh\n```\nsocket服务启动后，输入点边数据，计算结果会实时显示在屏幕下：\n\n```\n. 1,jim\n. 2,kate\n. 3,lily\n. 4,lucy\n. 5,brown\n. 6,jack\n. 7,jackson\n- 1,2,0.2\n- 2,3,0.3\n- 3,4,0.2\n- 4,1,0.1\n- 4,5,0.1\n- 5,1,0.2\n- 5,6,0.1\n- 6,7,0.1\n```\n\n## K8S部署\nGeaFlow支持K8S部署。\n\n该段落位于文档的图计算任务创建部分，具体描述了如何向结果表 `tbl_result` 插入数据，并提供了获取本机IP地址的方法，以及后续操作如发布作业和启动socket服务以输入数据，最终展示实时计算结果。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_3.md",
        "chunks": [
            {
                "content": "# 地理空间数据类型使用示例\n\n## 1. 简介\n\nTuGraph图数据库由蚂蚁集团与清华大学联合研发，构建了一套包含图存储、图计算、图学习、图研发平台的完善的图技术体系，拥有业界领先规模的图集群。近年来，地理空间功能在图数据库中的应用价值显著，它不仅增强了数据的表达能力，还促进了跨领域数据的融合分析，尤其在社交网络、地图探索、城市规划等关键领域展现了强大的实用价值。TuGraph也正在逐步支持地理空间功能。\n\n## 2. 预备知识\n\nEPSG([EPSG.io: Coordinate Systems Worldwide](https://epsg.io/)) 是一个标准化的地理空间参考系统标识符集合， 用于标识不同的地理空间参考系统，包括坐标系统、地理坐标系、投影坐标系等。我们常用EPSG编码表示数据的坐标系，这里我们介绍两种最常见的空间地理坐标系，也是大部分数据库支持的坐标系类型。\n\n### 2.1 WGS84坐标系 EPSG: 4326\n\n全球GPS定位系统: WGS84是全球定位系统(GPS)的基础，允许全球的GPS接收器确定精确位置。几乎所有现代GPS设备都是基于WGS84坐标系来提供位置信息。地图制作和地理信息系统(GIS): 在地图制作和GIS领域，WGS84被广泛用于定义地球上的位置。这包括各种类型的地图创建、空间数据分析和管理等。\n\n### 2.2 Cartesian(笛卡尔)坐标系 EPSG: 7203\n\n直角坐标系，是一种最基本、最广泛应用的坐标系统。它通过两条数轴定义一个平面，三条数轴定义一个空间，这些轴互相垂直，在数学、物理、工程、天文和许多其他领域中有着广泛的应用。\n\n### 2.3 数据存储格式\n\nOGC(Open Geospatial Consortium) 定义了空间数据的标准表示格式，分别为WKT与WKB格式，用于在不同系统和平台之间交换和存储空间数据，现已被广泛采用。其中WKT(well-kown text)格式, 是一种文本标记语言,易于人类阅读和编写，而WKB(Well-Known Binary)格式采用一系列字节来编码空间数据，更适合在计算机中存储;\n\n**WKT:**\n\n```\nPOINT( )\nLINESTRING( , , ...)\n```\n\n本段落为《地理空间数据类型使用示例》的开头部分，介绍了TuGraph图数据库的背景及其在地理空间功能方面的应用价值，并简要说明了EPSG编码的作用以及常见的地理坐标系类型。接下来将详细介绍数据存储格式和基本数据类型。"
            },
            {
                "content": "### 2.2 Cartesian(笛卡尔)坐标系 EPSG: 7203\n\n直角坐标系，是一种最基本、最广泛应用的坐标系统。它通过两条数轴定义一个平面，三条数轴定义一个空间，这些轴互相垂直，在数学、物理、工程、天文和许多其他领域中有着广泛的应用。\n\n### 2.3 数据存储格式\n\nOGC(Open Geospatial Consortium) 定义了空间数据的标准表示格式，分别为WKT与WKB格式，用于在不同系统和平台之间交换和存储空间数据，现已被广泛采用。其中WKT(well-kown text)格式, 是一种文本标记语言,易于人类阅读和编写，而WKB(Well-Known Binary)格式采用一系列字节来编码空间数据，更适合在计算机中存储;\n\n**WKT:**\n\n```\nPOINT( )\nLINESTRING( , , ...)\n```\n\nWKT格式的数据如上例所示，先指定空间数据类型，再在括号内指定具体的坐标，一个坐标对表示一个点，每个坐标对之间用逗号隔开。对于Polygon类型的数据，第一个坐标对需要与最后一个坐标对相同，形成闭合的面。\n\n**WKB:**\n\n\n针对EWKB格式的编码，说明如下:\n\n- 第0 - 1位: 编码方式;\n- 第2 - 5位: 空间数据类型;\n    - 0100: point\n    - 0200: linestring\n    - 0300: polygon\n- 第6 - 9位: 数据维度;\n    - 0020: 二维\n    - 0030: 三维\n- 第10 - 17位: 坐标系的EPSG编码;\n- 第18 - n位: double类型的坐标对的16进制表示。\n\n### 2.4 常用函数\n\n本章节介绍了Cartesian坐标系（EPSG: 7203）及其广泛应用，接着讲解了OGC定义的空间数据存储格式WKT和WKB，为后续的空间数据处理和函数使用奠定基础。"
            },
            {
                "content": "### 2.4 常用函数\n\n| Name                 | Description           | Signature                                                                 |\n|----------------------|-----------------------|---------------------------------------------------------------------------|\n| `dbms.graph.createGraph` | 创建子图           | `dbms.graph.createGraph(graph_name::STRING, description::STRING, max_size_GB::INTEGER) :: (::VOID)` |\n| `db.createVertexLabel`  | 创建Vertex Label      | `db.createVertexLabel(label_name::STRING,field_specs::LIST) :: (::VOID)`      |\n| `db.getLabelSchema`     | 列出label schema      | `db.getLabelSchema(label_type::STRING,label_name::STRING) :: (name::STRING,type::STRING,optional::BOOLEAN)` |\n| `db.deleteLabel`        | 删除Vertex            | `db.deleteLabel(label_type::STRING,label_name::STRING) :: (::VOID)`         |\n表格内容描述:\n该表格包含三列，分别是“Name”（名称）、“Description”（描述）和“Signature”（签名）。\n\n在文档的第二部分\"预备知识\"中，作者介绍了TuGraph图数据库的基本数据类型和函数，特别是与地理空间数据处理相关的常用函数。在这一背景下，\"常用函数\"的表格提供了创建子图、创建和删除顶点标签及列出标签架构等功能的详细信息，帮助开发者快速理解和应用这些数据库操作。"
            },
            {
                "content": "逐行描述数据内容如下：\n1. 第一行的内容为`dbms.graph.createGraph`，其描述为“创建子图”，签名为`dbms.graph.createGraph(graph_name::STRING, description::STRING, max_size_GB::INTEGER) :: (::VOID)`，表示用于创建一个新的子图。\n2. 第二行的内容为`db.createVertexLabel`，其描述为“创建Vertex Label”，签名为`db.createVertexLabel(label_name::STRING,field_specs::LIST) :: (::VOID)`，这表示用于创建一个新的顶点标签。\n3. 第三行的内容为`db.getLabelSchema`，其描述为“列出label schema”，签名为`db.getLabelSchema(label_type::STRING,label_name::STRING) :: (name::STRING,type::STRING,optional::BOOLEAN)`，表明这个功能用于列出特定标签的架构信息。\n4. 第四行的内容为`db.deleteLabel`，其描述为“删除Vertex”，签名为`db.deleteLabel(label_type::STRING,label_name::STRING) :: (::VOID)`，表示用于删除指定的顶点标签。\n\n总体而言，该表格列出了几个数据库操作的功能，包括创建子图、创建和删除顶点标签，以及列出标签架构，提供了相应的描述和调用签名，便于开发者了解和使用这些功能。\n\n\n## 3. 数据类型\n\n目前在TuGraph中，我们已经支持了Point, Linestring与Polygon三种类型:\n\n- Point：点    point(2.0, 2.0, 7203)\n- Linestring：折线 LINESTRING(0 2,1 1,2 0)\n- Polygon：多边形  POLYGON((0 0,0 7,4 2,2 0,0 0))\n\n其中坐标点都是double型，创建图模型和插入数据示例如下：\n\n**创建标记美食位置的点模型**\n\n该段落描述了TuGraph图数据库中的常用函数及其功能和签名，包括创建子图、创建顶点标签、列出标签架构和删除顶点等操作，为读者提供了理解数据库操作的基础信息，并为后续的数据类型及实例展示做铺垫。"
            },
            {
                "content": "总体而言，该表格列出了几个数据库操作的功能，包括创建子图、创建和删除顶点标签，以及列出标签架构，提供了相应的描述和调用签名，便于开发者了解和使用这些功能。\n\n\n## 3. 数据类型\n\n目前在TuGraph中，我们已经支持了Point, Linestring与Polygon三种类型:\n\n- Point：点    point(2.0, 2.0, 7203)\n- Linestring：折线 LINESTRING(0 2,1 1,2 0)\n- Polygon：多边形  POLYGON((0 0,0 7,4 2,2 0,0 0))\n\n其中坐标点都是double型，创建图模型和插入数据示例如下：\n\n**创建标记美食位置的点模型**\n\n```\nCALL db.createVertexLabel('food', 'id', 'id', int64, false, 'name', string, true,'pointTest',point,true) \n```\n\n**插入标记美食点的数据**\n\n```\n CREATE (n:food {id:10001, name: 'aco Bell',pointTest:point(3.0,4.0,7203)}) RETURN n\n```\n\n**创建具有折线属性的点模型**\n\n```\nCALL db.createVertexLabel('lineTest', 'id', 'id', int64, false, 'name', string, true,'linestringTest',linestring,true)\n```\n\n**插入具有折线属性的点数据**\n\n```\nCREATE (n:lineTest {id:102, name: 'Tom',linestringTest:linestringwkt('LINESTRING(0 2,1 1,2 0)', 7203)}) RETURN n\n```\n\n**创建具有多边型属性的点模型**\n\n```\nCALL db.createVertexLabel('polygonTest', 'id', 'id', int64, false, 'name', string, true,'polygonTest',polygon,true)\n```\n\n**插入具有多边型属性的点数据**\n\n该块内容位于文档的第三部分，主要介绍了TuGraph图数据库支持的三种地理空间数据类型（Point、Linestring和Polygon），以及相关的图模型创建和数据插入示例，为后续的地理空间数据操作提供基础知识和实践参考。"
            },
            {
                "content": "**创建具有折线属性的点模型**\n\n```\nCALL db.createVertexLabel('lineTest', 'id', 'id', int64, false, 'name', string, true,'linestringTest',linestring,true)\n```\n\n**插入具有折线属性的点数据**\n\n```\nCREATE (n:lineTest {id:102, name: 'Tom',linestringTest:linestringwkt('LINESTRING(0 2,1 1,2 0)', 7203)}) RETURN n\n```\n\n**创建具有多边型属性的点模型**\n\n```\nCALL db.createVertexLabel('polygonTest', 'id', 'id', int64, false, 'name', string, true,'polygonTest',polygon,true)\n```\n\n**插入具有多边型属性的点数据**\n\n```\nCREATE (n:polygonTest {id:103, name: 'polygonTest',polygonTest:polygonwkt('POLYGON((0 0,0 7,4 2,2 0,0 0))', 7203)}) RETURN n\n```\n\n## 4. 函数介绍\n\n| 函数名  | 描述 | 输入参数                         | 返回值类型 |\n| --- | --- |------------------------------| --- |\n| Distance() | 计算两个空间数据间的距离(要求坐标系相同) | Spatial data1, Spatial data2 | double |\n| Disjoint()  |  判断两个空间数据是否相交（开发中） | Spatial data1, Spatial data2 | bool |\n| WithinBBox() | 判断某个空间数据是否在给定的长方形区域内（开发中） | Spatial data, Point1         | bool |\n表格内容描述:\n\n该表格包含四列，分别是“函数名”、“描述”、“输入参数”和“返回值类型”。\n\n该章节位于文档的“数据类型”部分后，详细介绍了如何创建和插入具有折线及多边形属性的点模型，紧接着进入“函数介绍”部分，总结了与空间数据处理相关的函数及其功能。这段内容展示了TuGraph在地理空间数据建模方面的应用实例。"
            },
            {
                "content": "## 4. 函数介绍\n\n| 函数名  | 描述 | 输入参数                         | 返回值类型 |\n| --- | --- |------------------------------| --- |\n| Distance() | 计算两个空间数据间的距离(要求坐标系相同) | Spatial data1, Spatial data2 | double |\n| Disjoint()  |  判断两个空间数据是否相交（开发中） | Spatial data1, Spatial data2 | bool |\n| WithinBBox() | 判断某个空间数据是否在给定的长方形区域内（开发中） | Spatial data, Point1         | bool |\n表格内容描述:\n\n该表格包含四列，分别是“函数名”、“描述”、“输入参数”和“返回值类型”。 \n\n- 第一行描述了“Distance()”函数，功能是计算两个空间数据之间的距离，前提是它们的坐标系相同。该函数接受两个参数：Spatial data1 和 Spatial data2，并返回一个 double 类型的值。\n- 第二行介绍了“Disjoint()”函数，该函数用于判断两个空间数据是否相交，目前处于开发中状态。它同样接受两个参数：Spatial data1 和 Spatial data2，并返回一个 bool 类型的值。\n- 第三行列出了“WithinBBox()”函数，功能是判断某个空间数据是否位于给定的长方形区域内，此功能也正在开发中。它接受两个参数：Spatial data 和 Point1，并返回一个 bool 类型的值。\n\n总体来说，该表格展示了三个与空间数据处理相关的函数，其中“Distance()”函数已完成并可用，而“Disjoint()”和“WithinBBox()”函数正在开发中。每个函数都指定了输入参数和返回值的类型，显示了这些函数在空间数据分析中的潜在应用。\n\n## 5. 美食探索\n### 5.1 基于地理位置的个性化推荐\n\n在本章节中，我们将探索如何利用Tugraph图数据库的地理空间功能，构建一个生动有趣的美食探索应用，将“人”与“美食”通过地理位置紧密相连，实现个性化美食推荐。想象一下，无论身处何方，只需轻轻一点，周围诱人美食便尽收眼底，这正是我们即将构建的场景魅力所在。\n\n该块内容位于文档的第4章，介绍了TuGraph图数据库中与地理空间数据处理相关的函数，包括距离计算、空间数据相交性检测和在给定区域内的判断，随后紧接着是第5章，讨论基于地理位置的个性化美食推荐应用。"
            },
            {
                "content": "总体来说，该表格展示了三个与空间数据处理相关的函数，其中“Distance()”函数已完成并可用，而“Disjoint()”和“WithinBBox()”函数正在开发中。每个函数都指定了输入参数和返回值的类型，显示了这些函数在空间数据分析中的潜在应用。\n\n## 5. 美食探索\n### 5.1 基于地理位置的个性化推荐\n\n在本章节中，我们将探索如何利用Tugraph图数据库的地理空间功能，构建一个生动有趣的美食探索应用，将“人”与“美食”通过地理位置紧密相连，实现个性化美食推荐。想象一下，无论身处何方，只需轻轻一点，周围诱人美食便尽收眼底，这正是我们即将构建的场景魅力所在。\n\n### 5.2 数据模型设计\n我们首先定义两种核心节点类型：\n\n- Food（美食）节点：每一家餐厅或小吃店都可以作为一个Food节点，其属性包括但不限于名称、地址、评分、美食类别等。特别地，我们将在每个Food节点上附加地理坐标信息，用以精确记录其地理位置。\n\n```\n CALL db.createVertexLabel('food', 'id', 'id', int64, false, 'name', string, true,'pointTest',point,true,'mark',double,true)\n```\n\n准备数据：\n\n该段落位于文档的第5节，讨论了TuGraph图数据库在美食探索应用中的地理空间功能，主要涵盖个性化推荐的实现及相关数据模型设计。前文介绍了与空间数据处理的一些函数，接着深入探讨如何通过节点类型（Food和Person）来构建美食推荐系统。"
            },
            {
                "content": "### 5.2 数据模型设计\n我们首先定义两种核心节点类型：\n\n- Food（美食）节点：每一家餐厅或小吃店都可以作为一个Food节点，其属性包括但不限于名称、地址、评分、美食类别等。特别地，我们将在每个Food节点上附加地理坐标信息，用以精确记录其地理位置。\n\n```\n CALL db.createVertexLabel('food', 'id', 'id', int64, false, 'name', string, true,'pointTest',point,true,'mark',double,true)\n```\n\n准备数据：\n\n```\nCREATE (n:food {id:10001, name: 'Starbucks',pointTest:point(1.0,1.0,7203),mark:4.8}) RETURN n\nCREATE (n:food {id:10002, name: 'KFC',pointTest:point(2.0,1.0,7203),mark:4.5}) RETURN n\nCREATE (n:food {id:10003, name: 'Pizza Hut',pointTest:point(2.0,5.0,7203),mark:4.5}) RETURN n\nCREATE (n:food {id:10004, name: 'Taco Bell',pointTest:point(3.0,4.0,7203),mark:4.7}) RETURN n\nCREATE (n:food {id:10005, name: 'Pizza Fusion',pointTest:point(5.0,3.0,7203),mark:4.9}) RETURN n\nCREATE (n:food {id:10006, name: 'HaiDiLao Hot Pot',pointTest:point(2.0,2.0,7203),mark:4.8}) RETURN n\nCREATE (n:food {id:10007, name: 'Lao Sze Chuan',pointTest:point(4.0,3.0,7203),mark:4.7}) RETURN n\n```\n\n- Person（人物）节点：代表应用的用户，属性包含用户名、当前位置等。用户的当前位置同样通过地理坐标表示，便于后续的地理空间查询。\n\n在文档的第5章“美食探索”中，5.2节专注于数据模型设计，定义了两个核心节点类型：Food（美食）节点和Person（人物）节点，旨在通过地理坐标信息来实现个性化美食推荐，这一部分为后续的美食探索查询提供了基础数据结构和准备数据示例。"
            },
            {
                "content": "- Person（人物）节点：代表应用的用户，属性包含用户名、当前位置等。用户的当前位置同样通过地理坐标表示，便于后续的地理空间查询。\n\n```\n CALL db.createVertexLabel('person', 'id', 'id', int64, false, 'name', string, true,'pointTest',point,true)\n```\n\n准备数据：\n\n```\n CREATE (n:person {id:1, name: 'Tom',pointTest:point(3.0,3.0,7203)}) RETURN n\n```\n\n### 5.3 构建美食探索查询\n\n能够根据用户的当前位置，寻找距离2.5以内的美食,根据距离进行升序排列。返回距离和评分让用户得倒更好的体验。\n\n**查询语句**\n\n```\nmatch (n:person{id:1}),(m:food) with n.pointTest as p1,m.pointTest as p2,m.name as food,m.mark as mark\nCALL spatial.distance(p1,p2) YIELD distance \nWHERE distance<2.5\nRETURN food,distance,mark ORDER by distance\n```\n\n此查询首先匹配特定的Person节点（以用户名“Tom”为例），然后找到所有Food节点，利用自定义的distance函数，计算Person节点当前位置与每个Food节点之间的直线距离，筛选出距离在2.5之内的美食。最后，按照美食的距离升序排列结果，附带评分参考，为用户提供最优质的推荐。\n\n## 6. 展望\n\n通过上述章节，我们不仅展示了TuGraph在地理空间数据处理的能力，也描绘了一个富有吸引力的美食探索场景，证明了图数据库在结合地理位置信息进行个性化服务方面具有巨大潜力。无论是寻找周末的休闲去处，还是探索旅行途中的特色美食，这样的应用都将极大地丰富人们的生活体验。\n\nTuGraph将来会继续实现Disjoint() 、WithinBBox()，会丰富更多使用场景。当然，也欢迎大家一起参与，共同开发地理空间功能。\n\n该段落位于文档的第5章，主要介绍了基于地理位置的个性化美食推荐应用。它描述了如何创建和使用“Person”节点来表示用户及其当前位置，并提供了构建美食探索查询的示例，以便用户能够根据当前位置寻找附近的美食选项。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_4.md",
        "chunks": [
            {
                "content": "# G6VP(https://github.com/antvis/g6vp) 图可视化\n\n## 仅需 5 步，即可呈现\n\n### 1. 启动 GeaFlow 流图作业和 Socket 服务\n\n参考[快速开始](https://github.com/TuGraph-family/tugraph-analytics/blob/master/docs/docs-cn/quick_start.md)\n\n注意在 `启动SocketServer` 步骤使用下列命令代替\n\n```bash\nbin/socket.sh 9003 GI\n```\n\n输出下列内容时，即表示 Tugraph Analytics 准备好建立连接\n\n\n\n> 如启动服务过程中遇到问题，可见 https://github.com/TuGraph-family/tugraph-analytics/issues/1\n\n### 2. 创建 G6VP 项目\n\n进入[新建画布](https://insight.antv.antgroup.com/#/workbook/create)，输入工作簿名称。我们会在后面手动添加点边数据，所以这里随便选择一个案例数据集即可，模版使用**极简模版**\n\n### 3. 添加组件\n\n我们需要添加两个组件，在工具栏中添加 **清空画布**；然后在默认布局的侧边容器中添加**环路检测 Demo**\n\n\n\n\n> 此时项目画布应该如下所示\n> \n\n点击工具栏中的`🧹清除`选项来清空画布节点\n\n\n\n默认情况下，添加完`环路检测Demo`组件后，会自动建立连接。\n\n\n\nTugraph Analytics 端建立连接后同样会输出以下内容：\n\n\n\n### 4. 演示\n\n环路检测 Demo 提供了两种方式来进行交互：\n\n* 方式一 在输入框中输入点边信息\n* 方式二 使用内置数据进行演示\n\n> 两种方式本质都是调用 Tugraph Analytics 进行实时计算，不过方式二省略了手动输入过程。\n\n这里我们使用内置数据进行快速演示，点击【选项】，选择`添加点`，画布中出现了 7 个点信息；接着选择`添加边`。我们可以在上方对话框中看到添加记录。\n\n\n\n同样的，Tugraph Analytics 终端也会实时输出操作信息，并自动启动计算任务。\n\n\n\n### 5. 结果展示\n\nTugraph Analytics 完成环路检测计算任务后，会自动返回检测结果。\n\n该文档介绍了如何使用 G6VP 进行图可视化，通过五个步骤展示了如何启动服务、创建项目、添加组件、演示操作及结果展示，主要与 Tugraph Analytics 的环路检测功能相关。"
            },
            {
                "content": "### 3. 添加组件\n\n我们需要添加两个组件，在工具栏中添加 **清空画布**；然后在默认布局的侧边容器中添加**环路检测 Demo**\n\n\n\n\n> 此时项目画布应该如下所示\n> \n\n点击工具栏中的`🧹清除`选项来清空画布节点\n\n\n\n默认情况下，添加完`环路检测Demo`组件后，会自动建立连接。\n\n\n\nTugraph Analytics 端建立连接后同样会输出以下内容：\n\n\n\n### 4. 演示\n\n环路检测 Demo 提供了两种方式来进行交互：\n\n* 方式一 在输入框中输入点边信息\n* 方式二 使用内置数据进行演示\n\n> 两种方式本质都是调用 Tugraph Analytics 进行实时计算，不过方式二省略了手动输入过程。\n\n这里我们使用内置数据进行快速演示，点击【选项】，选择`添加点`，画布中出现了 7 个点信息；接着选择`添加边`。我们可以在上方对话框中看到添加记录。\n\n\n\n同样的，Tugraph Analytics 终端也会实时输出操作信息，并自动启动计算任务。\n\n\n\n### 5. 结果展示\n\nTugraph Analytics 完成环路检测计算任务后，会自动返回检测结果。\n\n\n\n右侧画布中会动态显示出本次环路检测结果信息：\n\n![Jun-12-2023 19-53-35](https://github.com/TuGraph-family/tugraph-analytics/assets/25787943/f8595322-d477-4702-a52e-4f03092b7219)\n\n该文档介绍了如何使用G6VP进行图可视化，特别是通过Tugraph Analytics进行环路检测的步骤。第三步和第四步具体说明了如何添加组件和演示交互功能，以及使用内置数据进行快速演示的过程。第五步则展示了计算结果的展示方式。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_5.md",
        "chunks": [
            {
                "content": "# 数据导入\n\n> 此文档主要介绍 TuGraph 的数据导入功能。其中包括 CSV 格式的分隔符，jsonline 的格式示例，以及导入在线和离线的两种模式。\n\n## 1.简介\n\n在图数据库服务安装成功后，您可以使用`lgraph_import`批量导入工具将现有数据导入 TuGraph。`lgraph_import`支持从 CSV 文件和 JSON 数据源导入数据。\n\n> CSV 格式\n\n```\n[movies.csv]\nid, name, year, rating\ntt0188766,King of Comedy,1999,7.3\ntt0286112,Shaolin Soccer,2001,7.3\ntt4701660,The Mermaid,2016,6.3\n```\n\n> jsonline 格式\n\n```json\n[\"tt0188766\",\"King of Comedy\",1999,7.3]\n[\"tt0286112\",\"Shaolin Soccer\",2001,7.3]\n[\"tt4701660\",\"The Mermaid\",2016,6.3]\n```\n\nTuGraph 支持两种导入模式：\n\n- _离线模式_：读取数据并将其导入指定服务器的数据文件，应仅在服务器离线时完成。\n- _在线模式_：读取数据并将其发送到工作中的服务器，然后将数据导入其数据库。\n\n## 2.CSV文件格式分隔符\n\n    CSV格式的分隔符可以是单字符或多字符组成的字符串，其中不能包含`\\r`或`\\n`。注意不同的shell会对输入字符串做不同的处理，因此针对不同的shell输入参数可能需要不同的转义处理。\n\n此外，`lgraph_import`还支持以下转义字符，以便输入特殊符号：\n\n该文档主要介绍了 TuGraph 数据导入功能，包括不同格式的数据（如 CSV 和 JSON）及其导入模式（在线和离线）。本文的前两部分详细说明了使用 `lgraph_import` 工具进行数据导入的基本情况，并列出了 CSV 文件格式的示例和分隔符规则。"
            },
            {
                "content": "TuGraph 支持两种导入模式：\n\n- _离线模式_：读取数据并将其导入指定服务器的数据文件，应仅在服务器离线时完成。\n- _在线模式_：读取数据并将其发送到工作中的服务器，然后将数据导入其数据库。\n\n## 2.CSV文件格式分隔符\n\n    CSV格式的分隔符可以是单字符或多字符组成的字符串，其中不能包含`\\r`或`\\n`。注意不同的shell会对输入字符串做不同的处理，因此针对不同的shell输入参数可能需要不同的转义处理。\n\n此外，`lgraph_import`还支持以下转义字符，以便输入特殊符号：\n\n| 转义符 | 说明                                                             |\n| ------ | ---------------------------------------------------------------- |\n| \\\\     | 反斜杠`\\\\`                                                       |\n| \\\\a    | 响铃，即 ASCII 码 0x07                                           |\n| \\\\f    | form-feed，即 ASCII 码 0x0c                                      |\n| \\\\t    | 水平制表符，即 ASCII 码 0x09                                     |\n| \\\\v    | 垂直制表符，即 ASCII 码 0x0b                                     |\n| \\\\xnn  | 两位十六进制数，表示一个字节，如\\\\x9A                            |\n| \\\\nnn  | 三位八进制数，表示一个字节，如\\\\001, \\\\443，数值范围不能超过 255 |\n表格内容描述:  \n该表格由两列组成，第一列为“转义符”，第二列为“说明”。\n\n该文档主要介绍 TuGraph 的数据导入功能，包括离线模式和在线模式，以及 CSV 文件格式的相关细节和转义字符的使用说明。此处的内容具体集中在两种导入模式的定义以及关于 CSV 文件格式分隔符的细节上，为后续配置和使用提供必要的基础知识。"
            },
            {
                "content": "逐行描述数据内容如下：  \n1. 转义符“\\\\”表示反斜杠。  \n2. 转义符“\\\\a”表示响铃，对应的 ASCII 码为 0x07。  \n3. 转义符“\\\\f”表示换页（form-feed），对应的 ASCII 码为 0x0c。  \n4. 转义符“\\\\t”表示水平制表符，对应的 ASCII 码为 0x09。  \n5. 转义符“\\\\v”表示垂直制表符，对应的 ASCII 码为 0x0b。  \n6. 转义符“\\\\xnn”表示一个字节的两位十六进制数，例如 \\\\x9A。  \n7. 转义符“\\\\nnn”表示一个字节的三位八进制数，例如 \\\\001 或 \\\\443，且数值范围不能超过 255。  \n\n总体来说，该表格列出了常用的转义符及其具体说明，包括 ASCII 码对应的字符和表示特定字节的十六进制和八进制格式。\n\n例：\n\n```bash\n$ ./lgraph_import -c ./import.config --delimiter \"\\001\\002\"\n```\n\n## 3.配置文件\n\n`lgraph_import`工具通过指定的配置文件进行环境配置。配置文件描述输入文件的路径、它们所代表的点/边以及点/边的格式。\n\n### 3.1.配置文件格式\n\n配置文件包含两部分：schema 和 files。`schema`部分定义 label，`files`部分描述要导入的数据文件。\n\n#### 3.1.1.关键字\n\n该块内容位于文档的第三部分，具体介绍了用于数据导入工具`lgraph_import`的转义字符及其说明，随后引入了配置文件的相关信息和结构，包括`schema`和`files`的定义。这部分为后续配置文件的详细说明提供了基础。"
            },
            {
                "content": "- schema (数组形式）\n  - label（必选，字符串形式）\n  - type（必选，值只能是 VERTEX 或者 EDGE）\n  - properties（数组形式，对于点必选，对于边如果没有属性可以不配置）\n    - name（必选，字符串形式）\n    - type （必选，BOOL，INT8，INT16，INT32，INT64，DATE，DATETIME，FLOAT，DOUBLE，STRING，BLOB）\n    - optional（可选，代表该字段可以配置，也可以不配置）\n    - index（可选，该字段是否需要建索引）\n    - unique（可选，该字段是否建索引，并且是 unique 类型的，即全局唯一）\n    - pair_unique（可选，该字段是否建索引，并且是 pari_unique 类型的，即两点间唯一，仅用于边索引）unique与pair_unique只能设置一个，同时设置并运行将会因为输入异常而终止\n  - primary (仅点配置，必选，主键字段，需指定一个 property，用来唯一确定一个点)\n  - temproal (仅边配置，可选，指定时间戳属性用于存储层排序)\n  - temporal_field_order (仅边配置，可选，默认为\"ASC\"，表示升序，也可配置为\"DESC\"，表示降序)\n  - constraints (仅边配置，可选，数组形式，起点和终点的 label，不配置或者为空代表不限制)\n  - detach_property (点边都可配置，可选，默认是`false`。`true` 代表属性数据单独存放，在内存不够，属性数据比较多的场景下可以减少io读放大)\n- files （数组形式）\n  - path（必选，字符串，可以是文件路径或者目录的路径，如果是目录会导入此目录下的所有文件，需要保证有相同的 schema）\n  - header（可选，数字，头信息占文件起始的几行，没有就是 0）\n  - format（必须选，只能是 JSON 或者 CSV）\n  - label（必选，字符串）\n  - columns（数组形式）\n    - SRC_ID (特殊字符串，仅边有，代表这列是起始点数据)\n    - DST_ID (特殊字符串，仅边有，代表这列是目的点数据)\n    - SKIP   (特殊字符串，代表跳过这列数据)\n\n该段落位于文档的配置文件格式部分，详细说明了`lgraph_import`工具中`schema`和`files`的构成及其关键字定义，为用户提供了在导入数据时需要配置的几种属性和格式要求的具体信息。"
            },
            {
                "content": "- temporal_field_order (仅边配置，可选，默认为\"ASC\"，表示升序，也可配置为\"DESC\"，表示降序)\n  - constraints (仅边配置，可选，数组形式，起点和终点的 label，不配置或者为空代表不限制)\n  - detach_property (点边都可配置，可选，默认是`false`。`true` 代表属性数据单独存放，在内存不够，属性数据比较多的场景下可以减少io读放大)\n- files （数组形式）\n  - path（必选，字符串，可以是文件路径或者目录的路径，如果是目录会导入此目录下的所有文件，需要保证有相同的 schema）\n  - header（可选，数字，头信息占文件起始的几行，没有就是 0）\n  - format（必须选，只能是 JSON 或者 CSV）\n  - label（必选，字符串）\n  - columns（数组形式）\n    - SRC_ID (特殊字符串，仅边有，代表这列是起始点数据)\n    - DST_ID (特殊字符串，仅边有，代表这列是目的点数据)\n    - SKIP   (特殊字符串，代表跳过这列数据)\n    - [property]\n  - SRC_ID (仅边配置，值是起始点标签)\n  - DST_ID (仅边配置，值是目的点标签)\n\n该chunk位于第三部分“配置文件”的子部分“3.1.1.关键字”中，主要描述了边配置中的选项和文件部分的格式要求。其中包括边的时间戳字段、约束条件以及导入文件的路径、格式、标签和列映射等内容。"
            },
            {
                "content": "#### 3.1.2.索引长度\n因为TuGraph对key的长度有限制，唯一索引不允许建立超过限制长度的索引，而非唯一索引会对超过长度限制的属性进行截断处理，并且在通过迭代器遍历非唯一索引时，拿到的key也是经过截断的，可能和预期不一致。针对不同类型的非唯一索引，截断长度是不同的。\n##### 3.1.2.1.unique索引\nunique索引是全局唯一的，该索引key的最大长度是480bytes。primary作为特殊的unique索引，因此最大key的长度也是480bytes，超过无法建立索引。\n##### 3.1.2.2.pair_unique索引\npair_unique索引是指两点间唯一的索引，这种类型的索引只能创建于边的schema中，这种索引在用户指定的key后面加上了源点和目标点的vid，每个vid是5bytes长度。因此最大key的长度是470bytes，超过无法建立索引。\n##### 3.1.2.3.非唯一索引\n非唯一索引是指既没有设置unique为1，也没有设置pair_unique为1的索引，在TuGraph的实现中，此类索引一个key可能映射到多个值，为了加速查找和写入，在用户指定的key后面加上了一组vid或euid中的最大值。其中对于创建于点中的非唯一索引，key后面跟着vid，每个vid是5bytes长度，因此最大长度是475bytes。\n对于创建于边中的非唯一索引，key后面跟着euid，每个euid是24bytes长度，因此最大长度是456bytes。索引key超过对应长度则会自动截断。\n\n### 3.2.配置文件示例\n\n该内容位于文档的第3部分，讨论了TuGraph中索引的长度限制，具体介绍了三种索引类型（唯一索引、配对唯一索引和非唯一索引）的最大键长度及其截断规则。该部分紧接着介绍了配置文件的示例，为数据导入的索引设置提供了重要参考。"
            },
            {
                "content": "```json\n{\n  \"schema\": [\n    {\n      \"label\": \"actor\",\n      \"type\": \"VERTEX\",\n      \"properties\": [\n        { \"name\": \"aid\", \"type\": \"STRING\" },\n        { \"name\": \"name\", \"type\": \"STRING\" }\n      ],\n      \"primary\": \"aid\"\n    },\n    {\n      \"label\": \"movie\",\n      \"type\": \"VERTEX\",\n      \"properties\": [\n        { \"name\": \"mid\", \"type\": \"STRING\" },\n        { \"name\": \"name\", \"type\": \"STRING\" },\n        { \"name\": \"year\", \"type\": \"INT16\" },\n        { \"name\": \"rate\", \"type\": \"FLOAT\", \"optional\": true }\n      ],\n      \"primary\": \"mid\",\n      \"detach_property\": false\n    },\n    {\n      \"label\": \"play_in\",\n      \"type\": \"EDGE\",\n      \"properties\": [{ \"name\": \"role\", \"type\": \"STRING\", \"optional\": true }],\n      \"constraints\": [[\"actor\", \"movie\"]]\n    }\n  ],\n  \"files\": [\n    {\n      \"path\": \"actors.csv\",\n      \"header\": 2,\n      \"format\": \"CSV\",\n      \"label\": \"actor\",\n      \"columns\": [\"aid\", \"name\"]\n    },\n    {\n      \"path\": \"movies.csv\",\n      \"header\": 2,\n      \"format\": \"CSV\",\n      \"label\": \"movie\",\n\n该代码块来自文档第三部分\"配置文件\"，具体描述了导入配置文件中的schema部分和files部分的格式与示例，定义了图数据库中点和边的标签、属性及其类型，以及要导入的数据文件的信息。这部分内容为用户提供了如何配置数据导入所需的关键基础信息。"
            },
            {
                "content": "],\n      \"primary\": \"mid\",\n      \"detach_property\": false\n    },\n    {\n      \"label\": \"play_in\",\n      \"type\": \"EDGE\",\n      \"properties\": [{ \"name\": \"role\", \"type\": \"STRING\", \"optional\": true }],\n      \"constraints\": [[\"actor\", \"movie\"]]\n    }\n  ],\n  \"files\": [\n    {\n      \"path\": \"actors.csv\",\n      \"header\": 2,\n      \"format\": \"CSV\",\n      \"label\": \"actor\",\n      \"columns\": [\"aid\", \"name\"]\n    },\n    {\n      \"path\": \"movies.csv\",\n      \"header\": 2,\n      \"format\": \"CSV\",\n      \"label\": \"movie\",\n      \"columns\": [\"mid\", \"name\", \"year\", \"rate\"]\n    },\n    {\n      \"path\": \"roles.csv\",\n      \"header\": 2,\n      \"format\": \"CSV\",\n      \"label\": \"play_in\",\n      \"SRC_ID\": \"actor\",\n      \"DST_ID\": \"movie\",\n      \"columns\": [\"SRC_ID\", \"role\", \"DST_ID\"]\n    }\n  ]\n}\n```\n\n该片段位于文档的第3.2节，描述了一个配置文件示例，定义了图数据库中三个label的详细信息，包括点类型（演员和电影）及边类型（参与角色），同时展示了相应数据文件的路径、格式及内容结构。这一部分主要为用户提供具体的导入配置文件格式与示例，帮助理解如何导入数据至TuGraph数据库。"
            },
            {
                "content": "对于上述配置文件，定义了三个 label：两个点类型`actor`和`movie`，一个边类型`role`。每个 label 都描述了：label 的名字、类型（点还是边）、属性字段有哪些以及每个字段的类型。对于点，另外定义了 primary 字段是哪个；对于边，另外定义了 constraints 字段，用来限制边的起点和终点只能是哪些组合。\n\n还描述了三个数据文件，两个点的数据文件`actors.csv`和`movies.csv`，一个边的数据文件`roles.csv`。每个部分都描述了：文件的路径（path）、数据类型（format）、信息头占开头几行（header）、是哪个 label 的数据（label）、文件中每行数据中的每个列对应的字段是哪个。\n\n对于上述配置文件，import 工具在执行的过程中会先在 TuGraph 中创建`actor`、`movie`、`role`这三个 label，然后再执行三个文件的数据导入。\n\n## 4.离线全量导入\n\n离线模式只能在离线状态的服务器使用。离线导入会创建一张新图，因此更适合新安装的 TuGraph 服务器上的第一次数据导入。\n要在离线模式下使用`lgraph_import`工具，可以指定`lgraph_import --online false`选项。要了解可用的命令行选项，请使用`lgraph_import --online false --help`：\n\n```shell\n$ ./lgraph_import --online false -help\nAvailable command line options:\n    --log               Log file to use, empty means stderr. Default=\"\".\n    -v, --verbose       Verbose level to use, higher means more verbose.\n                        Default=1.\n    ...\n    -h, --help          Print this help message. Default=0.\n```\n\n命令行参数：\n\n该段落位于文档的第三部分，主要介绍了配置文件的内容及结构，定义了三个标签（label）及其对应的数据文件，用于在TuGraph中执行数据导入操作。同时，接下来的部分将介绍离线全量导入的具体步骤和命令行选项。"
            },
            {
                "content": "```shell\n$ ./lgraph_import --online false -help\nAvailable command line options:\n    --log               Log file to use, empty means stderr. Default=\"\".\n    -v, --verbose       Verbose level to use, higher means more verbose.\n                        Default=1.\n    ...\n    -h, --help          Print this help message. Default=0.\n```\n\n命令行参数：\n\n- **-c, --config_file** `config_file`: 导入配置文件名，其格式要求见下述。\n- **--log** `log_dir`: 日志目录。默认为空字符串，此时将日志信息输出到控制台。\n- **--verbose** `0/1/2`: 日志等级，等级越高输出信息越详细。默认为 1。\n- **-i, --continue_on_error** `true/false`: 在碰到错误时跳过错误并继续，默认为 false，碰到错误立即退出。\n- **-d, --dir** `{diretory}`: 数据库目录，导入工具会将数据写到这个目录。默认为`./db`。\n- **--delimiter** `{delimiter}`: 数据文件分隔符。只在数据源是 CSV 格式时使用，默认为`\",\"`。\n- **-u, --username** `{user}`: 数据库用户名。需要是管理员用户才能执行离线导入。\n- **-p, --password** `{password}`: 指定的数据库用户的密码\n- **--overwrite** `true/false`: 是否覆盖数据。设为 true 时，如果数据目录已经存在，则覆盖数据。默认为`false`。\n- **-g, --graph** `{graph_name}`: 指定需要导入的图种类。\n- **-h, --help**: 输出帮助信息。\n\n### 4.1.离线导入示例\n\n该内容片段位于文档的第4部分，主要介绍了TuGraph导入工具`lgraph_import`在离线模式下的命令行参数及其用法，同时提供了一个离线导入的示例。这部分内容有助于用户理解如何使用该工具进行离线数据导入，以及相关的配置选项和参数设置。"
            },
            {
                "content": "### 4.1.离线导入示例\n\n在这个例子中，我们使用上面描述的电影-演员数据来演示导入工具的使用方法。待导入数据分为三个文件：`movies.csv`，`actors.csv`，`roles.csv`。\n\n`movies.csv`包含的是电影的信息，其中每部电影有一个 id（作为检索的 primary key），此外每部电影还拥有 title、year 和 rating 等属性。（数据来自IMDb(http://www.imdb.com)）。\n\n```\n  [movies.csv]\n  id, name, year, rating\n  tt0188766,King of Comedy,1999,7.3\n  tt0286112,Shaolin Soccer,2001,7.3\n  tt4701660,The Mermaid,2016,6.3\n```\n\n对应的 jsonline 格式如下:\n也可以所有字段都是字符串形式，导入的时候会转换成对应的类型\n\n```json\n[\"tt0188766\",\"King of Comedy\",1999,7.3]\n[\"tt0286112\",\"Shaolin Soccer\",2001,7.3]\n[\"tt4701660\",\"The Mermaid\",2016,6.3]\n```\n\n```json\n[\"tt0188766\",\"King of Comedy\",\"1999\",\"7.3\"]\n[\"tt0286112\",\"Shaolin Soccer\",\"2001\",\"7.3\"]\n[\"tt4701660\",\"The Mermaid\",\"2016\",\"6.3\"]\n```\n\n`actors.csv`包含的是演员的信息。每个演员也拥有一个 id，以及 name 等属性。\n\n```\n  [actors.csv]\n  id, name\n  nm015950,Stephen Chow\n  nm0628806,Man-Tat Ng\n  nm0156444,Cecilia Cheung\n  nm2514879,Yuqi Zhang\n```\n\n> 对应的 jsonline 格式如下:\n\n该章节为文档的第4节中的示例部分，具体描述了如何在TuGraph中进行离线数据导入。通过展示关于电影和演员的示例数据文件（`movies.csv`、`actors.csv`和`roles.csv`），提供对导入工具使用方法的实际演示，帮助用户理解如何准备和配置数据以供导入。"
            },
            {
                "content": "```json\n[\"tt0188766\",\"King of Comedy\",1999,7.3]\n[\"tt0286112\",\"Shaolin Soccer\",2001,7.3]\n[\"tt4701660\",\"The Mermaid\",2016,6.3]\n```\n\n```json\n[\"tt0188766\",\"King of Comedy\",\"1999\",\"7.3\"]\n[\"tt0286112\",\"Shaolin Soccer\",\"2001\",\"7.3\"]\n[\"tt4701660\",\"The Mermaid\",\"2016\",\"6.3\"]\n```\n\n`actors.csv`包含的是演员的信息。每个演员也拥有一个 id，以及 name 等属性。\n\n```\n  [actors.csv]\n  id, name\n  nm015950,Stephen Chow\n  nm0628806,Man-Tat Ng\n  nm0156444,Cecilia Cheung\n  nm2514879,Yuqi Zhang\n```\n\n> 对应的 jsonline 格式如下:\n\n```json\n[\"nm015950\",\"Stephen Chow\"]\n[\"nm0628806\",\"Man-Tat Ng\"]\n[\"nm0156444\",\"Cecilia Cheung\"]\n[\"nm2514879\",\"Yuqi Zhang\"]\n```\n\n`roles.csv`则包含了演员在哪个电影中扮演了哪个角色的信息。其中每一行记录的是指定演员在指定电影里饰演的角色，对应数据库中的一条边。`SRC_ID` 和 `DST_ID` 分别是边的源点和目标点，他们分别是`actors.csv`和`movies.csv`中定义的`primary`属性。\n\n```\n  [roles.csv]\n  actor, role, movie\n  nm015950,Tianchou Yin,tt0188766\n  nm015950,Steel Leg,tt0286112\n  nm0628806,,tt0188766\n  nm0628806,coach,tt0286112\n  nm0156444,PiaoPiao Liu,tt0188766\n  nm2514879,Ruolan Li,tt4701660\n```\n\n对应的 jsonline 格式如下:\n\n该段落位于文档的第四部分“离线全量导入”中，具体描述了用于导入电影和演员数据的 JSONLine 格式示例，以及与之对应的 CSV 文件内容。这部分内容展示了处理演示数据的具体格式，有助于用户理解如何准备和导入数据。"
            },
            {
                "content": "`roles.csv`则包含了演员在哪个电影中扮演了哪个角色的信息。其中每一行记录的是指定演员在指定电影里饰演的角色，对应数据库中的一条边。`SRC_ID` 和 `DST_ID` 分别是边的源点和目标点，他们分别是`actors.csv`和`movies.csv`中定义的`primary`属性。\n\n```\n  [roles.csv]\n  actor, role, movie\n  nm015950,Tianchou Yin,tt0188766\n  nm015950,Steel Leg,tt0286112\n  nm0628806,,tt0188766\n  nm0628806,coach,tt0286112\n  nm0156444,PiaoPiao Liu,tt0188766\n  nm2514879,Ruolan Li,tt4701660\n```\n\n对应的 jsonline 格式如下:\n\n```json\n[\"nm015950\",\"Tianchou Yin\",\"tt0188766\"]\n[\"nm015950\",\"Steel Leg\",\"tt0286112\"]\n[\"nm0628806\",null,\"tt0188766\"]\n[\"nm0628806\",\"coach\",\"tt0286112\"]\n[\"nm0156444\",\"PiaoPiao Liu\",\"tt0188766\"]\n[\"nm2514879\",\"Ruolan Li\",\"tt4701660\"]\n```\n\n`配置文件import.conf`，注意每个文件中有两个标题行，因此我们需要指定`HEADER=2`选项。\n\n该块内容位于文档的第4部分“离线全量导入”中，具体介绍了数据文件`roles.csv`的格式和内容，展示了演员在电影中扮演角色的信息以及相应的jsonline格式转换，强调在配置文件中需要设置标题行的选项。"
            },
            {
                "content": "```json\n{\n  \"schema\": [\n    {\n      \"label\": \"actor\",\n      \"type\": \"VERTEX\",\n      \"properties\": [\n        { \"name\": \"aid\", \"type\": \"STRING\" },\n        { \"name\": \"name\", \"type\": \"STRING\" }\n      ],\n      \"primary\": \"aid\"\n    },\n    {\n      \"label\": \"movie\",\n      \"type\": \"VERTEX\",\n      \"properties\": [\n        { \"name\": \"mid\", \"type\": \"STRING\" },\n        { \"name\": \"name\", \"type\": \"STRING\" },\n        { \"name\": \"year\", \"type\": \"INT16\" },\n        { \"name\": \"rate\", \"type\": \"FLOAT\", \"optional\": true }\n      ],\n      \"primary\": \"mid\"\n    },\n    {\n      \"label\": \"play_in\",\n      \"type\": \"EDGE\",\n      \"properties\": [{ \"name\": \"role\", \"type\": \"STRING\", \"optional\": true }],\n      \"constraints\": [[\"actor\", \"movie\"]]\n    }\n  ],\n  \"files\": [\n    {\n      \"path\": \"actors.csv\",\n      \"header\": 2,\n      \"format\": \"CSV\",\n      \"label\": \"actor\",\n      \"columns\": [\"aid\", \"name\"]\n    },\n    {\n      \"path\": \"movies.csv\",\n      \"header\": 2,\n      \"format\": \"CSV\",\n      \"label\": \"movie\",\n\n该代码块是关于TuGraph数据导入中配置文件的示例，具体描述了图数据库中点（演员和电影）和边（演员在电影中的角色）相关的schema定义，以及对应的数据文件配置。这部分内容位于文档的第三节，重点在于如何通过配置文件指定数据的结构和来源，以便于后续的导入操作。"
            },
            {
                "content": "],\n      \"primary\": \"mid\"\n    },\n    {\n      \"label\": \"play_in\",\n      \"type\": \"EDGE\",\n      \"properties\": [{ \"name\": \"role\", \"type\": \"STRING\", \"optional\": true }],\n      \"constraints\": [[\"actor\", \"movie\"]]\n    }\n  ],\n  \"files\": [\n    {\n      \"path\": \"actors.csv\",\n      \"header\": 2,\n      \"format\": \"CSV\",\n      \"label\": \"actor\",\n      \"columns\": [\"aid\", \"name\"]\n    },\n    {\n      \"path\": \"movies.csv\",\n      \"header\": 2,\n      \"format\": \"CSV\",\n      \"label\": \"movie\",\n      \"columns\": [\"mid\", \"name\", \"year\", \"rate\"]\n    },\n    {\n      \"path\": \"roles.csv\",\n      \"header\": 2,\n      \"format\": \"CSV\",\n      \"label\": \"play_in\",\n      \"SRC_ID\": \"actor\",\n      \"DST_ID\": \"movie\",\n      \"columns\": [\"SRC_ID\", \"role\", \"DST_ID\"]\n    }\n  ]\n}\n```\n\n该代码块位于文档的第3.2节“配置文件示例”中，详细描述了一个配置文件的结构和内容，用于在TuGraph数据库中导入数据。示例配置文件定义了三个数据标签（点和边）及其属性，并列出了相应的数据文件及其格式，展示了如何设置导入所需的Schema和文件信息。"
            },
            {
                "content": "使用导入配置文件，我们现在可以使用以下命令导入数据：\n\n```shell\n$ ./lgraph_import\n        -c import.conf             # 从import.conf读取配置信息\n        --dir /data/lgraph_db      # 将数据存放在/data/lgraph_db\n        --graph mygraph            # 导入名为 mygraph 的图\n```\n\n**注意**：\n\n- 如果名为`mygraph`的图已存在，导入工具将打印错误消息并退出。要强制覆盖图形，可以使用`--overwrite true` 选项。\n- 配置文件和数据文件必须使用 UTF-8 编码（或普通 ASCII 编码，即 UTF-8 的子集）存储。如果任何文件使用 UTF-8 以外的编码（例如，带有 BOM 或 GBK 的 UTF-8）编码，则导入将失败，并输出分析器错误。\n\n## 5.在线增量导入\n\n在线导入模式可用于将一批文件导入已在运行中的 TuGraph 实例中。这对于处理通常以固定的时间间隔进行的增量批处理更新非常便利。`lgraph_import --online true`选项使导入工具能够在线模式工作。与`离线模式`一样，在线模式有自己的命令行选项集，可以使用`-h，--help`选项进行打印输出：\n\n```shell\n$ lgraph_import --online true -h\nAvailable command line options:\n    --online            Whether to import online.\n    -h, --help          Print this help message. Default=0.\n\n该块内容位于文档的第4部分，介绍了如何使用导入配置文件进行数据导入的具体命令及注意事项，接着引入了在线增量导入的主题。"
            },
            {
                "content": "Available command line options:\n    --log               Log file to use, empty means stderr. Default=\"\".\n    -v, --verbose       Verbose level to use, higher means more verbose.\n                        Default=1.\n    -c, --config_file   Config file path.\n    -r, --url           DB REST API address.\n    -u, --username      DB username.\n    -p, --password      DB password.\n    -i, --continue_on_error\n                        When we hit a duplicate uid or missing uid, should we\n                        continue or abort. Default=0.\n    -g, --graph         The name of the graph to import into. Default=default.\n    --skip_packages     How many packages should we skip. Default=0.\n    --delimiter         Delimiter used in the CSV files\n    --breakpoint_continue\n                        When the transmission process is interrupted,whether\n                        to re-transmit from zero package next time. Default=false\n    -h, --help          Print this help message. Default=0.\n```\n\n该段文本位于文档的“在线增量导入”部分，具体描述了在使用`lgraph_import`工具的在线导入模式时可用的命令行选项，包括日志设置、配置文件路径、数据库连接信息、图名称等参数。此部分为用户执行在线增量导入提供了必要的命令行参考。"
            },
            {
                "content": "文件的相关配置在配置文件中指定，其格式与`离线模式`完全相同。但是，我们现在不是将数据导入本地数据库，而是将数据发送到正在运行的 TuGraph 实例中，该实例通常运行在与运行导入工具的客户端计算机不同的计算机上。因此，我们需要指定远程计算机的 HTTP 地址的URL、DB用户和密码。\n\n如果用户和密码有效，并且指定的图存在，导入工具将将数据发送到服务器，服务器随后解析数据并将其写入指定的图。数据将以大约 16MB 大小的包发送，在最近的换行符处中断。每个包都是以原子方式导入的，这意味着如果成功导入包，则成功导入所有数据，否则，任何数据都不会进入数据库。如果指定了`--continue_on_error true`，则忽略数据完整性错误，并忽略违规行。否则，导入将在第一个错误包处停止，并打印出已导入的包数。在这种情况下，用户可以修改数据以消除错误，然后使用`--skip_packages N`重做导入以跳过已导入的包。\n\n## 6.在线全量导入\n\n在线全量导入可用于将一批文件导入运行中的TuGraph实例，TuGraph支持将两种不同类型的数据在线导入到实例中：\n1. 和离线导入类型相同的原数据文件（csv等）\n2. TuGraph的底层存储文件，即data.mdb文件，该文件可以由离线导入生成，也可以是其他TuGraph db的文件。\n这两种方式的适用场景不同，第一种是直接将数据导入到TuGraph中，优点是一次性自动导入，操作步骤简单。但是会在server端启动一个离线导入线程，\n只适合单机情况下的小规模数据导入。第二种是将已经准备好的底层存储文件导入到TuGraph中，虽然需要提前准备好mdb文件，但是对系统资源却没有很高的要求，\n而且支持远程下载文件导入，非常方便，适用于高可用模式或者大规模数据的在线导入。\n\n该块内容属于文档的第六部分，讨论了在线全量导入功能，具体介绍如何将数据发送到运行中的 TuGraph 实例，强调了配置方式、数据包发送机制、错误处理及支持的数据类型。"
            },
            {
                "content": "## 6.在线全量导入\n\n在线全量导入可用于将一批文件导入运行中的TuGraph实例，TuGraph支持将两种不同类型的数据在线导入到实例中：\n1. 和离线导入类型相同的原数据文件（csv等）\n2. TuGraph的底层存储文件，即data.mdb文件，该文件可以由离线导入生成，也可以是其他TuGraph db的文件。\n这两种方式的适用场景不同，第一种是直接将数据导入到TuGraph中，优点是一次性自动导入，操作步骤简单。但是会在server端启动一个离线导入线程，\n只适合单机情况下的小规模数据导入。第二种是将已经准备好的底层存储文件导入到TuGraph中，虽然需要提前准备好mdb文件，但是对系统资源却没有很高的要求，\n而且支持远程下载文件导入，非常方便，适用于高可用模式或者大规模数据的在线导入。\n\n### 6.1 从原数据导入\n从原数据导入的执行方式是向运行中的TuGraph实例发送导入请求，\n实例接到请求后先使用离线导入（V3）的方式将数据导入一个临时的db中，然后在实例中新建子图并将临时db的数据文件迁移到新子图中，最后刷新实例的元数据。\n相比在线增量导入，在线全量导入的性能更高。\n`lgraph_import --online true --online_type 1`选项使导入工具能够在线全量导入。\n与`离线模式`一样，在线模式有自己的命令行选项集，可以使用`-h，--help`选项进行打印输出：\n\n```shell\n$ lgraph_import --online true --online_type 1 -h\nAvailable command line options:\n    --online_type       The type of import online, 0 for increment, 1 for full\n                        import data,2 for full import file. Default=0.\n    --v3                Whether to use lgraph import V3. Default=1.\n    -h, --help          Print this help message. Default=0.\n\n该片段位于文档的第6部分，主要讲述TuGraph的在线全量导入功能，包括从原数据导入和从数据库文件导入的具体方法与适用场景。整体文档介绍了TuGraph的数据导入功能及其配置方式，包含离线和在线导入的细节。"
            },
            {
                "content": "```shell\n$ lgraph_import --online true --online_type 1 -h\nAvailable command line options:\n    --online_type       The type of import online, 0 for increment, 1 for full\n                        import data,2 for full import file. Default=0.\n    --v3                Whether to use lgraph import V3. Default=1.\n    -h, --help          Print this help message. Default=0.\n\nAvailable command line options:\n    --full              Whether to full import online. Default=0.\n    -h, --help          Print this help message. Default=0.\n\n该代码块位于文档的第6节“在线全量导入”中，具体描述了使用`lgraph_import`工具进行在线全量导入时的命令行选项及其参数，包括导入类型、版本控制等，旨在指导用户如何在运行中的TuGraph实例中进行数据导入操作。"
            },
            {
                "content": "Available command line options:\n    -c, --config_file   Config file path.\n    -r, --url           DB REST API address.\n    -u, --user          DB username.\n    -p, --password      DB password.\n    -i, --continue_on_error\n                        When we hit a duplicate uid or missing uid, should we\n                        continue or abort. Default=0.\n    -g, --graph         The name of the graph to import into. Default=default.\n    --delimiter         Delimiter used in the CSV files. Default=,.\n    --log               Log dir to use, empty means stderr. Default=\"\".\n    -v, --verbose       Verbose level to use, higher means more verbose.\n                        Default=1.\n    --overwrite         Whether to overwrite the existing DB if it already\n                        exists. Default=0.\n    --parse_block_size  Block size per parse. Default=8388608.\n    --parse_block_threads\n                        How many threads to parse the data block. Default=5.\n\n该段落位于文档的第5节和第6节之间，主要介绍在线增量导入和在线全量导入的可用命令行选项。这些选项包括配置文件路径、数据库API地址、用户名、密码、错误处理方式、导入图的名称、CSV文件的分隔符、日志目录、详细程度、是否覆盖现有数据库等参数设置。"
            },
            {
                "content": "--log               Log dir to use, empty means stderr. Default=\"\".\n    -v, --verbose       Verbose level to use, higher means more verbose.\n                        Default=1.\n    --overwrite         Whether to overwrite the existing DB if it already\n                        exists. Default=0.\n    --parse_block_size  Block size per parse. Default=8388608.\n    --parse_block_threads\n                        How many threads to parse the data block. Default=5.\n    --parse_file_threadsHow many threads to parse the files. Default=5.\n    --generate_sst_threads\n                        How many threads to generate sst files. Default=15.\n    --read_rocksdb_threads\n                        How many threads to read rocksdb in the final stage.\n                        Default=15.\n    --vid_num_per_reading\n                        How many vertex data to read each time. Default=10000.\n    --max_size_per_reading\n                        Maximum size of kvs per reading. Default=33554432.\n\n该块内容位于文档的第4节和第6节中，介绍了`lgraph_import`工具的命令行选项，主要涉及在线全量导入或增量导入时的参数配置，包括日志设置、并发处理的线程数、解析块大小以及读取数据时的一些配置，以优化导入性能。"
            },
            {
                "content": "--generate_sst_threads\n                        How many threads to generate sst files. Default=15.\n    --read_rocksdb_threads\n                        How many threads to read rocksdb in the final stage.\n                        Default=15.\n    --vid_num_per_reading\n                        How many vertex data to read each time. Default=10000.\n    --max_size_per_reading\n                        Maximum size of kvs per reading. Default=33554432.\n    --compact           Whether to compact. Default=0.\n    --keep_vid_in_memoryWhether to keep vids in memory. Default=1.\n    --enable_fulltext_index\n                        Whether to enable fulltext index. Default=0.\n    --fulltext_index_analyzer\n                        fulltext index analyzer. Default=StandardAnalyzer.\n                        Possible values: {<2>: SmartChineseAnalyzer,\n                        StandardAnalyzer}\n    -h, --help          Print this help message. Default=0.\n```\n\n该内容块位于文档的在线全量导入部分，具体与从数据库文件导入相关的命令行选项介绍中，主要描述了与生成 SST 文件、读取 RocksDB 和内存管理等相关的配置选项。这些选项旨在优化数据导入过程中的性能和资源管理。"
            },
            {
                "content": "文件的相关配置在配置文件中指定，其格式与`离线模式`完全相同。但是，我们现在不是将数据导入本地数据库，而是将数据导入正在运行的 TuGraph 实例中，\n该实例通常运行在与运行导入工具的客户端计算机不同的计算机上。因此，我们需要指定远程计算机的 HTTP 地址的URL、DB用户和密码。\n并且，配置文件（config_file参数）要求是 TuGraph 实例机器上的uri路径，其file配置也要求是 TuGraph 实例机器上资源的绝对路径。\n\n如果用户和密码有效，导入工具将在服务器端执行在线全量导入。如果想导入的图已存在，可以使用`--overwrite true` 选项强制覆盖子图。\n\n### 6.2 从数据库文件导入\n从原数据在线全量导入尽管操作简单、性能较高，但是对服务器资源要求较高，且耗时较长。\n一种更加通用的方式是先使用离线导入在一个空db中导入子图，得到data.mdb文件，然后把该文件在线导入到\nTuGraph服务中。其使用方式如下所示：\n\n```shell\n$ ./lgraph_import --online true --online_type 2 -h\nAvailable command line options:\n    --online            Whether to import online. Default=0.\n    --v3                Whether to use lgraph import V3. Default=1.\n    -h, --help          Print this help message. Default=0.\n\nAvailable command line options:\n    --online_type       The type of import online, 0 for increment, 1 for full\n                        import data,2 for full import file. Default=0.\n    -h, --help          Print this help message. Default=0.\n\n该片段位于文档的第六部分，讨论了在线全量导入的方法，特别是如何将数据导入正在运行的 TuGraph 实例中，强调了配置文件的要求以及如何根据数据库文件进行导入。这一部分紧接着前面关于在线全量导入的介绍，并提供了具体的命令使用示例。"
            },
            {
                "content": "Available command line options:\n    --online_type       The type of import online, 0 for increment, 1 for full\n                        import data,2 for full import file. Default=0.\n    -h, --help          Print this help message. Default=0.\n\nAvailable command line options:\n    -r, --url           DB REST API address.\n    -u, --user          DB username.\n    -p, --password      DB password.\n    -g, --graph         The name of the graph to import into. Default=default.\n    --path              The path of data file.\n    --remote            Whether to download file from remote server. Default=0.\n    -h, --help          Print this help message. Default=0.\n```\n\n除普通在线导入用到的url, user和password参数之外，从数据库文件导入的在线全量导入方式\n使用graph参数指定导入的子图名称，path参数指定文件路径，remote指定文件存在在远程或者本地。\n如果是本地文件，则需要保证HA集群中所有的节点在path路径下都有该文件。如果是远程文件，则会先下载再导入。\n需要注意的是，由于data.mdb只有一份，需要保证HA的各个节点和离线导入生成data.mdb的机器的环境完全一致，\n以保证不会出现环境问题。\n\n该块内容位于文档的第六部分，在线全量导入的说明中，具体涉及在线导入时的命令行选项，包括导入类型、数据库地址、用户名、密码等参数设置，并解释了从数据库文件导入的方式和注意事项。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_6.md",
        "chunks": [
            {
                "content": "# 环境分类\n\n> 此文档主要介绍 TuGraph 涉及的三种环境。\n\n## 1.分类\n\n根据环境所承载功能的不同，区分为编译环境，运行环境，以及精简运行环境。\n* 编译环境，具备TuGraph编译的所有依赖库，包含运行环境的所有依赖，并且能够编译TuGraph源码，但不包含预编译好的TuGraph可执行文件和库文件，供开发者编译源码使用。\n* 运行环境，具备GCC/Java/Python环境，能够运行TuGraph的所有功能，并且能承载全文索引，java client，c++源码上传为plugin，以及python plugin的完整功能，内置TuGraph预编译好的可执行文件和库文件，供客户直接安装使用，无需编译源码。\n* 精简运行环境，约等于裸系统加预编译TuGraph，仅能运行TuGraph的基本功能，无C++ plugin编译运行，仅so上传，无全文索引，无python plugin，供快速搭建试用。\n\nTuGraph编译后，会把所有的依赖库以.a的形式打包在一起，因此原则上运行不需要的其他的依赖库。但TuGraph支持存储过程，即在服务端编译C++代码，因此在环境中依然需要涉及的编译器。\n\n## 2.依赖系统库\n\n针对三种环境，除去TuGraph的运行包，所需要的系统库如下：\n* 编译环境，包括gcc、python、java等编译器，也包含antlr4、pybind11等，具体参见tugraph-db源码目录 ci/images/tugraph-compile-*-Dockerfile。\n* 运行环境，主要由存储过程引入，包括gcc、boost、cmake等，具体参见tugraph-db源码目录 ci/images/tugraph-runtime-*-Dockerfile。\n* 精简运行环境，无，可以参见tugraph-db源码目录 ci/images/ tugraph-mini-runtime-*-Dockerfile。\n\n本文档详细介绍了TuGraph的三种环境分类，包括编译环境、运行环境和精简运行环境，并列出了每种环境所需的系统库和相关功能，以帮助用户选择合适的环境进行开发和部署。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_7.md",
        "chunks": [
            {
                "content": "# TuGraph-Restful-Server\n\n> TuGraph Restful Server 强依赖 TuGraph，Restful Server 与 Tugraph 共存\n\n## 1.TuGraph-Restful-Server 简介\nTuGraph Restful Server 使用brpc框架支持的http协议，提供restful接口查询功能，在实现中，restful server 与rpc server 使用同一个端口。目前restful接口提供文件上传，数据导入，导入进度查询，cypher查询，文件删除等功能\n\n## 2.启动 TuGraph-Restful-Server\n需要在启动Tugraph时设置enable_rpc参数为true的方式，正常启动TuGraph\n\n## 3.连接 TuGraph-Restful-Server\nTuGraph正常启动后，Restful Server 将监听在rpc_port上， 通过访问 http://${ip}:${rpc_port}/LGraphHttpService/Query/ url可以链接到TuGraph\n\n## 4.数据格式\n客户端与服务端数据交互的格式是 JSON。在发送请求时，请将发送数据的请求的报头设置为 `Accept:application/json, Content-Type:application/json`。\n例如在创建一个点时，请求报头包含以下内容：\n\n```\n    Accept: application/json; charset=UTF-8\n    Content-Type: application/json\n    server_version: 12\n```\n\n## 5.返回值\n\n通用返回格式\n\n|  body参数  | 参数说明  |  参数类型  |  是否必填  |\n|:--------:|:-----:|:------:| :-----: |\n| errorCode |  状态码  |  字符串  |  是  |\n| errorMessage | 错误信息  |  字符串  |  是  |\n| data | 返回的数据 |  字符串  |  是  |\n表格内容描述: \n\n该表格包含四列，分别为“body参数”、“参数说明”、“参数类型”和“是否必填”。\n\n该文档全面介绍了TuGraph Restful Server的功能和使用方法，包括启动、连接、数据格式、返回值等内容。当前选定的片段涵盖了Restful Server的基本简介、启动方式、连接流程以及数据交互格式和通用返回格式，为用户提供了使用该服务的基础信息。"
            },
            {
                "content": "## 4.数据格式\n客户端与服务端数据交互的格式是 JSON。在发送请求时，请将发送数据的请求的报头设置为 `Accept:application/json, Content-Type:application/json`。\n例如在创建一个点时，请求报头包含以下内容：\n\n```\n    Accept: application/json; charset=UTF-8\n    Content-Type: application/json\n    server_version: 12\n```\n\n## 5.返回值\n\n通用返回格式\n\n|  body参数  | 参数说明  |  参数类型  |  是否必填  |\n|:--------:|:-----:|:------:| :-----: |\n| errorCode |  状态码  |  字符串  |  是  |\n| errorMessage | 错误信息  |  字符串  |  是  |\n| data | 返回的数据 |  字符串  |  是  |\n表格内容描述: \n\n该表格包含四列，分别为“body参数”、“参数说明”、“参数类型”和“是否必填”。\n\n逐行描述表格中的数据内容：\n1. 第一行的数据为：body参数为“errorCode”，参数说明为“状态码”，参数类型为“字符串”，是否必填为“是”。\n2. 第二行的数据为：body参数为“errorMessage”，参数说明为“错误信息”，参数类型为“字符串”，是否必填为“是”。\n3. 第三行的数据为：body参数为“data”，参数说明为“返回的数据”，参数类型为“字符串”，是否必填为“是”。\n\n总体总结：该表格列举了三个必填的参数，分别为状态码、错误信息和返回的数据，所有参数均为字符串类型。这些参数在提供响应时具有重要的作用。\n\nTuGraph 返回的 HTTP 状态码包含以下四种：\n\n该部分内容概述了TuGraph Restful Server的数据交互格式，说明客户端与服务端之间使用JSON进行数据传输，并详细介绍了通用返回格式及其参数，包括错误码、错误信息和返回数据的定义，旨在帮助用户理解如何处理请求和响应。"
            },
            {
                "content": "该表格包含四列，分别为“body参数”、“参数说明”、“参数类型”和“是否必填”。\n\n逐行描述表格中的数据内容：\n1. 第一行的数据为：body参数为“errorCode”，参数说明为“状态码”，参数类型为“字符串”，是否必填为“是”。\n2. 第二行的数据为：body参数为“errorMessage”，参数说明为“错误信息”，参数类型为“字符串”，是否必填为“是”。\n3. 第三行的数据为：body参数为“data”，参数说明为“返回的数据”，参数类型为“字符串”，是否必填为“是”。\n\n总体总结：该表格列举了三个必填的参数，分别为状态码、错误信息和返回的数据，所有参数均为字符串类型。这些参数在提供响应时具有重要的作用。\n\nTuGraph 返回的 HTTP 状态码包含以下四种：\n\n- 200 OK: 操作成功\n- 400 Bad Request: 输入有误，例如 URI 错误，或者请求中的 JSON 参数错误\n- 401 Unauthorized: 未通过鉴权认证，例如用户名密码错误，token超过有效期等\n- 500 Internal Server Error: 服务器端错误\n  当操作成功时，返回的 data 中包含操作的返回值。\n  当发生输入错误或者服务器错误时，返回的 errorMessage 中包含错误提示。\n\n## 6.URI格式\n\n该段落位于文档的第5部分，主要描述了TuGraph Restful Server的返回值格式和HTTP状态码。具体介绍了响应中的必填参数，包括状态码、错误信息和返回数据，并对不同的HTTP状态码进行了详细说明，为后续对API请求的理解和使用提供了指导。"
            },
            {
                "content": "总体总结：该表格列举了三个必填的参数，分别为状态码、错误信息和返回的数据，所有参数均为字符串类型。这些参数在提供响应时具有重要的作用。\n\nTuGraph 返回的 HTTP 状态码包含以下四种：\n\n- 200 OK: 操作成功\n- 400 Bad Request: 输入有误，例如 URI 错误，或者请求中的 JSON 参数错误\n- 401 Unauthorized: 未通过鉴权认证，例如用户名密码错误，token超过有效期等\n- 500 Internal Server Error: 服务器端错误\n  当操作成功时，返回的 data 中包含操作的返回值。\n  当发生输入错误或者服务器错误时，返回的 errorMessage 中包含错误提示。\n\n## 6.URI格式\n\n| URI               | 说明                 |\n|-------------------|--------------------|\n| /cypher           | 执行cypher查询请求       |\n| /refresh          | 刷新token请求          |\n| /login            | 用户登陆请求             |\n| /logout           | 用户登出请求             |\n| /upload_files     | 上传文件请求             |\n| /clear_cache      | 清理用户上传文件请求         |\n| /check_file       | 文件认证请求             |\n| /import_data      | 数据导入请求             |\n| /import_progress  | 导入进度查询请求           |\n| /import_schema    | 批量创建schema请求       |\n表格内容描述: 此表格列出了两列数据：第一列为URI，第二列为说明。每一行分别对应一个特定的请求类型及其描述。\n\n该块内容位于文档的第5节和第6节之间，主要总结了TuGraph返回值的通用格式及其所包含的状态码。这为后续的URI格式说明提供了基础，明确了不同请求的处理结果和响应状态，使用户更好地理解API接口的返回机制。"
            },
            {
                "content": "1. 第一行：URI为\"/cypher\"，说明是执行cypher查询请求。\n2. 第二行：URI为\"/refresh\"，说明是刷新token请求。\n3. 第三行：URI为\"/login\"，说明是用户登陆请求。\n4. 第四行：URI为\"/logout\"，说明是用户登出请求。\n5. 第五行：URI为\"/upload_files\"，说明是上传文件请求。\n6. 第六行：URI为\"/clear_cache\"，说明是清理用户上传文件请求。\n7. 第七行：URI为\"/check_file\"，说明是文件认证请求。\n8. 第八行：URI为\"/import_data\"，说明是数据导入请求。\n9. 第九行：URI为\"/import_progress\"，说明是导入进度查询请求。\n10. 第十行：URI为\"/import_schema\"，说明是批量创建schema请求。\n\n总体来说，该表格提供了有关API请求的URI及其相应说明，涵盖了从用户认证到文件管理和数据导入等多个功能，帮助用户理解各个请求的用途。\n\n## 7.接口\n### 7.1 用户登陆\n用于用户第一次与服务端通信时的鉴权操作，请求报文在 http body 中携带用户名和密码，响应报文在 http body 中会返回一个带有有效期的token，后续请求中需要在http header中携带该token作为凭证\n#### 7.1.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/login\n#### 7.1.2 REQUEST\n|  body参数  |  参数说明  |  参数类型  |  是否必填  |\n|:--------:|:------:|:------:| :-----: |\n表格内容描述: \n\n该表格包含四个列名：`body参数`、`参数说明`、`参数类型`和`是否必填`。\n\n目前表格为空，没有具体的数据内容可供描述。\n\n该内容段落位于文档第6节\"URI格式\"下，主要提供TuGraph Restful Server的各个API请求的URI及其说明，涵盖用户认证、文件管理及数据导入等功能，以便用户了解不同请求的用途，为后续的接口调用提供依据。"
            },
            {
                "content": "总体来说，该表格提供了有关API请求的URI及其相应说明，涵盖了从用户认证到文件管理和数据导入等多个功能，帮助用户理解各个请求的用途。\n\n## 7.接口\n### 7.1 用户登陆\n用于用户第一次与服务端通信时的鉴权操作，请求报文在 http body 中携带用户名和密码，响应报文在 http body 中会返回一个带有有效期的token，后续请求中需要在http header中携带该token作为凭证\n#### 7.1.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/login\n#### 7.1.2 REQUEST\n|  body参数  |  参数说明  |  参数类型  |  是否必填  |\n|:--------:|:------:|:------:| :-----: |\n表格内容描述: \n\n该表格包含四个列名：`body参数`、`参数说明`、`参数类型`和`是否必填`。\n\n目前表格为空，没有具体的数据内容可供描述。\n\n综上所述，此表格的结构为一个参数配置表，但由于缺少数据，无法提供具体的参数信息或说明。\n | userName |  用户名  |  字符串  |  是  |\n | password |   密码   |  字符串  |  是  |\n#### 7.1.3 RESPONSE\n|    body参数     | 参数说明  |  参数类型  |  是否必填  |\n|:-------------:|:-----:|:------:| :-----: |\n| authorization | token |  字符串  |  是  |\n表格内容描述: 表格包含四个列名，分别是\"body参数\"、\"参数说明\"、\"参数类型\"和\"是否必填\"。表格中仅有一行数据，具体内容为：参数\"authorization\"的说明为\"token\"，其类型为\"字符串\"，并且该参数是必填项。总体来看，该表格明确了一个名为\"authorization\"的必填字符串参数，其用途是用于传递令牌。\n\n该段落位于文档的第7部分，主要介绍了TuGraph-Restful-Server的API接口，包括用户登录的详细请求和响应格式，旨在指导用户如何进行身份验证并获取访问令牌。"
            },
            {
                "content": "该表格包含四个列名：`body参数`、`参数说明`、`参数类型`和`是否必填`。\n\n目前表格为空，没有具体的数据内容可供描述。\n\n综上所述，此表格的结构为一个参数配置表，但由于缺少数据，无法提供具体的参数信息或说明。\n | userName |  用户名  |  字符串  |  是  |\n | password |   密码   |  字符串  |  是  |\n#### 7.1.3 RESPONSE\n|    body参数     | 参数说明  |  参数类型  |  是否必填  |\n|:-------------:|:-----:|:------:| :-----: |\n| authorization | token |  字符串  |  是  |\n表格内容描述: 表格包含四个列名，分别是\"body参数\"、\"参数说明\"、\"参数类型\"和\"是否必填\"。表格中仅有一行数据，具体内容为：参数\"authorization\"的说明为\"token\"，其类型为\"字符串\"，并且该参数是必填项。总体来看，该表格明确了一个名为\"authorization\"的必填字符串参数，其用途是用于传递令牌。\n\n### 7.2 刷新token\ntoken到期后将无法使用此token与服务端正常通信，需要获取新的token作为后续请求的凭证，请求报文在http header中携带旧的token，响应报文在http body中返回新的token\n#### 7.2.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/refresh\n#### 7.2.2 REQUEST\n|   header参数    |  参数说明   |  参数类型  |  是否必填  |\n|:-------------:|:-------:|:------:| :-----: |\n| Authorization | 旧的token |  字符串  |  是  |\n表格内容描述: 该表格包含四列，分别为“header参数”、“参数说明”、“参数类型”和“是否必填”。\n\n第一行数据为：\n- “Authorization”：表示旧的token；\n- “字符串”：表明该参数的数据类型；\n- “是”：表示该参数是必填项。\n\n该段落位于文档的第7.1节关于用户登陆的接口描述中，具体说明了请求的参数配置表及其各自的说明，同时还定义了返回的响应参数结构，紧接着将讨论刷新token的接口及其请求和响应参数。"
            },
            {
                "content": "### 7.2 刷新token\ntoken到期后将无法使用此token与服务端正常通信，需要获取新的token作为后续请求的凭证，请求报文在http header中携带旧的token，响应报文在http body中返回新的token\n#### 7.2.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/refresh\n#### 7.2.2 REQUEST\n|   header参数    |  参数说明   |  参数类型  |  是否必填  |\n|:-------------:|:-------:|:------:| :-----: |\n| Authorization | 旧的token |  字符串  |  是  |\n表格内容描述: 该表格包含四列，分别为“header参数”、“参数说明”、“参数类型”和“是否必填”。\n\n第一行数据为：\n- “Authorization”：表示旧的token；\n- “字符串”：表明该参数的数据类型；\n- “是”：表示该参数是必填项。\n\n整体而言，该表格用于描述一个名为“Authorization”的参数，提供了该参数的说明、类型以及是否为必填项的信息。\n表格内容描述：该表格包含四列，分别是“header参数”、“参数说明”、“参数类型”和“是否必填”。\n\n在第一行中，header参数为“Authorization”，其参数说明为“旧的token”，参数类型为“字符串”，并且该参数是“必填”的。\n\n总结：此表格描述了一个名为“Authorization”的header参数，它是字符串类型且必须提供，代表旧的token。\n\n#### 7.2.3 RESPONSE\n|    body参数     |  参数说明   |  参数类型  |  是否必填  |\n|:-------------:|:-------:|:------:| :-----: |\n| authorization | 新的token |  字符串  |  是  |\n表格内容描述: 该表格包含四列，分别为“body参数”、“参数说明”、“参数类型”和“是否必填”。\n\n在数据内容方面：\n- 第一行显示的body参数为“authorization”，其参数说明为“新的token”，参数类型为“字符串”，并且该参数是必填项。\n\n该内容段落属于文档中关于TuGraph Restful Server的接口部分，具体为“刷新token”接口的描述。它详细说明了请求的URL、所需的请求头参数、响应格式以及相关参数的说明，帮助用户在token过期后获取新的token以继续与服务端通信。"
            },
            {
                "content": "在第一行中，header参数为“Authorization”，其参数说明为“旧的token”，参数类型为“字符串”，并且该参数是“必填”的。\n\n总结：此表格描述了一个名为“Authorization”的header参数，它是字符串类型且必须提供，代表旧的token。\n\n#### 7.2.3 RESPONSE\n|    body参数     |  参数说明   |  参数类型  |  是否必填  |\n|:-------------:|:-------:|:------:| :-----: |\n| authorization | 新的token |  字符串  |  是  |\n表格内容描述: 该表格包含四列，分别为“body参数”、“参数说明”、“参数类型”和“是否必填”。\n\n在数据内容方面：\n- 第一行显示的body参数为“authorization”，其参数说明为“新的token”，参数类型为“字符串”，并且该参数是必填项。\n\n总结：该表格详细描述了一个必填的body参数“authorization”，它的类型为字符串，表示一个新的token。\n\n### 7.3 用户登出\n用户不再需要与服务端进行通信时，需要请求登出接口，释放自己的token。请求报文在http header中携带旧的token，如果拿到返回errorCode为200的响应报文即为正常登出\n#### 7.3.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/logout\n#### 7.3.2 REQUEST\n|   header参数    |  参数说明   |  参数类型  |  是否必填  |\n|:-------------:|:-------:|:------:| :-----: |\n| Authorization | 旧的token |  字符串  |  是  |\n\n### 7.4 执行cypher查询请求\n用户通过此类请求发cypher给server端执行并获取执行结果，请求报文在http body 中将执行的cypher语句和目标子图发送给server，server执行完成后在响应报文的http body中返回执行结果\n#### 7.4.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/cypher\n\n该块内容位于文档的第7.2节，描述了\"刷新token\"的请求和响应，包括请求的header参数“Authorization”和响应的body参数“authorization”。前后文讨论了用户登出和执行cypher查询的相关接口，构成了服务端用户身份验证和操作请求的整体流程。"
            },
            {
                "content": "### 7.4 执行cypher查询请求\n用户通过此类请求发cypher给server端执行并获取执行结果，请求报文在http body 中将执行的cypher语句和目标子图发送给server，server执行完成后在响应报文的http body中返回执行结果\n#### 7.4.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/cypher\n\n#### 7.4.2 REQUEST\n| body参数 |    参数说明    |  参数类型  |  是否必填  |\n|:------:|:----------:|:------:| :-----: |\n| graph  |   查询目标子图   |  字符串  |  是  |\n| script | cypher查询语句 |  字符串  |  是  |\n表格内容描述: \n该表格包含四个列名，分别为“body参数”、“参数说明”、“参数类型”和“是否必填”。 \n\n- 第一行数据为“graph”，其参数说明为“查询目标子图”，参数类型为“字符串”，并且为必填项。\n- 第二行数据为“script”，其参数说明为“cypher查询语句”，参数类型同样为“字符串”，并且也是必填项。\n\n总体来看，该表格列出了两个必填的参数，分别是“graph”和“script”，它们用于进行查询时的具体说明和要求。\n\n#### 7.4.3 RESPONSE\n|    body参数     |  参数说明   |  参数类型  |  是否必填  |\n|:-------------:|:-------:|:------:| :-----: |\n| result | 返回结果 |  字符串  |  是  |\n表格内容描述: \n该表格包含四列，分别是“body参数”、“参数说明”、“参数类型”和“是否必填”。 \n\n第一行数据为：\n- body参数为“result”，其参数说明是“返回结果”，参数类型为“字符串”，并且这是一个必填项。\n\n整体来看，该表格仅包含一项参数信息，说明在接口请求中必须提供一个名为“result”的字符串类型的参数，用于返回结果。\n\n该片段位于TuGraph Restful Server文档的接口章节，专门介绍了如何执行cypher查询请求，包括请求的URL、请求参数及其说明，以及响应格式，旨在帮助用户理解如何通过Restful接口进行cypher查询的操作。"
            },
            {
                "content": "- 第一行数据为“graph”，其参数说明为“查询目标子图”，参数类型为“字符串”，并且为必填项。\n- 第二行数据为“script”，其参数说明为“cypher查询语句”，参数类型同样为“字符串”，并且也是必填项。\n\n总体来看，该表格列出了两个必填的参数，分别是“graph”和“script”，它们用于进行查询时的具体说明和要求。\n\n#### 7.4.3 RESPONSE\n|    body参数     |  参数说明   |  参数类型  |  是否必填  |\n|:-------------:|:-------:|:------:| :-----: |\n| result | 返回结果 |  字符串  |  是  |\n表格内容描述: \n该表格包含四列，分别是“body参数”、“参数说明”、“参数类型”和“是否必填”。 \n\n第一行数据为：\n- body参数为“result”，其参数说明是“返回结果”，参数类型为“字符串”，并且这是一个必填项。\n\n整体来看，该表格仅包含一项参数信息，说明在接口请求中必须提供一个名为“result”的字符串类型的参数，用于返回结果。\n\n### 7.5 上传文件请求\n用户通过此类请求向server发送文件，可以对文件进行分片，分片大小不大于1MB，支持多线程乱序发送，请求报文在http header 中包含文件名，第一字节内容在文件中的偏移和分片大小，在body中包含文件内容，server收到请求后将验证分片大小是否与分片内容一致，一致时将文件分段写入文件。不一致时将返回errorCode为400的响应\n#### 7.5.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/upload_files\n\n该块内容主要涉及TuGraph Restful Server中执行cypher查询请求的参数配置和返回结果的描述，属于接口部分的详细说明，紧接在用户通过cypher执行查询之后，随后介绍了上传文件请求的相关信息。"
            },
            {
                "content": "第一行数据为：\n- body参数为“result”，其参数说明是“返回结果”，参数类型为“字符串”，并且这是一个必填项。\n\n整体来看，该表格仅包含一项参数信息，说明在接口请求中必须提供一个名为“result”的字符串类型的参数，用于返回结果。\n\n### 7.5 上传文件请求\n用户通过此类请求向server发送文件，可以对文件进行分片，分片大小不大于1MB，支持多线程乱序发送，请求报文在http header 中包含文件名，第一字节内容在文件中的偏移和分片大小，在body中包含文件内容，server收到请求后将验证分片大小是否与分片内容一致，一致时将文件分段写入文件。不一致时将返回errorCode为400的响应\n#### 7.5.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/upload_files\n\n#### 7.5.2 REQUEST\n| header参数  |    参数说明    |  参数类型  |  是否必填  |\n|:---------:|:----------:|:------:| :-----: |\n| File-Name |   文件名   |  字符串  |  是  |\n| Begin-Pos | 开始位置在文件内的偏移 |  字符串  |  是  |\n|   Size    | 文件分片大小 |  字符串  |  是  |\n|  body参数   |  参数说明   |  参数类型  |  是否必填  |\n|     -     | 文件内容 |  字符串  |  是  |\n表格内容描述:\n\n该表格包含了两组参数的说明，分别为\"header参数\"和\"body参数\"。每组参数均有四列，分别是“参数名称”，“参数说明”，“参数类型”和“是否必填”。\n\n逐行描述表格中的数据内容：\n1. 对于\"header参数\"部分：\n   - 文件名（File-Name）：此参数表示文件的名称，类型为字符串，且为必填项。\n   - 开始位置（Begin-Pos）：表示文件内的偏移开始位置，类型为字符串，且为必填项。\n   - 文件分片大小（Size）：表示文件的分片大小，类型为字符串，且为必填项。\n\n2. 对于\"body参数\"部分：\n   - 文件内容（-）：此参数用于表示文件的实际内容，类型为字符串，且为必填项。\n\n该chunk位于文档的第7节，涉及接口请求的具体参数说明，特别是第7.4节中有关执行cypher查询的响应参数“result”，以及第7.5节中关于上传文件请求的详细参数，包括请求头和请求体参数的必填性。"
            },
            {
                "content": "该表格包含了两组参数的说明，分别为\"header参数\"和\"body参数\"。每组参数均有四列，分别是“参数名称”，“参数说明”，“参数类型”和“是否必填”。\n\n逐行描述表格中的数据内容：\n1. 对于\"header参数\"部分：\n   - 文件名（File-Name）：此参数表示文件的名称，类型为字符串，且为必填项。\n   - 开始位置（Begin-Pos）：表示文件内的偏移开始位置，类型为字符串，且为必填项。\n   - 文件分片大小（Size）：表示文件的分片大小，类型为字符串，且为必填项。\n\n2. 对于\"body参数\"部分：\n   - 文件内容（-）：此参数用于表示文件的实际内容，类型为字符串，且为必填项。\n\n总结：\n本表格详细列出了两个参数组，其中\"header参数\"涉及与文件相关的重要信息，均为必填项，\"body参数\"则专注于文件内容的传递。所有参数均以字符串类型呈现，确保了数据交换的规范性和一致性。\n\n### 7.6 文件认证请求\n用户通过此类请求验证发送到server端的文件是否与期望一致，server端使用两种验证方式，md5值和文件长度，目前已支持文件长度验证。\n#### 7.6.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/check_file\n#### 7.6.2 REQUEST\n|  body参数  |          参数说明           |  参数类型  |  是否必填  |\n|:--------:|:-----------------------:|:------:| :-----: |\n| fileName |           文件名           |  字符串  |  是  |\n| checkSum |        文件对应md5值         |  字符串  |  否  |\n| fileSize |       文件长度(以字节计算)       |  字符串  |  否  |\n| flag | 标记位，为1时校验md5值，为2时校验文件长度 |  字符串  |  是  |\n表格内容描述:\n该表格包含四列，分别是“body参数”、“参数说明”、“参数类型”和“是否必填”。\n\n该文本块位于文档的第7.5节“上传文件请求”之后，紧接着第7.6节“文件认证请求”的开始部分。它详细描述了上传文件请求的参数，包括header参数和body参数，强调了各参数的重要性和必填要求，为用户提供了清晰的接口使用指南。"
            },
            {
                "content": "- 第一行数据是：文件名（fileName），参数类型为字符串，且是必填项。\n- 第二行数据是：文件对应md5值（checkSum），参数类型为字符串，非必填项。\n- 第三行数据是：文件长度（以字节计算）（fileSize），参数类型为字符串，非必填项。\n- 第四行数据是：标记位（flag），说明为当值为1时校验md5值，为2时校验文件长度，参数类型为字符串，且是必填项。\n\n整体总结：该表格列出了与文件相关的参数，包括文件名、md5值、文件长度以及标记位。其中，文件名和标记位是必填项，而md5值和文件长度则为可选项。\n\n#### 7.6.3 RESPONSE\n|    body参数     |  参数说明   |  参数类型  |  是否必填  |\n|:-------------:|:-------:|:------:| :-----: |\n| pass | 检查成功为true，否则为false |  bool  |  是  |\n表格内容描述: 该表格包含四列，分别是“body参数”、“参数说明”、“参数类型”和“是否必填”。\n\n在表格的第一行，列出了一个参数“pass”，其参数说明为“检查成功为true，否则为false”。该参数的类型为“bool”，并且是一个必填参数。\n\n总体来看，该表格主要描述了一个必填的布尔型参数“pass”，用于指示检查是否成功。\n\n### 7.7 批量创建schema请求\n用户通过此类请求批量创建schema，请求报文在http body 中将创建schema的目标子图和schema信息发送给server，如果拿到返回errorCode为200的响应报文即为正常创建\n#### 7.7.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/import_schema\n#### 7.7.2 REQUEST\n|  body参数  |    参数说明    |  参数类型  |  是否必填  |\n|:--------:|:----------:|:------:| :-----: |\n| graph |   创建目标子图   |  字符串  |  是  |\n| schema | schema描述信息 |  字符串  |  是  |\n表格内容描述:\n\n该段落位于文档的第7.6节，主要讨论文件认证请求的参数说明，具体列举了与文件验证相关的必填和非必填参数，包括文件名、md5值、文件长度及标记位。接下来是第7.6.3节，提供了该请求的响应格式和参数描述。"
            },
            {
                "content": "在表格的第一行，列出了一个参数“pass”，其参数说明为“检查成功为true，否则为false”。该参数的类型为“bool”，并且是一个必填参数。\n\n总体来看，该表格主要描述了一个必填的布尔型参数“pass”，用于指示检查是否成功。\n\n### 7.7 批量创建schema请求\n用户通过此类请求批量创建schema，请求报文在http body 中将创建schema的目标子图和schema信息发送给server，如果拿到返回errorCode为200的响应报文即为正常创建\n#### 7.7.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/import_schema\n#### 7.7.2 REQUEST\n|  body参数  |    参数说明    |  参数类型  |  是否必填  |\n|:--------:|:----------:|:------:| :-----: |\n| graph |   创建目标子图   |  字符串  |  是  |\n| schema | schema描述信息 |  字符串  |  是  |\n表格内容描述: \n\n该表格包含四列，分别为“body参数”、“参数说明”、“参数类型”和“是否必填”。 \n\n第一行数据为“graph”，其参数说明为“创建目标子图”，参数类型为“字符串”，并且该参数是必填的。 \n\n第二行数据为“schema”，其参数说明为“schema描述信息”，参数类型同样为“字符串”，该参数也是必填的。 \n\n总体而言，该表格列出了两个必填的字符串类型参数，分别用于创建目标子图和描述schema的相关信息。\n\n该块内容位于文档的第7.6节“文件认证请求”和第7.8节“批量创建schema请求”之间，主要描述了文件检查的响应参数“pass”，其类型和必填性，以及随后的批量创建schema请求的相关信息和参数。"
            },
            {
                "content": "该表格包含四列，分别为“body参数”、“参数说明”、“参数类型”和“是否必填”。 \n\n第一行数据为“graph”，其参数说明为“创建目标子图”，参数类型为“字符串”，并且该参数是必填的。 \n\n第二行数据为“schema”，其参数说明为“schema描述信息”，参数类型同样为“字符串”，该参数也是必填的。 \n\n总体而言，该表格列出了两个必填的字符串类型参数，分别用于创建目标子图和描述schema的相关信息。\n\n### 7.8 数据导入请求\n用户通过此类请求导入已经上传的数据文件。导入不论成功或失败，都将删除已上传文件。数据导入请求在server中实现为一个异步任务，响应返回并不意味着导入已完成，返回的是任务id，后续可以通过此任务id查询导入进度\n#### 7.8.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/import_data\n#### 7.8.2 REQUEST\n|  body参数  |          参数说明           |  参数类型  | 是否必填 |\n|:--------:|:-----------------------:|:------:|:----:|\n| graph |         导入目标子图          |  字符串  |  是   |\n| schema |       导入schema描述        | json字符串  |  是   |\n| delimiter |           分隔符           |  字符串  |  是   |\n| continueOnError |     单行数据出错是否跳过错误并继续     |  boolean  |  否   |\n| skipPackages |         跳过的包个数          |  字符串  |  否   |\n| taskId |  任务id   |  字符串  |  否   |\n| other | 其他参数 |  json字符串  |  否   |\n表格内容描述：\n该表格包含四列，分别为“body参数”、“参数说明”、“参数类型”和“是否必填”。\n\n该段落位于文档的第7.7节和第7.8节之间，主要描述了批量创建schema请求的参数，包括创建目标子图和schema描述信息的必填项。而后续部分则介绍了数据导入请求的URL和请求参数，涵盖导入目标子图、schema描述、分隔符等多个参数信息。"
            },
            {
                "content": "逐行描述如下：\n1. **graph**：该参数用于导入目标子图，类型为字符串，必填。\n2. **schema**：此参数用于导入schema描述，类型为json字符串，必填。\n3. **delimiter**：代表分隔符，类型为字符串，必填。\n4. **continueOnError**：用于指示单行数据出错时是否跳过错误并继续，类型为boolean，非必填。\n5. **skipPackages**：指跳过的包个数，类型为字符串，非必填。\n6. **taskId**：表示任务id，类型为字符串，非必填。\n7. **other**：用于其他参数，类型为json字符串，非必填。\n\n总结：该表格列出了与数据导入相关的多个参数，包括必填和非必填选项，共有七个参数，涵盖了数据导入的目标、格式和处理方式等信息。\n\n#### 7.8.3 RESPONSE\n|    body参数     |  参数说明   |  参数类型  |  是否必填  |\n|:-------------:|:-------:|:------:| :-----: |\n| taskId | 任务编号 |  字符串  |  是  |\n表格内容描述: 该表格包含四列，分别是“body参数”、“参数说明”、“参数类型”和“是否必填”。\n\n- 第一行数据中，body参数为“taskId”，参数说明为“任务编号”，参数类型为“字符串”，并且该参数为必填项。\n  \n整体来看，该表格仅包含一项参数信息，主要描述了“taskId”作为必填的字符串类型参数，用于标识任务编号。\n\n该段落位于文档的第7.8节“数据导入请求”中，详细描述了在进行数据导入时所需的参数，包括必填和非必填项，并总结了参数的用途和类型。在这之后，是对响应参数的说明。"
            },
            {
                "content": "总结：该表格列出了与数据导入相关的多个参数，包括必填和非必填选项，共有七个参数，涵盖了数据导入的目标、格式和处理方式等信息。\n\n#### 7.8.3 RESPONSE\n|    body参数     |  参数说明   |  参数类型  |  是否必填  |\n|:-------------:|:-------:|:------:| :-----: |\n| taskId | 任务编号 |  字符串  |  是  |\n表格内容描述: 该表格包含四列，分别是“body参数”、“参数说明”、“参数类型”和“是否必填”。\n\n- 第一行数据中，body参数为“taskId”，参数说明为“任务编号”，参数类型为“字符串”，并且该参数为必填项。\n  \n整体来看，该表格仅包含一项参数信息，主要描述了“taskId”作为必填的字符串类型参数，用于标识任务编号。\n\n### 7.9 清理用户上传文件请求\n用户通过此类请求清理已经上传的文件，如果拿到返回errorCode为200的响应报文即为正常清理\n#### 7.9.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/clear_cache\n#### 7.9.2 REQUEST\n|  body参数  |    参数说明    |  参数类型  |  是否必填  |\n|:--------:|:----------:|:------:| :-----: |\n| fileName |    文件名称    |  字符串  |  否  |\n| userName |    用户名称    |  字符串  |  否  |\n| flag | 标记位， flag = 0时删除fileName指定文件, flag = 1时删除userName指定用户已经上传的所有文件， flag = 2时删除所有用户上传的文件 |  字符串  |  是  |\n表格内容描述：\n该表格包含四列，分别是“body参数”、“参数说明”、“参数类型”和“是否必填”。\n\n- 第一行数据：  \n  - body参数为“fileName”，  \n  - 参数说明为“文件名称”，  \n  - 参数类型为“字符串”，  \n  - 是否必填为“否”。\n\n该区块位于文档关于数据导入请求的章节中，具体讨论了数据导入请求的响应参数及其含义，接着转向清理用户上传文件请求的相关信息，涉及清理请求的URL、请求参数以及参数的说明、类型和是否必填的判定。这部分内容有助于用户理解如何处理上传的文件及导入任务。"
            },
            {
                "content": "- 第一行数据：  \n  - body参数为“fileName”，  \n  - 参数说明为“文件名称”，  \n  - 参数类型为“字符串”，  \n  - 是否必填为“否”。\n\n- 第二行数据：  \n  - body参数为“userName”，  \n  - 参数说明为“用户名称”，  \n  - 参数类型为“字符串”，  \n  - 是否必填为“否”。\n\n- 第三行数据：  \n  - body参数为“flag”，  \n  - 参数说明为“标记位，flag = 0时删除fileName指定文件，flag = 1时删除userName指定用户已经上传的所有文件，flag = 2时删除所有用户上传的文件”，  \n  - 参数类型为“字符串”，  \n  - 是否必填为“是”。\n\n总体而言，该表格主要描述了三个参数的特性，其中“flag”参数是必填的，而“fileName”和“userName”则为可选参数。这些参数用于操作文件删除的相关功能。\n\n### 7.10. 导入进度查询请求\n用户通过此类请求获得导入任务的状态\n#### 7.10.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/import_progress\n#### 7.10.2 REQUEST\n|  body参数  |          参数说明           |  参数类型  |  是否必填  |\n|:--------:|:-----------------------:|:------:| :-----: |\n| taskId |           任务编号           |  字符串  |  是  |\n表格内容描述: \n\n该表格包含四列，分别为“body参数”、“参数说明”、“参数类型”和“是否必填”。\n\n- 第一行数据为“taskId”，其参数说明为“任务编号”，参数类型为“字符串”，并且是必填项。\n\n整体来看，该表格提供了一个必填的请求体参数，旨在识别和描述特定任务，其唯一标识符为“taskId”。\n\n该块内容位于文档的第7.9节“清理用户上传文件请求”下，详细描述了请求中的body参数，包括文件名称、用户名称和标记位的具体说明、类型和是否必填的要求。此部分内容为用户提供了清理上传文件时所需的参数信息，紧接着是第7.10节“导入进度查询请求”，用于获得导入任务的状态。"
            },
            {
                "content": "### 7.10. 导入进度查询请求\n用户通过此类请求获得导入任务的状态\n#### 7.10.1 URL\nhttp://${ip}:${rpc_port}/LGraphHttpService/Query/import_progress\n#### 7.10.2 REQUEST\n|  body参数  |          参数说明           |  参数类型  |  是否必填  |\n|:--------:|:-----------------------:|:------:| :-----: |\n| taskId |           任务编号           |  字符串  |  是  |\n表格内容描述: \n\n该表格包含四列，分别为“body参数”、“参数说明”、“参数类型”和“是否必填”。\n\n- 第一行数据为“taskId”，其参数说明为“任务编号”，参数类型为“字符串”，并且是必填项。\n\n整体来看，该表格提供了一个必填的请求体参数，旨在识别和描述特定任务，其唯一标识符为“taskId”。\n\n#### 7.10.3 RESPONSE\n| body参数 |                  参数说明                   |  参数类型  |  是否必填  |\n|:------:|:---------------------------------------:|:------:| :-----: |\n| state  | 状态标记，为0表示准备导入，为1表示导入中，为2表示导入成功，为3表示导入失败 |  字符串  |  是  |\n|  progress  |             导入进度，state为1时包含             |  字符串  |  否  |\n|  reason  |             失败原因，state为3时包含             |  字符串  |  否  |\n表格内容描述:\n该表格包含四列，分别是“body参数”、“参数说明”、“参数类型”和“是否必填”。\n\n该块内容位于文档的第7节，主要介绍导入进度查询请求的相关信息，包括请求的URL、请求参数及其说明，以及响应格式。这部分内容帮助用户了解如何查询数据导入的状态和进度。"
            },
            {
                "content": "整体来看，该表格提供了一个必填的请求体参数，旨在识别和描述特定任务，其唯一标识符为“taskId”。\n\n#### 7.10.3 RESPONSE\n| body参数 |                  参数说明                   |  参数类型  |  是否必填  |\n|:------:|:---------------------------------------:|:------:| :-----: |\n| state  | 状态标记，为0表示准备导入，为1表示导入中，为2表示导入成功，为3表示导入失败 |  字符串  |  是  |\n|  progress  |             导入进度，state为1时包含             |  字符串  |  否  |\n|  reason  |             失败原因，state为3时包含             |  字符串  |  否  |\n表格内容描述:\n该表格包含四列，分别是“body参数”、“参数说明”、“参数类型”和“是否必填”。\n\n- 第一行：state，表示状态标记。当其值为0时表示准备导入，1表示导入中，2表示导入成功，3表示导入失败。该参数的类型为字符串，并且是必填项。\n- 第二行：progress，表示导入进度，仅在state为1时包含。该参数的类型也是字符串，但不是必填项。\n- 第三行：reason，表示失败原因，仅在state为3时包含。该参数同样是字符串类型，也不是必填项。\n\n总体而言，该表格定义了一些与导入过程相关的参数，以及各参数的详细说明、数据类型和是否为必填项的信息。\n\n该chunk位于文档的第7.10节，主要介绍导入进度查询请求的响应格式及其相关参数的详细说明，包括状态标记、导入进度和失败原因等信息。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_8.md",
        "chunks": [
            {
                "content": "# 公司贡献者许可协议\n\nAnt_Group_Open_Source_Corporate_CLA_English_Chinese_2021\n\nAnt Group\n\nCorporate Contributor License Agreement\n\n蚂蚁集团\n\n公司贡献者许可协议\n\nThank you for your interest in contributing documentation and related software code to a project hosted or managed by Ant Group, or any of its affiliates. In order to clarify the intellectual property license granted with Contributions from any person or entity, Ant Group must have a Contributor License Agreement (\"CLA\") on file that has been signed by each Contributor, indicating agreement to the license terms below.  This version of the Contributor License Agreement allows a legal entity (the \"Corporation\") to submit Contributions to the applicable project.  If you are an individual making a submission on your own behalf, then you should sign the separation Individual Contributor License Agreement.\n\n该文本块位于公司贡献者许可协议的开头部分，介绍了蚂蚁集团对贡献者提交文档和软件代码的欢迎，阐明了知识产权许可协议的必要性，并说明了法人实体与个人贡献者之间的区别。"
            },
            {
                "content": "感谢您对向蚂蚁集团或其任何关联方主办或管理的项目贡献文档和相关软件代码的兴趣。为厘清就个人或实体贡献内容而授予的知识产权许可，蚂蚁集团必须对每位贡献者签署的贡献者许可协议（“CLA”）进行归档，以证明就以下许可条件达成的一致。此版本的贡献者许可协议允许法人实体（“公司”）向相应项目提交贡献内容。如果您是以自身名义进行提交的个人，您应当另行签署一份个人贡献者许可协议。\n\nYou accept and agree to the following terms and conditions for Your present and future Contributions submitted to Ant Group. Except for the license granted herein to Ant Group and recipients of documentation and software distributed by Ant Group, You reserve all right, title, and interest in and to Your Contributions.\n\n就您目前和将来向蚂蚁集团提交的贡献内容，您接受并同意以下条款和条件。除了根据本协议向蚂蚁集团和蚂蚁集团发布文档和软件的接收方授予的许可，您对于您的贡献内容保留所有权利、所有权和利益。\n1. Definitions.\n1. 定义。\n\n该部分位于“公司贡献者许可协议”的开头，介绍了贡献者向蚂蚁集团提交文档和软件代码的重要性，以及签署贡献者许可协议（CLA）的必要性，明确了贡献者在提交内容时的权利和义务，同时定义了一些关键术语。"
            },
            {
                "content": "就您目前和将来向蚂蚁集团提交的贡献内容，您接受并同意以下条款和条件。除了根据本协议向蚂蚁集团和蚂蚁集团发布文档和软件的接收方授予的许可，您对于您的贡献内容保留所有权利、所有权和利益。\n1. Definitions.\n1. 定义。\n\n\"You\" (or \"Your\") shall mean the copyright owner or legal entity authorized by the copyright owner that is making this Agreement with Ant Group. For legal entities, the entity making a Contribution and all other entities that control, are controlled by, or are under common control with that entity are considered to be a single Contributor. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.\n\n“您”（或“您的”）系指与蚂蚁集团签署本协议的著作权人或经著作权人授权的法律实体。对于法律实体而言，提交贡献内容的实体以及其他任何控制该实体、受其控制或与其受到同一主体控制的实体被视为单个贡献者。为本定义之目的，“控制” 系指（i）通过合同或其他方式，直接或间接对该实体进行指导和管理的权力，（ii）持有该实体百分之五十（50%）或更多的已发行股份，或（iii）间接持有该实体权益。\n\n该段落位于公司贡献者许可协议的开头部分，介绍了贡献者的权利和接受的条款，紧接着定义了关键术语，确立了参与者和贡献的基本概念，为后续的法律条款和责任奠定基础。"
            },
            {
                "content": "“您”（或“您的”）系指与蚂蚁集团签署本协议的著作权人或经著作权人授权的法律实体。对于法律实体而言，提交贡献内容的实体以及其他任何控制该实体、受其控制或与其受到同一主体控制的实体被视为单个贡献者。为本定义之目的，“控制” 系指（i）通过合同或其他方式，直接或间接对该实体进行指导和管理的权力，（ii）持有该实体百分之五十（50%）或更多的已发行股份，或（iii）间接持有该实体权益。\n\n\"Contribution\" shall mean any original work of authorship, including any modifications or additions to an existing work, that is intentionally submitted by You to Ant Group for inclusion in, or documentation of, any of the products or projects owned or managed by Ant Group (the \"Work\"), including without limitation any Work described in Schedule B. For the purposes of this definition, \"submitted\" means any form of electronic or written communication sent to Ant Group or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, Ant Group for the purpose of discussing and improving the Work.\n\n该段落位于公司贡献者许可协议的定义部分，解释了“您”和“贡献内容”的含义，以明确协议中有关贡献者的身份和他们提交的贡献内容的性质，为后续条款奠定基础。"
            },
            {
                "content": "“贡献内容”系指由您有意地向蚂蚁集团提交，以便被包含或记载在任何蚂蚁集团拥有或管理的产品或项目（“作品”，包括但不限于任何在附录B中列举的作品）中的任何原创作品，包括对既存作品的任何修改和增加。为本定义之目的，“提交”系指向蚂蚁集团或其代表进行的任何形式的电子或书面交流，包括但不限于为讨论和改善作品为目的，通过蚂蚁集团管理的（或以蚂蚁集团名义管理的）电子邮件列表、源代码控制系统和问题跟踪系统进行的交流。\n\n2. Grant of Copyright License. Subject to the terms and conditions of this Agreement, You hereby grant to Ant Group and to recipients of documentation and software distributed by Ant Group a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare derivative works of, publicly display, publicly perform, sublicense, and distribute Your Contributions and such derivative works.\n2. 著作权许可的授予。受限于本协议的条款和条件，您在此授予蚂蚁集团以及蚂蚁集团发布文档和软件的接收方永久性的、全球范围内的、非排他的、完全无须许可费的、完全无须版权费的和不可撤销的著作权许可，以复制、衍生、公开展示、公开执行、转授权和发布您的贡献内容和该等衍生作品。\n\n该块内容位于“公司贡献者许可协议”中，主要定义了“贡献内容”的概念，并紧接着授予蚂蚁集团对该贡献内容的著作权许可。这部分内容是协议的核心条款之一，旨在明确贡献者提交的作品的权益及蚂蚁集团对这些作品的使用权限。"
            },
            {
                "content": "3. Grant of Patent License. Subject to the terms and conditions of this Agreement, You hereby grant to Ant Group and to recipients of documentation and software distributed by Ant Group a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by You that are necessarily infringed by Your Contribution(s) alone or by combination of Your Contribution(s) with the Work to which such Contribution(s) was submitted. If any entity institutes patent litigation against You or any other entity (including a cross-claim or counterclaim in a lawsuit) alleging that your Contribution, or the Work to which you have contributed, constitutes direct or contributory patent infringement, then any patent licenses granted to that entity under this Agreement for that Contribution or Work shall terminate as of the\n\n该段落属于公司贡献者许可协议中的第三部分，涉及专利许可的授予。它规定了贡献者对蚂蚁集团及其文档和软件接收方授权的专利使用权，包括对贡献内容可能侵犯的专利权的说明及相关的法律责任条款。"
            },
            {
                "content": "Contribution(s) alone or by combination of Your Contribution(s) with the Work to which such Contribution(s) was submitted. If any entity institutes patent litigation against You or any other entity (including a cross-claim or counterclaim in a lawsuit) alleging that your Contribution, or the Work to which you have contributed, constitutes direct or contributory patent infringement, then any patent licenses granted to that entity under this Agreement for that Contribution or Work shall terminate as of the date such litigation is filed.\n\n该段落位于第3节“专利许可的授予”中，具体说明了贡献者在提交贡献时授予的专利许可的范围，以及如果出现针对贡献内容的专利诉讼时相关许可的终止条件。"
            },
            {
                "content": "3. 专利许可的授予。  受限于本协议的条款和条件，您在此授予蚂蚁集团以及蚂蚁集团发布文档和软件的接收方永久性的、全球范围内的、非排他的、完全无须许可费的、完全无须版权费的和不可撤销（本节规定的情形除外）的专利许可，以开发、利用、要约出售、出售、导入或以其他方式转让作品，但该许可仅适用于您有权许可的，且必然会被您的贡献内容侵权（贡献内容单独构成侵权、或与贡献内容的相关作品一同构成侵权）的专利申请范围。如果任何实体针对您或其他实体提起专利诉讼（包括诉讼中的交叉请求或反诉），主张您的贡献内容（或您参与贡献的作品）造成了直接性或辅助性的专利侵权，则任何根据本协议针对该贡献内容或作品授予该实体的专利许可应当在起诉之日终止。\n\n该段落位于公司贡献者许可协议中，具体涉及专利许可的条款，阐明了贡献者对其贡献内容授予蚂蚁集团及其软件和文档接收方的专利许可条件，以及在面临专利诉讼情况下该许可的终止条件。"
            },
            {
                "content": "4. You represent that you are legally entitled to grant the above license. You represent further that each employee of the Corporation designated on Schedule A below (or in a subsequent written modification to that Schedule) is authorized to submit Contributions on behalf of the Corporation.\n4. 您保证您依法有权授予上述许可。您进一步保证下文附表A（该附表可通过书面方式进行后续更改）所指定的任意公司员工均有权以公司名义提交贡献内容。\n\n5. You represent that each of Your Contributions is Your original creation (see section 7 for submissions on behalf of others).  You represent that Your Contribution submissions include complete details of any third-party license or other restriction (including, but not limited to, related patents and trademarks) of which you are personally aware and which are associated with any part of Your Contributions.\n5. 您保证您所有的贡献内容均为您的原创作品（关于为他人提交作品的规定，可参见第7节）。您保证您提交的贡献内容包括任何第三方许可或其他限制（包括但不限于相关专利或商标）的全部细节，只要该等许可或其他限制为您个人所知悉且与您的贡献内容的任何部分相关。\n\n该段落位于协议的条款部分，主要阐述了贡献者的法律资格以及对贡献内容原创性的保证。这些条款明确贡献者在提交贡献内容时需要确认其合法性和原创性，并确保相应的员工有权代表公司进行提交。"
            },
            {
                "content": "6. You are not expected to provide support for Your Contributions, except to the extent You desire to provide support. You may provide support for free, for a fee, or not at all. Unless required by applicable law or agreed to in writing, You provide Your Contributions on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON- INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE.\n6. 在您自愿提供支持的范围之外，您无需对您的贡献内容提供支持。您可以提供免费支持或收费支持，也可以完全不提供支持。除非适用法律另有规定或另有书面约定，您“按照现状”提供您的贡献内容，而不对其提供任何类型的保证或条件，无论明示还是默示，包括但不限于为任何特定目的对所有权、无侵权、适销性或适当性的保证或条件。\n\n该段落位于公司贡献者许可协议的第6条，主要说明了贡献者在提交贡献内容后，对其贡献的支持责任和免责声明，包括不提供任何形式的保证或条件。"
            },
            {
                "content": "7. Should You wish to submit work that is not Your original creation, You may submit it to Ant Group separately from any Contribution, identifying the complete details of its source and of any license or other restriction (including, but not limited to, related patents, trademarks, and license agreements) of which you are personally aware, and conspicuously marking the work as \"Submitted on behalf of a third-party: [named here]\".\n7. 如果您希望提交并非您原创的作品，您可以在任何贡献内容之外单独向蚂蚁集团提交，标注关于其来源和您个人所知悉的任何许可或其他限制（包括但不限于相关专利、商标和许可协议）的完整信息，并以显著方式标明该作品属于“以第三方名义提交：【填写姓名】”。\n\n8. You agree to notify Ant Group of any facts or circumstances of which you become aware that would make these representations inaccurate in any respect.\n8. 您同意在您获悉任何可能导致上述保证在任何方面不准确的事实或情况之时通知蚂蚁集团。\n\n该内容位于公司贡献者许可协议的第7和第8节，主要说明了如果贡献者希望提交非原创作品的要求和义务，包括标识来源及许可，同时保证在知晓信息不准确时需通知蚂蚁集团。这些条款旨在明确贡献者在提交工作时的责任和义务。"
            },
            {
                "content": "8. You agree to notify Ant Group of any facts or circumstances of which you become aware that would make these representations inaccurate in any respect.\n8. 您同意在您获悉任何可能导致上述保证在任何方面不准确的事实或情况之时通知蚂蚁集团。\n\n9. This Agreement will be governed by and construed in accordance with the laws of the People's Republic of China excluding that body of laws known as conflict of laws.  The parties expressly agree that the United Nations Convention on Contracts for the International Sale of Goods will not apply.  Any legal action or proceeding arising under this Agreement will be brought exclusively in the courts located in Hangzhou, China, and the parties hereby irrevocably consent to the personal jurisdiction and venue therein.\n9. 本协议受中华人民共和国法律管辖，并依据其进行解释，但冲突法规则除外。协议各方明确同意排除《联合国国际货物销售合同公约》的适用。任何由本协议产生的法律诉讼或程序均应排他性地提交至中国杭州的法院进行审理，且各方在此不可撤销地同意该等关于属人管辖和法院地的安排。\n\n该段落位于公司贡献者许可协议的后半部分，主要涉及贡献者的通知义务以及协议适用的法律条款，明确规定了在法律纠纷发生时的管辖法院和适用法律。这些条款旨在保护双方在协议执行过程中的权益。"
            },
            {
                "content": "10. For your reading convenience, this Agreement is written in parallel English and Chinese sections. To the extent there is a conflict between the English and Chinese sections, the English sections shall govern.\n10. 为了您的阅读方便，本协议同时提供了英文和中文段落。如果英文和中文段落有矛盾，则以英文段落为准。\n\nPlease sign请签署: __________________________________ Date日期: ____________\n\nCompany Name公司名称: ________________________________________________\n\nFull name全名: _____________________________________________________\n\nTitle职务: _____________________________________________________\n\nMailing Address信件地址: ________________________________________________\n\nCountry国家: _____________________________________________________\n\nTelephone电话: _____________________________________________________\n\nE-Mail电子邮箱:    ______________________________________________________\n\nSchedule A附录A:\n\nPlease provide an initial list of designated employees authorized to submit Contributions on behalf of the Corporation:\n\n请提供一份有权以公司名义提交贡献内容的指定员工的初始名单：\n\nSchedule B 附录B:\n\n该段落位于《公司贡献者许可协议》的最终部分，主要涉及协议的签署和确认，以及提供公司信息和初始员工名单的要求。同时，提醒读者英文和中文版本之间的优先权，以便于阅读和理解协议内容。"
            },
            {
                "content": "Mailing Address信件地址: ________________________________________________\n\nCountry国家: _____________________________________________________\n\nTelephone电话: _____________________________________________________\n\nE-Mail电子邮箱:    ______________________________________________________\n\nSchedule A附录A:\n\nPlease provide an initial list of designated employees authorized to submit Contributions on behalf of the Corporation:\n\n请提供一份有权以公司名义提交贡献内容的指定员工的初始名单：\n\nSchedule B 附录B:\n\nDescription of Initial Contribution:\n\n描述初始贡献内容：\n\n该片段位于《公司贡献者许可协议》的签署部分，包含了签署者的联系信息和附录A与附录B的内容，用于收集有关授权提交贡献内容的员工名单及初始贡献内容的描述。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_9.md",
        "chunks": [
            {
                "content": "# Sampling API\n\n> 此文档主要详细介绍了Sampling API的使用说明\n\n## 1. 概述\n\n本手册介绍使用TuGraph的Sampling API接口。\n\n## 2. 图数据预处理\n在采样操作之前，根据图数据路径加载图数据，并映射成olapondb图分析类，代码如下：\n\n```python\ngalaxy = PyGalaxy(args.db_path) # 根据路径创建一个galaxy实例\ngalaxy.SetCurrentUser(args.username, args.password) # 设置当前用户\ndb = galaxy.OpenGraph('default', False) # 打开图数据库指定db\ntxn = db.CreateReadTxn() # 创建一个事务实例\nolapondb = PyOlapOnDB('Empty', db, txn) # 根据图加载方式、图数据库实例、事务实例实例化OlapOnDB\ndel txn\ndel db\ndel galaxy\n```\n## 3. 图采样算子介绍\n图采样算子在cython层实现，用于对输入的图进行采样处理，生成的NodeInfo用于保存feature属性、label属性等点信息，EdgeInfo用于保存边信息，这些元数据信息可以被用于特征抽取、网络嵌入等任务中。目前TuGraph图学习模块支持GetDB、NeighborSampling、EdgeSampling、RandomWalkSampling、NegativeSampling五种采样算子。\n### 3.1.RandomWalk算子：\n在给定的采样点周围进行指定次数的随机游走，得到采样子图。\n\n该文档主要介绍TuGraph的Sampling API，包括图数据预处理和五种图采样算子（如RandomWalk、NeighborSampling等）的详细说明。此内容为文档的开头部分，提供了Sampling API的概述和相关代码示例，便于用户理解如何使用这些功能进行图数据采样。"
            },
            {
                "content": "```python\nProcess(db_: lgraph_db_python.PyGraphDB, olapondb: lgraph_db_python.PyOlapOnDB, feature_num: size_t, sample_node: list, step: size_t, NodeInfo: list, EdgeInfo: list)\n```\n参数列表：\ndb_: 图数据库实例。\nolapondb: 图分析类。\nfeature_num: size_t类型，feature特征向量的长度。\nsample_node: list类型，采样点列表。\nstep: size_t类型，采样步数。\nNodeInfo: list类型，点属性字典的列表，表示点的元数据信息。\nEdgeInfo: list类型，边属性字典的列表，表示边的元数据信息。\n返回值: 无。\n\n### 3.2.NeighborSample算子：\n在给定采样点的一度邻居中采样一定数量的点，得到采样子图。\n```python\nProcess(db_: lgraph_db_python.PyGraphDB, olapondb: lgraph_db_python.PyOlapOnDB, feature_num: size_t, sample_node: list, nei_num: size_t, NodeInfo: list, EdgeInfo: list)\n```\n参数列表：\ndb_: 图数据库实例。\nolapondb: 图分析类。\nfeature_num: size_t类型，feature特征向量的长度。\nsample_node: list类型，采样点列表。\nnei_num: size_t类型，邻居采样点数。\nNodeInfo: list类型，点属性字典的列表，表示点的元数据信息。\nEdgeInfo: list类型，边属性字典的列表，表示边的元数据信息。\n返回值: 无。\n\n此代码块位于文档的第3节，介绍了图采样算子。具体而言，它详细描述了RandomWalk算子和NeighborSample算子的实现方法及其参数，包括如何在图数据库中进行随机游走和邻居采样以生成子图。这些内容有助于用户理解和使用TuGraph的采样机制。"
            },
            {
                "content": "### 3.2.NeighborSample算子：\n在给定采样点的一度邻居中采样一定数量的点，得到采样子图。\n```python\nProcess(db_: lgraph_db_python.PyGraphDB, olapondb: lgraph_db_python.PyOlapOnDB, feature_num: size_t, sample_node: list, nei_num: size_t, NodeInfo: list, EdgeInfo: list)\n```\n参数列表：\ndb_: 图数据库实例。\nolapondb: 图分析类。\nfeature_num: size_t类型，feature特征向量的长度。\nsample_node: list类型，采样点列表。\nnei_num: size_t类型，邻居采样点数。\nNodeInfo: list类型，点属性字典的列表，表示点的元数据信息。\nEdgeInfo: list类型，边属性字典的列表，表示边的元数据信息。\n返回值: 无。\n\n### 3.3.Nagetive算子：\n采用负采样算法，生成不存在边的子图。\n```python\nProcess(db_: lgraph_db_python.PyGraphDB, olapondb: lgraph_db_python.PyOlapOnDB, feature_num: size_t, num_samples: size_t, NodeInfo: list, EdgeInfo: list)\n```\n参数列表：\ndb_: 图数据库实例。\nolapondb: 图分析类。\nfeature_num: size_t类型，feature特征向量的长度。\nnum_samples: size_t类型，生成不存在边的数量。\nNodeInfo: list类型，点属性字典的列表，表示点的元数据信息。\nEdgeInfo: list类型，边属性字典的列表，表示边的元数据信息。\n返回值： 无。\n\n该片段位于文档的第3节，介绍了图采样算子的具体实现，包括NeighborSample算子和Negative算子，分别用于从图的邻居中采样节点和生成不存在的边的子图，属于TuGraph图学习模块下的采样算法部分，旨在为用户提供采样数据的具体参数与使用方法。"
            },
            {
                "content": "### 3.3.Nagetive算子：\n采用负采样算法，生成不存在边的子图。\n```python\nProcess(db_: lgraph_db_python.PyGraphDB, olapondb: lgraph_db_python.PyOlapOnDB, feature_num: size_t, num_samples: size_t, NodeInfo: list, EdgeInfo: list)\n```\n参数列表：\ndb_: 图数据库实例。\nolapondb: 图分析类。\nfeature_num: size_t类型，feature特征向量的长度。\nnum_samples: size_t类型，生成不存在边的数量。\nNodeInfo: list类型，点属性字典的列表，表示点的元数据信息。\nEdgeInfo: list类型，边属性字典的列表，表示边的元数据信息。\n返回值： 无。\n\n### 3.4.EdgeSampling算子：\n根据边采样率，生成采样边的子图。\n```python\nProcess(db_: lgraph_db_python.PyGraphDB, olapondb:lgraph_db_python.PyOlapOnDB, feature_num: size_t, sample_rate: double, NodeInfo: list, EdgeInfo: list,EdgeInfo: list)\n```\n参数列表：\ndb_: 图数据库实例。\nolapondb: 图分析类。\nfeature_num: size_t类型，feature特征向量的长度。\nsample_rate: double类型，采样率。\nNodeInfo: list类型，一个点属性字典的列表，表示点的元数据信息。\nEdgeInfo: list类型，一个边属性字典的列表，表示边的元数据信息。\n返回值: 无。\n\n该块内容位于文档的第三部分“图采样算子介绍”中，详细描述了“Nagetive算子”和“EdgeSampling算子”的功能及其参数列表，作为TuGraph中五种采样算子之一，帮助用户理解和实现图数据的采样操作。"
            },
            {
                "content": "### 3.4.EdgeSampling算子：\n根据边采样率，生成采样边的子图。\n```python\nProcess(db_: lgraph_db_python.PyGraphDB, olapondb:lgraph_db_python.PyOlapOnDB, feature_num: size_t, sample_rate: double, NodeInfo: list, EdgeInfo: list,EdgeInfo: list)\n```\n参数列表：\ndb_: 图数据库实例。\nolapondb: 图分析类。\nfeature_num: size_t类型，feature特征向量的长度。\nsample_rate: double类型，采样率。\nNodeInfo: list类型，一个点属性字典的列表，表示点的元数据信息。\nEdgeInfo: list类型，一个边属性字典的列表，表示边的元数据信息。\n返回值: 无。\n\n### 3.5.GetDB算子：\n从数据库中获取图数据并转换成所需数据结构。\n```python\nProcess(db_: lgraph_db_python.PyGraphDB, olapondb:lgraph_db_python.PyOlapOnDB, feature_num: size_t, NodeInfo: list, EdgeInfo: list)\n```\n参数列表：\ndb_: 图数据库实例。\nolapondb: 图分析类。\nfeature_num: size_t类型，feature特征向量的长度。\nNodeInfo: list类型，一个点属性字典的列表，表示点的元数据信息。\nEdgeInfo: list类型，一个边属性字典的列表，表示边的元数据信息。\n返回值: 无。\n\n## 4. 用户自定义采样算法\n用户也可以通过TuGraph Olap接口实现自定义采样算法。\n\n该段落包含了Sampling API中EdgeSampling和GetDB两种采样算子的详细介绍，包括它们的功能、参数列表及返回值说明。此部分位于文档的第三章，主要阐述图采样算子的使用方法和特点，为用户提供了自定义采样算法的基础。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_10.md",
        "chunks": [
            {
                "content": "# 数据库运行\n\n> 本文档主要描述 TuGraph 服务的运行模式、启动、停止和重启的操作,以及 TuGraph 的服务配置参数、配置文件格式和命令行配置参数。\n\n## 1.前置条件\n\nTuGraph 运行的前置条件为 TuGraph 正确安装。\n\nTuGraph 运行需要保证库文件 liblgraph.so 的文件位置在环境变量 LD_LIBRARY_PATH。\n\n运行 TuGraph 进程的用户不需要超级权限，但需要对配置文件（一般为lgraph.json）及文件中涉及的文件有读权限，并且对数据文件夹、日志文件夹等有写权限。\n\n## 2.运行模式\n\nTuGraph 可以作为前台普通进程启动，也可以作为后台守护进程启动。\n当作为普通进程运行时，TuGraph 可以直接将日志打印到终端，这在调试服务器配置时非常方便。但是，由于前台进程在终端退出后被终止，因此用户须确保在 TuGraph 服务器处于运行状态时，终端保持打开状态。另一方面，在守护进程模式下，即使启动它的终端退出，TuGraph 服务器也可以继续运行。因此，在长时间运行的服务器下推荐以守护进程模式启动 TuGraph 服务器。\n\n### 2.1.运行普通进程\n\n`lgraph_server -d run`命令可以将 TuGraph 作为普通进程运行。普通进程依赖命令行终端，因此终端结束时，TuGraph 进程也会自动终止。普通进程模式配合`--log_dir \"\"`可以将进程日志直接输出到终端，因此更方便调试。注：当不使用`-d run`命令时，将默认运行普通进程。\n\nlgraph_server的默认路径为：/usr/local/bin/lgraph_server 。\n\nlgraph.json的默认路径为：/usr/local/etc/lgraph.json 。\n\n启动命令：\n\n```shell\n$ ./lgraph_server -d run -c lgraph.json --log_dir \"\"\n```\n或者：\n```shell\n$ ./lgraph_server -c lgraph.json --log_dir \"\"\n```\n\n普通模式的运行输出示例：\n\n该章节主要介绍了TuGraph数据库的运行模式，包括前置条件、普通进程运行和守护进程运行的启动命令及其输出示例，为用户提供了基础的操作指导和配置要求，以确保服务的正确启动和运行。"
            },
            {
                "content": "```shell\n**********************************************************************\n*                  TuGraph Graph Database v4.3.2                     *\n*                                                                    *\n*    Copyright(C) 2018-2023 Ant Group. All rights reserved.          *\n*                                                                    *\n**********************************************************************\nServer is configured with the following parameters:\n  Backup log enable:                   0\n  DB directory:                        /var/lib/lgraph/data\n  HA enable:                           0\n  HTTP port:                           7070\n  HTTP web dir:                        /usr/local/share/lgraph/browser-resource\n  RPC enable:                          1\n  RPC port:                            9090\n  SSL enable:                          0\n  Whether the token is unlimited:      0\n  audit log enable:                    0\n  bind host:                           0.0.0.0\n\n该代码块是TuGraph图数据库在运行时输出的服务器配置参数的示例，展示了服务器的版本信息及其重要配置选项，如数据目录、HTTP和RPC端口、以及高可用性设置等，位于“普通进程的运行输出示例”部分下，用于帮助用户了解当前服务器的配置状态。"
            },
            {
                "content": "DB directory:                        /var/lib/lgraph/data\n  HA enable:                           0\n  HTTP port:                           7070\n  HTTP web dir:                        /usr/local/share/lgraph/browser-resource\n  RPC enable:                          1\n  RPC port:                            9090\n  SSL enable:                          0\n  Whether the token is unlimited:      0\n  audit log enable:                    0\n  bind host:                           0.0.0.0\n  bolt port:                           7687\n  disable auth:                        0\n  durable:                             0\n  log dir:                             \"\"\n  log verbose:                         1\n  number of bolt io threads:           1\n  optimistic transaction:              0\n  reset admin password if you forget:  0\n  subprocess idle limit:               600\n  thread limit:                        0\n\n该内容片段位于文档的“普通进程运行输出示例”部分，展示了启动 TuGraph 服务时所配置的具体参数和状态信息，包括数据库目录、HA 功能、HTTP 和 RPC 端口等设置，便于用户理解和调试服务器配置。"
            },
            {
                "content": "audit log enable:                    0\n  bind host:                           0.0.0.0\n  bolt port:                           7687\n  disable auth:                        0\n  durable:                             0\n  log dir:                             \"\"\n  log verbose:                         1\n  number of bolt io threads:           1\n  optimistic transaction:              0\n  reset admin password if you forget:  0\n  subprocess idle limit:               600\n  thread limit:                        0\n[20240730 15:34:27.848783 0x00007f81bb3889c0 INFO  src/server/lgraph_server.h:78] [StateMachine] Builtin services are disabled according to ServerOptions.has_builtin_services\n[20240730 15:34:27.849116 0x00007f81bb3889c0 INFO  src/server/lgraph_server.cpp:268] Listening for RPC on port 9090\n[20240730 15:34:27.868819 0x00007f81bb3889c0 INFO  src/restful/server/rest_server.cpp:479] Listening for REST on port 7070\n[20240730 15:34:27.869970 0x00006e7d435ff700 INFO  src/server/bolt_server.cpp:36] bolt server run\n\n该块内容位于 TuGraph 服务的运行模式描述中，具体是展示了服务启动后的配置信息和运行日志，包括各种参数的值（如审核日志启用状态、绑定主机、Bolt端口、认证禁用状态等）和服务器监听端口的相关信息。这些信息有助于用户了解当前服务器的配置和运行状态。"
            },
            {
                "content": "[20240730 15:34:27.848783 0x00007f81bb3889c0 INFO  src/server/lgraph_server.h:78] [StateMachine] Builtin services are disabled according to ServerOptions.has_builtin_services\n[20240730 15:34:27.849116 0x00007f81bb3889c0 INFO  src/server/lgraph_server.cpp:268] Listening for RPC on port 9090\n[20240730 15:34:27.868819 0x00007f81bb3889c0 INFO  src/restful/server/rest_server.cpp:479] Listening for REST on port 7070\n[20240730 15:34:27.869970 0x00006e7d435ff700 INFO  src/server/bolt_server.cpp:36] bolt server run\n[20240730 15:34:27.870040 0x00007f81bb3889c0 INFO  src/server/lgraph_server.cpp:302] Server started.\n```\n\n该片段位于文档的“普通模式的运行输出示例”部分，展示了TuGraph在以普通进程模式启动后，服务器启动时的日志信息，包括监听的RPC和REST端口，以及服务状态的指示。"
            },
            {
                "content": "普通进程模式下，用户可以通过按 `CTRL+C` 来提前终止 TuGraph 进程。\n\n### 2.2.运行进程守护模式\n\n启动命令：\n\n```shell\n$ ./lgraph_server -d start -c lgraph.json\n```\n\n守护模式的运行输出示例：\n\n```shell\nStarting lgraph...\nThe service process is started at pid 12109.\n```\n\n此命令启动的 TuGraph 服务器进程为守护进程，它将从文件`lgraph.json`加载相关配置。服务器启动后，它将开始在日志文件中打印日志，之后可用该日志文件确定服务器的状态。\n\n## 3.服务操作\n\n### 3.1.启动服务\n\nTuGraph 需要通过 `lgraph_server -d start` 命令行启动，启动命令示例如下：\n\n```bash\n$ ./lgraph_server -d start -c lgraph.json\nStarting lgraph...\nThe service process is started at pid 12109.\n```\n\n此命令启动的 TuGraph 服务器进程为守护进程，它将从文件`lgraph.json`加载相关配置。服务器启动后，它将开始在日志文件中打印日志，之后可用该日志文件确定服务器的状态。\n\n### 3.2.停止服务\n\n用户可以使用`kill`命令以及`lgraph_server -d stop`命令停止 TuGraph 守护进程。由于可能在同一台计算机上运行多个 TuGraph 服务器进程，因此我们使用`.pid`文件区分不同的服务器进程，该文件写入启动该进程的工作目录。因此，需要在相同工作目录中运行`lgraph_server-d stop`命令，以停止正确的服务器进程。\n\n```shell\nuser@host:~/tugraph$ ./lgraph_server -d start -c lgraph.json\n20200508122306.378: Starting lgraph...\n20200508122306.379: The service process is started at pid 93.\n\nuser@host:~/tugraph$ cat ./lgraph.pid\n93\n\n该块内容主要涉及 TuGraph 数据库的运行模式，包括普通进程和守护进程的启动、停止和重启操作，详细说明了相应的命令及其输出示例，帮助用户理解如何有效管理 TuGraph 服务。"
            },
            {
                "content": "此命令启动的 TuGraph 服务器进程为守护进程，它将从文件`lgraph.json`加载相关配置。服务器启动后，它将开始在日志文件中打印日志，之后可用该日志文件确定服务器的状态。\n\n### 3.2.停止服务\n\n用户可以使用`kill`命令以及`lgraph_server -d stop`命令停止 TuGraph 守护进程。由于可能在同一台计算机上运行多个 TuGraph 服务器进程，因此我们使用`.pid`文件区分不同的服务器进程，该文件写入启动该进程的工作目录。因此，需要在相同工作目录中运行`lgraph_server-d stop`命令，以停止正确的服务器进程。\n\n```shell\nuser@host:~/tugraph$ ./lgraph_server -d start -c lgraph.json\n20200508122306.378: Starting lgraph...\n20200508122306.379: The service process is started at pid 93.\n\nuser@host:~/tugraph$ cat ./lgraph.pid\n93\n\nuser@host:~/tugraph$ ./lgraph_server -d stop -c lgraph.json\n20200508122334.857: Stopping lgraph...\n20200508122334.857: Process stopped.\n```\n\n### 3.3.重启服务\n\n用户也可以通过`lgraph_server -d restart`来重启 TuGraph 服务：\n\n```bash\n$ ./lgraph_server -d restart\nStopping lgraph...\nProcess stopped.\nStarting lgraph...\nThe service process is started at pid 20899.\n```\n\n### 3.4.新旧前端切换\n\n该文本块位于文档的第三部分，主要描述了 TuGraph 服务器的启动、停止和重启操作。具体内容包括如何通过命令行启动守护进程、停止服务的步骤以及重启服务的命令示例。此外，还提到如何在新的前端和旧的前端之间进行切换。"
            },
            {
                "content": "user@host:~/tugraph$ cat ./lgraph.pid\n93\n\nuser@host:~/tugraph$ ./lgraph_server -d stop -c lgraph.json\n20200508122334.857: Stopping lgraph...\n20200508122334.857: Process stopped.\n```\n\n### 3.3.重启服务\n\n用户也可以通过`lgraph_server -d restart`来重启 TuGraph 服务：\n\n```bash\n$ ./lgraph_server -d restart\nStopping lgraph...\nProcess stopped.\nStarting lgraph...\nThe service process is started at pid 20899.\n```\n\n### 3.4.新旧前端切换\n\n进入容器，可以通过修改配置文件\"/usr/local/etc/lgraph.json\"中的\"web\"参数来选择使用老版本或新版本的前端。对于老版本，可以将\"web\"的值设为\"/usr/local/share/lgraph/resource\"；对于新版本，可以将\"web\"的值设为\"/usr/local/share/lgraph/browser-resource\"。完成配置文件的修改后，请执行命令 `docker restart tugraph` 以使更改生效。需要注意的是，新版本是默认选项。\n\n## 4.服务配置\n\nTuGraph 服务器在启动时从配置文件和命令行选项加载配置，如果在配置文件和命令行中同一选项指定了不同的值，将优先使用命令行中指定的值。\n\n### 4.1.配置参数\n\n具体参数及其类型描述如下：\n\n该段落位于文档第三部分“服务操作”中，具体描述了通过`cat`命令查看TuGraph进程的PID文件内容以及使用`lgraph_server -d stop`命令停止TuGraph服务的操作示例，紧接着是对重启服务和新旧前端切换的介绍。整体上属于TuGraph服务管理及操作的细节部分。"
            },
            {
                "content": "| **参数名**                      | **参数类型** | **参数说明**                                                                                                                                                                          |\n|------------------------------|-----------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| directory                    | 字符串                   | 数据文件所在目录。如果目录不存在 ，则自动创建。默认目录为 /var/lib/lgraph/data。                                                                                                                               |\n| durable                      | 布尔值                   | 是否开启实时持久化。关闭持久化可以减少写入时的磁盘 IO 开销，但是在机器断电等极端情况下可能丢失数据。默认值为 `true`。                                                                                                                  |\n\n该文本块位于文档的“服务配置”部分，具体描述了 TuGraph 服务器的配置参数及其类型和说明，旨在帮助用户理解各个配置项的功能和默认值，以便进行系统配置与管理。"
            },
            {
                "content": "| directory                    | 字符串                   | 数据文件所在目录。如果目录不存在 ，则自动创建。默认目录为 /var/lib/lgraph/data。                                                                                                                               |\n| durable                      | 布尔值                   | 是否开启实时持久化。关闭持久化可以减少写入时的磁盘 IO 开销，但是在机器断电等极端情况下可能丢失数据。默认值为 `true`。                                                                                                                  |\n| host                         | 字符串                   | REST 服务器监听时使用的地址，一般为服务器的 IP 地址。默认地址为 0.0.0.0。注：在HA模式下，host需要设置为对应服务器的IP地址，不能设置为0.0.0.0。                                                                                           |\n| port                         | 整型                    | REST 服务器监听时使用的端口。默认端口为 7070。                                                                                                                                                      |\n\n该内容块位于文档的“服务配置”部分，具体介绍了TuGraph服务器在启动时所需配置参数的详细说明，包括参数名称、类型及其功能描述，帮助用户理解和配置服务器的运行环境。"
            },
            {
                "content": "| host                         | 字符串                   | REST 服务器监听时使用的地址，一般为服务器的 IP 地址。默认地址为 0.0.0.0。注：在HA模式下，host需要设置为对应服务器的IP地址，不能设置为0.0.0.0。                                                                                           |\n| port                         | 整型                    | REST 服务器监听时使用的端口。默认端口为 7070。                                                                                                                                                      |\n| enable_rpc                   | 布尔值                   | 是否使用 RPC 服务。默认值为 false。                                                                                                                                                           |\n| rpc_port                     | 整型                    | RPC 及 HA 服务所用端口。默认端口为 9090。                                                                                                                                                       |\n\n该部分内容位于文档的“服务配置”章节，具体描述了TuGraph服务器的配置参数，包括REST服务器的监听地址、端口以及RPC服务的启用与端口设置。这些参数对于正确配置和运行TuGraph服务至关重要。"
            },
            {
                "content": "| enable_rpc                   | 布尔值                   | 是否使用 RPC 服务。默认值为 false。                                                                                                                                                           |\n| rpc_port                     | 整型                    | RPC 及 HA 服务所用端口。默认端口为 9090。                                                                                                                                                       |\n| bolt_port                    | 整型                    | Bolt 客户端端口。默认端口为 7687。                                                                                                                                                            |\n| enable_ha                    | 布尔值                   | 是否启动高可用模式。默认值为 false。                                                                                                                                                             |\n\n该片段位于文档的“服务配置”部分，具体描述了与 TuGraph 服务器相关的几个重要配置参数，包括启用 RPC 服务、RPC 端口、Bolt 客户端端口和高可用模式的启用情况。这些参数在启动和配置 TuGraph 服务时至关重要。"
            },
            {
                "content": "| bolt_port                    | 整型                    | Bolt 客户端端口。默认端口为 7687。                                                                                                                                                            |\n| enable_ha                    | 布尔值                   | 是否启动高可用模式。默认值为 false。                                                                                                                                                             |\n| ha_log_dir                   | 字符串                   | HA 日志所在目录，需要启动 HA 模式。默认值为空。                                                                                                                                                       |\n| verbose                      | 整型                    | 日志输出信息的详细程度。可设为 0，1，2，值越大则输出信息越详细。默认值为 1。                                                                                                                                         |\n\n该块内容位于文档的第4节“服务配置”中的“配置参数”部分，具体描述了与TuGraph服务配置相关的几个参数，包括Bolt客户端端口、高可用模式的启用、HA日志目录和日志输出详细程度。这些参数用于定义和调整TuGraph数据库的运行和管理特性。"
            },
            {
                "content": "| ha_log_dir                   | 字符串                   | HA 日志所在目录，需要启动 HA 模式。默认值为空。                                                                                                                                                       |\n| verbose                      | 整型                    | 日志输出信息的详细程度。可设为 0，1，2，值越大则输出信息越详细。默认值为 1。                                                                                                                                         |\n| log_dir                      | 字符串                   | 日志文件所在的目录。默认目录为 /var/log/lgraph/。                                                                                                                                                 |\n| ssl_auth                     | 布尔值                   | 是否使用 SSL 安全认证。当开启时，REST 服务器只开启 HTTPS 服务。默认值为 false。                                                                                                                               |\n\n该片段位于文档的“服务配置”部分，具体描述了TuGraph服务器的配置参数，包括HA日志目录、日志输出详细程度、日志文件目录及SSL安全认证设置，旨在帮助用户正确配置和管理服务器运行参数。"
            },
            {
                "content": "| log_dir                      | 字符串                   | 日志文件所在的目录。默认目录为 /var/log/lgraph/。                                                                                                                                                 |\n| ssl_auth                     | 布尔值                   | 是否使用 SSL 安全认证。当开启时，REST 服务器只开启 HTTPS 服务。默认值为 false。                                                                                                                               |\n| web                          | 字符串                   | Web 文件（包括可视化组件）的存储位置，默认设置在 /usr/local/share/lgraph/browser-resource 目录下。而对于之前的老版本，该目录则位于 /usr/local/share/lgraph/resource 。                                                       |\n| server_cert                  | 字符串                   | 在 SSL 认证开启时，服务器所使用的 certificate 文件路径。默认路径为 /usr/local/etc/lgraph/server-cert.pem。                                                                                                 |\n\n该片段位于文档的“服务配置”部分，具体讲述了TuGraph服务器的相关配置参数，包括日志文件目录、SSL安全认证设置及Web文件存储位置等，便于用户进行系统配置与管理。"
            },
            {
                "content": "| web                          | 字符串                   | Web 文件（包括可视化组件）的存储位置，默认设置在 /usr/local/share/lgraph/browser-resource 目录下。而对于之前的老版本，该目录则位于 /usr/local/share/lgraph/resource 。                                                       |\n| server_cert                  | 字符串                   | 在 SSL 认证开启时，服务器所使用的 certificate 文件路径。默认路径为 /usr/local/etc/lgraph/server-cert.pem。                                                                                                 |\n| server_key                   | 字符串                   | 在 SSL 认证开启时，服务器所使用的公钥文件。默认目录为 /usr/local/etc/lgraph/server-key.pem。                                                                                                               |\n| enable_audit_log             | 布尔值                   | 是否启用审计日志，默认值为 false。                                                                                                                                                              |\n\n该内容块位于文档的“服务配置”部分，主要描述了TuGraph服务器的配置参数，包括Web文件存储位置、SSL认证相关证书路径及审计日志的启用设置。这些参数对服务器的安全性和数据管理具有重要影响。"
            },
            {
                "content": "| server_key                   | 字符串                   | 在 SSL 认证开启时，服务器所使用的公钥文件。默认目录为 /usr/local/etc/lgraph/server-key.pem。                                                                                                               |\n| enable_audit_log             | 布尔值                   | 是否启用审计日志，默认值为 false。                                                                                                                                                              |\n| audit_log_expire             | 整型                    | 启用审计日志时，日志的有效时间（小时），超时自动清理，值为 0 时表示不清理。默认值为 0。                                                                                                                                    |\n| audit_log_dir                | 字符串                   | 启用审计日志时，日志文件的存放目录。默认目录为 $directory/_audit_log_。                                                                                                                                   |\n\n在文档的服务配置部分，介绍了TuGraph服务器的配置参数及其说明，其中包括SSL认证相关的公钥文件设置和审计日志的启用、有效时间和存放目录等选项。该段落具体列出了与审计日志及其文件管理相关的配置参数，有助于用户理解和配置TuGraph的日志管理机制。"
            },
            {
                "content": "| audit_log_expire             | 整型                    | 启用审计日志时，日志的有效时间（小时），超时自动清理，值为 0 时表示不清理。默认值为 0。                                                                                                                                    |\n| audit_log_dir                | 字符串                   | 启用审计日志时，日志文件的存放目录。默认目录为 $directory/_audit_log_。                                                                                                                                   |\n| load_plugins                 | 布尔值                   | 启动服务时导入所有存储过程。默认值为 true。                                                                                                                                                          |\n| optimistic_txn               | 布尔值                   | 为 Cypher 开启乐观多线程写入事务。默认为 false。                                                                                                                                                   |\n\n该片段位于文档的服务配置部分，具体描述了与审计日志和工具插件相关的配置参数，包括审计日志的有效时间、存放目录、服务启动时的插件加载及乐观事务处理的设置。这些配置对运行TuGraph服务时的日志管理和性能调优具有重要意义。"
            },
            {
                "content": "| load_plugins                 | 布尔值                   | 启动服务时导入所有存储过程。默认值为 true。                                                                                                                                                          |\n| optimistic_txn               | 布尔值                   | 为 Cypher 开启乐观多线程写入事务。默认为 false。                                                                                                                                                   |\n| disable_auth                 | 布尔值                   | 关闭 REST 验证。默认为 false。                                                                                                                                                             |\n| ha_snapshot_interval_s       | 整型                    | 快照间隔（以秒为单位），默认值为 604800。-1表示不自动生成快照。                                                                                                                                              |\n\n该块内容位于文档的“服务配置”部分，具体描述了几个服务配置参数及其说明，包括是否加载插件、乐观事务、REST验证和快照间隔。这些参数的配置影响TuGraph服务器的运行方式和功能。"
            },
            {
                "content": "| disable_auth                 | 布尔值                   | 关闭 REST 验证。默认为 false。                                                                                                                                                             |\n| ha_snapshot_interval_s       | 整型                    | 快照间隔（以秒为单位），默认值为 604800。-1表示不自动生成快照。                                                                                                                                              |\n| ha_heartbeat_interval_ms     | 整型                    | 心跳间隔（以毫秒为单位）。 默认值为 1000。                                                                                                                                                          |\n| ha_node_offline_ms           | 整型                    | 心跳超时且节点下线间隔（以毫秒为单位）。默认为 60000。                                                                                                                                                    |\n\n该段内容属于文档中的“服务配置”部分，主要介绍了 TuGraph 服务器的配置参数及其说明，具体涵盖了 REST 验证的关闭、快照间隔、心跳间隔以及节点下线等参数的类型和默认值，为用户在配置服务器时提供了详细参考。"
            },
            {
                "content": "| ha_heartbeat_interval_ms     | 整型                    | 心跳间隔（以毫秒为单位）。 默认值为 1000。                                                                                                                                                          |\n| ha_node_offline_ms           | 整型                    | 心跳超时且节点下线间隔（以毫秒为单位）。默认为 60000。                                                                                                                                                    |\n| ha_node_remove_ms            | 整型                    | 节点被视为完全死亡并从列表中删除的间隔（以毫秒为单位）。默认值为 120000。                                                                                                                                          |\n| ha_first_snapshot_start_time | 字符串                   | 第一次打快照的时间，格式为\"HH:MM:SS\"，表示为在下一个HH:MM:SS时间点第一次打snapshot，以后每ha_snapshot_interval_s秒打一次。默认值为\"\"，表示在0-ha_snapshot_interval_s内的任一时刻随机打第一次snapshot，以后每ha_snapshot_interval_s秒打一次snapshot |\n\n该片段属于文档的“服务配置”部分，具体描述了高可用性（HA）相关的配置参数，包括心跳间隔、节点下线和删除的时间设置，以及首次快照的时间配置。这些参数对于确保TuGraph服务的稳定性和可靠性至关重要。"
            },
            {
                "content": "| ha_node_remove_ms            | 整型                    | 节点被视为完全死亡并从列表中删除的间隔（以毫秒为单位）。默认值为 120000。                                                                                                                                          |\n| ha_first_snapshot_start_time | 字符串                   | 第一次打快照的时间，格式为\"HH:MM:SS\"，表示为在下一个HH:MM:SS时间点第一次打snapshot，以后每ha_snapshot_interval_s秒打一次。默认值为\"\"，表示在0-ha_snapshot_interval_s内的任一时刻随机打第一次snapshot，以后每ha_snapshot_interval_s秒打一次snapshot |\n| enable_ip_check              | 布尔值                   | 允许 IP 白名单，默认值为 false。                                                                                                                                                             |\n| idle_seconds                 | 整型                    | 子进程可以处于空闲状态的最大秒数。 默认值为 600。                                                                                                                                                       |\n\n该块内容位于文档的“服务配置”部分，具体是在“配置参数”表格中，描述了与高可用性（HA）相关的参数及其它服务参数的详细信息，包括节点删除间隔、快照时间、IP白名单设置和子进程空闲时间等。"
            },
            {
                "content": "| enable_ip_check              | 布尔值                   | 允许 IP 白名单，默认值为 false。                                                                                                                                                             |\n| idle_seconds                 | 整型                    | 子进程可以处于空闲状态的最大秒数。 默认值为 600。                                                                                                                                                       |\n| enable_backup_log            | 布尔值                   | 是否启用备份日志记录。 默认值为 false。                                                                                                                                                           |\n| backup_log_dir               | 字符串                   | 存储备份文件的目录。 默认值为空。                                                                                                                                                                 |\n\n该片段位于文档的“服务配置”部分，具体描述了TuGraph服务器的配置参数，包括IP白名单、子进程空闲时间、备份日志启用与否以及备份文件存储目录等设置。这些参数帮助用户优化和管理服务器的运行环境。"
            },
            {
                "content": "| enable_backup_log            | 布尔值                   | 是否启用备份日志记录。 默认值为 false。                                                                                                                                                           |\n| backup_log_dir               | 字符串                   | 存储备份文件的目录。 默认值为空。                                                                                                                                                                 |\n| snapshot_dir                 | 字符串                   | 存储快照文件的目录。 默认值为空。                                                                                                                                                                 |\n| thread_limit                 | 整型                    | 同时使用的最大线程数。 默认值为 0，即不做限制，以 license 为准。                                                                                                                                            |\n\n该块内容位于文档的“服务配置”部分，具体描述了与备份日志、快照文件和线程限制相关的配置参数及其默认值，以帮助用户了解如何设置和管理TuGraph服务器的日志和线程资源。"
            },
            {
                "content": "| snapshot_dir                 | 字符串                   | 存储快照文件的目录。 默认值为空。                                                                                                                                                                 |\n| thread_limit                 | 整型                    | 同时使用的最大线程数。 默认值为 0，即不做限制，以 license 为准。                                                                                                                                            |\n| unlimited_token              | 布尔值                   | 是否将链接token设置为无期限。 默认值为 false，有效期为24小时。                                                                                                                                            |\n| reset_admin_password         | 布尔值                   | 是否重置管理者密码。 默认值为 false。 为 true 时，密码重置为`73@TuGraph`。                                                                                                                                |\n\n该内容块位于文档的“4.1.配置参数”部分，列出了TuGraph服务的几个配置信息，包括快照文件目录、线程数限制、链接token有效期及管理员密码重置设置，并提供了每个参数的类型和默认值说明。"
            },
            {
                "content": "| unlimited_token              | 布尔值                   | 是否将链接token设置为无期限。 默认值为 false，有效期为24小时。                                                                                                                                            |\n| reset_admin_password         | 布尔值                   | 是否重置管理者密码。 默认值为 false。 为 true 时，密码重置为`73@TuGraph`。                                                                                                                                |\n| enable_fulltext_index        | 布尔值                   | 是否启用全文索引功能，默认值为 false。                                                                                                                                                            |\n| fulltext_analyzer            | 字符串                   | 全文索引分词器类型。可设为`StandardAnalyzer`或者`SmartChineseAnalyzer`。默认是`StandardAnalyzer`                                                                                                     |\n\n该代码块位于文档的“4.1.配置参数”部分，列出了与TuGraph服务配置相关的多个参数，主要涉及链接token的有效期、管理员密码的重置、全文索引功能的启用及其分词器类型。这些参数的设置对数据库运行性能和安全性具有重要影响。"
            },
            {
                "content": "| enable_fulltext_index        | 布尔值                   | 是否启用全文索引功能，默认值为 false。                                                                                                                                                            |\n| fulltext_analyzer            | 字符串                   | 全文索引分词器类型。可设为`StandardAnalyzer`或者`SmartChineseAnalyzer`。默认是`StandardAnalyzer`                                                                                                     |\n| fulltext_commit_interval     | 整形                    | 全文索引数据提交周期,针对写操作，单位秒。默认是 0，立即提交。                                                                                                                                                  |\n| fulltext_refresh_interval    | 整形                    | 全文索引数据刷新周期，针对读操作，单位秒。默认是 0，立即可以读到最新写入的数据。                                                                                                                                         |\n\n该段落位于文档的第四部分“服务配置”中，具体介绍了与全文索引相关的配置参数，包括是否启用全文索引、使用的分词器类型、数据提交及刷新周期等设置。这些参数帮助用户优化数据检索能力和提高数据库查询效率。"
            },
            {
                "content": "| fulltext_commit_interval     | 整形                    | 全文索引数据提交周期,针对写操作，单位秒。默认是 0，立即提交。                                                                                                                                                  |\n| fulltext_refresh_interval    | 整形                    | 全文索引数据刷新周期，针对读操作，单位秒。默认是 0，立即可以读到最新写入的数据。                                                                                                                                         |\n| ha_conf                      | 字符串                   | 根据 host1:port1,host2:port2,host3:port3 初始化HA集群，默认值为空。                                                                                                                             |\n| ha_node_join_group_s         | 整形                    | 节点尝试加入高可用集群的等待时长，单位秒，默认是 10。                                                                                                                                                      |\n\n该部分内容位于文档的第四节“服务配置”中，主要描述了TuGraph服务器的配置参数，具体包括全文索引的提交与刷新周期，以及高可用性（HA）集群的初始化和节点加入等待时长等参数。这些参数对于优化数据库的性能和保障系统的高可用性至关重要。"
            },
            {
                "content": "| ha_conf                      | 字符串                   | 根据 host1:port1,host2:port2,host3:port3 初始化HA集群，默认值为空。                                                                                                                             |\n| ha_node_join_group_s         | 整形                    | 节点尝试加入高可用集群的等待时长，单位秒，默认是 10。                                                                                                                                                      |\n| ha_bootstrap_role            | 整形                    | 是否使用bootstrap方式启动，以及使用该方式启动的服务器角色，0代表不使用bootstrap方式启动，1代表使用bootstrap方式启动且本节点为leader，2代表使用bootstrap方式启动且本节点为follower，只有这3种选项。 默认值为 0。                                              |\n| help                         | 布尔值                   | 打印此帮助消息。 默认值为 false。                                                                                                                                                              |\n\n该部分内容位于文档的“4.服务配置”节下，具体介绍了TuGraph服务器配置参数的相关属性，包括高可用性（HA）配置以及帮助信息的设置，旨在帮助用户理解和配置服务器以实现高可用性和快速获取帮助信息。"
            },
            {
                "content": "| ha_bootstrap_role            | 整形                    | 是否使用bootstrap方式启动，以及使用该方式启动的服务器角色，0代表不使用bootstrap方式启动，1代表使用bootstrap方式启动且本节点为leader，2代表使用bootstrap方式启动且本节点为follower，只有这3种选项。 默认值为 0。                                              |\n| help                         | 布尔值                   | 打印此帮助消息。 默认值为 false。                                                                                                                                                              |\n| browser.credential_timeout                         | 整形                    | 浏览器缓存的用户名和密码过期时间。                                                                                                                                                                 |\n| browser.retain_connection_credentials                         | 布尔值                   | 浏览器是否缓存用户名和密码。                                                                                                                                                              |\n表格内容描述:\n\n该chunk位于文档的第4.1节“配置参数”中，具体列出了TuGraph服务的配置信息，包括服务器在使用bootstrap方式启动时的角色设置、帮助信息、浏览器缓存的用户名和密码过期时间等参数的详细描述。此部分旨在帮助用户理解和配置TuGraph数据库的相关参数。"
            },
            {
                "content": "该表格包含三个列名，分别为“参数名”、“参数类型”和“参数说明”。以下是逐行描述的内容：\n\n该段落位于文档关于服务配置的部分，具体描述了TuGraph服务器的配置参数及其详细说明，以帮助用户理解参数的功能和使用方法。"
            },
            {
                "content": "1. **directory**: 字符串类型，表示数据文件所在的目录。如果该目录不存在，则会自动创建。默认目录为 `/var/lib/lgraph/data`。\n2. **durable**: 布尔值类型，指示是否开启实时持久化。关闭持久化可以减少写入时的磁盘 IO 开销，但在极端情况下可能丢失数据。默认值为 `true`。\n3. **host**: 字符串类型，用于REST服务器监听的地址，一般为服务器的IP地址。默认地址为 `0.0.0.0`，在高可用模式下需设置为具体IP地址。\n4. **port**: 整型，REST服务器监听的端口，默认端口为 `7070`。\n5. **enable_rpc**: 布尔值，表示是否使用RPC服务。默认值为 `false`。\n6. **rpc_port**: 整型，RPC及HA服务使用的端口，默认为 `9090`。\n7. **bolt_port**: 整型，Bolt客户端使用的端口，默认为 `7687`。\n8. **enable_ha**: 布尔值，标记是否启动高可用模式。默认值为 `false`。\n9. **ha_log_dir**: 字符串类型，HA日志所在目录，仅在HA模式下需要，默认为空。\n10. **verbose**: 整型，日志输出详细程度，可设置为0、1、2，值越大信息越详细，默认值为 `1`。\n11. **log_dir**: 字符串类型，日志文件所在的目录，默认目录为 `/var/log/lgraph/`。\n12. **ssl_auth**: 布尔值，指示是否使用SSL安全认证，开启后REST服务器只提供HTTPS服务。默认值为 `false`。\n13. **web**: 字符串类型，Web文件的存储位置，默认设置在 `/usr/local/share/lgraph/browser-resource`。\n14. **server_cert**: 字符串类型，在SSL认证开启时使用的证书文件路径，默认路径为 `/usr/local/etc/lgraph/server-cert.pem`。\n15. **server_key**: 字符串类型，在SSL认证开启时使用的公钥文件路径，默认路径为 `/usr/local/etc/lgraph/server-key.pem`。\n\n该部分内容位于文档的“服务配置”章节中，详细列出了TuGraph服务器的配置参数及其类型和说明，包括数据文件目录、持久化设置、服务器监听地址和端口等信息。这些配置参数对服务器的运行和管理至关重要，能够帮助用户正确配置和优化TuGraph服务。"
            },
            {
                "content": "9. **ha_log_dir**: 字符串类型，HA日志所在目录，仅在HA模式下需要，默认为空。\n10. **verbose**: 整型，日志输出详细程度，可设置为0、1、2，值越大信息越详细，默认值为 `1`。\n11. **log_dir**: 字符串类型，日志文件所在的目录，默认目录为 `/var/log/lgraph/`。\n12. **ssl_auth**: 布尔值，指示是否使用SSL安全认证，开启后REST服务器只提供HTTPS服务。默认值为 `false`。\n13. **web**: 字符串类型，Web文件的存储位置，默认设置在 `/usr/local/share/lgraph/browser-resource`。\n14. **server_cert**: 字符串类型，在SSL认证开启时使用的证书文件路径，默认路径为 `/usr/local/etc/lgraph/server-cert.pem`。\n15. **server_key**: 字符串类型，在SSL认证开启时使用的公钥文件路径，默认路径为 `/usr/local/etc/lgraph/server-key.pem`。\n16. **enable_audit_log**: 布尔值，表示是否启用审计日志。默认值为 `false`。\n17. **audit_log_expire**: 整型，审计日志的有效时间（小时），超时后自动清理，值为0表示不清理。默认值为 `0`。\n18. **audit_log_dir**: 字符串类型，审计日志文件的存放目录，默认目录为 `$directory/_audit_log_`。\n19. **load_plugins**: 布尔值，启动服务时导入所有存储过程。默认值为 `true`。\n20. **optimistic_txn**: 布尔值，为Cypher开启乐观多线程写入事务。默认值为 `false`。\n21. **disable_auth**: 布尔值，标记是否关闭REST验证，默认为 `false`。\n22. **ha_snapshot_interval_s**: 整型，快照间隔（以秒为单位），默认值为 `604800`，-1表示不自动生成快照。\n23. **ha_heartbeat_interval_ms**: 整型，心跳间隔（以毫秒为单位）。默认值为 `1000`。\n\n该部分内容位于文档第4章“服务配置”中，专门介绍TuGraph服务器的配置参数，包括HA日志目录、日志详细程度、日志文件存放位置、SSL安全认证、Web文件存储路径、审计日志设置及其他相关参数，帮助用户进行系统配置与管理。"
            },
            {
                "content": "16. **enable_audit_log**: 布尔值，表示是否启用审计日志。默认值为 `false`。\n17. **audit_log_expire**: 整型，审计日志的有效时间（小时），超时后自动清理，值为0表示不清理。默认值为 `0`。\n18. **audit_log_dir**: 字符串类型，审计日志文件的存放目录，默认目录为 `$directory/_audit_log_`。\n19. **load_plugins**: 布尔值，启动服务时导入所有存储过程。默认值为 `true`。\n20. **optimistic_txn**: 布尔值，为Cypher开启乐观多线程写入事务。默认值为 `false`。\n21. **disable_auth**: 布尔值，标记是否关闭REST验证，默认为 `false`。\n22. **ha_snapshot_interval_s**: 整型，快照间隔（以秒为单位），默认值为 `604800`，-1表示不自动生成快照。\n23. **ha_heartbeat_interval_ms**: 整型，心跳间隔（以毫秒为单位）。默认值为 `1000`。\n24. **ha_node_offline_ms**: 整型，心跳超时后节点被标记为下线的间隔（毫秒），默认值为 `60000`。\n25. **ha_node_remove_ms**: 整型，节点完全死亡并从列表中删除的时间间隔（毫秒），默认值为 `120000`。\n26. **ha_first_snapshot_start_time**: 字符串类型，第一次快照的时间格式为“HH:MM:SS”，表示在下一个时间点开始快照。默认值为空。\n27. **enable_ip_check**: 布尔值，允许IP白名单，默认值为 `false`。\n28. **idle_seconds**: 整型，子进程最大空闲时间（秒），默认值为 `600`。\n29. **enable_backup_log**: 布尔值，是否启用备份日志记录，默认值为 `false`。\n30. **backup_log_dir**: 字符串类型，存储备份文件的目录，默认为空。\n31. **snapshot_dir**: 字符串类型，存储快照文件的目录，默认为空。\n32. **thread_limit**: 整型，最大使用线程数，默认值为 `0`，表示不限制。\n\n该块内容位于文档的“服务配置”部分，具体介绍了 TuGraph 服务器的多个配置参数，包括审计日志、插件加载、事务处理、高可用性设置及其他相关选项，旨在帮助用户理解和管理服务器配置。"
            },
            {
                "content": "25. **ha_node_remove_ms**: 整型，节点完全死亡并从列表中删除的时间间隔（毫秒），默认值为 `120000`。\n26. **ha_first_snapshot_start_time**: 字符串类型，第一次快照的时间格式为“HH:MM:SS”，表示在下一个时间点开始快照。默认值为空。\n27. **enable_ip_check**: 布尔值，允许IP白名单，默认值为 `false`。\n28. **idle_seconds**: 整型，子进程最大空闲时间（秒），默认值为 `600`。\n29. **enable_backup_log**: 布尔值，是否启用备份日志记录，默认值为 `false`。\n30. **backup_log_dir**: 字符串类型，存储备份文件的目录，默认为空。\n31. **snapshot_dir**: 字符串类型，存储快照文件的目录，默认为空。\n32. **thread_limit**: 整型，最大使用线程数，默认值为 `0`，表示不限制。\n33. **unlimited_token**: 布尔值，链接token是否设为无期限。默认值为 `false`，有效期为24小时。\n34. **reset_admin_password**: 布尔值，是否重置管理员密码。为 `true`时，密码重置为 `73@TuGraph`。\n35. **enable_fulltext_index**: 布尔值，标记是否启用全文索引功能，默认值为 `false`。\n36. **fulltext_analyzer**: 字符串类型，全文索引分词器类型。默认值为 `StandardAnalyzer`。\n37. **fulltext_commit_interval**: 整型，全文索引数据的提交周期（秒），默认为0，表示立即提交。\n38. **fulltext_refresh_interval**: 整型，全文索引数据的刷新周期（秒），默认为0，表示可以即时读取最新写入的数据。\n39. **ha_conf**: 字符串类型，根据`host1:port1,host2:port2,host3:port3`初始化HA集群，默认为空。\n40. **ha_node_join_group_s**: 整型，节点尝试加入HA集群的等待时长（秒），默认值为 `10`。\n\n该块内容位于文档的“服务配置”部分，具体讨论了TuGraph服务器的配置参数，描述了与高可用性、备份日志、线程限制、链接token有效期等相关的整型和布尔值参数设置。这些参数影响服务器的性能和管理策略，尤其是在高可用性模式下的行为。"
            },
            {
                "content": "34. **reset_admin_password**: 布尔值，是否重置管理员密码。为 `true`时，密码重置为 `73@TuGraph`。\n35. **enable_fulltext_index**: 布尔值，标记是否启用全文索引功能，默认值为 `false`。\n36. **fulltext_analyzer**: 字符串类型，全文索引分词器类型。默认值为 `StandardAnalyzer`。\n37. **fulltext_commit_interval**: 整型，全文索引数据的提交周期（秒），默认为0，表示立即提交。\n38. **fulltext_refresh_interval**: 整型，全文索引数据的刷新周期（秒），默认为0，表示可以即时读取最新写入的数据。\n39. **ha_conf**: 字符串类型，根据`host1:port1,host2:port2,host3:port3`初始化HA集群，默认为空。\n40. **ha_node_join_group_s**: 整型，节点尝试加入HA集群的等待时长（秒），默认值为 `10`。\n41. **ha_bootstrap_role**: 整型，指定是否使用bootstrap方式启动及其角色，默认值为 `0`。\n42. **help**: 布尔值，标记是否打印帮助消息，默认值为 `false`。\n43. **browser.credential_timeout**: 整型，浏览器缓存的用户名和密码的过期时间。\n44. **browser.retain_connection_credentials**: 布尔值，浏览器是否缓存用户名和密码。\n\n该段落位于文档的“4. 服务配置”部分，详细列出了TuGraph服务器的配置参数及其说明，涵盖了重置管理员密码、启用全文索引、全文索引分词器类型设置、快照及群集的配置选项等内容。"
            },
            {
                "content": "整体而言，该表格列出了多项服务参数的名称、类型和详细说明，涉及服务器配置、日志管理、高可用性设置、身份验证、备份策略、全文索引等方面，帮助用户进行系统配置与管理。\n\n### 4.2.服务器配置文件\n\nTuGraph 的配置文件以 JSON 格式存储。建议将大多数配置存储在配置文件中，并且仅在需要时使用命令行选项临时修改某些配置参数。\n一个典型的配置文件如下：\n\n```json\n{\n  \"directory\" : \"/var/lib/lgraph/data\",\n  \"host\" : \"0.0.0.0\",\n  \"port\" : 7070,\n  \"rpc_port\" : 9090,\n  \"enable_rpc\" : true,\n  \"bolt_port\": 7687,\n  \"enable_ha\" : false,\n  \"verbose\" : 1,\n  \"log_dir\" : \"/var/log/lgraph_log\",\n  \"disable_auth\" : false,\n  \"ssl_auth\" : false,\n  \"server_key\" : \"/usr/local/etc/lgraph/server-key.pem\",\n  \"server_cert\" : \"/usr/local/etc/lgraph/server-cert.pem\",\n  \"web\" : \"/usr/local/share/lgraph/browser-resource\"\n}\n```\n\n该段落位于文档的第四部分，主要介绍了TuGraph服务的配置参数和服务器配置文件。具体内容包括服务参数的名称、类型和详细说明，以及如何以JSON格式存储配置文件的示例，旨在指导用户进行系统配置和管理。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_11.md",
        "chunks": [
            {
                "content": "# Heterogeneous Graph\n\n> 本文档介绍如何使用异质图进行训练。\n\n## 1. 异质图简介\n异质图（Heterogeneous Graph）是指由不同类型的节点和边构成的图结构。在异质图中，节点和边可以具有多样化的属性和关系，代表了不同实体以及它们之间的复杂关联。\n\n在异质图中，节点类型可以代表不同的实体，如用户、商品、话题等，而边类型表示不同实体之间的关系，如用户之间的关注关系、用户与商品之间的购买关系等。节点和边可以具有不同的属性。\n\n异质图提供了一种强大的图模型，能够更好地表达和分析具有多种类型实体和复杂关系的现实世界系统。在不同领域的数据分析和应用中，异质图具有广泛的应用前景和研究价值。\n\n## 2. 异质图创建\n在TuGraph中，一个异构图由一系列边关系构成。每个关系由一个字符串三元组定义 (源节点类型, 边类型, 目标节点类型) 。异质图的创建方式与同质图类似，只是在创建图时需要指定字符串三元组定义。如下所示。\n    \n```python\n    olapondb = PyOlapOnDB('Empty', db, txn, [(\"node\", \"edge\", \"node\")])\n```\n其中，第四个参数为异质图的边关系定义，可以通过该参数，指定筛选的异质图点边类型。如果不指定该参数，则默认将全部点边类型的数据进行构图训练。\n\n## 3. 异质图查询接口\n为了方便用户使用，当用户给定第四个参数时，TuGraph提供了查询异质图点边类型的接口。示例如下所示：\n\n### 3.1 点类型查询接口\n```python\nolapondb.ntypes()\n```\n返回值为点类型列表，如['node1', 'node2', 'node3']。\n\n### 3.2 边类型查询接口\n```python\nolapondb.etypes()\n```\n返回值为边类型列表，如['edge1', 'edge2', 'edge3']。\n\n### 3.3 点类型和边类型查询接口\n```python\nolapondb.metagraph()\n```\n返回值为字符串三元组定义 (源节点类型, 边类型, 目标节点类型)，如\n[('node1', 'edge1', 'node2'), ('node2', 'edge2', 'node3')]。\n\n该段落介绍了异质图的基本概念、创建方法和查询接口，属于文档的前半部分，为后续关于异质图输出格式和训练内容奠定基础。"
            },
            {
                "content": "## 3. 异质图查询接口\n为了方便用户使用，当用户给定第四个参数时，TuGraph提供了查询异质图点边类型的接口。示例如下所示：\n\n### 3.1 点类型查询接口\n```python\nolapondb.ntypes()\n```\n返回值为点类型列表，如['node1', 'node2', 'node3']。\n\n### 3.2 边类型查询接口\n```python\nolapondb.etypes()\n```\n返回值为边类型列表，如['edge1', 'edge2', 'edge3']。\n\n### 3.3 点类型和边类型查询接口\n```python\nolapondb.metagraph()\n```\n返回值为字符串三元组定义 (源节点类型, 边类型, 目标节点类型)，如\n[('node1', 'edge1', 'node2'), ('node2', 'edge2', 'node3')]。\n\n## 4. 异质图输出格式\n和同质图相同的是，异质图的采样数据结果也存储在NodeInfo和EdgeInfo中。\n可通过如下方式获取输出数据。\n```python\n    NodeInfo = []\n    EdgeInfo = []\n    getdb.Process(db, olapondb, feature_len, NodeInfo, EdgeInfo)\n```\n其中getdb为获取全图数据的函数，db为图数据库实例，olapondb为图分析类。feature_len为节点特征长度，NodeInfo和EdgeInfo为输出的节点和边信息。\n\n其存储信息结果如下：\n| 图数据 | 存储信息位置 |\n| --- | --- |\n| 边起点 | EdgeInfo[0] |\n| 边终点 | EdgeInfo[1] |\n| 边类型 | EdgeInfo[2] |\n| 顶点ID | NodeInfo[0] |\n| 顶点特征 | NodeInfo[1] |\n| 顶点标签 | NodeInfo[2] |\n| 顶点类型 | NodeInfo[3] |\n表格内容描述: 该表格包含两列，分别为“图数据”和“存储信息位置”。\n\n该块内容主要介绍了异质图查询接口的使用，包括点类型和边类型的查询方法，以及如何获取异质图的输出格式和存储信息位置。这部分内容属于异质图的实用操作指南，有助于用户有效地访问和处理图数据。"
            },
            {
                "content": "其存储信息结果如下：\n| 图数据 | 存储信息位置 |\n| --- | --- |\n| 边起点 | EdgeInfo[0] |\n| 边终点 | EdgeInfo[1] |\n| 边类型 | EdgeInfo[2] |\n| 顶点ID | NodeInfo[0] |\n| 顶点特征 | NodeInfo[1] |\n| 顶点标签 | NodeInfo[2] |\n| 顶点类型 | NodeInfo[3] |\n表格内容描述: 该表格包含两列，分别为“图数据”和“存储信息位置”。\n\n逐行描述表格中的数据内容：\n1. 第一行显示边的起点存储在EdgeInfo[0]。\n2. 第二行显示边的终点存储在EdgeInfo[1]。\n3. 第三行显示边的类型存储在EdgeInfo[2]。\n4. 第四行显示顶点的ID存储在NodeInfo[0]。\n5. 第五行显示顶点的特征存储在NodeInfo[1]。\n6. 第六行显示顶点的标签存储在NodeInfo[2]。\n7. 第七行显示顶点的类型存储在NodeInfo[3]。\n\n总体总结: 表格提供了图数据的不同要素及其对应的存储位置，分别涉及边的起点、终点和类型，以及顶点的ID、特征、标签和类型，为图数据的存储结构提供了清晰的概述。\n\n## 5. 异质图训练\n异构图训练的目标是学习图中节点和边的表示，以便于进行后续的任务，如节点分类、链接预测、图聚类等。为了实现这一目标，研究者们提出了多种基于图神经网络（Graph Neural Networks，GNNs）的模型。这些模型通过聚合邻居节点的信息来更新节点的表示，进而捕捉图结构中的复杂关系。\n\n由于异构图中包含多种类型的节点和边，因此在设计GNN模型时需要考虑如何处理这些不同类型的信息。一种常见的方法是设计不同的聚合函数来分别处理不同类型的邻居节点。此外，还需要考虑如何将这些不同类型的信息整合到一起，以便于模型能够有效地学习到节点和边的表示。\n\nTuGraph 提供了使用裁剪版ogbn-mag数据集进行异质图训练的方法，可供使用者参考。\n\nTuGraph提供的官方docker中暂未提供异质图训练的环境，因此需要用户自行安装相关依赖包。\n在训练之前需要下载ogb和pandas包，具体安装方式如下：\n```shell\npip3 install ogb\npip3 install pandas==0.24.2\n```\n\n训练代码如下所示：\n\n该块内容位于文档的第4部分，详细介绍了异质图的输出格式，包括节点和边的信息存储位置，以及如何通过表格展示图数据的各个要素。这部分内容为后续的异质图训练提供了基础数据结构的理解。"
            },
            {
                "content": "TuGraph提供的官方docker中暂未提供异质图训练的环境，因此需要用户自行安装相关依赖包。\n在训练之前需要下载ogb和pandas包，具体安装方式如下：\n```shell\npip3 install ogb\npip3 install pandas==0.24.2\n```\n\n训练代码如下所示：\n\n```python\ndef train(graph, model, model_save_path):\n    optimizer = torch.optim.Adam(model.parameters(), lr=1e-2, weight_decay=5e-4)\n    model.train()\n    s = time.time()\n    load_time = time.time()\n    graph = dgl.add_self_loop(graph)\n    logits = model(graph, graph.ndata['feat'])\n    loss = loss_fcn(logits, graph.ndata['label'])\n    optimizer.zero_grad()\n    loss.backward()\n    optimizer.step()\n    train_time = time.time()\n    current_loss = float(loss)\n    if model_save_path != \"\":\n        if 'min_loss' not in train.__dict__:\n            train.min_loss = current_loss\n        elif current_loss < train.min_loss:\n            train.min_loss = current_loss\n            model_save_path = 'best_model.pth'\n        torch.save(model.state_dict(), model_save_path)\n    return current_loss\n```\n全部训练代码可参考tugraph/learn/examples/train_full_mag.py文件。\n\n该段落位于文档的\"异质图训练\"部分，主要介绍了在TuGraph中进行异质图训练的环境要求、依赖包的安装方法以及具体的训练代码示例。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_12.md",
        "chunks": [
            {
                "content": "# 场景：流浪地球（基于tugraph-db的产品内置场景上手体验）\n\n> 此文档主要介绍 流浪地球 demo的使用方法。\n\n## 1.Demo场景设计\n\nDemo背景基于流浪地球1、流浪地球2的故事背景进行设计\n\n- 基于剧情，设计了图结构，包含组织、角色、天体与设施3类点，事件、关系两类边\n- 根据剧情准备了对应Schema的数据\n- 准备了一些query，提出一些关于剧情的问题\n\n## 2.使用说明\n\n前置条件：TuGraph已安装\n\n## 3.数据导入\n\n- 手动导入\n  - 数据存放目录：https://github.com/TuGraph-family/tugraph-db-demo （该项目汇集了TuGraph的Demo，每个文件夹为一个能够单独运行的demo，可以在tugraph-db中快速使用。）\n  - 根据数据存放目录对应修改import.json里面的DATA_PATH。\n  - 启动TuGraph服务后，访问${HOST_IP}:7070，打开web页面，确认数据是否导入成功。\n- 自动创建\n    - 点击`新建图项目`，选择流浪地球数据，填写图项目配置，系统会自动完成流浪地球场景图项目创建。\n\n## 4.Cypher查询\n\n参考cypher文档，在TuGraph的Web页面前端输入Cypher进行查询\n\n## 5.使用展示\n\n### 5.1.数据导入的展示\n\n### 5.2.查询展示\n查询木星危机的所有事件经过\n\n```\nMATCH (n)-[e:事件关系]-(m) where e.title='木星危机' RETURN n,e\n```\n\n查询所以危机的相关事件经过\n\n```cypher\nMATCH (n)-[e1]-(m)-[e2]-(p)\nwhere e1.title REGEXP \".*危机\" and e2.title REGEXP \".*危机\" and e1.title <> e2.title\nRETURN n,e1,e2,p\n```\n\n该文本块是关于流浪地球（基于tugraph-db的产品内置场景上手体验）文档的开头部分，介绍了Demo的设计背景、使用说明、数据导入方法以及Cypher查询的基本信息。这部分内容为用户提供了如何使用TuGraph进行场景体验的初步指导。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_13.md",
        "chunks": [
            {
                "content": "# 如何贡献\n\n## 1. 前言\n感谢您为TuGraph做出贡献，我们由衷地希望有更多社区的同学加入进来，一起建设一个更好的图数据库项目。\n\n对于优秀社区贡献者，我们将颁发TuGraph优秀社区贡献者证书。\n\n## 2. 贡献什么\n我们随时都欢迎任何贡献，无论是简单的错别字修正，BUG 修复还是增加新功能。请踊跃提出问题或发起 PR。我们同样重视文档以及与其它开源项目的整合，欢迎在这方面做出贡献。\n对于任何修改，尤其是较为复杂的修改，建议新建一个issue ，按照BUG或者PR的模板填写。\n\n## 3. 准备工作\n\n### 3.1. 了解TuGraph\n\n建议您从文档地图开始，了解TuGraph的特性和接口。\n\n### 3.2. 准备环境\n\n对于文档贡献，可以直接通过[文档](https://tugraph-db.readthedocs.io/zh_CN/latest)，点击右上角的\"在GitHub上编译\"直接修改并提PR。\n\n对于代码贡献，通常需要在搭建编译执行的环境，可以采用Docker部署或本地部署。\n\n### 3.3. 许可协议\n\n在贡献代码之前，请您稍微花一些时间了解为TuGraph贡献代码的流程，并阅读 个人贡献者许可协议 或 公司贡献者许可协议，参与贡献则视为同意上述协议。\n\n## 4. 贡献代码流程\n### 4.1. 提交issue\n不论您是修复 TuGraph 的 bug 还是新增 TuGraph 的功能，在您提交代码之前，请在 TuGraph 的 GitHub 上提交一个 issue，描述您要修复的问题或者要增加的功能。这么做有几个好处:\n\n- 不会与其它开发者或是他们对这个项目的计划发生冲突，产生重复工作。\n- TuGraph 的维护人员会对您提的 bug 或者新增功能进行相关讨论，确定该修改是不是必要，有没有提升的空间或更好的办法。\n- 在达成一致后再开发，并提交代码，减少双方沟通成本，也减少 pull request 被拒绝的情况。\n### 4.2. 获取源码\n要修改或新增功能，在提交 issue 后，fork一份 TuGraph  Master代码到您的代码仓库。\n### 4.3. 拉分支\nTuGraph 所有修改都在分支上进行，修改完成后提交 pull request，在 Code Review 后由项目维护人员 Merge 到 Master。 因此，在获取源码步骤介绍后，您需要:\n\n该内容为TuGraph的贡献指南，介绍了如何参与项目，包括贡献方式、准备工作、提交代码流程等，旨在引导社区成员有效贡献代码和文档。"
            },
            {
                "content": "## 4. 贡献代码流程\n### 4.1. 提交issue\n不论您是修复 TuGraph 的 bug 还是新增 TuGraph 的功能，在您提交代码之前，请在 TuGraph 的 GitHub 上提交一个 issue，描述您要修复的问题或者要增加的功能。这么做有几个好处:\n\n- 不会与其它开发者或是他们对这个项目的计划发生冲突，产生重复工作。\n- TuGraph 的维护人员会对您提的 bug 或者新增功能进行相关讨论，确定该修改是不是必要，有没有提升的空间或更好的办法。\n- 在达成一致后再开发，并提交代码，减少双方沟通成本，也减少 pull request 被拒绝的情况。\n### 4.2. 获取源码\n要修改或新增功能，在提交 issue 后，fork一份 TuGraph  Master代码到您的代码仓库。\n### 4.3. 拉分支\nTuGraph 所有修改都在分支上进行，修改完成后提交 pull request，在 Code Review 后由项目维护人员 Merge 到 Master。 因此，在获取源码步骤介绍后，您需要:\n\n1. 下载代码到本地，这一步您可以选择git/https方式，近年github的权限要求更加严格，比如git方式需要更复杂的ssh key(https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent)，https方式不能直接使用用户名密码验证，请按照指引授权。 git clone https://github.com/您的账号名/tugraph-db\n2. 拉分支准备修改代码:\ngit branch add_xxx_feature \n3. 执行完上述命令后，您的代码仓库就切换到相应分支了。执行如下命令可以看到您当前分支: git branch -a \n4. 如果您想切换回 Master，执行下面命令: git checkout -b master\n5. 如果您想切换回分支，执行下面命令: git checkout -b \"branchName\"\n\n### 4.4. 编译运行\n\n本文件是关于如何为TuGraph图数据库项目做出贡献的指南，其中包含贡献的前言、贡献内容、准备工作和具体的代码贡献流程。该段落主要描述贡献代码的具体步骤，包括提交issue、获取源码、拉分支以及编译运行的操作，为希望参与项目开发的贡献者提供详细的指引。"
            },
            {
                "content": "1. 下载代码到本地，这一步您可以选择git/https方式，近年github的权限要求更加严格，比如git方式需要更复杂的ssh key(https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent)，https方式不能直接使用用户名密码验证，请按照指引授权。 git clone https://github.com/您的账号名/tugraph-db\n2. 拉分支准备修改代码:\ngit branch add_xxx_feature \n3. 执行完上述命令后，您的代码仓库就切换到相应分支了。执行如下命令可以看到您当前分支: git branch -a \n4. 如果您想切换回 Master，执行下面命令: git checkout -b master\n5. 如果您想切换回分支，执行下面命令: git checkout -b \"branchName\"\n\n### 4.4. 编译运行\n\n代码的编译运行流程可以参考[ci脚本](https://github.com/TuGraph-family/tugraph-db/blob/master/ci/github_ci.sh)：\n\n```sh\n#!/bin/bash\nset -e\n\nASAN=$1\nTEST=$2\nWITH_PROCEDURE=${3:-\"OFF\"}\n\ncd $WORKSPACE\n\n# cpplint check\nbash ./cpplint/doc_gen.sh\nbash ./cpplint/check_all.sh\n\n# build deps\ncd deps\nbash ./build_deps.sh -j2\n\n该段落位于文档的“4. 贡献代码流程”部分，具体是描述如何获取源码和准备进行代码修改的步骤，包括下载代码到本地、拉分支以及切换分支的操作。同时，接下来介绍了代码的编译运行流程，为后续贡献代码提供了必要的技术支持。"
            },
            {
                "content": "### 4.4. 编译运行\n\n代码的编译运行流程可以参考[ci脚本](https://github.com/TuGraph-family/tugraph-db/blob/master/ci/github_ci.sh)：\n\n```sh\n#!/bin/bash\nset -e\n\nASAN=$1\nTEST=$2\nWITH_PROCEDURE=${3:-\"OFF\"}\n\ncd $WORKSPACE\n\n# cpplint check\nbash ./cpplint/doc_gen.sh\nbash ./cpplint/check_all.sh\n\n# build deps\ncd deps\nbash ./build_deps.sh -j2\n\n# build tugraph\ncd $WORKSPACE\nmkdir build && cd build\nif [[ \"$ASAN\" == \"asan\" ]]; then\necho 'build with asan ...'\ncmake .. -DCMAKE_BUILD_TYPE=Debug -DENABLE_ASAN=ON -DBUILD_PROCEDURE=$WITH_PROCEDURE\nelse\ncmake .. -DCMAKE_BUILD_TYPE=Coverage -DBUILD_PROCEDURE=$WITH_PROCEDURE\nfi\nmake -j2\n\nif [[ \"$TEST\" == \"ut\" ]]; then\n  # build tugraph db management\n  #cd $WORKSPACE/deps/tugraph-db-management/\n  #sh local_build.sh\n  #cp target/tugraph-db-management-*.jar $WORKSPACE/build/output/\n\n该文本块位于文档的第4节“贡献代码流程”下，具体是4.4节“编译运行”。它详细说明了如何编译和运行TuGraph项目的代码，包括脚本的使用和环境配置的步骤，对于希望为TuGraph贡献代码的开发者尤为重要。"
            },
            {
                "content": "# unittest\n  mkdir -p $WORKSPACE/testresult/gtest/\n  cd $WORKSPACE/build/output\n  ln -s ../../test/integration/data ./\n  OMP_NUM_THREADS=2 ./fma_unit_test -t all\n  if [[ \"$ASAN\" == \"asan\" ]]; then\n    export LSAN_OPTIONS=suppressions=$WORKSPACE/test/asan.suppress\n  else\n    export LD_PRELOAD=$WORKSPACE/build/output/liblgraph.so\n  fi\n  OMP_NUM_THREADS=2 ./unit_test --gtest_output=xml:$WORKSPACE/testresult/gtest/\n  rm -rf testdb* .import_tmp\n  if [[ \"$ASAN\" == \"asan\" ]]; then\n    exit 0\n  fi\n  # codecov\n  cd $WORKSPACE\n  bash ./ci/codecov.sh $WORKSPACE/build $WORKSPACE/testresult\n  # Uploading report to CodeCov\n  bash <(curl -s https://codecov.io/bash) -f $WORKSPACE/testresult/coverage.info -t $CODECOV_TOKEN || echo \"Codecov did not collect coverage reports\"\n  python3  ./ci/lcov_cobertura.py $WORKSPACE/testresult/coverage.info --output $WORKSPACE/testresult/coverage.xml --demangle\nelse\n  # build java client\n  #cd $WORKSPACE/deps/tugraph-db-client-java/\n  #sh local_build.sh\n\n该段落位于文档的第四部分“贡献代码流程”的“4.4. 编译运行”小节中，主要描述了如何执行单元测试以及相关的代码覆盖率报告生成步骤。它提供了具体的命令和流程，以确保对TuGraph源代码的修改经过严格的测试和验证。"
            },
            {
                "content": "exit 0\n  fi\n  # codecov\n  cd $WORKSPACE\n  bash ./ci/codecov.sh $WORKSPACE/build $WORKSPACE/testresult\n  # Uploading report to CodeCov\n  bash <(curl -s https://codecov.io/bash) -f $WORKSPACE/testresult/coverage.info -t $CODECOV_TOKEN || echo \"Codecov did not collect coverage reports\"\n  python3  ./ci/lcov_cobertura.py $WORKSPACE/testresult/coverage.info --output $WORKSPACE/testresult/coverage.xml --demangle\nelse\n  # build java client\n  #cd $WORKSPACE/deps/tugraph-db-client-java/\n  #sh local_build.sh\n  #cp rpc-client-test/target/tugraph-db-java-rpc-client-test-*.jar $WORKSPACE/build/output/\n  #cp ogm/tugraph-db-ogm-test/target/tugraph-db-ogm-test-*.jar $WORKSPACE/build/output/\n\n该代码块位于文档的第4.4节“编译运行”中，具体描述了在编译和运行TuGraph时的操作，包括生成代码覆盖率报告的步骤。在此之前，还涉及了如何编译代码和进行单元测试的相关内容。"
            },
            {
                "content": "# build cpp client test\n  export LD_PRELOAD=$WORKSPACE/build/output/liblgraph.so\n  cd $WORKSPACE/test/test_rpc_client\n  sh ./cpp/CppClientTest/compile.sh\n  cp -r ./cpp/CppClientTest/build/clienttest $WORKSPACE/build/output/\n\n  #cd $WORKSPACE/src/client/python/TuGraphClient\n  # install TuGraphClient\n  #python3 setup.py install\n  # run TuGraphClient unit_tests\n  #python3 setup.py test\n\n该段落位于文档的“4.4. 编译运行”部分，主要介绍如何构建和测试TuGraph的C++客户端，包括设置环境变量、编译测试程序及其他相关操作。"
            },
            {
                "content": "#cd $WORKSPACE/src/client/python/TuGraphClient\n  # install TuGraphClient\n  #python3 setup.py install\n  # run TuGraphClient unit_tests\n  #python3 setup.py test\n\n  # integrate tests\n  cd $WORKSPACE/build/output\n  cp ../../src/client/python/TuGraphClient/TuGraphClient.py .\n  cp ../../src/client/python/TuGraphClient/TuGraphRestClient.py .\n  cp -r ../../test/integration/* ./\n  cp -r ../../learn/examples/* ./\n  cp -r ../../demo/movie .\n  if [[ \"$WITH_PROCEDURE\" == \"OFF\" ]]; then\n      rm -rf test_algo.py test_sampling.py test_train.py test_algo_v2.py\n  fi\n  pytest ./\n  # codecov\n  cd $WORKSPACE\n  mkdir testresult\n  bash ./ci/codecov.sh $WORKSPACE/build $WORKSPACE/testresult\n  # Uploading report to CodeCov\n  bash <(curl -s https://codecov.io/bash) -f $WORKSPACE/testresult/coverage.info -t $CODECOV_TOKEN || echo \"Codecov did not collect coverage reports\"\n  python3  ./ci/lcov_cobertura.py $WORKSPACE/testresult/coverage.info --output $WORKSPACE/testresult/coverage.xml --demangle\nfi\n```\n\n该代码块位于文档的第4.4节“编译运行”中，具体描述了如何在构建完成后安装并运行TuGraphClient、进行集成测试，以及生成测试覆盖率报告的步骤。"
            },
            {
                "content": "### 4.5. 配置 Github 信息\n在您的机器执行 git config  --list ，查看 git 的全局用户名和邮箱。检查显示的 user.name 和 user.email 是不是与自己 github 的用户名和邮箱相匹配。\n\n如果公司内部有自己的 gitlab 或者使用了其他商业化的 gitlab，则可能会出现不匹配的情况。这时候，您需要为 TuGraph DB 项目单独设置用户名和邮箱。设置用户名和邮箱的方式请参考 github 官方文档。\n\n### 4.6. 修改代码提交到本地\n\n拉完分支后，就可以修改代码了。\n\n**修改代码注意事项 **\n\n代码⻛格保持一致：TuGraph 通过 cpplint 来保持代码格式一致，IDE可以通过.clang来配置风格。在提交代码前，务必本地检查代码风格，否则ACI将报错。\n\n补充单元测试代码：新有修改应该通过已有的单元测试,应该提供新的单元测试来证明以前的代码存在 bug，而新的代码已经解决了这些 bug ,您可以用如下命令运行所有测试: ./unit_test\n也可以通过IDE来辅助运行。\n\n**其它注意事项 **\n\n请保持您编辑的代码的原有⻛格，尤其是空格、换行等。 对于无用的注释，请直接删除。 对逻辑和功能不容易被理解的地方添加注释。 及时更新文档。 修改完代码后，请按照如下格式执行命令提交所有的修改到本地:\ngit commit -am '(feat) 添加xx功能' git commit -am '(fix) 修复xx问题'`\n\n### 4.7. 提交代码到远程仓库\n在代码提交到本地后，接下来就可以与远程仓库同步代码了，执行如下命令提交本地修改到 github 上: git push origin \"branchname\"\n\n如果前面您是通过 fork 来做的，那么这里的 origin 是 push 到您的代码仓库，而不是 TuGraph 的代码仓库。\n\n该段落位于文档的第4部分，主要讲述了贡献代码的流程，包括如何配置GitHub信息、修改代码的注意事项及提交代码到远程仓库的步骤，旨在指导贡献者顺利进行代码修改与提交。"
            },
            {
                "content": "补充单元测试代码：新有修改应该通过已有的单元测试,应该提供新的单元测试来证明以前的代码存在 bug，而新的代码已经解决了这些 bug ,您可以用如下命令运行所有测试: ./unit_test\n也可以通过IDE来辅助运行。\n\n**其它注意事项 **\n\n请保持您编辑的代码的原有⻛格，尤其是空格、换行等。 对于无用的注释，请直接删除。 对逻辑和功能不容易被理解的地方添加注释。 及时更新文档。 修改完代码后，请按照如下格式执行命令提交所有的修改到本地:\ngit commit -am '(feat) 添加xx功能' git commit -am '(fix) 修复xx问题'`\n\n### 4.7. 提交代码到远程仓库\n在代码提交到本地后，接下来就可以与远程仓库同步代码了，执行如下命令提交本地修改到 github 上: git push origin \"branchname\"\n\n如果前面您是通过 fork 来做的，那么这里的 origin 是 push 到您的代码仓库，而不是 TuGraph 的代码仓库。\n\n提交合并代码到 Master 的请求 在的代码提交到 GitHub 后，您就可以发送请求来把您改好的代码合入 TuGraph Master 代码了。此时您需要进入您在 GitHub 上的对应仓库，按右上⻆的 pull request 按钮。选择目标分支，一般就是 master，系统会通知 TuGraph 的人员， TuGraph 人员会 Review 您的代码，符合要求后就会合入主干，成为 TuGraph 的一部分。 \n\n请注意会自动检查CI，以及所有Commits中的贡献者是否签署了cla，通过后会有绿色的标识。\n\n### 4.8. 代码 Review\n\n在您提交代码后，您的代码会被指派给维护人员 Review，请耐心等待。如果两个工作日后，仍然没有人对您的提交给予任何回复，可以在 PR 下面留言，并 @ 对应的人员。\n\n对于代码 Review 的意⻅会直接备注到到对应 PR 或者 Issue。如果觉得建议是合理的，也请您把这些建议更新到您的代码中。\n\n### 4.9. 合并代码到Master\n\n在代码 Review 通过后，就由 TuGraph 维护人员操作合入 Master，在此过程中维护人员可能会指定新的Reviewer，提出新的意见需要修改。一般这一步不用参与，代码合并之后，您会收到合并成功的提示。\n\n该片段位于文档的第4节“贡献代码流程”，主要讨论了提交代码时需要补充单元测试的重要性、代码修改的注意事项，以及代码提交到远程仓库的具体操作和后续的代码审查流程。这部分内容为开发者提供了清晰的指导，以确保代码贡献的质量和规范性。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_14.md",
        "chunks": [
            {
                "content": "# TuGraph console client（console client 使用介绍）\n\n`lgraph_cli` 是基于bolt协议的 console client，c++编写，使用时需要连接tugraph的bolt端口。\n\n`lgraph_cli` 是一个二进制的可执行文件，不依赖其他动态库，拷贝到一台linux机器上就可执行。\n\n## `lgraph_cli`使用\n\n语句以分号结束，输入`exit`, `quit`或者Ctrl-C退出客户端。\n\n```powershell\nlgraph_cli --ip 127.0.0.1 --port 7687 --graph default --user admin --password 73@TuGraph\n\nWelcome to the TuGraph console client. Commands end with ';'.\nCopyright(C) 2018-2023 Ant Group. All rights reserved.\nType 'exit', 'quit' or Ctrl-C to exit.\n\n该段落是文档的开头部分，介绍了TuGraph控制台客户端`lgraph_cli`的基本信息，包括其功能、使用方法以及连接参数的示例。"
            },
            {
                "content": "语句以分号结束，输入`exit`, `quit`或者Ctrl-C退出客户端。\n\n```powershell\nlgraph_cli --ip 127.0.0.1 --port 7687 --graph default --user admin --password 73@TuGraph\n\nWelcome to the TuGraph console client. Commands end with ';'.\nCopyright(C) 2018-2023 Ant Group. All rights reserved.\nType 'exit', 'quit' or Ctrl-C to exit.\n\nTuGraph> match(n) return n limit 1;\n+-------------------------------------------------------------------------------------------------------------------------------------+\n| n                                                                                                                                   |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n| (:person {id:2,born:1961,poster_image:\"https://image.tmdb.org/t/p/w185/mh0lZ1XsT84FayMNiT6Erh91mVu.jpg\",name:\"Laurence Fishburne\"}) |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n\n该片段提供了使用`lgraph_cli`命令行客户端连接到TuGraph数据库的基本操作说明，包括输入语句格式及结束指令，展示了如何执行一条查询命令并显示结果。这部分内容位于文档的开头，旨在帮助用户快速上手使用该客户端。"
            },
            {
                "content": "TuGraph>\n```\n\n语句可以中间换行，多行输入。\n\n```powershell\nTuGraph> match(n)\n      -> return n\n      -> limit 1;\n+-------------------------------------------------------------------------------------------------------------------------------------+\n| n                                                                                                                                   |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n| (:person {id:2,born:1961,poster_image:\"https://image.tmdb.org/t/p/w185/mh0lZ1XsT84FayMNiT6Erh91mVu.jpg\",name:\"Laurence Fishburne\"}) |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n\nTuGraph>\n```\n\n非交互式\n```powershell\n\n该片段展示了如何在TuGraph控制客户端中输入多行查询语句，并提供了示例输出。此部分属于`lgraph_cli`使用指南的一部分，主要介绍了交互式输入的特性。"
            },
            {
                "content": "TuGraph>\n```\n\n非交互式\n```powershell\n\necho \"match(n) return n limit 1;\" | lgraph_cli --ip 127.0.0.1 --port 7687 --graph default --user admin --password 73@TuGraph\n+-------------------------------------------------------------------------------------------------------------------------------------+\n| n                                                                                                                                   |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n| (:person {id:2,born:1961,poster_image:\"https://image.tmdb.org/t/p/w185/mh0lZ1XsT84FayMNiT6Erh91mVu.jpg\",name:\"Laurence Fishburne\"}) |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n1 rows\n\n```\n\n从文件读取多条命令\n\n```powershell\n\ncat query.txt\nmatch(n) return n limit 1;\nmatch(n) return n limit 1;\n\n该片段位于文档中“非交互式”使用`lgraph_cli`命令的部分，主要介绍如何通过命令行输入和文件读取形式执行多条查询语句并显示返回结果。"
            },
            {
                "content": "lgraph_cli --ip 127.0.0.1 --port 7687 --graph default --user admin --password 73@TuGraph < query.txt\n+-------------------------------------------------------------------------------------------------------------------------------------+\n| n                                                                                                                                   |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n| (:person {id:2,born:1961,poster_image:\"https://image.tmdb.org/t/p/w185/mh0lZ1XsT84FayMNiT6Erh91mVu.jpg\",name:\"Laurence Fishburne\"}) |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n| (:person {id:3,born:1967,poster_image:\"https://image.tmdb.org/t/p/w185/8iATAc5z5XOKFFARLsvaawa8MTY.jpg\",name:\"Carrie-Anne Moss\"})   |\n\n该片段展示了如何通过 `lgraph_cli` 从文件中读取多条查询命令并执行，从而获取数据库中与人物相关的记录，具体包含了两位角色的详细信息和属性。"
            },
            {
                "content": "| (:person {id:2,born:1961,poster_image:\"https://image.tmdb.org/t/p/w185/mh0lZ1XsT84FayMNiT6Erh91mVu.jpg\",name:\"Laurence Fishburne\"}) |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n| (:person {id:3,born:1967,poster_image:\"https://image.tmdb.org/t/p/w185/8iATAc5z5XOKFFARLsvaawa8MTY.jpg\",name:\"Carrie-Anne Moss\"})   |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n2 rows\n\n该段落展示了通过 `lgraph_cli` 查询数据库得到的结果，包括两个人物的信息及其属性，如ID、出生年份和海报图像链接。这是使用 `lgraph_cli` 工具进行交互式查询或通过文件批量执行命令后获取的数据输出示例。"
            },
            {
                "content": "+-------------------------------------------------------------------------------------------------------------------------------------+\n| n                                                                                                                                   |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n| (:person {id:2,born:1961,poster_image:\"https://image.tmdb.org/t/p/w185/mh0lZ1XsT84FayMNiT6Erh91mVu.jpg\",name:\"Laurence Fishburne\"}) |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n| (:person {id:3,born:1967,poster_image:\"https://image.tmdb.org/t/p/w185/8iATAc5z5XOKFFARLsvaawa8MTY.jpg\",name:\"Carrie-Anne Moss\"})   |\n+-------------------------------------------------------------------------------------------------------------------------------------+\n2 rows\n```\n\n## 在线数据导出\n\n该段落位于文档的“从文件读取多条命令”部分之后，展示了通过 `lgraph_cli` 执行多个查询命令后返回的结果，描述了查询结果包含的两个角色及其相关信息。"
            },
            {
                "content": "## 在线数据导出\n\nlgraph_cli 支持流式读取，导出数据只需要把lgraph_cli的输出重定向到文件中即可，导出格式支持csv和json。\n\n### csv格式\n\n```powershell\n\necho \"match(n) return n.id, n.name;\" | lgraph_cli --ip 127.0.0.1 --port 7687 --graph default --user admin --password 73@TuGraph --format csv > output.txt\n\n```\n\n### json格式\n\n```powershell\n\necho \"match(n) return n.id, n.name;\" | lgraph_cli --ip 127.0.0.1 --port 7687 --graph default --user admin --password 73@TuGraph --format json > output.txt\n\n```\n\n该chunk位于文档的\"lgraph_cli使用\"部分，专门介绍了如何使用lgraph_cli命令行工具进行在线数据导出的功能，包括导出为csv和json格式的示例。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_15.md",
        "chunks": [
            {
                "content": "# Bolt客户端（bolt driver 使用介绍）\n\nTuGraph目前兼容了Neo4j的Bolt协议，可以直接使用Neo4j的客户端访问TuGraph。（通过客户端访问TuGraph）\n\n## 开启Bolt端口\n\nBolt端口是默认开启的，默认端口是7687。如果需要修改端口，请在配置文件中自行修改。基于docker方式部署的服务，配置文件在容器内 `/usr/local/etc/lgraph.json`文件中；如果是用rpm包部署的服务，配置文件在服务器的`/usr/local/etc/lgraph.json`。 修改端口后为了使端口生效，需要重启服务。\n\n## 使用示例\n\n添加Maven依赖\n\n```xml\n\norg.neo4j.driver\nneo4j-java-driver\n4.4.2\n\n```\nClient按照如下格式进行实例化:\n\n```java\n    Driver driver = GraphDatabase.driver(\"bolt://ip:port\", AuthTokens.basic(\"admin\", \"73@TuGraph\"));\n```\n\n常用语句\n\n该文档介绍了TuGraph的Bolt客户端使用方法，包括Bolt端口的开启、Maven依赖的添加以及如何实例化客户端和执行常用的Cypher语句。此处的内容主要聚焦于Bolt协议的支持及基本操作示例。"
            },
            {
                "content": "```java\n        //通过 driver 对象创建一个 Session，设置会话连接到特定的数据库，用于执行Cypher语句\n        Session session = driver.session(SessionConfig.forDatabase(\"default\"));\n        //清空图项目，请不要轻易尝试，它会清空你选中的图项目的模型以及数据\n        session.run(\"CALL db.dropDB()\");\n        //创建点模型\n        session.run(\"CALL db.createVertexLabel('person', 'id' , 'id' ,INT32, false, 'name' ,STRING, false)\");\n        //创建边模型\n        session.run(\"CALL db.createEdgeLabel('is_friend','[[\\\"person\\\",\\\"person\\\"]]')\");\n        //创建索引\n        session.run(\"CALL db.addIndex(\\\"person\\\", \\\"name\\\", false)\");\n        //插入点数据\n        session.run(\"create (n1:person {name:'jack',id:1}), (n2:person {name:'lucy',id:2})\");\n        //插入边数据\n        session.run(\"match (n1:person {id:1}), (n2:person {id:2}) create (n1)-[r:is_friend]->(n2)\");\n        //查询点和边\n        Result res = session.run(\"match (n)-[r]->(m) return n,r,m\");\n        //Parameterized Query\n        String cypherQuery = \"MATCH (n1:person {id:$id})-[r]-(n2:person {name:$name}) RETURN n1, r, n2\";\n\n该代码块位于文档的“使用示例”部分，展示了如何通过Bolt驱动创建会话并执行一系列Cypher语句，包括清空图项目、创建模型、插入数据、查询数据和使用参数化查询。"
            },
            {
                "content": "//插入点数据\n        session.run(\"create (n1:person {name:'jack',id:1}), (n2:person {name:'lucy',id:2})\");\n        //插入边数据\n        session.run(\"match (n1:person {id:1}), (n2:person {id:2}) create (n1)-[r:is_friend]->(n2)\");\n        //查询点和边\n        Result res = session.run(\"match (n)-[r]->(m) return n,r,m\");\n        //Parameterized Query\n        String cypherQuery = \"MATCH (n1:person {id:$id})-[r]-(n2:person {name:$name}) RETURN n1, r, n2\";\n        Result result1 = session.run(cypherQuery, parameters(\"id\", 1, \"name\", \"lucy\"));\n        while (result1.hasNext()) {\n        Record record = result1.next();\n        System.out.println(\"n1: \" + record.get(\"n1\").asMap());\n        System.out.println(\"r: \" + record.get(\"r\").asMap());\n        System.out.println(\"n2: \" + record.get(\"n2\").asMap());\n                }\n        //删除点数据\n        session.run(\"match (n1:person {id:1}) delete n1\");\n        //删除边数据\n        session.run(\"match (n1:person {id:1})-[r]-(n2:person{id:2}) delete r\");\n        //删除边模型\n\n该代码块位于文档的使用示例部分，主要展示了如何通过Bolt客户端在TuGraph中插入点和边数据，执行查询，并展示查询结果，同时还包括删除点和边数据的操作。这部分示例代码提供了具体的操作流程，帮助用户理解如何使用Bolt协议与TuGraph交互。"
            },
            {
                "content": "while (result1.hasNext()) {\n        Record record = result1.next();\n        System.out.println(\"n1: \" + record.get(\"n1\").asMap());\n        System.out.println(\"r: \" + record.get(\"r\").asMap());\n        System.out.println(\"n2: \" + record.get(\"n2\").asMap());\n                }\n        //删除点数据\n        session.run(\"match (n1:person {id:1}) delete n1\");\n        //删除边数据\n        session.run(\"match (n1:person {id:1})-[r]-(n2:person{id:2}) delete r\");\n        //删除边模型\n        session.run(\"CALL db.deleteLabel('edge', 'is_friend')\");\n        //删除点模型\n        session.run(\"CALL db.deleteLabel('vertex', 'person')\");\n```\n\n该代码片段位于文档的“常用语句”部分，展示了如何使用TuGraph通过Neo4j的Bolt协议执行查询和删除操作，包括查询点和边数据、删除点数据、删除边数据以及删除模型。"
            },
            {
                "content": "## Neo4j客户端使用限制\n\n目前，我们的系统尚未全面兼容Neo4j Bolt协议的所有高级特性。特别地，对于Neo4j客户端所具备的即时事务处理功能及弱schema灵活性这两项独特能力，当前尚不提供支持。因此，在采用客户端进行操作时，请务必留意规避涉及此类特性的操作，以确保应用的顺畅运行与数据的一致性。\n\n## 客户端示例\n\n在代码目录中的demo/Bolt下面有Golang、Java、JavaScript、Python、Rust 这几个语言的的例子。想要了解更多可见客户端示例(https://github.com/TuGraph-family/tugraph-db/tree/master/demo)\n\n该块内容位于文档的后半部分，主要讨论TuGraph在使用Neo4j客户端时的限制以及相关的客户端示例代码，旨在提醒用户注意当前系统对Neo4j Bolt协议高级特性的支持情况。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_16.md",
        "chunks": [
            {
                "content": "# OlapBase API\n\n> 此文档主要详细介绍了OlapBase API的使用说明\n\n\n## 1. 概述\n\n本手册将介绍使用TuGraph图计算系统需要的简单配置，同时结合代码对TuGraph中几个共同的重要文件和接口进行解释。\n\n## 2. 配置要求\n\n如果要使用TuGraph图计算编写以及编译自己的应用程序，需要的配置要求为：\n\n- linux操作系统，目前在Ubuntu16.04, Ubuntu18.04, Ubuntu20.04和Centos7, Centos8系统上可成功运行。\n- 支持C++17的编译器，要求GCC版本为8.4.0或更新的版本。\n\n## 3. 原子操作\n\nTuGraph使用了多线程技术进行批处理操作，在这种情况下可能会出现访存冲突现象。为了保证并行计算时修改操作的正确性，TuGraph实现了原子操作。代码部分见lgraph文件夹下的lgraph_atomic.cpp文件。\nTuGraph还自定义了4个常用的原子操作。当我们需要在多线程模式下修改点的数据时，我们都应该使用原子操作来确保并行环境下修改操作的正确性。除了这4个原子操作外，用户也可以使用“cas”来构建自己的原子操作函数。\n\n- `bool cas(T * ptr, T oldv, T newv)`：如果ptr指向的值等于oldv，则将ptr指向的值赋为newv并返回true，否则返回false\n- `bool write_min(T *a, T b)`：如果b比a指向的值更小，那么将a指向的值赋为b并返回true，否则返回false。\n- `bool write_max(T *a, T b)`：如果b比a指向的值更大，那么将a指向的值赋为b并返回true，否则返回false。\n- `void write_add(T *a, T b)`：将b的值加到a指向的值上。\n- `void write_sub(T *a, T b)`：将a指向的值减去b的值。\n\n## 4. 点集合类ParallelBitset\n\n在使用TuGraph进行批处理操作时，需要使用点集合来表示需要处理的点。ParallelBitset实现了点集合类，以bit为单位表示点，因此能够节省大量内存。对应的代码见lgraph文件夹下的olap_base.h文件。\n\n### 4.1 ParallelBitset类成员\n\n本段落为OlapBase API文档的开头部分，主要介绍了TuGraph图计算系统的概述、配置要求、原子操作以及点集合类ParallelBitset的基本信息。这为后续的内容提供了背景和基础知识，方便用户理解后续的接口和功能。"
            },
            {
                "content": "- `bool cas(T * ptr, T oldv, T newv)`：如果ptr指向的值等于oldv，则将ptr指向的值赋为newv并返回true，否则返回false\n- `bool write_min(T *a, T b)`：如果b比a指向的值更小，那么将a指向的值赋为b并返回true，否则返回false。\n- `bool write_max(T *a, T b)`：如果b比a指向的值更大，那么将a指向的值赋为b并返回true，否则返回false。\n- `void write_add(T *a, T b)`：将b的值加到a指向的值上。\n- `void write_sub(T *a, T b)`：将a指向的值减去b的值。\n\n## 4. 点集合类ParallelBitset\n\n在使用TuGraph进行批处理操作时，需要使用点集合来表示需要处理的点。ParallelBitset实现了点集合类，以bit为单位表示点，因此能够节省大量内存。对应的代码见lgraph文件夹下的olap_base.h文件。\n\n### 4.1 ParallelBitset类成员\n\n- `size_t Size()`：表示Bitmap中的点个数。\n- `ParallelBitset(size_t size)`：初始化size和data，data长度为(size >> 6)+1\n- `void Clear()`：清空集合\n- `void Fill()`：将所有点加入集合\n- `bool Has(size_t i)`：检查点i是否在集合中\n- `bool Add(size_t i)`：将点i加入集合中\n- `void Swap(ParallelBitset &other)`：和另一组ParallelBitset集合交换元素\n\n## 5. 点数组类ParallelVector\n\n在使用TuGraph进行批处理操作时，需要使用点数组来表示对点的处理结果。ParallelVector实现了点数组类。对应的代码见lgraph文件夹下的olap_base.h文件。\n\n### 5.1 ParallelVector类成员\n\n该段落位于OlapBase API文档的第三章中，主要介绍TuGraph实现的原子操作，包括五种常用的原子操作功能，随后紧接着描述了点集合类ParallelBitset的相关内容及其成员函数。这部分内容对理解多线程操作和批处理过程中数据的安全访问至关重要。"
            },
            {
                "content": "## 5. 点数组类ParallelVector\n\n在使用TuGraph进行批处理操作时，需要使用点数组来表示对点的处理结果。ParallelVector实现了点数组类。对应的代码见lgraph文件夹下的olap_base.h文件。\n\n### 5.1 ParallelVector类成员\n\n- `ParallelVector(size_t capacity)` 构建ParallelVector，capacity为点数组的初始容量大小\n- `T &operator[](size_t i)`：下标为i的数据\n- `T *begin()`：ParallelVector的起始指针\n- `T *end()`：ParallelVector的结束指针。begin和end的用法类似于vector容器的begin和end指针，可以使用这两个指针对数组进行顺序访问\n- `T &Back()`：ParallelVector最后一个数据\n- `T *Data()`：表示数组本身数据\n- `void Destroy()`：清空ParallelVector数组内数据并删除数组\n- `size_t Size()`：表示ParallelVector中的数据个数\n- `size_t Capacity()`：表示ParallelVector的容量大小\n- `void Resize(size_t size)`：更改ParallelVector为size大小，该size应大于等于更改前的大小且小于capacity\n- `void Clear()`：清空ParallelVector内数据\n- `void ReAlloc(size_t capacity)`：给ParallelVector分配新的容量大小，若数组有数据则将数据迁移至新内存\n- `void Fill(T elem)`：为ParallelVector的全部数据赋值为elem\n- `void Append(const T &elem, bool atomic = true)`：向ParallelVector结尾添加一个数据\n- `void Swap(ParallelVector &other)`：和其他的ParallelVector交换数据\n- `ParallelVector Copy()`：复制当前的ParallelVector数据存至Copy数组中\n\n## 6. 自定义数据结构\n\n该段落位于OlapBase API文档的第5部分，介绍了点数组类ParallelVector的实现及其成员函数，主要用于在TuGraph进行批处理操作时表示对点的处理结果。"
            },
            {
                "content": "## 6. 自定义数据结构\n\n### 6.1 基本数据类型\n\n我们自定义了点和边的数据结构表示，用于在覆盖所有点的同时节省内存空间：\n\n- `Empty`：内容为空的特殊数据类型。\n\n### 6.2 组合数据结构\n\n为了便于计算，我们根据计算场景不同，定义了几种点和边数据的数据结构，分别是：\n\n- `EdgeUnit`：表示权值类型为EdgeData的边，用于解析输入文件，包含三个成员变量：\n  - `size_t src`：边的起始点\n  - `size_t dst`：边的终点\n  - `EdgeData edge_data`：边的权值\n- `AdjUnit`：表示权值类型为EdgeData的边，用于批处理计算过程中，包含两个成员变量：\n  - `size_t neighbour`：边的邻居点\n  - `EdgeData edge_data`：边的权值\n- `AdjList`：权值类型为EdgeData的点的邻接表，常用于表示点的入边和出边集合，包含两个成员变量：\n  - `AdjUnit * begin`：列表的起始指针\n  - `AdjUnit * end`：列表的结束指针。begin和end的用法类似于vector容器的begin和end指针，可以使用这两个指针对邻接表进行循环访问。\n\n## 7. 图类OlapBase\n\n图类OlapBase是TuGraph用于加载图以及进行图计算操作的主类，常用OlapBase表示权值类型为EdgeData的图，代码部分见lgraph文件夹下的olap_base.hpp。本章将介绍Graph类中常用的类型和API接口。上文介绍Procedure、Embed及Standalone功能所使用的类均为该类的子类。\n\n### 7.1 基本信息\n\n- `size_t NumVertices()`：获取点数\n- `size_t NumEdges()`：获取边数\n- `size_t OutDegree(size_t vid)`：点vid的出度\n- `size_t InDegree(size_t vid)`：点vid的入度\n\n### 7.2 点集和边集及其相关操作\n\n该片段位于文档的中部，介绍了TuGraph图计算系统中自定义的数据结构，包括基本数据类型和组合数据结构。这部分内容为后续的图类OlapBase的详细说明奠定了基础，涉及点和边的表示方法，以及相关操作的基本概念。"
            },
            {
                "content": "### 7.1 基本信息\n\n- `size_t NumVertices()`：获取点数\n- `size_t NumEdges()`：获取边数\n- `size_t OutDegree(size_t vid)`：点vid的出度\n- `size_t InDegree(size_t vid)`：点vid的入度\n\n### 7.2 点集和边集及其相关操作\n\n- `ParallelVector AllocVertexArray()`：分配一个类型为VertexData的数组，大小为点个数\n- `void fill_vertex_array(V * array, V value)`：将数组array中的所有元素赋值为value\n- `ParallelBitset AllocVertexSubset()`：分配一个ParallelBitset集合，用于表示所有点的状态是否激活\n- `AdjList OutEdges(size_t vid)`：获取点v的所有出边集合\n- `AdjList InEdges(size_t vid)`：获取点v的所有入边集合\n- `void Transpose()`：对有向图进行图反转\n- `LoadFromArray(char * edge_array, VertexId input_vertices, EdgeId input_edges,  EdgeDirectionPolicy edge_direction_policy)`：从数组中加载图数据，包含四个参数，其含义分别表示：\n  - `edge_array`：将该数组中的数据读入图，一般情况下该数组包含多条边。\n  - `input_vertices`：指定数组读入图的点个数。\n  - `input_edges`：指定数组读入图的边的条数。\n  - `edge_direction_policy`：指定图为有向或无向，包含三种模式，分别为DUAL_DIRECTION、MAKE_SYMMETRIC以及INPUT_SYMMETRIC。对应的详细介绍见include/lgraph/olap_base.h文件的`enum EdgeDirectionPolicy`。\n\n### 7.3 锁机制\n\nTuGraph实现了一对锁机制，来控制程序对于点数据的访存权限。分别是：\n\n该块内容位于OlapBase API文档的第7章，主要介绍图类OlapBase的基本信息、点集和边集的相关操作，以及锁机制。这些内容是理解如何在TuGraph图计算系统中有效地管理图数据和控制并发访问权限的关键部分。"
            },
            {
                "content": "### 7.3 锁机制\n\nTuGraph实现了一对锁机制，来控制程序对于点数据的访存权限。分别是：\n\n- `void AcquireVertexLock(size_t vid)`：对点vid加锁，禁止其它线程对该锁对应的点数据进行访存\n- `void ReleaseVertexLock(size_t vid)`：对点vid解锁，所有线程均可访存该锁对应的点数据\n- `VertexLockGuard GuardVertexLock(size_t vid)`：在对vid操作时，对点vid加锁，退出作用域时时自动释放锁\n\n### 7.4 批处理操作\n\nTuGraph提供了两个批处理操作来并行地进行以点为中心的批处理过程。分别是：\n\n```c++\n/*\n    函数名称:ReducedSum ProcessVertexInRange(std::function work, size_t lower, size_t upper,\n                ReducedSum zero = 0,std::function reduce =reduce_plus)\n\t\t\t\t\n    函数用途:对Graph中节点编号介于lower和upper之间的节点执行work函数。第四个参数表示累加的基数，默认为0；\n    第五个参数表示对每个work处理后的节点返回值进行迭代reduce函数操作，默认为累加操作。\n    具体实现请参考include/lgraph/olap_base.h中具体代码\n\n    使用示例:统计数组parent数组中有出边的点个数\n*/\n\nauto vertex_num = graph.ProcessVertexInRange(\n    [&](size_t i) {\n        if (graph.OutDegree(parent[i]) > 0) {\n            return 1;\n        }\n    },\n    0, parent.Size()\n);\nprintf(\"the number is %lu\\n\",vertex_num);\n```\n\n其中graph为图类OlapBase的实例化对象\n\n该块内容位于文档的第7章，介绍了TuGraph图计算系统中的锁机制和批处理操作，重点说明了如何通过锁控制对点数据的访问权限以及使用批处理操作进行点为中心的并行计算。"
            },
            {
                "content": "使用示例:统计数组parent数组中有出边的点个数\n*/\n\nauto vertex_num = graph.ProcessVertexInRange(\n    [&](size_t i) {\n        if (graph.OutDegree(parent[i]) > 0) {\n            return 1;\n        }\n    },\n    0, parent.Size()\n);\nprintf(\"the number is %lu\\n\",vertex_num);\n```\n\n其中graph为图类OlapBase的实例化对象\n\n```C++\n/*\n    函数名称:ReducedSum ProcessVertexActive(std::function work, ParallelBitset &active_vertices,\n                ReducedSum zero = 0,std::function reduce =reduce_plus)\n\t\t\t\t\n    函数用途:对active_vertices中对应为1的节点执行work函数，第三个参数表示累加的基数，默认为0；\n    第四个参数表示对每个work处理后的节点返回值进行迭代reduce函数操作，默认为累加操作。\n    具体实现请参考/include/lgraph/olap_base.h中具体代码\n    \n    使用示例:输出Graph中节点1，2，3的所有出度邻居，并统计这三个节点的总出度\n*/\n\n该代码块位于OlapBase API文档第7.4节“批处理操作”中，具体展示了如何使用`ProcessVertexInRange`和`ProcessVertexActive`函数进行批处理操作的实际示例，旨在说明如何统计符合特定条件的节点数量以及对节点邻居进行遍历的用法。"
            },
            {
                "content": "其中graph为图类OlapBase的实例化对象\n\n```C++\n/*\n    函数名称:ReducedSum ProcessVertexActive(std::function work, ParallelBitset &active_vertices,\n                ReducedSum zero = 0,std::function reduce =reduce_plus)\n\t\t\t\t\n    函数用途:对active_vertices中对应为1的节点执行work函数，第三个参数表示累加的基数，默认为0；\n    第四个参数表示对每个work处理后的节点返回值进行迭代reduce函数操作，默认为累加操作。\n    具体实现请参考/include/lgraph/olap_base.h中具体代码\n    \n    使用示例:输出Graph中节点1，2，3的所有出度邻居，并统计这三个节点的总出度\n*/\n\nauto active_in = graph.AllocVertexSubset();\nactive_in.Add(1);\nactive_in.Add(2);\nactive_in.Add(3);\nauto total_outdegree = graph.ProcessVertexActive(\n    [&](size_t vi) {\n        size_t local_outdegree = 0;\n        for (auto & edge : graph.OutEdges(vi)) {\n            size_t dst = edge.neighbour;\n            printf(\"node %lu has neighbour %lu\\n\",vi,dst);\n            local_outdegree += 1;\n        }\n        return local_outdegree;\n    },\n    active_in\n);\nprintf(\"total outdegree of node1,2,3 is %lu\\n\",total_outdegree);\n```\n\n该代码片段位于OlapBase API文档的第7.4节“批处理操作”中，介绍了通过`ProcessVertexActive`函数对激活的节点执行指定操作的方法，并提供了一个具体的示例，展示了如何输出特定节点的出度邻居及其总出度。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_17.md",
        "chunks": [
            {
                "content": "# ISO GQL\n\n\n## 1.GQL简介\nGraph Query Language(GQL, 图查询语言)是一种国际标准语言，用于属性图查询，该语言建立在SQL的基础上，并整合了现有的[openCypher、PGQL、GSQL和G-CORE](https://gql.today/comparing-cypher-pgql-and-g-core/)语言的成熟思想。目前该标准仍然处于草稿阶段。\n\nTuGraph基于[ISO GQL (ISO/IEC 39075) Antlr4 语法文件](https://github.com/TuGraph-family/gql-grammar)实现了GQL，并做了一些扩展与改造。目前并未完全支持所有的GQL语法，我们会在未来逐步完善。\n\n(https://github.com/TuGraph-family/gql-grammar)仓库包含了图查询语言标准（ISO/IEC 39075） 的 Antlr4 语法文件实现，该标准目前处于草案阶段。我们最新的语法文件基于 2023 年 3 月版的草案。GQL 是一种用于将结构化数据建模为图的数据库语言，可用于在图数据库或其他图存储中存储、查询和修改数据。通过开源这些语法文件，我们旨在促进 GQL 在图数据库中的快速应用，并加速标准化过程。\n\n## 2.Clauses\n\n| 类别                | 子句           |\n| ------------------- | -------------- |\n| Reading clauses     | MATCH          |\n|                     | OPTIONAL MATCH |\n| Projecting clauses  | RETURN         |\n|                     | NEXT           |\n| Reading sub-clauses | WHERE          |\n|                     | ORDER BY       |\n|                     | SKIP           |\n|                     | LIMIT          |\n表格内容描述:\n该表格包括两列：类别和子句。\n\n该文档介绍了ISO GQL（图查询语言）的基本概念、发展背景及其语法结构，包含了各类子句的说明和示例。该块内容主要涵盖了GQL的基本介绍及其子句分类，为后续具体子句的使用提供了基础知识。"
            },
            {
                "content": "## 2.Clauses\n\n| 类别                | 子句           |\n| ------------------- | -------------- |\n| Reading clauses     | MATCH          |\n|                     | OPTIONAL MATCH |\n| Projecting clauses  | RETURN         |\n|                     | NEXT           |\n| Reading sub-clauses | WHERE          |\n|                     | ORDER BY       |\n|                     | SKIP           |\n|                     | LIMIT          |\n表格内容描述:\n该表格包括两列：类别和子句。 \n\n在“Reading clauses”类别下，有两个子句：MATCH 和 OPTIONAL MATCH。 \n\n在“Projecting clauses”类别中，有两个子句：RETURN 和 NEXT。 \n\n在“Reading sub-clauses”类别里，列出了四个子句：WHERE、ORDER BY、SKIP 和 LIMIT。 \n\n总体来看，该表格列出了与查询相关的不同类别和其对应的子句，提供了对查询语句结构的清晰分类。\n\n### 2.1.MATCH\n\n`MATCH`子句式是GQL最基础的子句，几乎所有查询都是通过 `MATCH`展开。\n\n`MATCH`子句用于指定在图中搜索的匹配模式，用来匹配满足一定条件的点或者路径。\n\n#### 点查询\n\n##### 查询所有点\n\n```\nMATCH (n)\nRETURN n\n```\n\n##### 查询特定标签的点\n\n```\nMATCH (n:Person)\nRETURN n\n```\n\n##### 通过属性匹配点\n\n```\nMATCH (n:Person{name:'Michael Redgrave'})\nRETURN n.birthyear\n```\n\n返回结果\n```JSON\n[{\"n.birthyear\":1908}]\n```\n\n##### 通过过滤条件匹配点\n\n该段落位于文档的第二部分，主要介绍了GQL的各种子句，包括不同类型的查询结构和用法。这部分详细列出了查询的类别及其对应的子句，如MATCH、OPTIONAL MATCH、RETURN等，并提供了具体的查询示例和返回结果，用于帮助用户理解GQL的基本语法和功能。"
            },
            {
                "content": "在“Projecting clauses”类别中，有两个子句：RETURN 和 NEXT。 \n\n在“Reading sub-clauses”类别里，列出了四个子句：WHERE、ORDER BY、SKIP 和 LIMIT。 \n\n总体来看，该表格列出了与查询相关的不同类别和其对应的子句，提供了对查询语句结构的清晰分类。\n\n### 2.1.MATCH\n\n`MATCH`子句式是GQL最基础的子句，几乎所有查询都是通过 `MATCH`展开。\n\n`MATCH`子句用于指定在图中搜索的匹配模式，用来匹配满足一定条件的点或者路径。\n\n#### 点查询\n\n##### 查询所有点\n\n```\nMATCH (n)\nRETURN n\n```\n\n##### 查询特定标签的点\n\n```\nMATCH (n:Person)\nRETURN n\n```\n\n##### 通过属性匹配点\n\n```\nMATCH (n:Person{name:'Michael Redgrave'})\nRETURN n.birthyear\n```\n\n返回结果\n```JSON\n[{\"n.birthyear\":1908}]\n```\n\n##### 通过过滤条件匹配点\n\n\n```\nMATCH (n:Person WHERE n.birthyear > 1910)\nRETURN n.name LIMIT 2\n```\n\n返回结果\n```JSON\n[{\"n.name\":\"Christopher Nolan\"},{\"n.name\":\"Corin Redgrave\"}]\n```\n\n#### 边查询\n\n##### 出边匹配\n\n```\nMATCH (n:Person WHERE n.birthyear = 1970)-[e]->(m)\nRETURN n.name, label(e), m.name\n```\n\n返回结果\n```JSON\n[{\"label(e)\":\"BORN_IN\",\"m.name\":\"London\",\"n.name\":\"Christopher Nolan\"},{\"label(e)\":\"DIRECTED\",\"m.name\":null,\"n.name\":\"Christopher Nolan\"}]\n```\n\n##### 入边匹配\n\n该文本块位于ISO GQL文档的第二部分，主要介绍了GQL中的不同子句，重点是\"Projecting clauses\"和\"Reading sub-clauses\"的内容，包括`MATCH`子句的基本使用和查询示例。这部分内容为GQL的查询功能提供基础理解，并详细阐述了如何在图中进行点和边的查询。"
            },
            {
                "content": "返回结果\n```JSON\n[{\"n.birthyear\":1908}]\n```\n\n##### 通过过滤条件匹配点\n\n\n```\nMATCH (n:Person WHERE n.birthyear > 1910)\nRETURN n.name LIMIT 2\n```\n\n返回结果\n```JSON\n[{\"n.name\":\"Christopher Nolan\"},{\"n.name\":\"Corin Redgrave\"}]\n```\n\n#### 边查询\n\n##### 出边匹配\n\n```\nMATCH (n:Person WHERE n.birthyear = 1970)-[e]->(m)\nRETURN n.name, label(e), m.name\n```\n\n返回结果\n```JSON\n[{\"label(e)\":\"BORN_IN\",\"m.name\":\"London\",\"n.name\":\"Christopher Nolan\"},{\"label(e)\":\"DIRECTED\",\"m.name\":null,\"n.name\":\"Christopher Nolan\"}]\n```\n\n##### 入边匹配\n\n```\nMATCH (n:Person WHERE n.birthyear = 1939)<-[e]-(m)\nRETURN n.name, label(e), m.name\n```\n\n返回结果\n```JSON\n[{\"label(e)\":\"HAS_CHILD\",\"m.name\":\"Rachel Kempson\",\"n.name\":\"Corin Redgrave\"},{\"label(e)\":\"HAS_CHILD\",\"m.name\":\"Michael Redgrave\",\"n.name\":\"Corin Redgrave\"}]\n```\n\n##### 带过滤条件的边匹配\n\n```\nMATCH (n:Person)-[e:BORN_IN WHERE e.weight > 20]->(m)\nRETURN n.name, e.weight, m.name\n```\n\n该块内容位于ISO GQL文档的第二部分，主要介绍了通过 `MATCH` 子句进行边和点的查询，包括通过属性和过滤条件匹配点与边的示例及其返回结果。内容涉及到点查询和边查询的不同场景，帮助用户理解如何在图数据库中执行复杂查询。"
            },
            {
                "content": "##### 入边匹配\n\n```\nMATCH (n:Person WHERE n.birthyear = 1939)<-[e]-(m)\nRETURN n.name, label(e), m.name\n```\n\n返回结果\n```JSON\n[{\"label(e)\":\"HAS_CHILD\",\"m.name\":\"Rachel Kempson\",\"n.name\":\"Corin Redgrave\"},{\"label(e)\":\"HAS_CHILD\",\"m.name\":\"Michael Redgrave\",\"n.name\":\"Corin Redgrave\"}]\n```\n\n##### 带过滤条件的边匹配\n\n```\nMATCH (n:Person)-[e:BORN_IN WHERE e.weight > 20]->(m)\nRETURN n.name, e.weight, m.name\n```\n\n返回结果\n```JSON\n[{\"e.weight\":20.549999237060547,\"m.name\":\"New York\",\"n.name\":\"John Williams\"},{\"e.weight\":20.6200008392334,\"m.name\":\"New York\",\"n.name\":\"Lindsay Lohan\"}]\n```\n\n#### 路径匹配\n\n##### 不定跳查询\n\n```\nMATCH (n:Person)-[e]->{2,3}(m:Person)\nRETURN m.name LIMIT 2\n```\n\n返回结果\n```JSON\n[{\"m.name\":\"Liam Neeson\"},{\"m.name\":\"Natasha Richardson\"}]\n```\n\n### 2.2.OPTIONAL MATCH\n\n`OPTIONAL MATCH`匹配图模式，如果未命中，则返回`null`。\n\n#### 查询命中\n\n```\nOPTIONAL MATCH (n:Person{name:'Michael Redgrave'})\nRETURN n.birthyear\n```\n\n返回结果\n```JSON\n[{\"n.birthyear\":1908}]\n```\n\n#### 查询未命中\n\n```\nOPTIONAL MATCH (n:Person{name:'Redgrave Michael'})\nRETURN n.birthyear\n```\n\n该内容位于文档的第2部分，主要介绍了GQL中的图查询，包括边的匹配查询（入边匹配和带过滤条件的边匹配）以及路径匹配的用法，并接着讲解了`OPTIONAL MATCH`子句的概念和示例。"
            },
            {
                "content": "#### 路径匹配\n\n##### 不定跳查询\n\n```\nMATCH (n:Person)-[e]->{2,3}(m:Person)\nRETURN m.name LIMIT 2\n```\n\n返回结果\n```JSON\n[{\"m.name\":\"Liam Neeson\"},{\"m.name\":\"Natasha Richardson\"}]\n```\n\n### 2.2.OPTIONAL MATCH\n\n`OPTIONAL MATCH`匹配图模式，如果未命中，则返回`null`。\n\n#### 查询命中\n\n```\nOPTIONAL MATCH (n:Person{name:'Michael Redgrave'})\nRETURN n.birthyear\n```\n\n返回结果\n```JSON\n[{\"n.birthyear\":1908}]\n```\n\n#### 查询未命中\n\n```\nOPTIONAL MATCH (n:Person{name:'Redgrave Michael'})\nRETURN n.birthyear\n```\n\n返回结果\n\n```JSON\n[{\"n.birthyear\":null}]\n```\n\n### 2.3.RETURN\n\n`RETURN`子句指定返回结果，包括返回点、边、路径、属性等。\n\n#### 返回点\n\n```\nMATCH (n)\nRETURN n LIMIT 2\n```\n\n返回结果\n```JSON\n[{\"n\":{\"identity\":0,\"label\":\"Person\",\"properties\":{\"birthyear\":1910,\"name\":\"Rachel Kempson\"}}},{\"n\":{\"identity\":1,\"label\":\"Person\",\"properties\":{\"birthyear\":1908,\"name\":\"Michael Redgrave\"}}}]\n```\n\n#### 返回边\n\n```\nMATCH (n)-[e]->(m)\nRETURN e LIMIT 2\n```\n\n返回结果\n\n该段落涵盖了GQL中的路径匹配和可选匹配子句，详细介绍了如何使用`MATCH`和`OPTIONAL MATCH`进行查询，并给出了相关的示例和返回结果。这部分内容是文档中关于GQL查询子句的具体分析，旨在帮助读者理解如何在图数据库中进行高效的数据检索。"
            },
            {
                "content": "#### 查询未命中\n\n```\nOPTIONAL MATCH (n:Person{name:'Redgrave Michael'})\nRETURN n.birthyear\n```\n\n返回结果\n\n```JSON\n[{\"n.birthyear\":null}]\n```\n\n### 2.3.RETURN\n\n`RETURN`子句指定返回结果，包括返回点、边、路径、属性等。\n\n#### 返回点\n\n```\nMATCH (n)\nRETURN n LIMIT 2\n```\n\n返回结果\n```JSON\n[{\"n\":{\"identity\":0,\"label\":\"Person\",\"properties\":{\"birthyear\":1910,\"name\":\"Rachel Kempson\"}}},{\"n\":{\"identity\":1,\"label\":\"Person\",\"properties\":{\"birthyear\":1908,\"name\":\"Michael Redgrave\"}}}]\n```\n\n#### 返回边\n\n```\nMATCH (n)-[e]->(m)\nRETURN e LIMIT 2\n```\n\n返回结果\n\n```JSON\n[{\"e\":{\"dst\":2,\"forward\":false,\"identity\":0,\"label\":\"HAS_CHILD\",\"label_id\":0,\"src\":0,\"temporal_id\":0}},{\"e\":{\"dst\":3,\"forward\":false,\"identity\":0,\"label\":\"HAS_CHILD\",\"label_id\":0,\"src\":0,\"temporal_id\":0}}]\n```\n\n#### 返回属性\n\n```\nMATCH (n:Person)\nRETURN n.name LIMIT 2\n```\n\n返回结果\n\n```JSON\n[{\"n.name\":\"Christopher Nolan\"},{\"n.name\":\"Corin Redgrave\"}]\n```\n\n#### 不常见字符串作为变量名\n\n```\nMATCH (`/uncommon variable`:Person)\nRETURN `/uncommon variable`.name LIMIT 3\n```\n\n返回结果\n\n该块内容位于文档中关于GQL的子句部分，主要描述了`OPTIONAL MATCH`子句的使用，对于未命中查询的示例和`RETURN`子句的功能，包括返回点、边、属性及不常见字符串作为变量名的用法和示例。"
            },
            {
                "content": "返回结果\n\n```JSON\n[{\"e\":{\"dst\":2,\"forward\":false,\"identity\":0,\"label\":\"HAS_CHILD\",\"label_id\":0,\"src\":0,\"temporal_id\":0}},{\"e\":{\"dst\":3,\"forward\":false,\"identity\":0,\"label\":\"HAS_CHILD\",\"label_id\":0,\"src\":0,\"temporal_id\":0}}]\n```\n\n#### 返回属性\n\n```\nMATCH (n:Person)\nRETURN n.name LIMIT 2\n```\n\n返回结果\n\n```JSON\n[{\"n.name\":\"Christopher Nolan\"},{\"n.name\":\"Corin Redgrave\"}]\n```\n\n#### 不常见字符串作为变量名\n\n```\nMATCH (`/uncommon variable`:Person)\nRETURN `/uncommon variable`.name LIMIT 3\n```\n\n返回结果\n\n```JSON\n[{\"`/uncommon variable`.name\":\"Christopher Nolan\"},{\"`/uncommon variable`.name\":\"Corin Redgrave\"},{\"`/uncommon variable`.name\":\"Dennis Quaid\"}]\n```\n\n#### 列别名\n\n```\nMATCH (n:Person)\nRETURN n.name AS nname LIMIT 2\n```\n\n返回结果\n\n```JSON\n[{\"nname\":\"Christopher Nolan\"},{\"nname\":\"Corin Redgrave\"}]\n```\n\n#### 可选属性\n\n```\nMATCH (n:Person)\nRETURN n.age LIMIT 2\n```\n\n返回结果\n\n```JSON\n[{\"n.age\":null},{\"n.age\":null}]\n```\n\n#### 其它表达式\n\n```\nMATCH (n:Person)\nRETURN n.birthyear > 1970, \"I'm a literal\", 1 + 2, abs(-2)\nLIMIT 2\n```\n\n返回结果\n\n该片段位于文档的\"RETURN\"子句部分，详细介绍了如何在GQL查询中返回边、点、属性及其相关的各种用法和示例，旨在帮助用户理解如何提取和处理图数据库中的数据。"
            },
            {
                "content": "#### 列别名\n\n```\nMATCH (n:Person)\nRETURN n.name AS nname LIMIT 2\n```\n\n返回结果\n\n```JSON\n[{\"nname\":\"Christopher Nolan\"},{\"nname\":\"Corin Redgrave\"}]\n```\n\n#### 可选属性\n\n```\nMATCH (n:Person)\nRETURN n.age LIMIT 2\n```\n\n返回结果\n\n```JSON\n[{\"n.age\":null},{\"n.age\":null}]\n```\n\n#### 其它表达式\n\n```\nMATCH (n:Person)\nRETURN n.birthyear > 1970, \"I'm a literal\", 1 + 2, abs(-2)\nLIMIT 2\n```\n\n返回结果\n\n```JSON\n[{\"\\\"I'm a literal\\\"\":\"I'm a literal\",\"1 + 2\":3,\"abs(-2)\":2,\"n.birthyear > 1970\":false},{\"\\\"I'm a literal\\\"\":\"I'm a literal\",\"1 + 2\":3,\"abs(-2)\":2,\"n.birthyear > 1970\":false}]\n```\n\n#### 结果唯一性\n\n\n```\nMATCH (n)\nRETURN DISTINCT label(n) AS label\n```\n\n返回结果\n\n```JSON\n[{\"label\":\"Person\"},{\"label\":\"City\"},{\"label\":\"Film\"}]\n```\n\n### 2.4.NEXT\n\n`NEXT`子句用于连接多个子句。\n\n#### 连接MATCH\n\n```\nMATCH (n:Person) WHERE n.birthyear = 1970\nRETURN n\nNEXT\nMATCH (m:Person) WHERE m.birthyear < 1968\nRETURN n.name, n.birthyear, m.name LIMIT 2\n```\n\n该片段位于GQL文档的“RETURN”子句部分，详细介绍了如何使用列别名、可选属性、其他表达式和结果唯一性来返回查询结果。它还介绍了如何将`NEXT`子句用于连接多个查询，以便更灵活地处理和返回数据。"
            },
            {
                "content": "#### 结果唯一性\n\n\n```\nMATCH (n)\nRETURN DISTINCT label(n) AS label\n```\n\n返回结果\n\n```JSON\n[{\"label\":\"Person\"},{\"label\":\"City\"},{\"label\":\"Film\"}]\n```\n\n### 2.4.NEXT\n\n`NEXT`子句用于连接多个子句。\n\n#### 连接MATCH\n\n```\nMATCH (n:Person) WHERE n.birthyear = 1970\nRETURN n\nNEXT\nMATCH (m:Person) WHERE m.birthyear < 1968\nRETURN n.name, n.birthyear, m.name LIMIT 2\n```\n\n返回结果\n```JSON\n[{\"m.name\":\"Rachel Kempson\",\"n.birthyear\":1970,\"n.name\":\"Christopher Nolan\"},{\"m.name\":\"Michael Redgrave\",\"n.birthyear\":1970,\"n.name\":\"Christopher Nolan\"}]\n```\n\n### 2.5.WHERE\n\n`WHERE`子句用于过滤记录。\n\n#### 过滤点\n\n```\nMATCH (n:Person WHERE n.birthyear > 1965)\nRETURN n.name\n```\n\n返回结果\n\n```JSON\n[{\"n.name\":\"Christopher Nolan\"},{\"n.name\":\"Lindsay Lohan\"}]\n```\n\n#### 过滤边\n\n```\nMATCH (n:Person WHERE n.birthyear > 1965)-[e:ACTED_IN]->(m:Film)\nWHERE e.charactername = 'Halle/Annie'\nRETURN m.title\n```\n\n返回结果\n\n```JSON\n[{\"m.title\":\"The Parent Trap\"}]\n```\n\n#### 布尔表达式\n\n`AND`, `OR`, `XOR`和 `NOT`布尔表达式可以用在 `WHERE`中用来过滤数据。\n\n该块内容主要介绍了GQL中的结果唯一性、NEXT子句和WHERE子句的用法，涵盖了如何连接多个查询、过滤记录、处理布尔表达式以及示例查询和返回结果，属于GQL的查询语法和结构部分。"
            },
            {
                "content": "### 2.5.WHERE\n\n`WHERE`子句用于过滤记录。\n\n#### 过滤点\n\n```\nMATCH (n:Person WHERE n.birthyear > 1965)\nRETURN n.name\n```\n\n返回结果\n\n```JSON\n[{\"n.name\":\"Christopher Nolan\"},{\"n.name\":\"Lindsay Lohan\"}]\n```\n\n#### 过滤边\n\n```\nMATCH (n:Person WHERE n.birthyear > 1965)-[e:ACTED_IN]->(m:Film)\nWHERE e.charactername = 'Halle/Annie'\nRETURN m.title\n```\n\n返回结果\n\n```JSON\n[{\"m.title\":\"The Parent Trap\"}]\n```\n\n#### 布尔表达式\n\n`AND`, `OR`, `XOR`和 `NOT`布尔表达式可以用在 `WHERE`中用来过滤数据。\n\n```\nMATCH (n:Person)\nWHERE\n\tn.birthyear > 1930 AND (n.birthyear < 1950 OR n.name = 'Corin Redgrave')\nRETURN n LIMIT 2\n```\n\n返回结果\n\n```JSON\n[{\"n\":{\"identity\":3,\"label\":\"Person\",\"properties\":{\"birthyear\":1939,\"name\":\"Corin Redgrave\"}}},{\"n\":{\"identity\":11,\"label\":\"Person\",\"properties\":{\"birthyear\":1932,\"name\":\"John Williams\"}}}]\n```\n\n\n### 2.6.ORDER BY\n\n`ORDER BY`是`RETURN`的子句，对输出的结果进行排序。\n\n#### 对结果排序\n\n```\nMATCH (n:Person WHERE n.birthyear < 1970)\nRETURN n.birthyear AS q\nORDER BY q ASC\nLIMIT 5\n```\n\n返回结果\n```JSON\n[{\"q\":1873},{\"q\":1908},{\"q\":1910},{\"q\":1930},{\"q\":1932}]\n```\n\n该内容段落位于ISO GQL文档的第2节，具体涉及`WHERE`子句的应用，包括过滤点、过滤边以及布尔表达式的使用。接着介绍了`ORDER BY`子句，主要用于对查询结果进行排序。这部分内容对理解图查询中的条件过滤和结果排序非常重要。"
            },
            {
                "content": "返回结果\n\n```JSON\n[{\"n\":{\"identity\":3,\"label\":\"Person\",\"properties\":{\"birthyear\":1939,\"name\":\"Corin Redgrave\"}}},{\"n\":{\"identity\":11,\"label\":\"Person\",\"properties\":{\"birthyear\":1932,\"name\":\"John Williams\"}}}]\n```\n\n\n### 2.6.ORDER BY\n\n`ORDER BY`是`RETURN`的子句，对输出的结果进行排序。\n\n#### 对结果排序\n\n```\nMATCH (n:Person WHERE n.birthyear < 1970)\nRETURN n.birthyear AS q\nORDER BY q ASC\nLIMIT 5\n```\n\n返回结果\n```JSON\n[{\"q\":1873},{\"q\":1908},{\"q\":1910},{\"q\":1930},{\"q\":1932}]\n```\n\n### 2.7.SKIP\n\n`SKIP`指定结果偏移行数。\n\n#### 未使用SKIP\n\n```\nMATCH (n:Person)\nRETURN n.name LIMIT 3\n```\n\n返回结果\n\n```JSON\n[{\"n.name\":\"Christopher Nolan\"},{\"n.name\":\"Corin Redgrave\"},{\"n.name\":\"Dennis Quaid\"}]\n```\n\n#### 使用SKIP\n\n```\nMATCH (n:Person)\nRETURN n.name SKIP 1 LIMIT 2\n```\n\n返回结果\n```JSON\n[{\"n.name\":\"Corin Redgrave\"},{\"n.name\":\"Dennis Quaid\"}]\n```\n\n### 2.8.LIMIT\n\n`LIMIT`限制结果行数。\n\n#### 使用LIMIT\n\n```\nMATCH (n:Person)\nRETURN n.name LIMIT 2;\n```\n\n返回结果\n```JSON\n[{\"n.name\":\"Christopher Nolan\"},{\"n.name\":\"Corin Redgrave\"}]\n```\n\n该段落位于文档的第2.6节至第2.8节，主要介绍了GQL中的`ORDER BY`、`SKIP`和`LIMIT`子句，用于结果的排序、偏移和限制返回行数。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_18.md",
        "chunks": [
            {
                "content": "# 快速上手\n\n> 此文档主要用于新用户快速上手，其中包含了 TuGraph 的简介、特征、安装和使用。\n\n## 1.简介\n\nTuGraph 是蚂蚁集团自主研发的大规模图计算系统，提供图数据库引擎和图分析引擎。其主要特点是大数据量存储和计算，高吞吐率，以及灵活的 API，同时支持高效的在线事务处理（OLTP）和在线分析处理（OLAP）。 LightGraph、GeaGraph 是 TuGraph 的曾用名。\n\n主要功能特征包括：\n\n- 标签属性图模型\n- 支持多图\n- 完善的 ACID 事务处理\n- 内置 34 图分析算法\n- 基于 web 客户端的图可视化工具\n- 支持 RESTful API 和 RPC\n- OpenCypher 图查询语言\n- 基于 C++/Python 的存储过程\n- 适用于高效图算法开发的 Traversal API\n\n性能及可扩展性特征包括：\n\n- TB 级大容量\n- 千万点/秒的高吞吐率\n- 高可用性支持\n- 高性能批量导入\n- 在线/离线备份\n\n\n### 1.1.支持的平台\n\nTuGraph 无论是物理、虚拟还是容器化环境，均支持 X86_64 和 ARM64 架构的的平台。\n\n### 1.2.硬件要求\n\n_目前我们建议用户使用 NVMe SSD 配合较大的内存配置以获取最佳性能。_\n\n| 硬件   | 最低配置      | 建议配置                     |\n|------|-----------|--------------------------|\n| CPU  | X86_64    | Xeon E5 2670 v4          |\n| 内存   | 4GB       | 256GB                    |\n| 硬盘   | 100GB     | 1TB NVMe SSD             |\n| 操作系统 | Linux 2.6 | Ubuntu 18.04, CentOS 7.3 |\n表格内容描述:\n该表格包含了三列，分别是“硬件”、“最低配置”和“建议配置”。\n\n该文档是 TuGraph 的快速上手指南，主要针对新用户，包含了系统的简介、功能特性、硬件要求以及安装步骤。其中，介绍了 TuGraph 的大规模图计算特点、支持的平台和详细的硬件配置建议。"
            },
            {
                "content": "- TB 级大容量\n- 千万点/秒的高吞吐率\n- 高可用性支持\n- 高性能批量导入\n- 在线/离线备份\n\n\n### 1.1.支持的平台\n\nTuGraph 无论是物理、虚拟还是容器化环境，均支持 X86_64 和 ARM64 架构的的平台。\n\n### 1.2.硬件要求\n\n_目前我们建议用户使用 NVMe SSD 配合较大的内存配置以获取最佳性能。_\n\n| 硬件   | 最低配置      | 建议配置                     |\n|------|-----------|--------------------------|\n| CPU  | X86_64    | Xeon E5 2670 v4          |\n| 内存   | 4GB       | 256GB                    |\n| 硬盘   | 100GB     | 1TB NVMe SSD             |\n| 操作系统 | Linux 2.6 | Ubuntu 18.04, CentOS 7.3 |\n表格内容描述:\n该表格包含了三列，分别是“硬件”、“最低配置”和“建议配置”。 \n\n- 在“硬件”这一行，CPU的最低配置为X86_64，建议配置为Xeon E5 2670 v4。\n- 在“内存”这一行，最低配置为4GB，建议配置为256GB。\n- 在“硬盘”这一行，最低配置为100GB，建议配置为1TB NVMe SSD。\n- 在“操作系统”这一行，最低配置为Linux 2.6，建议配置为Ubuntu 18.04或CentOS 7.3。\n\n总体来看，该表格展示了不同硬件的最低和建议配置要求，强调了在性能和存储方面的巨大提升建议。\n\n## 2.安装\n\nTuGraph 可以通过 Docker Image 快速安装，或者通过 rpm/deb 包本地安装。另外TuGraph在阿里云计算巢上提供了社区版服务，您无需自行购置云主机，即可在计算巢上快速部署TuGraph服务、实现运维监控，从而搭建您自己的图应用。\n\n> 安装包/镜像下载：参考TuGraph最新版本：\n\n该块内容位于文档的第一部分，主要介绍了TuGraph的性能特性及硬件要求，整合了对系统支持的平台、最低和建议配置的详细说明，以及安装方法的简要引导。这部分为用户提供了适当的硬件设置建议，以优化TuGraph的性能，随后引入了安装方式，便于用户快速上手。"
            },
            {
                "content": "| 描述                  | 文件                                         | 链接                                                                                                                                                                                              |\n|---------------------|--------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| CentOS7 安装包         | tugraph-4.5.0-1.el7.x86_64.rpm             | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.el7.x86_64.rpm)                                                                                      |\n\n该chunk位于文档的“安装”部分，主要提供了TuGraph在CentOS7操作系统上的安装包信息，包括文件名称和下载链接，帮助用户快速获取所需的软件包以进行安装。"
            },
            {
                "content": "| CentOS7 安装包         | tugraph-4.5.0-1.el7.x86_64.rpm             | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.el7.x86_64.rpm)                                                                                      |\n| CentOS8 安装包         | tugraph-4.5.0-1.el8.x86_64.rpm             | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.el8.x86_64.rpm)                                                                                      |\n| Ubuntu18.04 安装包     | tugraph-4.5.0-1.x86_64.deb                 | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.x86_64.deb)                                                                                          |\n\n该内容位于文档的“安装”部分，主要列出了不同操作系统（CentOS7、CentOS8 和 Ubuntu18.04）的 TuGraph 安装包的文件名及下载链接，为用户提供了快速获取所需软件的详细信息。"
            },
            {
                "content": "| Ubuntu18.04 安装包     | tugraph-4.5.0-1.x86_64.deb                 | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.x86_64.deb)                                                                                          |\n| CentOS7 预安装镜像       | tugraph-runtime-centos7-4.5.0.tar          | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-centos7-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-runtime-centos7)                   |\n| CentOS8 预安装镜像       | tugraph-runtime-centos8-4.5.0.tar          | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-centos8-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-runtime-centos8)                   |\n\n该段落位于文档的“安装”部分，主要提供了TuGraph在不同操作系统（如Ubuntu18.04和CentOS7、CentOS8）上的安装包和预安装镜像的详细信息，包括文件名和下载链接，旨在帮助用户快速获取所需的安装资源。"
            },
            {
                "content": "| CentOS8 预安装镜像       | tugraph-runtime-centos8-4.5.0.tar          | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-centos8-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-runtime-centos8)                   |\n| Ubuntu18.04 预安装镜像   | tugraph-runtime-ubuntu18.04-4.5.0.tar      | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-ubuntu18.04-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-runtime-ubuntu18.04)           |\n| CentOS7 精简安装包       | tugraph-mini-4.5.0-1.el7.x86_64.rpm        | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.el7.x86_64.rpm)                                                                                 |\n\n该块内容位于安装章节，具体描述了针对不同操作系统的预安装镜像和精简安装包的信息，包括文件名称和下载链接，旨在为用户提供快速获取和安装 TuGraph 的资源。"
            },
            {
                "content": "| CentOS7 精简安装包       | tugraph-mini-4.5.0-1.el7.x86_64.rpm        | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.el7.x86_64.rpm)                                                                                 |\n| CentOS8 精简安装包       | tugraph-mini-4.5.0-1.el8.x86_64.rpm        | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.el8.x86_64.rpm)                                                                                 |\n| Ubuntu18.04 精简安装包   | tugraph-mini-4.5.0-1.x86_64.deb            | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.x86_64.deb)                                                                                     |\n\n该部分内容位于文档的安装章节中，具体介绍了TuGraph在CentOS7、CentOS8和Ubuntu18.04操作系统上的精简安装包，包括文件名和下载链接，旨在帮助用户找到合适的安装资源。"
            },
            {
                "content": "| Ubuntu18.04 精简安装包   | tugraph-mini-4.5.0-1.x86_64.deb            | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.x86_64.deb)                                                                                     |\n| CentOS7 精简预安装镜像     | tugraph-mini-runtime-centos7-4.5.0.tar     | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-centos7-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-centos7)         |\n| CentOS8 精简预安装镜像     | tugraph-mini-runtime-centos8-4.5.0.tar     | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-centos8-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-centos8)         |\n\n该片段位于文档的“安装”部分，列出了针对 Ubuntu18.04 和 CentOS7、CentOS8 的精简安装包及预安装镜像的详细信息，包括文件名和下载链接，方便用户快速获取所需资源。"
            },
            {
                "content": "| CentOS8 精简预安装镜像     | tugraph-mini-runtime-centos8-4.5.0.tar     | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-centos8-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-centos8)         |\n| Ubuntu18.04 精简预安装镜像 | tugraph-mini-runtime-ubuntu18.04-4.5.0.tar | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-ubuntu18.04-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-ubuntu18.04) |\n| CentOS7 编译镜像        | tugraph-compile-centos7-1.3.2.tar          | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-centos7-1.3.2.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-compile-centos7)          |\n\n该块内容位于文档的安装部分，具体列出了 TuGraph 针对不同操作系统（包括 CentOS8 和 Ubuntu18.04）的精简预安装镜像及编译镜像的信息，包括文件名和下载链接，旨在帮助用户快速获取所需资源以便于安装和部署 TuGraph。"
            },
            {
                "content": "| CentOS7 编译镜像        | tugraph-compile-centos7-1.3.2.tar          | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-centos7-1.3.2.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-compile-centos7)          |\n| CentOS8 编译镜像        | tugraph-compile-centos8-1.3.2.tar          | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-centos8-1.3.2.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-compile-centos8)          |\n| Ubuntu18.04 编译镜像    | tugraph-compile-ubuntu18.04-1.3.2.tar      | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-ubuntu18.04-1.3.2.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-compile-ubuntu18.04)  |\n表格内容描述:\n\n该内容块位于文档的“安装”部分，具体介绍了适用于不同操作系统（CentOS7、CentOS8 和 Ubuntu18.04）的编译镜像的详细信息，包括文件名、下载链接和访问链接，为用户提供便捷的资源获取方式。"
            },
            {
                "content": "该表格包含三列：描述、文件和链接。描述列提供了每种软件包或镜像的类型和操作系统，文件列则列出了对应的文件名，而链接列则提供了通往这些文件的下载地址及部分访问链接。\n\n该段落位于文档的安装部分，具体描述了一个表格的内容，该表格列出了不同操作系统下的 TuGraph 安装包和镜像的详细信息，包括每种软件包的描述、文件名和下载链接。"
            },
            {
                "content": "逐行描述如下：\n1. CentOS7 安装包：文件名为 tugraph-4.5.0-1.el7.x86_64.rpm，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.el7.x86_64.rpm)。\n2. CentOS8 安装包：文件名为 tugraph-4.5.0-1.el8.x86_64.rpm，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.el8.x86_64.rpm)。\n3. Ubuntu18.04 安装包：文件名为 tugraph-4.5.0-1.x86_64.deb，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.x86_64.deb)。\n4. CentOS7 预安装镜像：文件名为 tugraph-runtime-centos7-4.5.0.tar，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-centos7-4.5.0.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-runtime-centos7)。\n5. CentOS8 预安装镜像：文件名为 tugraph-runtime-centos8-4.5.0.tar，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-centos8-4.5.0.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-runtime-centos8)。\n\n该段落对TuGraph的安装包和预安装镜像进行了逐项描述，主要包括文件名和下载链接，帮助用户快速找到适合其操作系统的安装资源，内容出现在安装步骤部分，以便新用户顺利进行软件的安装和配置。"
            },
            {
                "content": "4. CentOS7 预安装镜像：文件名为 tugraph-runtime-centos7-4.5.0.tar，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-centos7-4.5.0.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-runtime-centos7)。\n5. CentOS8 预安装镜像：文件名为 tugraph-runtime-centos8-4.5.0.tar，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-centos8-4.5.0.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-runtime-centos8)。\n6. Ubuntu18.04 预安装镜像：文件名为 tugraph-runtime-ubuntu18.04-4.5.0.tar，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-ubuntu18.04-4.5.0.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-runtime-ubuntu18.04)。\n7. CentOS7 精简安装包：文件名为 tugraph-mini-4.5.0-1.el7.x86_64.rpm，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.el7.x86_64.rpm)。\n\n该块内容位于文档的安装部分，具体介绍了不同操作系统（CentOS7、CentOS8和Ubuntu18.04）的预安装镜像和精简安装包的详细信息，包括文件名、下载链接和访问链接，帮助用户快速获取所需安装资源。"
            },
            {
                "content": "6. Ubuntu18.04 预安装镜像：文件名为 tugraph-runtime-ubuntu18.04-4.5.0.tar，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-ubuntu18.04-4.5.0.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-runtime-ubuntu18.04)。\n7. CentOS7 精简安装包：文件名为 tugraph-mini-4.5.0-1.el7.x86_64.rpm，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.el7.x86_64.rpm)。\n8. CentOS8 精简安装包：文件名为 tugraph-mini-4.5.0-1.el8.x86_64.rpm，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.el8.x86_64.rpm)。\n9. Ubuntu18.04 精简安装包：文件名为 tugraph-mini-4.5.0-1.x86_64.deb，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.x86_64.deb)。\n\n该文档为新用户提供快速上手指导，其中包括 TuGraph 的安装相关信息。在安装部分，介绍了不同操作系统下的多种软件包及预安装镜像，包括 CentOS 和 Ubuntu 系列。所提供的段落主要列出 Ubuntu 18.04 及精简版相关安装包的信息和下载链接。"
            },
            {
                "content": "8. CentOS8 精简安装包：文件名为 tugraph-mini-4.5.0-1.el8.x86_64.rpm，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.el8.x86_64.rpm)。\n9. Ubuntu18.04 精简安装包：文件名为 tugraph-mini-4.5.0-1.x86_64.deb，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.x86_64.deb)。\n10. CentOS7 精简预安装镜像：文件名为 tugraph-mini-runtime-centos7-4.5.0.tar，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-centos7-4.5.0.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-centos7)。\n11. CentOS8 精简预安装镜像：文件名为 tugraph-mini-runtime-centos8-4.5.0.tar，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-centos8-4.5.0.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-centos8)。\n\n该内容片段位于文档的安装章节中，具体列出了针对不同操作系统（CentOS8 和 Ubuntu18.04）的精简安装包和预安装镜像的详细信息，包括文件名、下载链接和访问链接，方便用户快速下载和获取所需资源。"
            },
            {
                "content": "11. CentOS8 精简预安装镜像：文件名为 tugraph-mini-runtime-centos8-4.5.0.tar，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-centos8-4.5.0.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-centos8)。\n12. Ubuntu18.04 精简预安装镜像：文件名为 tugraph-mini-runtime-ubuntu18.04-4.5.0.tar，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-ubuntu18.04-4.5.0.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-ubuntu18.04)。\n13. CentOS7 编译镜像：文件名为 tugraph-compile-centos7-1.3.2.tar，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-centos7-1.3.2.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-compile-centos7)。\n\n该块内容属于文档的安装部分，具体列出了针对 CentOS8 和 Ubuntu18.04 的精简预安装镜像以及 CentOS7 的编译镜像的详细信息，包括文件名、下载链接和访问链接。旨在为用户提供快速获取所需镜像的便利。"
            },
            {
                "content": "13. CentOS7 编译镜像：文件名为 tugraph-compile-centos7-1.3.2.tar，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-centos7-1.3.2.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-compile-centos7)。\n14. CentOS8 编译镜像：文件名为 tugraph-compile-centos8-1.3.2.tar，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-centos8-1.3.2.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-compile-centos8)。\n15. Ubuntu18.04 编译镜像：文件名为 tugraph-compile-ubuntu18.04-1.3.2.tar，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-ubuntu18.04-1.3.2.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-compile-ubuntu18.04)。\n\n该片段位于文档的安装部分，主要列出针对不同操作系统（CentOS7、CentOS8 和 Ubuntu18.04）的编译镜像信息，包括文件名、下载链接和访问链接。这部分内容旨在帮助用户快速找到并下载适用于各自操作系统的编译镜像。"
            },
            {
                "content": "总结： \n该表格列出了针对不同操作系统（CentOS7、CentOS8 和 Ubuntu18.04）的多个软件包和预装镜像的详细信息，包括标准版、精简版及相应的编译镜像，每种类型都提供了对应的下载链接和访问链接，方便用户快速访问和下载所需的资源。\n\n\n\n> 计算巢部署：可以在阿里云计算巢自行搜索，也可以通过部署链接(https://computenest.console.aliyun.com/user/cn-hangzhou/serviceInstanceCreate?ServiceId=service-7b50ea3d20e643da95bf&&isTrial=true)快速访问。\n\n### 2.1.通过docker快速体验\n\n1. 本地安装 docker 环境\n\n   参考 docker 官方文档：https://docs.docker.com/get-started/\n\n2. 拉取镜像\n   ```shell\n   docker pull tugraph/tugraph-runtime-centos7\n   ```\n\n3. 启动docker\n\n启动 TuGraph 服务可以通过两种方式来实现。第一种方式将镜像拉取与服务启动整合在一起，用户只需执行运行容器的操作，即可同时启动 TuGraph 服务。第二种方式则是在创建 TuGraph 容器后，手动进入容器内部以触发服务启动。尽管这种方法初期步骤稍显繁琐，但在如忘记密码的情况下，它提供了更灵活的密码重置选项。\n\n**方式一**\n\n该内容位于文档的安装部分，具体介绍了通过阿里云计算巢部署 TuGraph 的过程以及如何使用 Docker 快速体验 TuGraph 服务，包括软件包下载和服务启动的具体步骤。"
            },
            {
                "content": "### 2.1.通过docker快速体验\n\n1. 本地安装 docker 环境\n\n   参考 docker 官方文档：https://docs.docker.com/get-started/\n\n2. 拉取镜像\n   ```shell\n   docker pull tugraph/tugraph-runtime-centos7\n   ```\n\n3. 启动docker\n\n启动 TuGraph 服务可以通过两种方式来实现。第一种方式将镜像拉取与服务启动整合在一起，用户只需执行运行容器的操作，即可同时启动 TuGraph 服务。第二种方式则是在创建 TuGraph 容器后，手动进入容器内部以触发服务启动。尽管这种方法初期步骤稍显繁琐，但在如忘记密码的情况下，它提供了更灵活的密码重置选项。\n\n**方式一**\n\n   ```shell\n    docker run -d -p 7070:7070  -p 7687:7687 -p 9090:9090 -v /root/tugraph/data:/var/lib/lgraph/data  -v /root/tugraph/log:/var/log/lgraph_log \\\n    --name tugraph_demo ${REPOSITORY}:${VERSION}\n   \n   # ${REPOSITORY}是镜像地址，${VERSION}是版本号。\n   # 7070是默认的http端口，访问tugraph-db-browser使用。   \n   # 7687是bolt端口，bolt client访问使用。\n   # 9090是默认的rpc端口，rpc client访问使用。\n   # /var/lib/lgraph/data是容器内的默认数据目录，/var/log/lgraph_log是容器内的默认日志目录\n   # 命令将数据目录和日志目录挂载到了宿主机的/root/tugraph/上进行持久化，您可以根据实际情况修改。\n   ```\n\n**方式二**\n\n该内容位于文档的安装部分，具体介绍了通过 Docker 快速体验 TuGraph 的方法，包括如何安装 Docker 环境、拉取镜像以及启动 TuGraph 服务的两种方式。"
            },
            {
                "content": "**方式二**\n\n   ```shell\n    docker run -dt -p 7070:7070  -p 7687:7687 -p 9090:9090 -v /root/tugraph/data:/var/lib/lgraph/data  -v /root/tugraph/log:/var/log/lgraph_log \\\n    --name tugraph_demo ${REPOSITORY}:${VERSION} /bin/bash\n    \n    docker exec -it tugraph_demo bash\n    lgraph_server -c /usr/local/etc/lgraph.json -d start\n    \n   # ${REPOSITORY}是镜像地址，${VERSION}是版本号。\n   # 7070是默认的http端口，访问tugraph-db-browser使用。   \n   # 7687是bolt端口，bolt client访问使用。\n   # 9090是默认的rpc端口，rpc client访问使用。\n   # /var/lib/lgraph/data是容器内的默认数据目录，/var/log/lgraph_log是容器内的默认日志目录\n   # 命令将数据目录和日志目录挂载到了宿主机的/root/tugraph/上进行持久化，您可以根据实际情况修改。\n   ```\n\n5. 前端访问\n\n访问tugraph-db-browser: `http://x.x.x.x:7070`（7070 是 TuGraph Browser 的默认访问端口号），数据库地址格式为 `bolt://ip:bolt_port`（老版本不用填），默认用户名为 `admin`，密码为 `73@TuGraph`。\n首次登录会默认跳转修改密码页面，请尽快修改默认密码避免安全风险。\n\n该段落位于文档的“2.安装”部分，具体描述了通过 Docker 快速启动 TuGraph 服务的第二种方式，包括相关命令和前端访问信息。"
            },
            {
                "content": "5. 前端访问\n\n访问tugraph-db-browser: `http://x.x.x.x:7070`（7070 是 TuGraph Browser 的默认访问端口号），数据库地址格式为 `bolt://ip:bolt_port`（老版本不用填），默认用户名为 `admin`，密码为 `73@TuGraph`。\n首次登录会默认跳转修改密码页面，请尽快修改默认密码避免安全风险。   \n\n### 2.2.新旧前端说明\n进入容器，可以通过修改配置文件\"/usr/local/etc/lgraph.json\"中的\"web\"参数来选择使用老版本或新版本的前端。对于老版本，可以将\"web\"的值设为\"/usr/local/share/lgraph/resource\"；对于新版本，可以将\"web\"的值设为\"/usr/local/share/lgraph/browser-resource\"。完成配置文件的修改后，请执行命令 `docker restart tugraph` 以使更改生效。需要注意的是，新版本是默认选项。\n\n该内容位于文档的第二部分“安装”之下，主要介绍了如何通过 TuGraph 的前端访问服务，包括默认访问地址、数据库连接格式、初始登录用户名和密码，以及如何选择使用旧版或新版前端的配置方法。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_19.md",
        "chunks": [
            {
                "content": "# 名词解释\n\n## 1.图技术\n\n> __图计算__：广义图计算，技术上包括图查询、图分析、图学习；狭义图计算，包括图计算任务和图分析。\n\n> __图查询__：指图数据库的查询能力，通常通过Cypher/ISO GQL等查询语言实现。\n\n> __图分析__：侧重于对全图数据的算法分析、模式分析等。\n\n> __图学习__：与图神经网络、图机器学习含义相同。\n\n> __图智能__：等于广义图计算，包括图数据库、图分析、图学习，通常用于概念推广，不用于产品。\n\n## 2.图产品\n\n> __图计算系统__：一般包括图数据库、图分析系统、图学习系统，有时也特指图分析系统。\n\n> __图数据库__：侧重于对图数据的增删改查、事务性操作等，如TuGraph DB、Neo4j、JanusGraph等。\n\n> __图分析系统__：解决图分析问题，可以细分为流水图分析、离线图分析，如TuGraph Analytics、GraphX等。\n\n> __图学习系统__：解决图学习问题，比如TuGraph Learn、DGL等。\n\n## 3.具体概念\n\n\n> __Vertex__：点，也叫顶点，也指 Vertex Value。尽量避免Node（结点、节点）的叫法，一般用Node表示服务器个数，容易叫混。结点指结合、交结、交叉的意思；节点可以指一个时间线上的里程碑（关键节点）或计算机系统里的一个处理实体（如计算机网络里的一台服务器）。\n\n> __Edge__：边，也指 Edge Value。\n\n> __Vertex Label__：点类型，也叫 Vertex Type。\n\n> __Edge Label__：边类型，也叫 Edge Type。\n\n> __Degree__：度，入度/出度，表示一个点的入边、出边的条数。注意，在非图论的场景中，往往把“跳”也称作“度”。\n\n> __Hop__：跳，表示一个点到另一个点之间的路径经过的点数（不含起点、含终点）。算法性能测试里K-Hop即为此义。\n\n该文档主要介绍图技术、图产品及相关具体概念，涵盖图计算、图查询、图分析和图学习等内容，为深入理解图相关技术和系统提供了基础性定义和分类。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_20.md",
        "chunks": [
            {
                "content": "# 什么是图\n\n> 本文面向初学者，介绍图（Graph）的基本概念。\n\n我们今天介绍的图，是图论中使用点和边表示的图（Graph），而非图像的图（Image）。\n\n图的基本元素是点和边，其中点表示事物或实体，边表示点之间的关联关系。\n\n如上图左侧所示，点表示的有公司、员工、项目。边表示的是他们之间的关系，包括：公司和员工之间的雇佣关系，员工和员工之间的好友关系，项目和员工之间的参与关系。除此之外，点和边上可以附加属性，比如员工的工号，雇佣的时间，这样的图是属性图。也就是说，我们可以用图的方式来抽象地表示实体及其关联关系，图有非常丰富的表达能力。\n\n除了上述的员工图谱，图还可以用于金融、工业、医疗等各个领域。在实际应用中，图的规模越来越大，比如金融交易图，点边规模可能到达百亿，与其同时，基于图的查询通常会复杂，最典型的是K跳查询，每增加一跳访问的数据都呈指数增长。\n\n本文内容主要介绍图（Graph）的基本定义、构成元素（点和边）、以及它在不同领域中的应用与复杂查询特性，旨在为初学者提供基础知识。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_21.md",
        "chunks": [
            {
                "content": "# UDGA介绍\nUDGA（User Define Graph Algorithm）定义了一个图算法，例如SSSP（单源最短路径）和PageRank算法。\n## 接口\n\n```java\n/**\n * Interface for the User Defined Graph Algorithm.\n * @param  The id type for vertex.\n * @param  The message type for message send between vertices.\n */\npublic interface AlgorithmUserFunction extends Serializable {\n\n    /**\n     * Init method for the function\n     * @param context The runtime context.\n     * @param params  The parameters for the function.\n     */\n    void init(AlgorithmRuntimeContext context, Object[] params);\n\n    /**\n     * Processing method for each vertex and the messages it received.\n     */\n    void process(RowVertex vertex, Iterator messages);\n\n    /**\n     * Returns the output type for the function.\n     */\n    StructType getOutputType();\n}\n\n```\n\n## 示例\n\n```java\npublic class PageRank implements AlgorithmUserFunction {\n\n    private AlgorithmRuntimeContext context;\n    private double alpha = 0.85;\n    private double convergence = 0.01;\n    private int iteration = 20;\n\n该块内容介绍了用户定义图算法（UDGA）的接口及其示例实现，特别是PageRank算法，详细说明了算法的初始化、处理方法及输出类型。"
            },
            {
                "content": "```\n\n## 示例\n\n```java\npublic class PageRank implements AlgorithmUserFunction {\n\n    private AlgorithmRuntimeContext context;\n    private double alpha = 0.85;\n    private double convergence = 0.01;\n    private int iteration = 20;\n\n    @Override\n    public void init(AlgorithmRuntimeContext context, Object[] parameters) {\n        this.context = context;\n        if (parameters.length > 3) {\n            throw new IllegalArgumentException(\n                \"Only support zero or more arguments, false arguments \"\n                    + \"usage: func([alpha, [convergence, [max_iteration]]])\");\n        }\n        if (parameters.length > 0) {\n            alpha = Double.parseDouble(String.valueOf(parameters[0]));\n        }\n        if (parameters.length > 1) {\n            convergence = Double.parseDouble(String.valueOf(parameters[1]));\n        }\n        if (parameters.length > 2) {\n            iteration = Integer.parseInt(String.valueOf(parameters[2]));\n        }\n    }\n\n该块内容是关于UDGA（用户自定义图算法）中PageRank算法实现的示例代码，主要包括算法的初始化方法。在文档的前面部分介绍了UDGA的接口定义和功能，接着提供了具体的PageRank算法示例，展示其构造、初始化及参数设置的实现细节。"
            },
            {
                "content": "@Override\n    public void process(RowVertex vertex, Iterator messages) {\n        List outEdges = new ArrayList<>(context.loadEdges(EdgeDirection.OUT));\n        outEdges.addAll(context.loadEdges(EdgeDirection.BOTH));\n        if (context.getCurrentIterationId() == 1L) {\n            double initValue = 1.0;\n            sendMessageToNeighbors(outEdges, 1.0 / outEdges.size());\n            sendMessageToNeighbors(outEdges, -1.0);\n            context.updateVertexValue(ObjectRow.create(initValue));\n        } else if (context.getCurrentIterationId() <= iteration) {\n            double sum = 0.0;\n            while (messages.hasNext()) {\n                double input = (double) messages.next();\n                input = input > 0 ? input : 0.0;\n                sum += input;\n            }\n            double pr = (1 - alpha) + (sum * alpha);\n            double currentPr = (double) vertex.getValue().getField(0, \n\t\t\t\t\t\t\t\tDoubleType.INSTANCE);\n            if (Math.abs(currentPr - pr) > convergence) {\n\n该代码块位于UDGA（用户自定义图算法）文档中的PageRank算法实现部分，具体负责处理每个顶点及其接收到的消息。该方法计算PageRank值，并根据当前迭代更新顶点值或发送消息给邻居。"
            },
            {
                "content": "} else if (context.getCurrentIterationId() <= iteration) {\n            double sum = 0.0;\n            while (messages.hasNext()) {\n                double input = (double) messages.next();\n                input = input > 0 ? input : 0.0;\n                sum += input;\n            }\n            double pr = (1 - alpha) + (sum * alpha);\n            double currentPr = (double) vertex.getValue().getField(0, \n\t\t\t\t\t\t\t\tDoubleType.INSTANCE);\n            if (Math.abs(currentPr - pr) > convergence) {\n                sendMessageToNeighbors(outEdges, pr / outEdges.size());\n            }\n            sendMessageToNeighbors(outEdges, -1.0);\n            context.updateVertexValue(ObjectRow.create(pr));\n        } else {\n            double currentPr = (double) vertex.getValue().getField(0, \n\t\t\t\t\t\t\t\tDoubleType.INSTANCE);\n            context.take(ObjectRow.create(vertex.getId(), currentPr));\n            return;\n        }\n    }\n\n该代码块位于UDGA示例中的PageRank算法实现部分，具体负责处理每个顶点在算法迭代过程中的计算逻辑，包括消息汇总、PR值更新及收敛判断，以便于在多个迭代中逐步逼近最终的PageRank值。"
            },
            {
                "content": "@Override\n    public StructType getOutputType() {\n        return new StructType(\n            new TableField(\"id\", LongType.INSTANCE, false),\n            new TableField(\"pr\", DoubleType.INSTANCE, false)\n        );\n    }\n\n    private void sendMessageToNeighbors(List outEdges, Object message) {\n        for (RowEdge rowEdge : outEdges) {\n            context.sendMessage(rowEdge.getTargetId(), message);\n        }\n    }\n```\n\n```sql\nCREATE Function my_page_rank AS 'com.antgroup.geaflow.dsl.udf.graph.PageRank';\n\nINSERT INTO tbl_result\nCALL my_page_rank(1) YIELD (vid, prValue)\nRETURN vid, ROUND(prValue, 2)\n;\n```\n\n该块代码定义了PageRank算法中的输出类型和发送消息给邻居节点的方法，紧接着是一个示例SQL语句，它演示了如何创建该算法的函数并调用以计算页面排名。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_22.md",
        "chunks": [
            {
                "content": "# TuGraph 更新日志\n\n# 4.5.0 (2024-09-05)\n\n**重大变更:**\n\n1. cypher & gql ast统一完成，查询引擎全面升级。\n2. browser前端架构升级，支持图分析。\n\n**优化和错误修复:**\n1. cypher支持解析emoji符号。\n2. lgraph_cli输出执行计划格式优化。\n3. 优化可变长路径查询性能。\n4. 支持使用pair unique索引upsert边。\n5. cypher查询点边时支持map类型参数。\n\n**接口更变:**\n1. list plugin返回结果增加code type。\n2. 丰富algo procedure返回结果内容，支持输出到文件。\n3. 支持使用DataX导入TuGraph。\n\n\n# 4.3.2 (2024-07-25)\n\n**重大变更:**\n\n1. browser前端架构优化，并设置为默认前端。\n2. 初步支持向量数据类型。\n\n**优化和错误修复:**\n\n1. 修复边属性条件过滤不生效。\n2. 优化RPM包产出物的大小，去掉一些不再用的文件。\n3. cypher语句性能优化。\n4. 修复cypher order by报错。\n5. bolt客户端支持不强制设置graph名字。\n6. 文档修复。\n7. cypher & gql ast统一。\n\n**接口更变:**\n\n1. 内置最短路径存储过程支持多个边条件过滤。\n\n# 4.3.1 (2024-06-13)\n\n**重大变更:**\n\n1. 支持非唯一组合索引\n2. cypher支持GQL ASTNode解析链路\n3. 支持通过websocket进行Bolt数据传输\n\n**优化和错误修复:**\n\n1. 修复内置存储过程algo.native.extract\n2. 其他错误修复\n\n**接口更变:**\n\n1. lgraph_server启动时默认不打开增删procedure的功能，需配置enable_procedure为true才可增删procedure\n2. java client新增callCypher接口可返回header信息\n\n# 4.3.0 (2024-05-21)\n\n**重大变更:**\n\n1. DB-GPT中实现TuGraph上的知识图谱构建与检索\n2. DB-GPT支持TuGraph\n3. 属性分离模式下的schema变更优化，支持快速变更\n4. 支持组合索引\n\n该文档为TuGraph的更新日志，详细记录了各个版本的重大变更、优化与错误修复以及接口更变。其中，所提供的内容片段涵盖了4.5.0、4.3.2、4.3.1和4.3.0版本的更新信息，反映了查询引擎升级、前端架构优化、数据类型支持和接口调整等关键改进。"
            },
            {
                "content": "**接口更变:**\n\n1. 内置最短路径存储过程支持多个边条件过滤。\n\n# 4.3.1 (2024-06-13)\n\n**重大变更:**\n\n1. 支持非唯一组合索引\n2. cypher支持GQL ASTNode解析链路\n3. 支持通过websocket进行Bolt数据传输\n\n**优化和错误修复:**\n\n1. 修复内置存储过程algo.native.extract\n2. 其他错误修复\n\n**接口更变:**\n\n1. lgraph_server启动时默认不打开增删procedure的功能，需配置enable_procedure为true才可增删procedure\n2. java client新增callCypher接口可返回header信息\n\n# 4.3.0 (2024-05-21)\n\n**重大变更:**\n\n1. DB-GPT中实现TuGraph上的知识图谱构建与检索\n2. DB-GPT支持TuGraph\n3. 属性分离模式下的schema变更优化，支持快速变更\n4. 支持组合索引\n\n**优化和错误修复:**\n\n1. 新增内置存储过程：upsertVertexByJson、upsertEdgeByJson、createVertexLabelByJson、createEdgeLabelByJson、dropAllVertex\n2. 支持自定义HA模式下snapshot开始时间\n3. 新增地理类型数据相关内置函数\n4. 新增开发者说明文档\n5. 其他错误修复\n\n**接口更变:**\n\n1. 数据导入时默认为属性分离模式\n2. 启动参数新增`ha_first_snapshot_start_time`\n\n# 4.2.0 (2024-04-11)\n\n**重大变更:**\n\n1. 更新2024年的RoadMap\n2. 文档重构：更加清晰文档目录结构\n3. HA支持witness角色，并新增HA管理工具`lgraph_peer`\n4. bolt支持流式返回、参数化查询\n\n**优化和错误修复:**\n\n1. 错误码优化\n2. TuGraph-DB-Browser集成打包优化\n3. 支持HA模式下的全量快速在线导入\n4. 存储过程支持多个cpp文件上传\n5. Audit log变为Json形式\n6. 文档错误修复\n7. 其他错误修复\n\n**接口更变:**\n\n1. bolt支持流处理和参数化查询\n2. 存储过程支持多个cpp文件上传\n\n该chunk位于TuGraph的更新日志中，紧接着4.3.1版本的记录，涵盖了接口更变及其重大变更、优化和错误修复内容，同时也包含前一版本4.3.0和后续版本4.2.0的摘要信息。"
            },
            {
                "content": "**接口更变:**\n\n1. 数据导入时默认为属性分离模式\n2. 启动参数新增`ha_first_snapshot_start_time`\n\n# 4.2.0 (2024-04-11)\n\n**重大变更:**\n\n1. 更新2024年的RoadMap\n2. 文档重构：更加清晰文档目录结构\n3. HA支持witness角色，并新增HA管理工具`lgraph_peer`\n4. bolt支持流式返回、参数化查询\n\n**优化和错误修复:**\n\n1. 错误码优化\n2. TuGraph-DB-Browser集成打包优化\n3. 支持HA模式下的全量快速在线导入\n4. 存储过程支持多个cpp文件上传\n5. Audit log变为Json形式\n6. 文档错误修复\n7. 其他错误修复\n\n**接口更变:**\n\n1. bolt支持流处理和参数化查询\n2. 存储过程支持多个cpp文件上传\n\n# 4.1.0 (2023-12-25)\n\n**重大变更:**\n\n1. 兼容bolt协议，支持java/js/python/go/rust/cli客户端；\n\n2. 支持全量快速在线导入\n\n3. 支持异步任务管理\n\n4. 支持空间数据类型\n\n5. GQL功能演进\n\n**优化和错误修复:**\n\n1. 图学习引擎支持异构图\n\n2. 高可用支持异步存储快照\n\n3. 完善边索引，添加 pair-unique 唯一性\n\n4. 解耦KV层抽象\n\n5. 支持M1 Docker\n\n6. 优化CI&CD流程，显著缩短时间\n\n**接口更变:**\n\n1. 新增bolt协议标准\n\n2. 新增空间数据类型\n\n3. 索引中 is_unique 参数改用 IndexType 枚举，涉及 AddVertexIndex/AddEdgeIndex 接口；\n\n# 4.0.1 (2023-9-28)\n\n**重大变更:**\n\n1. 支持 Temporal 属性排序的升序和降序\n\n2. 添加 5 个图算法\n\n**优化和错误修复:**\n\n1. 修复Python存储过程不能立马kill的问题\n\n2. 类型名称支持 255 字节\n\n3. 其他错误修复\n\n**接口更变:**\n\n1. 修复 import.conf 中的 temporal 关键字\n\n# 4.0.0 (2023-9-6)\n\n**重大变更:**\n\n1. ISO GQL 标准查询语言支持\n\n2. 开源11个常用图算法\n\n**优化和错误修复:**\n\n该块内容位于TuGraph更新日志的4.2.0版本部分，主要描述了接口变更相关信息，包括数据导入模式和启动参数的更新。此外，它前后紧接着关于重大变更和优化修复的详细说明，特别是在HA支持和错误码优化等方面的增强。"
            },
            {
                "content": "**优化和错误修复:**\n\n1. 图学习引擎支持异构图\n\n2. 高可用支持异步存储快照\n\n3. 完善边索引，添加 pair-unique 唯一性\n\n4. 解耦KV层抽象\n\n5. 支持M1 Docker\n\n6. 优化CI&CD流程，显著缩短时间\n\n**接口更变:**\n\n1. 新增bolt协议标准\n\n2. 新增空间数据类型\n\n3. 索引中 is_unique 参数改用 IndexType 枚举，涉及 AddVertexIndex/AddEdgeIndex 接口；\n\n# 4.0.1 (2023-9-28)\n\n**重大变更:**\n\n1. 支持 Temporal 属性排序的升序和降序\n\n2. 添加 5 个图算法\n\n**优化和错误修复:**\n\n1. 修复Python存储过程不能立马kill的问题\n\n2. 类型名称支持 255 字节\n\n3. 其他错误修复\n\n**接口更变:**\n\n1. 修复 import.conf 中的 temporal 关键字\n\n# 4.0.0 (2023-9-6)\n\n**重大变更:**\n\n1. ISO GQL 标准查询语言支持\n\n2. 开源11个常用图算法\n\n**优化和错误修复:**\n\n1. 提供m1芯片的编译和运行Docker\n\n2. 前端支持丰富的探索功能\n\n3. 修复导入时的索引BUG\n\n4. 其他错误修复\n\n**接口更变:**\n\n1. Proto版本更新至1.2.0\n\n2. 客户端支持ISO GQL\n\n# 3.6.0 (2023-8-11)\n\n**重大变更:**\n\n1. 支持高可用组件\n\n2. 日志系统升级\n\n**优化和错误修复:**\n\n1. 修复令牌（Token）问题\n\n2. 更加友好的 CI 日志\n\n3. 支持微秒级的时间（Datetime）属性\n\n4. 其他错误修复\n\n# 3.5.1 (2023-7-14)\n\n**重大变更:**\n\n1. 支持图学习引擎\n\n2. 支持图属性和拓扑分离存储\n\n3. 支持 Rust 存储过程\n\n**优化和错误修复:**\n\n1. 将 fma-common 移动至 include\n\n2. 整合存储过程文档\n\n3. 新增点和边的实时统计\n\n4. 其他错误修复\n\n# 3.5.0 (2023-6-5)\n\n**重大变更:**\n\n1. 支持POG（APOC）\n\n2. 全新的可视化操作页面\n\n3. 全新的产品文档，支持 readthedocs\n\n**优化和错误修复:**\n\n该块内容位于TuGraph更新日志的4.1.0版本之后，涵盖了4.0.1和4.0.0版本的优化与错误修复以及接口更变，主要涉及高可用性、图学习引擎、空间数据类型的支持等重要更新和修复，反映了TuGraph在功能和性能方面的持续提升。"
            },
            {
                "content": "2. 前端支持丰富的探索功能\n\n3. 修复导入时的索引BUG\n\n4. 其他错误修复\n\n**接口更变:**\n\n1. Proto版本更新至1.2.0\n\n2. 客户端支持ISO GQL\n\n# 3.6.0 (2023-8-11)\n\n**重大变更:**\n\n1. 支持高可用组件\n\n2. 日志系统升级\n\n**优化和错误修复:**\n\n1. 修复令牌（Token）问题\n\n2. 更加友好的 CI 日志\n\n3. 支持微秒级的时间（Datetime）属性\n\n4. 其他错误修复\n\n# 3.5.1 (2023-7-14)\n\n**重大变更:**\n\n1. 支持图学习引擎\n\n2. 支持图属性和拓扑分离存储\n\n3. 支持 Rust 存储过程\n\n**优化和错误修复:**\n\n1. 将 fma-common 移动至 include\n\n2. 整合存储过程文档\n\n3. 新增点和边的实时统计\n\n4. 其他错误修复\n\n# 3.5.0 (2023-6-5)\n\n**重大变更:**\n\n1. 支持POG（APOC）\n\n2. 全新的可视化操作页面\n\n3. 全新的产品文档，支持 readthedocs\n\n**优化和错误修复:**\n\n1. 修复边索引错误\n\n2. 更新 antlr\n\n3. 其他错误修复\n\n# 3.4.0 (2023-3-11)\n\n**重大变更:**\n\n1. 支持图分析（OLAP） Python 接口（API）\n\n2. 全新的 lgraph_import\n\n3. 支持 DataX 导出\n\n**优化和错误修复:**\n\n1. 支持 4MB 的字符串（String）属性\n\n2. 更新 lgraph_result 的 json 文件格式\n\n3. 其他错误修复\n\n# 3.3.4 (2023-1-28)\n\n**重大变更:**\n\n1. 暂无\n\n**优化和错误修复:**\n\n1. 修复 WAL 同步错误\n\n2. 更新 Python REST 客户端\n\n3. 其他错误修复\n\n# 3.3.3 (2022-12-23)\n\n**重大变更:**\n\n1. 优化 WAL 性能\n\n2. 新增英文文档\n\n3. 更新 JWT 安全问题\n\n**优化和错误修复:**\n\n1. 修复边约束问题\n\n2. 支持 Ubuntu 的 Docker\n\n3. 支持使用 pthread 运行全文索引\n\n4. 其他错误修复\n\n# 3.3.2 (2022-11-21)\n\n**重大变更:**\n\n1. 支持 OGM\n\n该块内容位于TuGraph更新日志中，涵盖了版本3.6.0至3.3.2的重大变更、优化和错误修复，包括高可用组件支持、图学习引擎、Rust存储过程等功能的引入和改进。"
            },
            {
                "content": "3. 其他错误修复\n\n# 3.4.0 (2023-3-11)\n\n**重大变更:**\n\n1. 支持图分析（OLAP） Python 接口（API）\n\n2. 全新的 lgraph_import\n\n3. 支持 DataX 导出\n\n**优化和错误修复:**\n\n1. 支持 4MB 的字符串（String）属性\n\n2. 更新 lgraph_result 的 json 文件格式\n\n3. 其他错误修复\n\n# 3.3.4 (2023-1-28)\n\n**重大变更:**\n\n1. 暂无\n\n**优化和错误修复:**\n\n1. 修复 WAL 同步错误\n\n2. 更新 Python REST 客户端\n\n3. 其他错误修复\n\n# 3.3.3 (2022-12-23)\n\n**重大变更:**\n\n1. 优化 WAL 性能\n\n2. 新增英文文档\n\n3. 更新 JWT 安全问题\n\n**优化和错误修复:**\n\n1. 修复边约束问题\n\n2. 支持 Ubuntu 的 Docker\n\n3. 支持使用 pthread 运行全文索引\n\n4. 其他错误修复\n\n# 3.3.2 (2022-11-21)\n\n**重大变更:**\n\n1. 支持 OGM\n\n2. 提升 UT 覆盖率至 87%\n\n3. 支持使用静态库创建链接\n\n**优化和错误修复:**\n\n1. 更新 python 存储过程接口文档\n\n2. 更新文档\n\n3. 添加 khop 存储过程\n\n4. 其他错误修复\n\n# 3.3.1 (2022-10-14)\n\n**重大变更:**\n\n1. 优化图分析引擎\n\n2. Cypher 支持路径语法\n\n**优化和错误修复:**\n\n1. 修复 RWLock 错误\n\n2. 重写文档\n\n3. 清理 Dockerfile\n\n# 3.3.0 (2022-08-05)\n\n正式开源\n\n该块内容位于TuGraph的更新日志中，涵盖了3.3.0到3.4.0版本之间的重要变更、优化及错误修复的详细信息，主要涉及图分析功能、Python接口支持以及存储过程的增强，反映了该软件在不断发展的过程中针对用户反馈和技术需求的改进情况。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_23.md",
        "chunks": [
            {
                "content": "# State原理介绍\n\n## Geaflow 中的状态管理\nGeaflow 中的状态是指图、流计算过程中的直接计算节点的中间计算结果，此中间结果可能是经过组织后的源数据信息，也有可能是计算产生的一些结果。状态管理负责这些数据的存取以及一致性保障，它作为Geaflow数据中枢存在于系统中，它的功能模型、性能和可靠性直接影响着Geaflow的整个使用过程，是作为整个系统的底盘存在。\n\n* 从功能来看，它支持Geaflow实时、多模的动态图引擎，包括低延迟流图融合计算、高性能长周期图仿真、大规模动态图探索等等。\n* 从计算模型来看，Geaflow 中的状态管理属于实时模型和图模型的结合，需要克服实时计算中，带有状态的处理机制，时延低，容错和恢复机制；另外它也需要解决图模型中数据复杂、关联度高，计算由数据驱动、中间结果大等问题。\n* 从性能上看，状态管理需要解决在低成本，多场景、大规模数据的前提下实现高吞吐、低延迟的存储和查询能力。包括在万亿边的规模下的存取，较大的属性信息的存取，带有多种下推语义的随机访问和遍历访问等。\n\n为此，我们有如下的架构图，整体结构上灵活可变、支持多种可插拔组件。\n\n### 架构图\n\n本文档介绍了Geaflow中的状态管理原理，主要涵盖状态的定义、功能模型、计算模型、性能要求以及相关的架构设计，为理解Geaflow在图计算和流计算中的状态管理机制提供了基础。该节特别强调了状态管理在整体系统中的重要性，并列出了其核心功能和架构图的概述。"
            },
            {
                "content": "* 从功能来看，它支持Geaflow实时、多模的动态图引擎，包括低延迟流图融合计算、高性能长周期图仿真、大规模动态图探索等等。\n* 从计算模型来看，Geaflow 中的状态管理属于实时模型和图模型的结合，需要克服实时计算中，带有状态的处理机制，时延低，容错和恢复机制；另外它也需要解决图模型中数据复杂、关联度高，计算由数据驱动、中间结果大等问题。\n* 从性能上看，状态管理需要解决在低成本，多场景、大规模数据的前提下实现高吞吐、低延迟的存储和查询能力。包括在万亿边的规模下的存取，较大的属性信息的存取，带有多种下推语义的随机访问和遍历访问等。\n\n为此，我们有如下的架构图，整体结构上灵活可变、支持多种可插拔组件。\n\n### 架构图\n\n* **State API**：提供了面向KV存储API，如get/put/delete等。以及面向图存储的API，如V/E/VE，以及点/边的add/update/delete等。\n* **State执行层**：通过KeyGroup的设计实现数据的Sharding和扩缩容能力，Accessor提供了面向不同读写策略和数据模型的IO抽象，StateOperator抽象了存储层SPI，如finish（刷盘）、archive（Checkpoint）、compact（压缩）、recover（恢复）等。另外，State提供了多种PushDown优化以加速IO访问效率。通过自定义内存管理和面向属性的二级索引也会提供大量的存储访问优化手段。\n* **Store层**：GeaFlow支持了多种存储系统类型，并通过StoreContext封装了Schema、序列化器，以及数据版本信息。这层涉及到内存数据结构如何真正映射到存储结构上。目前包括Redis、Rocksdb、CStore（GeaFlow自建存储系统）等存储引擎，各种不同的存储引擎通过SPI来提供服务，另外根据存储引擎的特点，他们可支持的数据模型可能不同，例如对Rocksdb所有的数据结构都需要映射到KV，而Redis天生就提供list/map等高阶的数据结构。\n* **持久化层**：GeaFlow State本身不提供持久化的能力，如果机器发生故障，磁盘损坏可能就会导致数据丢失。因此它需要依赖外部的组件来提供持久化存储，这里组件也是可插拔的，支持 HDFS/OSS/S3等分布式文件存储或对象存储。\n\n## State 运行流程\n\n该段落介绍了Geaflow中状态管理的功能、计算模型和性能需求，并引入了整体架构图。此段落位于文档的开头部分，为后续详细讨论状态的创建、读写、持久化和恢复流程奠定基础。"
            },
            {
                "content": "## State 运行流程\n\n当FailOver的时候，会从最近一个持久化的数据恢复，以下是在作业运行期间State的详细生命流程：\n\n### State创建\n\nState所处理的数据已经是每个分区维度的，也就是已经经过框架层分好片了。\n\n所有的State申请的入口都是StateFactory，可以根据不同的Descriptor申请不同的State。\n```java\nbuildGraphState(GraphStateDescriptor, Configuration):GraphState\nbuildKeyValueState(KeyValueStateDescriptor, Configuration):KeyValueState\nbuildKeyListState(KeyListDescriptor, Configuration):KeyListState\nbuildKeyMapState(KeyMapStateDescriptor, Configuration):KeyMapState\n```\n\nDescriptor 中需要申明基本的信息，包括State name，Store type等。不同的state name对应的 state 是相互隔离的，可以申请不同的 State 表示不同的场景，例如可以申请一个Memory Store State作为临时存储或者计算中介。\n\nStore type 的选择与存储性能也息息相关，例如对于Key State，如果底层Store支持 KMap 的方式则会直接使用到KMap的功能，可以进行增量的subkey操作；如果不支持则会转为 KV 模型的State，会对 Map 整体进行操作，这样无论读还是写都会放大很多。\n\n在创建完成后，我们还需要对state读写。\n\n### State 读写\n\n根据上文申请的不同State类型，具有不同的读写方式，文末部分会有介绍。\n\n### State 持久化\n在某一个计算任务中，如果有异常信息发生，例如机器故障，那么磁盘上存储的状态数据都会丢失。为了能够正常回滚，State还需要考虑持久化的能力，这样重新分配的机器可以拉取State数据继续进行计算。\n\n该段落介绍了Geaflow中State的运行流程，包括State的创建、读写和持久化机制，重点强调在故障发生时如何从持久化数据中恢复，以及不同State类型的应用场景和性能影响。"
            },
            {
                "content": "Descriptor 中需要申明基本的信息，包括State name，Store type等。不同的state name对应的 state 是相互隔离的，可以申请不同的 State 表示不同的场景，例如可以申请一个Memory Store State作为临时存储或者计算中介。\n\nStore type 的选择与存储性能也息息相关，例如对于Key State，如果底层Store支持 KMap 的方式则会直接使用到KMap的功能，可以进行增量的subkey操作；如果不支持则会转为 KV 模型的State，会对 Map 整体进行操作，这样无论读还是写都会放大很多。\n\n在创建完成后，我们还需要对state读写。\n\n### State 读写\n\n根据上文申请的不同State类型，具有不同的读写方式，文末部分会有介绍。\n\n### State 持久化\n在某一个计算任务中，如果有异常信息发生，例如机器故障，那么磁盘上存储的状态数据都会丢失。为了能够正常回滚，State还需要考虑持久化的能力，这样重新分配的机器可以拉取State数据继续进行计算。\n\n在每个计算任务中，用户需要定期做checkpoint，持久化数据来保证状态数据安全。可以在某批任务结束后做，也可以在导数任务完成后，此处的时机应该和source offset保持一致，只有state checkpoint以及source offset都保存完成才说明这个作业的所有状态数据都持久化。\n\n### State 恢复\n\n当异常发生时，框架层会进行FailOver, state也会自动回滚到最新的状态。根据上述持久层的选择不同，会从相应的分布式文件存储或对象存储拉取State数据并加载。\n\n\n## State 类型\n\nState大体可以区分为Graph State 和 Key State，分别对应不同的数据结构，同时映射到Store层的不同存储模型，例如对于rocksdb 的 store type，将会有KV、Graph等不同类型的存储模型。\n\n### Graph State\n\nGraphState根据是否是动态图，我们又区分 StaticGraph 和 DynamicGraph。\n区别在于 StaticGraph将整个图看做是一个完整的，所有操作都在一个完整图上进行。\n而DynamicGraph认为图动态变化的，由一个个切片图构成，所有切片构成一个完整的图。\n\n该段落介绍了Geaflow中状态管理的关键组成部分，重点讲述了State Descriptor的基本信息声明、不同存储类型对性能的影响、状态的读写过程、持久化和恢复机制，以及状态类型的分类，包括Graph State和Key State。这些内容在文档中属于状态管理功能的详细说明，帮助用户理解如何有效地管理和操作Geaflow中的状态数据。"
            },
            {
                "content": "### State 恢复\n\n当异常发生时，框架层会进行FailOver, state也会自动回滚到最新的状态。根据上述持久层的选择不同，会从相应的分布式文件存储或对象存储拉取State数据并加载。\n\n\n## State 类型\n\nState大体可以区分为Graph State 和 Key State，分别对应不同的数据结构，同时映射到Store层的不同存储模型，例如对于rocksdb 的 store type，将会有KV、Graph等不同类型的存储模型。\n\n### Graph State\n\nGraphState根据是否是动态图，我们又区分 StaticGraph 和 DynamicGraph。\n区别在于 StaticGraph将整个图看做是一个完整的，所有操作都在一个完整图上进行。\n而DynamicGraph认为图动态变化的，由一个个切片图构成，所有切片构成一个完整的图。\n\n\n#### Static Graph State\nStaticGraphState API分成不同的几个部分，包括query、upsert、delete、manage。\n\n* query即图查询，允许用户灵活的查询GraphStatte，可以从点、边、点以及出边等多个角度进行查询，可以是随机查询、也可以是全局查询，可以增加不同的pushdown条件等等。最后的返回值也可以是迭代器或者list。\n\n* upsert即增加点或者边\n\n* delete可以删除某个点或者id。\n\n* manage分成operator以及其他操作，operator是对state的数据操作，可以进行刷盘持久化或者恢复。其他操作包括summary以及metrics等信息的获取。\n\n\n#### Dynamic Graph State\nDynamicGraphState API 与 StaticGraphState 类似，但是每个点和边都会和一个版本号绑定。\n\n于此同时，DynamicGraphState还增加了版本信息相关的查询，可以获取某些点对应的所有版本或者最新版本，以及可以获取每个版本的具体值。\n\n\n### Key State\nKeyState API分成几个部分，包括\n* KeyValueState\n* KeyListState\n* KeyMapState。\n\n该chunk主要介绍了Geaflow中的状态恢复机制以及不同类型的状态，包括Graph State和Key State。这部分紧接在状态管理的流程描述之后，详细阐述了状态的恢复过程，类型区分以及各自的API功能，为理解Geaflow状态管理的整体架构和功能提供了重要信息。"
            },
            {
                "content": "* query即图查询，允许用户灵活的查询GraphStatte，可以从点、边、点以及出边等多个角度进行查询，可以是随机查询、也可以是全局查询，可以增加不同的pushdown条件等等。最后的返回值也可以是迭代器或者list。\n\n* upsert即增加点或者边\n\n* delete可以删除某个点或者id。\n\n* manage分成operator以及其他操作，operator是对state的数据操作，可以进行刷盘持久化或者恢复。其他操作包括summary以及metrics等信息的获取。\n\n\n#### Dynamic Graph State\nDynamicGraphState API 与 StaticGraphState 类似，但是每个点和边都会和一个版本号绑定。\n\n于此同时，DynamicGraphState还增加了版本信息相关的查询，可以获取某些点对应的所有版本或者最新版本，以及可以获取每个版本的具体值。\n\n\n### Key State\nKeyState API分成几个部分，包括\n* KeyValueState\n* KeyListState\n* KeyMapState。\n\n\n分别对应不同的用户层数据结构。与GraphState类似，KeyState同样提供 query/upsert/delete/manage的能力，但query没有类似GraphState的接口提供复杂的查询语义信息。不同的State数据结构在查询和存储上有差异，例如kmap允许对单个subkey修改和查询，而kv是是整个value进行修改和查询。\n\n该片段位于文档的“State类型”部分，主要介绍了图状态（Graph State）和键状态（Key State）的API及其功能。具体描述了静态图状态和动态图状态的查询、更新、删除及管理操作，并对键状态的不同类型进行了概述。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_24.md",
        "chunks": [
            {
                "content": "# 安装minikube\n\n这里以minikube为例，单机模拟K8S集群。如果已有K8S集群可以直接使用，跳过该部分。\n\n\n下载安装minikube\n```\n# arm架构\ncurl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-darwin-arm64\nsudo install minikube-darwin-arm64 /usr/local/bin/minikube\n\n# x86架构\ncurl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-darwin-amd64\nsudo install minikube-darwin-amd64 /usr/local/bin/minikube\n```\n\n启动minikube和dashboard\n```\n# 以docker为driver启动minikube\nminikube start --driver=docker --ports=32761:32761 —image-mirror-country='cn'\n# 启动minikube dashboard，会自动在浏览器中打开dashboard页面，如未打开复制终端给出的dashboard地址到浏览器打开\nminikube dashboard\n```\n\n**注意：**\n注意不要关闭dashboard所属的terminal进程，后续操作请另起终端进行，否则api server进程会退出\n\n如果希望在本地minikube环境使用GeaFlow，请确保minikube正常启动，GeaFlow引擎镜像会自动构建到minikube环境，否则构建到本地Docker环境，需要手工自行push到镜像仓库使用。\n```shell\n# confirm host、kubelet、apiserver is running\nminikube status\n```\n\n本文主要介绍如何在本地安装和配置minikube，以便模拟一个单机Kubernetes集群。如果已经有Kubernetes集群，用户可以跳过该部分。文中详细说明了minikube的下载安装步骤、启动方法以及如何访问dashboard，并提供了注意事项和状态确认的命令。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_25.md",
        "chunks": [
            {
                "content": "# 日志信息\n\n> 此文档主要介绍 TuGraph 的日志功能。\n\n## 1.简介\n\nTuGraph 保留两种类型的日志：服务器日志和审计日志。服务器日志记录人为可读的服务器状态信息，而审核日志维护服务器上执行的每个操作加密后的信息。\n\n## 2.服务器日志\n\n### 2.1.服务器日志配置项\n\n服务器日志的输出位置可以通过`log_dir`配置指定。服务器日志详细程度可通过`verbose`配置项指定。\n\n`log_dir`配置项默认为空。若`log_dir`配置项为空，则所有日志会输出到控制台(daemon模式下若log_dir配置项为空则不会向console输出任何日志)；若手动指定`log_dir`配置项，则日志文件会生成在对应的路径下面。单个日志文件最大大小为256MB。\n\n`verbose`配置项控制日志的详细程度，从粗到细分为`0, 1, 2`三个等级，默认等级为`1`。等级为`2`时，日志记录最详细，服务器将打印`DEBUG`及以上等级的全部日志信息；等级为`1`时，服务器将仅打印`INFO`等级及以上的主要事件的日志；等级为`0`时，服务器将仅打印`ERROR`等级及以上的错误日志。\n\n### 2.2.服务器日志输出宏使用示例\n\n如果开发者在开发过程中希望在代码中添加日志，可以参考如下示例\n\n```\n#include \"tools/lgraph_log.h\" //添加日志依赖\n\n该文档介绍了 TuGraph 的日志功能，包括服务器日志和审计日志的概述、配置项以及示例。当前的片段详细说明了服务器日志的配置选项和输出示例，适合开发者在代码中添加日志功能。"
            },
            {
                "content": "## 2.服务器日志\n\n### 2.1.服务器日志配置项\n\n服务器日志的输出位置可以通过`log_dir`配置指定。服务器日志详细程度可通过`verbose`配置项指定。\n\n`log_dir`配置项默认为空。若`log_dir`配置项为空，则所有日志会输出到控制台(daemon模式下若log_dir配置项为空则不会向console输出任何日志)；若手动指定`log_dir`配置项，则日志文件会生成在对应的路径下面。单个日志文件最大大小为256MB。\n\n`verbose`配置项控制日志的详细程度，从粗到细分为`0, 1, 2`三个等级，默认等级为`1`。等级为`2`时，日志记录最详细，服务器将打印`DEBUG`及以上等级的全部日志信息；等级为`1`时，服务器将仅打印`INFO`等级及以上的主要事件的日志；等级为`0`时，服务器将仅打印`ERROR`等级及以上的错误日志。\n\n### 2.2.服务器日志输出宏使用示例\n\n如果开发者在开发过程中希望在代码中添加日志，可以参考如下示例\n\n```\n#include \"tools/lgraph_log.h\" //添加日志依赖\n\n\nvoid LogExample() {\n    // 数据库启动阶段已经对日志模块进行了初始化，开发者只需直接调用宏即可\n    // 日志等级分为DEBUG, INFO, WARNING, ERROR, FATAL五个等级\n    LOG_DEBUG() << \"This is a debug level log message.\";\n    LOG_INFO() << \"This is a info level log message.\";\n    LOG_WARN() << \"This is a warning level log message.\";\n    LOG_ERROR() << \"This is a error level log message.\";\n    LOG_FATAL() << \"This is a fatal level log message.\";\n}\n```\n更多用法可以参考test/test_lgraph_log.cpp中的日志宏的使用方法\n\n### 2.3.存储过程日志\n\n该文档主要介绍 TuGraph 的日志功能，其中第2部分详细说明了服务器日志的配置、输出示例和存储过程日志的使用，为开发者提供了如何记录和管理日志信息的指导。"
            },
            {
                "content": "```\n#include \"tools/lgraph_log.h\" //添加日志依赖\n\n\nvoid LogExample() {\n    // 数据库启动阶段已经对日志模块进行了初始化，开发者只需直接调用宏即可\n    // 日志等级分为DEBUG, INFO, WARNING, ERROR, FATAL五个等级\n    LOG_DEBUG() << \"This is a debug level log message.\";\n    LOG_INFO() << \"This is a info level log message.\";\n    LOG_WARN() << \"This is a warning level log message.\";\n    LOG_ERROR() << \"This is a error level log message.\";\n    LOG_FATAL() << \"This is a fatal level log message.\";\n}\n```\n更多用法可以参考test/test_lgraph_log.cpp中的日志宏的使用方法\n\n### 2.3.存储过程日志\n\n用户在存储过程的编写过程中可以使用日志功能将所需的调试信息输出到日志中进行查看，辅助开发。调试信息会输出到与服务器日志相同的日志文件中(如未指定`log_dir`则同样输出至console)\n\n#### 2.3.1.cpp存储过程\n请使用2.2中提供的log宏输出调试信息，避免使用cout或者printf等输出方式。具体使用方式可参考如下示例代码（详见`procedures/demo/log_demo.cpp`）\n\n```\n#include \n#include \"lgraph/lgraph.h\"\n#include \"tools/lgraph_log.h\"  // add log dependency\nusing namespace lgraph_api;\n\n此代码块展示了在 TuGraph 中如何使用日志宏记录调试信息，特别是在 C++ 存储过程中进行日志记录的示例。它位于文档的第二章中，紧接着服务器日志输出宏的用法部分，并为用户提供了在开发中如何有效地记录日志的指导。"
            },
            {
                "content": "### 2.3.存储过程日志\n\n用户在存储过程的编写过程中可以使用日志功能将所需的调试信息输出到日志中进行查看，辅助开发。调试信息会输出到与服务器日志相同的日志文件中(如未指定`log_dir`则同样输出至console)\n\n#### 2.3.1.cpp存储过程\n请使用2.2中提供的log宏输出调试信息，避免使用cout或者printf等输出方式。具体使用方式可参考如下示例代码（详见`procedures/demo/log_demo.cpp`）\n\n```\n#include \n#include \"lgraph/lgraph.h\"\n#include \"tools/lgraph_log.h\"  // add log dependency\nusing namespace lgraph_api;\n\nvoid LogExample() {\n    LOG_DEBUG() << \"This is a debug level log message.\";\n    LOG_INFO() << \"This is a info level log message.\";\n    LOG_WARN() << \"This is a warning level log message.\";\n    LOG_ERROR() << \"This is a error level log message.\";\n}\n\nextern \"C\" bool Process(GraphDB& db, const std::string& request, std::string& response) {\n    response = \"TuGraph log demo\";\n    LogExample();\n    return true;\n}\n```\n将以上示例代码作为存储过程插入数据库并运行后，可以在日志文件中看到相应的日志条目。\n\n#### 2.3.1.python存储过程\n请使用python自带的print输出调试信息，调试信息会在存储过程运行结束后合并为一条WARN等级的日志条目输出至日志文件中。\n\n## 3.审计日志\n\n审核日志记录每个请求和响应，以及发送请求的用户以及收到请求的时间。审核日志只能是打开或关闭状态。可以使用 TuGraph 可视化工具和 REST API 查询结果。\n\n此块内容位于文档的第二部分，主要讲述存储过程日志的功能及使用方法，包括如何在C++和Python存储过程中输出调试信息，并说明这些信息如何记录在日志文件中。"
            },
            {
                "content": "extern \"C\" bool Process(GraphDB& db, const std::string& request, std::string& response) {\n    response = \"TuGraph log demo\";\n    LogExample();\n    return true;\n}\n```\n将以上示例代码作为存储过程插入数据库并运行后，可以在日志文件中看到相应的日志条目。\n\n#### 2.3.1.python存储过程\n请使用python自带的print输出调试信息，调试信息会在存储过程运行结束后合并为一条WARN等级的日志条目输出至日志文件中。\n\n## 3.审计日志\n\n审核日志记录每个请求和响应，以及发送请求的用户以及收到请求的时间。审核日志只能是打开或关闭状态。可以使用 TuGraph 可视化工具和 REST API 查询结果。\n\n开启审计日志需要在配置文件中将`enable_audit_log`参数设置为`true`。\n\n该块内容位于文档的第二部分 \"服务器日志\" 的子部分 \"2.3.存储过程日志\" 中，具体示例展示了如何在 C++ 存储过程中使用日志功能，并说明了如何记录日志信息以便于调试。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_26.md",
        "chunks": [
            {
                "content": "# Docker部署（基于Docker方式快速部署TuGraph）\n\n>本文档介绍TuGraph Compile及TuGraph Runtime的Docker镜像的创建、下载。\n\n## 1.简介\n\n- TuGraph Compile Image：提供编译环境，可以用于TuGraph的编译，测试；\n- TuGraph Runtime Image：提供二进制可运行环境，附带TuGraph库和可执行文件；\n- TuGraph Mini Runtime Image: 提供二进制可运行环境，不包含TuGraph中Java、Python相关的功能，无C++ plugin编译运行，仅so上传。\n\n## 2.现有Docker Image\n\n### 2.1.镜像下载方式\n\n镜像托管在DockerHub(https://hub.docker.com/u/tugraph)，可直接下载使用。\n\n### 2.2.命名规范\n\n#### 2.2.1.TuGraph Compile Image\n\n提供编译环境，可以用于TuGraph的编译。\n\n`tugraph/tugraph-compile-[os name & version]:[tugraph compile version]`\n\n例如： `tugraph/tugraph-compile-centos7:1.2.0`\n\n#### 2.2.2.TuGraph Runtime Image\n\n提供二进制可运行环境，附带TuGraph库和可执行文件。\n\n`tugraph/tugraph-runtime-[os name & version]:[tugraph-runtime version]`\n\n例如：`tugraph/tugraph-runtime-centos7:3.4.0`\n\n#### 2.2.3.TuGraph Mini Runtime Image\n\n提供二进制可运行环境，不包含TuGraph种Java、Python相关的功能，无C++ plugin编译运行，仅so上传。\n\n`tugraph/tugraph-mini-runtime-[os name & version]:[tugraph-runtime version]`\n\n例如： `tugraph/tugraph-mini-runtime-centos7:3.4.0`\n\n### 2.3.常见Docker操作\n\n该文档主要介绍了TuGraph的Docker镜像，包括编译和运行环境的创建与下载方法。所选的内容首先定义了TuGraph的不同镜像类型及其用途，接着说明了镜像的下载方式和命名规范，并列出了TuGraph Compile、Runtime以及Mini Runtime的详细命名格式和示例。在这一部分中，还涵盖了常见的Docker操作，帮助用户快速上手使用TuGraph的Docker镜像。"
            },
            {
                "content": "例如： `tugraph/tugraph-compile-centos7:1.2.0`\n\n#### 2.2.2.TuGraph Runtime Image\n\n提供二进制可运行环境，附带TuGraph库和可执行文件。\n\n`tugraph/tugraph-runtime-[os name & version]:[tugraph-runtime version]`\n\n例如：`tugraph/tugraph-runtime-centos7:3.4.0`\n\n#### 2.2.3.TuGraph Mini Runtime Image\n\n提供二进制可运行环境，不包含TuGraph种Java、Python相关的功能，无C++ plugin编译运行，仅so上传。\n\n`tugraph/tugraph-mini-runtime-[os name & version]:[tugraph-runtime version]`\n\n例如： `tugraph/tugraph-mini-runtime-centos7:3.4.0`\n\n### 2.3.常见Docker操作\n\nDocker由Dockerfile生成，注意创建镜像需要下载依赖，因此网络问题可能会导致创建较慢或者创建失败。注意不要覆盖镜像，除非tag为 `latest`。\n\n创建Compile镜像\n```bash\ndocker build -f tugraph-compile-centos7-Dockerfile -t tugraph/tugraph-compile-centos7:1.2.0 .\n```\n\n创建Runtime / Mini Runtine镜像\n```bash\ndocker build --build-arg FILEPATH=\"${rpm_path_in_oss}\" --build-arg FILENAME=\"${rpm_name}\" -f tugraph-compile-centos7-Dockerfile -t tugraph/tugraph-runtime-centos7:1.2.0 .\n```\n\n修改镜像名称\n```bash\ndocker tag ${image_name}:${image_tag} tugraph/tugraph-runtime-centos7:3.3.0\n```\n\n该块内容位于文档的第二部分，具体介绍了TuGraph的不同Docker镜像类型，包括Compile镜像、Runtime镜像和Mini Runtime镜像的命名规范及示例。此外，还列出了常见的Docker操作命令，如创建、修改镜像等，帮助用户快速上手和使用TuGraph的Docker镜像。"
            },
            {
                "content": "Docker由Dockerfile生成，注意创建镜像需要下载依赖，因此网络问题可能会导致创建较慢或者创建失败。注意不要覆盖镜像，除非tag为 `latest`。\n\n创建Compile镜像\n```bash\ndocker build -f tugraph-compile-centos7-Dockerfile -t tugraph/tugraph-compile-centos7:1.2.0 .\n```\n\n创建Runtime / Mini Runtine镜像\n```bash\ndocker build --build-arg FILEPATH=\"${rpm_path_in_oss}\" --build-arg FILENAME=\"${rpm_name}\" -f tugraph-compile-centos7-Dockerfile -t tugraph/tugraph-runtime-centos7:1.2.0 .\n```\n\n修改镜像名称\n```bash\ndocker tag ${image_name}:${image_tag} tugraph/tugraph-runtime-centos7:3.3.0\n```\n\n上传镜像\n```bash\ndocker push tugraph/tugraph-compile-centos7:1.2.0 .\n```\n\n获取镜像\n```bash\ndocker pull tugraph/tugraph-compile-centos7:1.2.0\n```\n\n导出镜像\n```bash\ndocker save ${image_name}:${image_tag} | gzip > lgraph_latest.tar.gz\n```\n\n导入镜像\n```bash\ndocker load --input lgraph_latest.tar.gz\n```\n\n其他Docker操作请参考docker官方文档(https://docs.docker.com/engine/reference/commandline/cli )\n\n\n### 2.4. M1芯片支持\n\n在 M1 芯片的机器上运行 amd64 容器可能造成未知错误。TuGraph提供 arm64 的镜像供 M1 机器使用。\n包含compile和runtime两种镜像。\n\n该块内容位于文档的“现有Docker Image”部分，主要介绍了Docker镜像的创建、上传、下载和管理操作，包括编译镜像和运行时镜像的具体命令。同时，提到M1芯片机器对不同架构镜像的支持，确保用户在构建和使用TuGraph Docker镜像时的兼容性和效率。"
            },
            {
                "content": "上传镜像\n```bash\ndocker push tugraph/tugraph-compile-centos7:1.2.0 .\n```\n\n获取镜像\n```bash\ndocker pull tugraph/tugraph-compile-centos7:1.2.0\n```\n\n导出镜像\n```bash\ndocker save ${image_name}:${image_tag} | gzip > lgraph_latest.tar.gz\n```\n\n导入镜像\n```bash\ndocker load --input lgraph_latest.tar.gz\n```\n\n其他Docker操作请参考docker官方文档(https://docs.docker.com/engine/reference/commandline/cli )\n\n\n### 2.4. M1芯片支持\n\n在 M1 芯片的机器上运行 amd64 容器可能造成未知错误。TuGraph提供 arm64 的镜像供 M1 机器使用。\n包含compile和runtime两种镜像。\n\n在`tugraph-runtime-centos7:3.6.0`与`tugraph-compile-centos7:1.2.7`及之后，`tugraph-runtime-centos7`与`tugraph-compile-centos7`提供linux/amd64和linux/arm64/v8两种架构的镜像，可以在 M1 机器上通过docker pull获取arm64架构镜像。\n\n### 2.5. 运行服务\n\n1. 拉取镜像\n   ```shell\n   docker pull tugraph/tugraph-runtime-centos7:${VERSION}\n   ```\n\n2. 启动docker\n\n该段落位于文档的第二部分，主要介绍常见的Docker操作，包括上传、获取、导出和导入镜像的命令，以及对于在M1芯片机器上运行容器的支持信息，并继续到运行TuGraph服务的步骤。这部分内容为用户提供了在使用Docker部署TuGraph时所需的基本操作指南。"
            },
            {
                "content": "其他Docker操作请参考docker官方文档(https://docs.docker.com/engine/reference/commandline/cli )\n\n\n### 2.4. M1芯片支持\n\n在 M1 芯片的机器上运行 amd64 容器可能造成未知错误。TuGraph提供 arm64 的镜像供 M1 机器使用。\n包含compile和runtime两种镜像。\n\n在`tugraph-runtime-centos7:3.6.0`与`tugraph-compile-centos7:1.2.7`及之后，`tugraph-runtime-centos7`与`tugraph-compile-centos7`提供linux/amd64和linux/arm64/v8两种架构的镜像，可以在 M1 机器上通过docker pull获取arm64架构镜像。\n\n### 2.5. 运行服务\n\n1. 拉取镜像\n   ```shell\n   docker pull tugraph/tugraph-runtime-centos7:${VERSION}\n   ```\n\n2. 启动docker\n\n   ```shell\n    docker run -d -p 7070:7070  -p 7687:7687 -p 9090:9090 -v /root/tugraph/data:/var/lib/lgraph/data  -v /root/tugraph/log:/var/log/lgraph_log \\\n    --name tugraph_demo ${REPOSITORY}:${VERSION}\n   \n   # ${REPOSITORY}是镜像地址，${VERSION}是版本号。\n   # 7070是默认的http端口，访问tugraph-db-browser使用。   \n   # 7687是bolt端口，bolt client访问使用。\n   # 9090是默认的rpc端口，rpc client访问使用。\n   # /var/lib/lgraph/data是容器内的默认数据目录，/var/log/lgraph_log是容器内的默认日志目录\n   # 命令将数据目录和日志目录挂载到了宿主机的/root/tugraph/上进行持久化，您可以根据实际情况修改。\n   ```\n\n这段内容位于文档的第2部分，主要介绍Docker镜像的使用，包括对M1芯片支持的说明以及如何运行TuGraph服务的具体步骤。它提供了关于适用于不同架构的镜像信息和运行服务的命令示例。"
            },
            {
                "content": "```shell\n    docker run -d -p 7070:7070  -p 7687:7687 -p 9090:9090 -v /root/tugraph/data:/var/lib/lgraph/data  -v /root/tugraph/log:/var/log/lgraph_log \\\n    --name tugraph_demo ${REPOSITORY}:${VERSION}\n   \n   # ${REPOSITORY}是镜像地址，${VERSION}是版本号。\n   # 7070是默认的http端口，访问tugraph-db-browser使用。   \n   # 7687是bolt端口，bolt client访问使用。\n   # 9090是默认的rpc端口，rpc client访问使用。\n   # /var/lib/lgraph/data是容器内的默认数据目录，/var/log/lgraph_log是容器内的默认日志目录\n   # 命令将数据目录和日志目录挂载到了宿主机的/root/tugraph/上进行持久化，您可以根据实际情况修改。\n   ```\n\n## 3. 使用和开发TuGraph-DB Docker镜像时的最佳实践\n\n在您刚开始为TuGraph做出贡献时，请仔细阅读以下要点，并遵循它们。\n\n- 为了避免过多的Docker Layer，请尽量像现有的Dockerfile一样单行的写ENV和RUN将您的依赖项添加到Docker中。\n- 对于您需要构建依赖项的软件包/资源，请使用原始的软件包/资源，而不是在没有VCS跟踪的情况下修改这些资源。之后联系TuGraph团队将其上传到OSS以加速构建过程，如同您在Dockerfiles中看到的URL一样。\n- 为了使开发更加高效，最好从Base TuGraph编译镜像添加依赖项开始，完成开发确认依赖没问题后在Dockerfile中重新复制该过程。\n- CI使用了Docker镜像。如果您的CI失败，请检查依赖项问题。\n\n该代码块位于文档的第2.5节，主要介绍如何在Docker中运行TuGraph服务的命令及其参数说明，包括端口映射、数据和日志目录的挂载等配置。这段内容对于用户在使用TuGraph Docker镜像时的服务启动过程非常重要。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_27.md",
        "chunks": [
            {
                "content": "# Hive Connector介绍\nGeaFlow 支持通过 Hive metastore 服务器读取 Hive 表中的数据。目前，我们支持 Hive 2.3.x系列版本。\n## 语法\n\n```sql\nCREATE TABLE hive_table (\n  id BIGINT,\n  name VARCHAR,\n  age INT\n) WITH (\n\ttype='hive',\n    geaflow.dsl.hive.database.name = 'default',\n\tgeaflow.dsl.hive.table.name = 'user',\n\tgeaflow.dsl.hive.metastore.uris = 'thrift://localhost:9083'\n)\n```\n## 参数\n\n| 参数名 | 是否必须 | 描述 |\n| -------- | ---- | -------- |\n| geaflow.dsl.hive.database.name     | 是 | Hive数据库名字     |\n| geaflow.dsl.hive.table.name     | 是 | Hive表名     |\n| geaflow.dsl.hive.metastore.uris     | 是 | 连接Hive元数据metastore的uri列表     |\n| geaflow.dsl.hive.splits.per.partition     | 否 | 每个Hive分片的逻辑分片数量，默认为1     |\n表格内容描述: \n\n该表格包含三个列名：参数名、是否必须和描述。 \n\n- 第一行数据：参数名为 \"geaflow.dsl.hive.database.name\"，该参数是必须的，描述为 \"Hive数据库名字\"。\n- 第二行数据：参数名为 \"geaflow.dsl.hive.table.name\"，该参数是必须的，描述为 \"Hive表名\"。\n- 第三行数据：参数名为 \"geaflow.dsl.hive.metastore.uris\"，该参数是必须的，描述为 \"连接Hive元数据metastore的uri列表\"。\n- 第四行数据：参数名为 \"geaflow.dsl.hive.splits.per.partition\"，该参数不是必须的，描述为 \"每个Hive分片的逻辑分片数量，默认为1\"。\n\n该文档介绍了GeaFlow的Hive Connector功能，支持通过Hive metastore读取数据，并详细描述了创建Hive表的语法、所需参数及其意义，以及相关的SQL示例和参数表格。"
            },
            {
                "content": "该表格包含三个列名：参数名、是否必须和描述。 \n\n- 第一行数据：参数名为 \"geaflow.dsl.hive.database.name\"，该参数是必须的，描述为 \"Hive数据库名字\"。\n- 第二行数据：参数名为 \"geaflow.dsl.hive.table.name\"，该参数是必须的，描述为 \"Hive表名\"。\n- 第三行数据：参数名为 \"geaflow.dsl.hive.metastore.uris\"，该参数是必须的，描述为 \"连接Hive元数据metastore的uri列表\"。\n- 第四行数据：参数名为 \"geaflow.dsl.hive.splits.per.partition\"，该参数不是必须的，描述为 \"每个Hive分片的逻辑分片数量，默认为1\"。\n\n总结：该表格列出了与Hive数据库相关的多个参数，其中前三个参数是必填项，用于配置数据库、表名以及元数据连接信息，最后一个参数为可选项，指定每个分片的逻辑分片数量。\n\n## 示例\n\n```sql\nCREATE TABLE hive_table (\n  id BIGINT,\n  name VARCHAR,\n  age INT\n) WITH (\n\ttype='hive',\n    geaflow.dsl.hive.database.name = 'default',\n\tgeaflow.dsl.hive.table.name = 'user',\n\tgeaflow.dsl.hive.metastore.uris = 'thrift://localhost:9083'\n);\n\nCREATE TABLE console (\n  id BIGINT,\n  name VARCHAR,\n  age INT\n) WITH (\n\ttype='console'\n);\n\nINSERT INTO console\nSELECT * FROM hive_table;\n```\n\n该块内容位于文档中关于Hive Connector的参数说明部分，具体描述了与Hive数据库相关的参数及其属性，包括是否必填及详细描述，旨在帮助用户理解如何正确配置Hive表。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_28.md",
        "chunks": [
            {
                "content": "# RESTful API\n\n> 此文档主要介绍 TuGrpah 的 Rest API 的调用详情。\n\n## 1.简介\nTuGraph 提供遵从 REST 规范的 HTTP API，以供开发者通过 HTTP 请求远程调用 TuGraph 提供的服务。\n\n本文档描述 TuGraph 的 HTTP API 使用方式。\n\n## 2.请求与响应格式\nTuGraph HTTP Server 接收json格式的请求，经过鉴权后开始提取请求中的字段，根据定义好的接口逻辑处理请求，并返回json格式的响应。\n\n### 2.1.标准响应格式\n每一个响应都以标准响应格式返回，格式如下：\n\n| body参数  | 参数说明         | 参数类型        | 是否必填       |\n| ------- |--------------|-------------|------------|\n| errorCode   | 业务级错误码       | int类型       | 是          |\n| success   | 请求是否成功       | int类型       | 是          |\n| errorMessage   | 业务级错误信息      | 字符串类型       | 是          |\n| data   | 请求成功时返回的响应信息 | json字符串     | 是          |\n表格内容描述：\n\n本表格包含四列，分别为“body参数”、“参数说明”、“参数类型”和“是否必填”。\n\n- 第一行：`errorCode`，表示业务级错误码，参数类型为整型（int），该参数是必填项。\n- 第二行：`success`，表示请求是否成功，参数类型为整型（int），该参数也是必填项。\n- 第三行：`errorMessage`，表示业务级错误信息，参数类型为字符串（string），同样是必填项。\n- 第四行：`data`，表示请求成功时返回的响应信息，参数类型为JSON字符串，该参数也是必填项。\n\n总体来看，该表格列出了与请求响应相关的必填参数及其说明，涵盖了错误码、请求成功状态、错误信息和成功时返回的数据格式。\n\n### 2.2请求类型\n\n该段落位于文档的前半部分，主要介绍了TuGraph的RESTful API的基本概念、请求与响应格式，以及标准响应格式的详细说明，为后续的具体请求类型（如用户登录、登出等）奠定了基础。"
            },
            {
                "content": "本表格包含四列，分别为“body参数”、“参数说明”、“参数类型”和“是否必填”。\n\n- 第一行：`errorCode`，表示业务级错误码，参数类型为整型（int），该参数是必填项。\n- 第二行：`success`，表示请求是否成功，参数类型为整型（int），该参数也是必填项。\n- 第三行：`errorMessage`，表示业务级错误信息，参数类型为字符串（string），同样是必填项。\n- 第四行：`data`，表示请求成功时返回的响应信息，参数类型为JSON字符串，该参数也是必填项。\n\n总体来看，该表格列出了与请求响应相关的必填参数及其说明，涵盖了错误码、请求成功状态、错误信息和成功时返回的数据格式。\n\n### 2.2请求类型\n\n#### 2.2.1. 用户登陆\n用户在登陆请求中携带用户名和密码发送到服务端。登录成功会收到带有签名的令牌(Json Web Token)和判断是否为默认密码的布尔型变量，客户端储存该令牌，在后续的请求中将令牌加入请求头的Authorization域中。如果登录失败会收到“Authentication failed”错误。\n\n- **URI**:     /login\n- **METHOD**:  POST\n- **REQUEST**:\n\n| body参数 | 参数说明 | 参数类型  | 是否必填       |\n| ------ |------|-------|------------|\n| user   | 用户名  | 字符串类型   | 是          |\n| password | 用户密码 | 字符串类型 | 是          |\n表格内容描述: 此表格包含四列，分别为“body参数”、“参数说明”、“参数类型”和“是否必填”。\n\n- 第一行数据为“user”，其参数说明为“用户名”，参数类型为“字符串类型”，且该参数为必填。\n- 第二行数据为“password”，其参数说明为“用户密码”，参数类型为“字符串类型”，同样为必填。\n\n总体来看，此表格列出了两个必填的参数（用户名和用户密码），并说明它们的类型均为字符串类型。\n\n- **RESPONSE**:\n  如果成功，返回的响应信息中success为00，data中包含令牌\n\n该块内容位于文档的第二部分，具体介绍了TuGraph的标准响应格式和用户登陆请求类型的详细信息，包括请求格式、必填参数及其说明，以及成功响应的结构。这部分内容是文档中关于API请求和响应的核心细节，有助于开发者理解如何使用Rest API进行用户身份验证。"
            },
            {
                "content": "- **URI**:     /login\n- **METHOD**:  POST\n- **REQUEST**:\n\n| body参数 | 参数说明 | 参数类型  | 是否必填       |\n| ------ |------|-------|------------|\n| user   | 用户名  | 字符串类型   | 是          |\n| password | 用户密码 | 字符串类型 | 是          |\n表格内容描述: 此表格包含四列，分别为“body参数”、“参数说明”、“参数类型”和“是否必填”。\n\n- 第一行数据为“user”，其参数说明为“用户名”，参数类型为“字符串类型”，且该参数为必填。\n- 第二行数据为“password”，其参数说明为“用户密码”，参数类型为“字符串类型”，同样为必填。\n\n总体来看，此表格列出了两个必填的参数（用户名和用户密码），并说明它们的类型均为字符串类型。\n\n- **RESPONSE**:\n  如果成功，返回的响应信息中success为00，data中包含令牌\n\n| body参数          | 参数说明           | 参数类型   |\n|------------------|--------------------|------------|\n| jwt              | 令牌               | 字符串类型 |\n| is_admin         | 是否是admin用户    | 布尔类型   |\n表格内容描述: 本表格包含三列，分别为“body参数”、“参数说明”和“参数类型”。 \n\n- 第一行数据为：\n  - body参数：jwt\n  - 参数说明：令牌\n  - 参数类型：字符串类型\n\n- 第二行数据为：\n  - body参数：is_admin\n  - 参数说明：是否是admin用户\n  - 参数类型：布尔类型\n\n总体来看，该表格列出了两个body参数及其说明和数据类型，分别为用于身份验证的字符串类型令牌和表示用户角色的布尔类型参数。\n| default_password  | 默认密码           | 布尔类型   |\n表格内容描述: 此表格包含三列，分别是\"body参数\"、\"参数说明\"和\"参数类型\"。\n\n该块内容位于文档的第二部分，详细描述了TuGraph的用户登录接口，包括请求的URI、请求方法、必填的请求参数（用户名和密码）、以及成功响应中包含的参数（令牌和用户权限信息）。"
            },
            {
                "content": "| body参数          | 参数说明           | 参数类型   |\n|------------------|--------------------|------------|\n| jwt              | 令牌               | 字符串类型 |\n| is_admin         | 是否是admin用户    | 布尔类型   |\n表格内容描述: 本表格包含三列，分别为“body参数”、“参数说明”和“参数类型”。 \n\n- 第一行数据为：\n  - body参数：jwt\n  - 参数说明：令牌\n  - 参数类型：字符串类型\n\n- 第二行数据为：\n  - body参数：is_admin\n  - 参数说明：是否是admin用户\n  - 参数类型：布尔类型\n\n总体来看，该表格列出了两个body参数及其说明和数据类型，分别为用于身份验证的字符串类型令牌和表示用户角色的布尔类型参数。\n| default_password  | 默认密码           | 布尔类型   |\n表格内容描述: 此表格包含三列，分别是\"body参数\"、\"参数说明\"和\"参数类型\"。\n\n- 第一行数据列出\"jwt\"，其参数说明为\"令牌\"，参数类型为\"字符串类型\"。\n- 第二行数据显示\"is_admin\"，其参数说明为\"是否是admin用户\"，参数类型为\"布尔类型\"。\n- 第三行数据为\"default_password\"，其参数说明为\"默认密码\"，参数类型为\"布尔类型\"。\n\n整体来看，该表格详细列出了三个与用户认证和权限相关的参数，以及它们的具体说明和数据类型。这些参数包括令牌、用户身份及默认密码设置，提供了用户管理功能的基本信息。\n\n**Example request.**\n\n```\n    {\"user\" : \"admin\", \"password\" : \"73@TuGraph\"}\n```\n\n#### 2.2.2. 用户登出\n用户登出，同时删除已经认证的token，用户后续发送请求时，需要重新登陆，并获取新的token。\n\n该内容片段位于文档的用户登录部分，描述了用户成功登录后返回的响应信息，包括身份验证令牌（jwt）、用户角色（is_admin）以及是否使用默认密码（default_password）的相关参数及其说明。这一部分为后续的用户登出和身份刷新功能提供了基础信息。"
            },
            {
                "content": "- 第一行数据列出\"jwt\"，其参数说明为\"令牌\"，参数类型为\"字符串类型\"。\n- 第二行数据显示\"is_admin\"，其参数说明为\"是否是admin用户\"，参数类型为\"布尔类型\"。\n- 第三行数据为\"default_password\"，其参数说明为\"默认密码\"，参数类型为\"布尔类型\"。\n\n整体来看，该表格详细列出了三个与用户认证和权限相关的参数，以及它们的具体说明和数据类型。这些参数包括令牌、用户身份及默认密码设置，提供了用户管理功能的基本信息。\n\n**Example request.**\n\n```\n    {\"user\" : \"admin\", \"password\" : \"73@TuGraph\"}\n```\n\n#### 2.2.2. 用户登出\n用户登出，同时删除已经认证的token，用户后续发送请求时，需要重新登陆，并获取新的token。\n\n- **URI**:     /logout\n- **METHOD**:  POST\n  - **REQUEST**:\n    http request header中携带调用login接口时返回的token，具体填写的字符串是`Bearer ${jwt}`，`${jwt}`就是login接口返回的jwt，body中没有参数\n\n| header参数           | 参数说明          | 参数类型   |\n|------------------|---------------|------------|\n| Authorization              | Bearer ${jwt} | 字符串类型 |\n表格内容描述: 本表格共有三列，分别为“header参数”、“参数说明”和“参数类型”。在数据内容方面，第一行提供了一个header参数“Authorization”，其对应的参数说明为“Bearer ${jwt}”，参数类型为“字符串类型”。整体来看，该表格描述了一个用于认证的header参数的具体信息，包括其名称、用途以及数据类型。\n表格内容描述: \n\n该表格包含三列，分别为“header参数”、“参数说明”和“参数类型”。 \n\n- 在第一行中，header参数为“Authorization”，参数说明为“Bearer ${jwt}”，参数类型为“字符串类型”。\n\n该段落位于TuGraph RESTful API文档中的用户登录部分，具体描述了用户登录后的响应信息，包括返回的令牌（jwt）、用户是否为管理员（is_admin），以及是否使用默认密码（default_password）的相关参数。在此之后，文档继续介绍用户登出接口的请求和响应格式。"
            },
            {
                "content": "| header参数           | 参数说明          | 参数类型   |\n|------------------|---------------|------------|\n| Authorization              | Bearer ${jwt} | 字符串类型 |\n表格内容描述: 本表格共有三列，分别为“header参数”、“参数说明”和“参数类型”。在数据内容方面，第一行提供了一个header参数“Authorization”，其对应的参数说明为“Bearer ${jwt}”，参数类型为“字符串类型”。整体来看，该表格描述了一个用于认证的header参数的具体信息，包括其名称、用途以及数据类型。\n表格内容描述: \n\n该表格包含三列，分别为“header参数”、“参数说明”和“参数类型”。 \n\n- 在第一行中，header参数为“Authorization”，参数说明为“Bearer ${jwt}”，参数类型为“字符串类型”。\n\n该表格的整体内容说明了一个HTTP请求的header参数，具体是用于身份验证的Authorization字段，其值格式为Bearer后接一个JWT（Json Web Token）字符串。该参数的数据类型为字符串。\n\n- **RESPONSE**:\n  如果成功，返回的响应信息中success为00，data中包含\n\n| body参数          | 参数说明           | 参数类型   |\n|------------------|--------------------|------------|\n| is_admin         | 是否是admin用户    | 布尔类型   |\n表格内容描述: 该表格包含三列，分别为“body参数”、“参数说明”和“参数类型”。表格中的数据行有一条，内容如下：参数“is_admin”表示用户是否为管理员，其参数类型为布尔类型。整体来看，表格提供了一个关于用户权限的参数设置，主要用于判断用户是否具有管理员权限。\n\n#### 2.2.3. 身份刷新\n已下发的token失效后，需要调用本接口重新认证。后端验证token合法性。token在初次登录后，1小时内有效，过期需要刷新\n\n该片段主要描述了在用户登出的过程中所需的HTTP请求头部参数“Authorization”的详细信息，包括其参数说明和类型。同时，片段还介绍了成功响应时返回的一个body参数“is_admin”，用于指示用户是否为管理员。此内容位于文档中的“用户登出”部分，以便让开发者理解在登出请求中需要遵循的格式与要求。"
            },
            {
                "content": "- **RESPONSE**:\n  如果成功，返回的响应信息中success为00，data中包含\n\n| body参数          | 参数说明           | 参数类型   |\n|------------------|--------------------|------------|\n| is_admin         | 是否是admin用户    | 布尔类型   |\n表格内容描述: 该表格包含三列，分别为“body参数”、“参数说明”和“参数类型”。表格中的数据行有一条，内容如下：参数“is_admin”表示用户是否为管理员，其参数类型为布尔类型。整体来看，表格提供了一个关于用户权限的参数设置，主要用于判断用户是否具有管理员权限。\n\n#### 2.2.3. 身份刷新\n已下发的token失效后，需要调用本接口重新认证。后端验证token合法性。token在初次登录后，1小时内有效，过期需要刷新\n\n- **URI**:     /refresh\n- **METHOD**:  POST\n- **REQUEST**:\n  http request header中携带调用login接口返回的token，具体填写的字符串是`Bearer ${jwt}`，`${jwt}`就是login接口返回的jwt，body中没有参数\n\n| header参数           | 参数说明          | 参数类型   |\n|------------------|---------------|------------|\n| Authorization              | Bearer ${jwt} | 字符串类型 |\n\n- **RESPONSE**:\n  如果成功，返回的响应信息中success为00，data中包含令牌\n\n| body参数          | 参数说明           | 参数类型   |\n|------------------|--------------------|------------|\n| jwt              | 令牌               | 字符串类型 |\n| is_admin         | 是否是admin用户    | 布尔类型   |\n\n该块内容位于文档的第二部分，主要描述了用户登出后的响应格式，包括返回的是否为管理员的布尔值参数，以及后续的身份刷新接口的信息，包括请求和响应格式。这部分内容是关于用户身份认证和权限管理的具体细节。"
            },
            {
                "content": "| header参数           | 参数说明          | 参数类型   |\n|------------------|---------------|------------|\n| Authorization              | Bearer ${jwt} | 字符串类型 |\n\n- **RESPONSE**:\n  如果成功，返回的响应信息中success为00，data中包含令牌\n\n| body参数          | 参数说明           | 参数类型   |\n|------------------|--------------------|------------|\n| jwt              | 令牌               | 字符串类型 |\n| is_admin         | 是否是admin用户    | 布尔类型   |\n\n#### 2.2.4. 调用cypher\n用户对TuGraph的增删改查请求需要调用cypher接口，并通过标准的cypher查询语言发起\n\n- **URI**:     /cypher\n- **METHOD**:  POST\n- **REQUEST**:\n\n| header参数           | 参数说明          | 参数类型   |\n|------------------|---------------|------------|\n| Authorization              | Bearer ${jwt} | 字符串类型 |\n\n| body参数  | 参数说明     | 参数类型  | 是否必填       |\n| ------- |----------|-------|------------|\n| graph   | 查询的子图名称  | 字符串类型   | 是          |\n| script   | cypher语句 | 字符串类型 | 是          |\n表格内容描述：\n\n该表格包含两部分：header参数和body参数。\n\n1. Header参数包含以下列：\n   - 参数名称：Authorization\n   - 参数说明：Bearer ${jwt}\n   - 参数类型：字符串类型\n\n此块内容位于文档的第2.2.3节和第2.2.4节之间，主要描述了用户身份刷新和调用cypher接口的请求及响应参数格式，具体涉及到身份验证的JWT令牌、是否为管理员用户等信息，以及与系统交互的cypher语句的使用。"
            },
            {
                "content": "- **URI**:     /cypher\n- **METHOD**:  POST\n- **REQUEST**:\n\n| header参数           | 参数说明          | 参数类型   |\n|------------------|---------------|------------|\n| Authorization              | Bearer ${jwt} | 字符串类型 |\n\n| body参数  | 参数说明     | 参数类型  | 是否必填       |\n| ------- |----------|-------|------------|\n| graph   | 查询的子图名称  | 字符串类型   | 是          |\n| script   | cypher语句 | 字符串类型 | 是          |\n表格内容描述：\n\n该表格包含两部分：header参数和body参数。\n\n1. Header参数包含以下列：\n   - 参数名称：Authorization\n   - 参数说明：Bearer ${jwt}\n   - 参数类型：字符串类型\n\n2. Body参数则包含以下列：\n   - 参数名称：graph\n     - 参数说明：查询的子图名称\n     - 参数类型：字符串类型\n     - 是否必填：是\n   - 参数名称：script\n     - 参数说明：cypher语句\n     - 参数类型：字符串类型\n     - 是否必填：是\n\n总体来看，该表格描述了一个API请求的必要参数。其中，header部分要求提供一个Bearer类型的身份验证令牌，而body部分则要求提供查询的子图名称和相应的cypher语句，二者均为必填项。\n\n- **RESPONSE**:\n  如果成功，返回的响应信息中success为00，data中包含查询结果\n\n| body参数  | 参数说明 | 参数类型    | 是否必填       |\n| ------- |------|---------|------------|\n| result   | 查询结果 | json字符串 | 是          |\n表格内容描述: \n\n该表格包含四列，分别为“body参数”、“参数说明”、“参数类型”和“是否必填”。\n\n该片段位于文档的第二部分，详细说明了TuGraph API中的/cypher接口的请求和响应格式，包括所需的header和body参数，适用的HTTP方法以及成功响应的格式和结构。"
            },
            {
                "content": "2. Body参数则包含以下列：\n   - 参数名称：graph\n     - 参数说明：查询的子图名称\n     - 参数类型：字符串类型\n     - 是否必填：是\n   - 参数名称：script\n     - 参数说明：cypher语句\n     - 参数类型：字符串类型\n     - 是否必填：是\n\n总体来看，该表格描述了一个API请求的必要参数。其中，header部分要求提供一个Bearer类型的身份验证令牌，而body部分则要求提供查询的子图名称和相应的cypher语句，二者均为必填项。\n\n- **RESPONSE**:\n  如果成功，返回的响应信息中success为00，data中包含查询结果\n\n| body参数  | 参数说明 | 参数类型    | 是否必填       |\n| ------- |------|---------|------------|\n| result   | 查询结果 | json字符串 | 是          |\n表格内容描述: \n\n该表格包含四列，分别为“body参数”、“参数说明”、“参数类型”和“是否必填”。\n\n第一行的数据为：\n- body参数为“result”；\n- 参数说明为“查询结果”；\n- 参数类型为“json字符串”； \n- 是否必填为“是”。\n\n整体来看，表格仅包含一个参数“result”，它用于表示查询结果，类型为json字符串，并且该参数是必填项。\n\n**Example request.**\n\n```\n    {\"script\" : \"Match (n) return n\", \"graph\" : \"default\"}\n```\n\n该片段位于文档第2.2.4节，具体讨论了调用cypher接口的请求格式，包括请求中的header和body参数要求，以及成功响应的结果结构。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_29.md",
        "chunks": [
            {
                "content": "# 从源码编译\n\n> 本文档主要描述 TuGraph 从源码进行编译。\n\n## 1.前置条件\n\n推荐在linux系统下搭建TuGraph。同时docker环境是个不错的选择。\n\n## 2.编译介绍\n\n以下是编译TuGraph的步骤：\n\n1. 如果需要web接口运行`deps/build_deps.sh`，不需要web接口则跳过此步骤\n2. 根据容器系统信息执行`cmake .. -DOURSYSTEM=centos`或者`cmake .. -DOURSYSTEM=ubuntu`，如果在arm机器编译（如M1芯片的Mac中，需要加上` -DENABLE_BUILD_ON_AARCH64=ON`）\n3. `make`\n4. `make package` 或者 `cpack --config CPackConfig.cmake`\n\n示例：`tugraph/tugraph-compile-centos7`Docker环境\n\n```bash\n$ git clone --recursive https://github.com/TuGraph-family/tugraph-db.git\n$ cd tugraph-db\n$ deps/build_deps.sh\n$ mkdir build && cd build\n$ cmake .. -DOURSYSTEM=centos7\n$ make\n$ make package\n```\n\n本文档详细介绍了如何从源码编译TuGraph，包括编译前的准备条件和具体步骤，适合在Linux或Docker环境中进行操作。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_30.md",
        "chunks": [
            {
                "content": "# Sink API介绍\nGeaFlow对外提供了Sink API，用于构建Window Sink，用户可以通过实现SinkFunction来定义具体的输出逻辑。\n\n## 接口\n| API | 接口说明 | 入参说明 |\n| -------- | -------- | -------- |\n| PStreamSink sink(SinkFunction sinkFunction)     | 将结果进行输出。     |sinkFunction：用户可以通过实现SinkFunction接口，用于定义其相应的输出语义。GeaFlow内部集成了几种sink function，例如：Console、File等。|\n表格内容描述：该表格包含三列，分别是“API”、“接口说明”和“入参说明”。\n\n第一行数据中，API为“PStreamSink sink(SinkFunction sinkFunction)”，接口说明为“将结果进行输出。”，入参说明为“sinkFunction：用户可以通过实现SinkFunction接口，用于定义其相应的输出语义。GeaFlow内部集成了几种sink function，例如：Console、File等。”\n\n整体来说，该表格描述了一个输出接口的功能及其参数的详细信息，主要提供了如何通过实现SinkFunction接口来定义数据输出方式，并提及了内置的多种输出方式。\n* Sink用法\n```java\n\t// 将结果直接打印到console。\n\tsource.sink(v -> {LOGGER.info(\"result: {}\", v)});\n```\n\n## 示例\n```java\npublic class WindowStreamWordCount {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(WindowStreamWordCount.class);\n\n该文档介绍了GeaFlow的Sink API及其接口，详述了如何通过SinkFunction实现数据输出逻辑，提供了接口用法和示例代码，以帮助用户理解和使用该输出机制。"
            },
            {
                "content": "## 示例\n```java\npublic class WindowStreamWordCount {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(WindowStreamWordCount.class);\n\n    public static void main(String[] args) {\n        Environment environment = EnvironmentFactory.onLocalEnvironment();\n        Pipeline pipeline = PipelineFactory.buildPipeline(environment);\n        pipeline.submit(new PipelineTask() {\n            @Override\n            public void execute(IPipelineTaskContext pipelineTaskCxt) {\n                Configuration config = pipelineTaskCxt.getConfig();\n                List words = Lists.newArrayList(\"hello\", \"world\", \"hello\", \"word\");\n                PWindowSource source = pipelineTaskCxt.buildSource(new CollectionSource(words) {\n                }, SizeTumblingWindow.of(100));\n                // 将结果直接打印在console\n                source.sink(v -> {\n                    LOGGER.info(\"result: {}\", v);\n                });\n            }\n        });\n\n该示例展示了如何使用GeaFlow的Sink API，通过实现SinkFunction来将窗口流数据输出至控制台，具体为展示一个简单的单词计数示例。"
            },
            {
                "content": "IPipelineResult result = pipeline.execute();\n        result.get();\n    }\n}\n```\n\n该代码块位于示例部分的末尾，展示了如何执行构建的管道并获取结果，属于整个Window Stream Word Count示例的执行过程，体现了如何在GeaFlow框架中运行数据流处理任务。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_31.md",
        "chunks": [
            {
                "content": "# 简介\n融合DSL是GeaFlow提供的图表一体的数据分析语言，支持标准SQL+ISO/GQL进行图表分析.通过融合DSL可以对表数据做关系运算处理，也可以对图数据做图匹配和图算法计算，同时也支持同时图表数据的联合处理.\n\n## 融合DSL使用案例\n\n- **通过SQL处理GQL结果**\n\n```sql\n    SELECT\n    a.id,\n    b.id,\n    AVG(e.amt),\n    MAX(e.amt)\n  \n    FROM (\n    MATCH (a) -[e:knows]->(b:person where b.id != 1)\n    RETURN a, e, b\n    ) \n    Group By a.id, b.id\n    Having AVG(e.amt) > 10\n```\n\n  GQL Match返回的Path可以通过SQL做进一步分析处理.\n\n\n\n- **通过SQL触发GQL图查询**\n\n```sql\n    SELECT *\n    FROM (\n      WITH p AS (\n    \tSELECT * FROM (VALUES(1, 'r0', 0.4), (4, 'r1', 0.5)) AS t(id, name, weight)\n      )\n      MATCH (a:person where id = p.id) -[e where weight > p.weight]->(b)\n      RETURN p.name as name, a.id as a_id, e.weight as weight, b.id as b_id\n    )\n```\n\n  可以给GQL定义一个参数表，参数表的数据逐条触发GQL查询.GQL将分别返回每个参数对应的计算结果.\n\n## Maven依赖\n* 开发UDF/UDAF/UDTF/UDGA需要添加以下依赖：\n\n```xml\n \ncom.antgroup.tugraph\ngeaflow-dsl-common\n0.1\n\n```\n* 开发自定义Connector需添加以下依赖：\n\n```xml\n\ncom.antgroup.tugraph\ngeaflow-dsl-connector-api\n0.1\n\n```\n\n该文档介绍了GeaFlow提供的融合DSL数据分析语言，包括其功能、使用案例以及Maven依赖信息。该chunk主要详细阐述了融合DSL的简介、具体使用案例以及开发过程中所需的Maven依赖，旨在帮助用户理解和应用融合DSL进行图表分析。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_32.md",
        "chunks": [
            {
                "content": "# Condition\n\nGeaFlow支持**Case**和**If**条件函数。\n* Case\n* If\n\n## Case\n**Syntax**\n\n```sql\nCASE expression\n    WHEN condition1 THEN result1\n    [WHEN condition2 THEN result2]\n    ...\n    [WHEN conditionN THEN resultN]\n    [ELSE result]\nEND\n```\nOR\n\n```\nCASE WHEN condition1 THEN result1\n    [WHEN condition2 THEN result2]\n    ...\n    [WHEN conditionN THEN resultN]\n    [ELSE result]\nEND\n```\n**Description**\n当Case函数中的某个分支与条件匹配时，返回表达式的结果。\n\n**Example**\n\n```sql\nCASE a\n\tWHEN 1 THEN '1'\n\tWHEN 2 THEN '2'\n\tELSE '3'\nEND\n\nCASE WHEN a = 1 THEN '1'\n     WHEN a = 2 THEN '2'\n\t ELSE '3'\nEND\n```\n\n## If\n**Syntax**\n\n```sql\nIF (expression, trueValue, falseValue)\n```\n**Description**\n当表达式为真时，返回trueValue的值，否则返回falseValue的值。\n\n**Example**\n\n```sql\nif(a = 1, -1, a)\n```\n\n本文档介绍了GeaFlow中的条件函数，详细说明了**Case**和**If**两种条件语法及其用法，包括使用示例。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_33.md",
        "chunks": [
            {
                "content": "# TuGraph 示例\n\n## 1 简介\n\nTuGraph 是蚂蚁集团自主研发的大规模图计算系统，提供图数据库引擎和图分析引擎。其主要特点是大数据量存储和计算，高吞吐率，以及灵活的 API，同时支持高效的在线事务处理（OLTP）和在线分析处理（OLAP）。 LightGraph、GeaGraph是TuGraph的曾用名。\n\n主要功能特征包括：\n\n- 支持属性图模型\n- 原生图存储及处理\n- 完全的ACID事务支持\n- 支持OpenCypher图查询语言\n- 支持原生的Core API和Traversal API\n- 支持REST和RPC接口\n- 支持CSV、JSON、MySQL等多数据源导入导出\n- 支持可视化图交互\n- 支持命令行交互\n- 内置用户权限控制、操作审计\n- 支持任务和日志的监控管理\n- 原生适配PandaGraph图分析引擎\n- 集成DGL图神经网络系统\n\n性能及可扩展性特征包括：\n\n- 支持TB级大容量\n- 吞吐率高达千万顶点每秒\n- 面向读优化的存储引擎\n- 支持高可用模式\n- 支持离线备份恢复\n- 在线热备份\n- 高性能批量导入导出\n\n## 2 快速上手\n\n见QuickStart文档。\n\n## 3 基本功能\n\n### 3.1 RPC Client\n#### 3.1.1 概述\nRPC Client是对cpp语言rpc客户端的简单封装，每次执行时会创建一条到lgraph_server的链接用于发送请求数据以及接收响应结果，执行完毕后进程退出前会断开链接\n#### 3.1.2 编译\n在代码目录demo/CppRpcClientDemo目录下,执行下列命令 ,成功后将会看到可执行文件clientdemo\n```bash\nmkdir build && cd build && cmake ../ && make\n```\n#### 3.1.3 运行\n先启动lgraph_server，确保rpc端口处于打开状态。\n\n该内容块详细介绍了TuGraph系统的基本功能，特别是RPC客户端的使用，包括其概述、编译和运行方法。这部分信息是文档中的第三章，旨在指导用户如何有效地利用TuGraph进行图计算和查询操作。"
            },
            {
                "content": "## 2 快速上手\n\n见QuickStart文档。\n\n## 3 基本功能\n\n### 3.1 RPC Client\n#### 3.1.1 概述\nRPC Client是对cpp语言rpc客户端的简单封装，每次执行时会创建一条到lgraph_server的链接用于发送请求数据以及接收响应结果，执行完毕后进程退出前会断开链接\n#### 3.1.2 编译\n在代码目录demo/CppRpcClientDemo目录下,执行下列命令 ,成功后将会看到可执行文件clientdemo\n```bash\nmkdir build && cd build && cmake ../ && make\n```\n#### 3.1.3 运行\n先启动lgraph_server，确保rpc端口处于打开状态。\n\nclientdemo程序接收参数如下：\n        -h             show this usage\n        -i --ip        ip for graph server\n        -p --port      port for graph server\n        -g --graph     graph name\n        -u --user      user name\n        --password     user password\n        -c --cypher    cypher to query\n举例如下\n```bash\n./clientdemo -i 127.0.0.1 -p 9090 -u admin --password 73@TuGraph -g default -c \"MATCH (n) RETURN n LIMIT 100\"\n```\n### 3.2 Python RPC Client\n#### 3.2.1 概述\nPython RPC Client是对python语言rpc客户端的简单封装，每次执行时会创建一条到lgraph_server的链接用于发送请求数据以及接收响应结果，执行完毕后进程退出前会断开链接\n#### 3.2.2 运行\n需要依赖编译生成的python_client.so库，将python_client.so与client_python.py放在同一目录下\n先启动lgraph_server，确保rpc端口处于打开状态。\n\n该片段位于文档的第二部分“快速上手”和第三部分“基本功能”之间，详细介绍了如何使用RPC客户端，包括cpp和Python语言的客户端的概述、编译、运行步骤及命令行参数设置，以便用户能够快速上手并利用TuGraph进行图计算和数据查询。"
            },
            {
                "content": "clientdemo程序接收参数如下：\n-h             show this usage\n-i --ip        ip for graph server\n-p --port      port for graph server\n-g --graph     graph name\n-u --user      user name\n--password     user password\n-c --cypher    cypher to query\n举例如下\n```bash\npython3 client_python.py -i 127.0.0.1 -p 9090 -u admin --password 73@TuGraph -g default -c \"MATCH (n) RETURN n LIMIT 100\"\n```\n## 4 集成工具\n\n### 4.1 DataX 导入导出工具\n#### 4.1.1 概述\nDataX 支持 TuGraph 和 MySQL、SQL Server、Oracle、PostgreSQL、HDFS、Hive、HBase、OTS、ODPS、Kafka 等各种异构数据源的数据导入导出。\n#### 4.1.2 运行\n以MySQL和为例，先在数据源中准备数据\n```bash\nmysql> source mysql_data.sql\n```\n然后启动TuGraph服务，使用DataX将数据从数据源导入到TuGraph中\n```bash\nbash ./import_from_mysql.sh\n```\n\n### 4.2 DGL图神经网络系统\n\n#### 4.2.1 概述\n\nDGL是一个开源的高性能图神经网络框架，能兼容PyTorch、Apache MXNet以及TensorFlow等主流机器学习库，并提供了多种常见的图学习算法。\n\n#### 4.2.2 环境配置\n\n使用pip3安装pytorch和dgl：\n\n```shell script\npip3 install torch\npip3 install dgl -f https://data.dgl.ai/wheels/repo.html\n```\n\n#### 4.2.3 图数据导入\n\n在demo/DGLDemo目录下执行以下命令，将data_cora数据导入到TuGraph数据库中\n\n该段落位于TuGraph文档的基本功能部分，主要介绍了Python RPC Client的参数接收方式和使用示例，包括如何运行客户端，以及后续的集成工具部分，继续介绍DataX导入导出工具和DGL图神经网络系统的概述与配置流程。这些内容为用户提供了操作TuGraph的具体方法和工具支持。"
            },
            {
                "content": "### 4.2 DGL图神经网络系统\n\n#### 4.2.1 概述\n\nDGL是一个开源的高性能图神经网络框架，能兼容PyTorch、Apache MXNet以及TensorFlow等主流机器学习库，并提供了多种常见的图学习算法。\n\n#### 4.2.2 环境配置\n\n使用pip3安装pytorch和dgl：\n\n```shell script\npip3 install torch\npip3 install dgl -f https://data.dgl.ai/wheels/repo.html\n```\n\n#### 4.2.3 图数据导入\n\n在demo/DGLDemo目录下执行以下命令，将data_cora数据导入到TuGraph数据库中\n\n```shell script\nlgraph_import -c data_cora/import.json -d db_cora --overwrite 1\n```\n\n#### 4.2.4 运行\n\n在demo/DGLDemo目录下执行以下命令，运行gcn程序。\n\n```shell script\npython3 gcn.py --db_path db_cora --password 73@TuGraph\n```\n\n## 5 管理功能\n\n## 6 高可用\n\n该部分内容位于文档的第四章，主要介绍了DGL图神经网络系统的相关功能，包括概述、环境配置、图数据导入和运行步骤，属于TuGraph系统的一部分，用于实现高性能图计算与机器学习的结合。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_34.md",
        "chunks": [
            {
                "content": "# 数据导出\n\n> 此文档主要介绍 TuGraph 的数据导出功能。\n\n## 1.简介\n\nTuGraph 可以通过 `lgraph_export` 工具来对已经存放在TuGraph的图数据进行数据导出。 `lgraph_export` 工具可以将指定 TuGraph 数据库的数据以 `csv` 或者 `json` 文件形式导出到指定目录，同时导出这些数据进行再导入时需要的配置文件 `import.config`。\n\n## 2.导出命令\n\n该工具的命令示例如下：\n\n```bash\n$ lgraph_export -d {database_dir} -e {export_destination_dir} -g {graph_to_use} -u {username} -p {password} -f {output_format}\n```\n\n其中：\n\n- `-d {database_dir}` 指定需要进行数据导出的数据库所在目录，默认值为 `./testdb`。\n- `-e {export_destination_dir}` 指定导出文件存放的目录，默认值为 `./exportdir`。\n- `-g {graph_to_use}` 指定图数据库的种类，默认为 `default` 。\n- `-u {username}` 指定进行该导出操作的用户的用户名。\n- `-p {password}` 指定进行该导出操作的用户的用户密码。\n- `-s {field_separator}` 指定导出文件的分隔符，默认为逗号。\n- `-f {output_format}` 指定导出数据的格式，`json`或者`csv`，默认为`csv`。\n- `-h` 除上述指定参数外，也可以使用该参数查看该工具的使用帮助。\n\n此文档主要介绍 TuGraph 数据导出功能，包括导出工具 `lgraph_export` 的使用方法及参数配置，以帮助用户将图数据导出为 `csv` 或 `json` 格式，并生成配置文件 `import.config`。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_35.md",
        "chunks": [
            {
                "content": "# OLAP API\n\n> 本文档是为TuGraph的用户设计的引导程序，用户在阅读详细的文档之前，应该首先阅读该文档，对TuGraph的图计算运行流程有一个大致的了解，之后再阅读详细文档会更加方便。引导程序是基于Tugraph的一个简单的BFS(宽度优先搜索)(https://en.wikipedia.org/wiki/Breadth-first_search)程序实例，我们将重点介绍其使用方式。\n\n## 1. TuGraph 图分析引擎介绍\n\nTuGraph的图分析引擎，面向的场景主要是全图/全量数据分析类的任务。借助TuGraph的 C++ / Python 图分析引擎 API ，用户可以对不同数据来源的图数据快速导出一个待处理的复杂子图，然后在该子图上运行诸如PageRank、LPA、WCC等迭代式图算法，最后根据运行结果做出相应的对策。\n\n在TuGraph中，导出和计算过程均可以通过在内存中并行处理的方式进行加速，从而达到近乎实时的处理分析，和传统方法相比，即避免了数据导出落盘的开销，又能使用紧凑的图数据结构获得计算的理想性能。\n\nTuGraph图计算系统社区版内置6个算法，商业版内置了25种算法，用户几乎不需要自己实现具体的图计算过程。其详细介绍可参考algorithms.md。\n\n根据数据来源及实现不同，可分为Procedure、Embed和Standalone三种运行方式，均继承于OlapBase API，OlapBase API接口文档可参考olapbase-api.md。\n\n其中Procedure和Embed的数据来源是图数据库中预加载的db数据，可以分别编译生成tugraph-web加载使用的.so文件和后台终端使用的embed文件，输入的图数据均通过db的加载形式，其接口文档可参考olapondb-api.md。\nStandalone用于编译生成standalone文件，区别于前者，该文件的输入图数据通过txt、二进制、ODPS文件的形式加载，其接口文档可参考olapondisk-api.md。\n\n## 2. Procedure 编译与运行\n\n该种方式主要用于tugraph-web界面进行可视化加载及运行。使用方法如下：\n\n该文档是TuGraph用户的引导程序，旨在帮助用户理解图计算的运行流程，特别是如何使用TuGraph进行宽度优先搜索（BFS）。文档首先介绍TuGraph的图分析引擎及其功能，接着详细说明三种主要的运行方式（Procedure、Embed和Standalone），并提供相应的编译与运行方法。此处的片段主要集中在引导用户了解图分析引擎和Procedure方式的实现。"
            },
            {
                "content": "TuGraph图计算系统社区版内置6个算法，商业版内置了25种算法，用户几乎不需要自己实现具体的图计算过程。其详细介绍可参考algorithms.md。\n\n根据数据来源及实现不同，可分为Procedure、Embed和Standalone三种运行方式，均继承于OlapBase API，OlapBase API接口文档可参考olapbase-api.md。\n\n其中Procedure和Embed的数据来源是图数据库中预加载的db数据，可以分别编译生成tugraph-web加载使用的.so文件和后台终端使用的embed文件，输入的图数据均通过db的加载形式，其接口文档可参考olapondb-api.md。\nStandalone用于编译生成standalone文件，区别于前者，该文件的输入图数据通过txt、二进制、ODPS文件的形式加载，其接口文档可参考olapondisk-api.md。\n\n## 2. Procedure 编译与运行\n\n该种方式主要用于tugraph-web界面进行可视化加载及运行。使用方法如下：\n\n### C++:\n在tugraph-db/procedures 目录下执行`bash make_so_cpp.sh bfs`即可在tugraph-db/procedures目录下得到bfs.so文件，将该文件以插件形式上传至tugraph-web，输入参数后即可执行。\n\n### Python:\n在tugraph-web的前端将python文件以插件形式上传，输入参数后即可执行。\n\n示例：\n在tugraph-db/procedures 编译.so算法文件\n`bash make_so_cpp.sh bfs`\n\n将bfs.so（或tugraph-db/procedures/algo_cython/bfs.py）文件以插件形式加载至tugraph-web后，输入如下json参数：\n\n```json\n{\n    \"root\":\"10\",\n    \"label\":\"user\",\n    \"field\":\"id\"\n}\n```\n即可得到返回结果如下。\n\n该段落位于文档的第二部分，介绍了TuGraph图计算系统的算法类型及运行方式，重点描述了Procedure、Embed和Standalone三种运行模式的特点与使用方法，随后给出了具体的编译和运行示例，包括C++和Python的实现，旨在指导用户如何在tugraph-web界面和后台进行图算法分析。"
            },
            {
                "content": "## 2. Procedure 编译与运行\n\n该种方式主要用于tugraph-web界面进行可视化加载及运行。使用方法如下：\n\n### C++:\n在tugraph-db/procedures 目录下执行`bash make_so_cpp.sh bfs`即可在tugraph-db/procedures目录下得到bfs.so文件，将该文件以插件形式上传至tugraph-web，输入参数后即可执行。\n\n### Python:\n在tugraph-web的前端将python文件以插件形式上传，输入参数后即可执行。\n\n示例：\n在tugraph-db/procedures 编译.so算法文件\n`bash make_so_cpp.sh bfs`\n\n将bfs.so（或tugraph-db/procedures/algo_cython/bfs.py）文件以插件形式加载至tugraph-web后，输入如下json参数：\n\n```json\n{\n    \"root\":\"10\",\n    \"label\":\"user\",\n    \"field\":\"id\"\n}\n```\n即可得到返回结果如下。\n\n```json\n{\n  \"core_cost\": 0.013641119003295898,\n  \"found_vertices\": 3829,\n  \"num_edges\": 88234,\n  \"num_vertices\": 4039,\n  \"output_cost\": 8.821487426757813e-06,\n  \"prepare_cost\": 0.03479194641113281,\n  \"total_cost\": 0.04844188690185547\n}\n```\n\n输出内容解释如下：\n- core_cost: 表示算法运行所需要的时间。\n- found_vertices: 表示查找到点的个数。\n- num_edges: 表示该图数据的边数量。\n- num_vertices: 表示该图数据点的数量。\n- output_cost: 表示算法结果写回db所需要的时间。\n- prepare_cost: 表示预处理阶段所需要的时间。预处理阶段的工作：加载参数、图数据加载、索引初始化等。\n- total_cost: 表示执行该算法整体运行时间。\n\n本文档的主要内容是介绍TuGraph图计算引擎的使用和运行方式。第二部分“Procedure 编译与运行”详细讲解了如何利用tugraph-web界面在C++和Python环境下编译和运行图算法，包括生成的.so文件的上传和参数输入示例，重点突出了算法执行的输出结果及其解释。"
            },
            {
                "content": "```json\n{\n  \"core_cost\": 0.013641119003295898,\n  \"found_vertices\": 3829,\n  \"num_edges\": 88234,\n  \"num_vertices\": 4039,\n  \"output_cost\": 8.821487426757813e-06,\n  \"prepare_cost\": 0.03479194641113281,\n  \"total_cost\": 0.04844188690185547\n}\n```\n\n输出内容解释如下：\n- core_cost: 表示算法运行所需要的时间。\n- found_vertices: 表示查找到点的个数。\n- num_edges: 表示该图数据的边数量。\n- num_vertices: 表示该图数据点的数量。\n- output_cost: 表示算法结果写回db所需要的时间。\n- prepare_cost: 表示预处理阶段所需要的时间。预处理阶段的工作：加载参数、图数据加载、索引初始化等。\n- total_cost: 表示执行该算法整体运行时间。\n\nmake_so.sh文件介绍：该文件用于将TuGraph-OLAP所涉及到的图算法文件编译成一个可供tugraph-web使用的.so文件。\n\n## 3. Embed 编译与运行\n\n该种方式主要用于TuGraph在后台程序中对预加载的db图数据进行算法分析。其使用方法如下：\n在tugraph-db/procedures 目录下对embed_main.cpp文件完善，补充数据名称、输入参数、数据路径等信息，示例如下：\n\n### C++:\n\n```C++\n#include \n#include \"lgraph/lgraph.h\"\n#include \"lgraph/olap_base.h\"\nusing namespace std;\n\nextern \"C\" bool Process(lgraph_api::GraphDB &db, const std::string &request, std::string &response);\n\n该块内容位于文档的第2部分，主要介绍了在TuGraph中进行宽度优先搜索（BFS）算法的运行结果及相关参数的解释，紧接着是关于Embed编译与运行的介绍。这部分内容提供了算法输出的详细信息和对手动编译与调用的方法说明。"
            },
            {
                "content": "## 3. Embed 编译与运行\n\n该种方式主要用于TuGraph在后台程序中对预加载的db图数据进行算法分析。其使用方法如下：\n在tugraph-db/procedures 目录下对embed_main.cpp文件完善，补充数据名称、输入参数、数据路径等信息，示例如下：\n\n### C++:\n\n```C++\n#include \n#include \"lgraph/lgraph.h\"\n#include \"lgraph/olap_base.h\"\nusing namespace std;\n\nextern \"C\" bool Process(lgraph_api::GraphDB &db, const std::string &request, std::string &response);\n\nint main(int argc, char **argv) {\n    // db_path表示预加载图数据存放的路径\n    std::string db_path = \"../fb_db/\";\n    if (argc > 1)\n        db_path = argv[1];\n    lgraph_api::Galaxy g(db_path);\n    g.SetCurrentUser(\"admin\", \"73@TuGraph\");\n    // 指定图数据的名称\n    lgraph_api::GraphDB db = g.OpenGraph(\"fb_db\");\n    std::string resp;\n    // 以json形式输入算法参数\n    bool r = Process(db, \"{\\\"root_id\\\":\\\"0\\\", \\\"label\\\":\\\"node\\\",\\\"field\\\":\\\"id\\\"}\", resp);\n    cout << r << endl;\n    cout << resp << endl;\n    return 0;\n}\n```\n保存后在tugraph-db/procedures 目录下执行`bash make_embed.sh bfs`即可在tugraph-db/procedures/algo_cpp 目录下得到bfs_procedure文件。\n\n在tugraph-db/procedures 文件夹下执行`./algo_cpp/bfs_procedure` 即可得到返回结果：\n\n该段落位于文档的第3部分，详细描述了TuGraph的Embed编译与运行方式，主要用于在后台程序中对预加载的图数据库数据进行算法分析。该部分包括C++代码示例和操作步骤，指导用户如何完善代码、编译和执行算法，从而获取算法运行的返回结果。"
            },
            {
                "content": "在tugraph-db/procedures 文件夹下执行`./algo_cpp/bfs_procedure` 即可得到返回结果：\n\n```json\n{\n  \"core_cost\":0.025603055953979492,\n  \"found_vertices\":3829,\n  \"num_edges\":88234,\n  \"num_vertices\":4039,\n  \"output_cost\":9.059906005859375e-06,\n  \"prepare_cost\":0.056738853454589844,\n  \"total_cost\":0.0823509693145752\n}\n```\n\n参数解释同上。\n\n### Python：\n在tugraph-db/procedures文件夹下执行\n`bash make_so_cython.sh bfs`\n或在tugraph-db/procedures/algo_cython文件夹下执行\n`python3 setup.py build_ext -i`\n得到bfs.so后，在Python中import bfs可使用，如tugraph-db/procedures/run_embed.py所示\n\n```python\n# tugraph-db/procedures/run_embed.py\nfrom lgraph_db_python import *\n\nimport bfs as python_plugin\n\nif __name__ == \"__main__\":\n    galaxy = PyGalaxy(\"../build/output/lgraph_db\")\n    galaxy.SetCurrentUser(\"admin\", \"73@TuGraph\")\n    db = galaxy.OpenGraph(\"default\", False)\n    res = python_plugin.Process(db, \"{\\\"root_id\\\":\\\"0\\\", \\\"label\\\":\\\"node\\\",\\\"field\\\":\\\"id\\\"}\".encode('utf-8'))\n    print(res)\n    del db\n    del galaxy\n```\n通过如下命令执行\n\n```bash\npython3 run_embed.py\n```\n\n输出结果与C++相同。\n\n该段落位于文档的\"Embed 编译与运行\"部分，主要描述了如何在TuGraph环境中使用C++和Python进行BFS算法的嵌入式运行及其返回结果，包括运行命令、输出结果示例及参数解释。这为用户提供了实用的操作指南，帮助他们理解和实施图算法分析。"
            },
            {
                "content": "```python\n# tugraph-db/procedures/run_embed.py\nfrom lgraph_db_python import *\n\nimport bfs as python_plugin\n\nif __name__ == \"__main__\":\n    galaxy = PyGalaxy(\"../build/output/lgraph_db\")\n    galaxy.SetCurrentUser(\"admin\", \"73@TuGraph\")\n    db = galaxy.OpenGraph(\"default\", False)\n    res = python_plugin.Process(db, \"{\\\"root_id\\\":\\\"0\\\", \\\"label\\\":\\\"node\\\",\\\"field\\\":\\\"id\\\"}\".encode('utf-8'))\n    print(res)\n    del db\n    del galaxy\n```\n通过如下命令执行\n\n```bash\npython3 run_embed.py\n```\n\n输出结果与C++相同。\n\n## 4. Standalone 编译与运行\n\n该文件主要用于在终端处直接加载图数据，并运行打印输出结果。使用方法如下：\n在tugraph-db/build目录下执行`make bfs_standalone` (需要在g++默认include路径中包含boost/sort/sort.hpp)即可得到bfs_standalone文件,该文件生成于tugraph-db/build/output/algo文件夹下。\n运行方式：在tugraph-db/build目录下执行`./output/algo/bfs_standalone -–type [type] –-input_dir [input_dir] --id_mapping [id_mapping] -–vertices [vertices] --root [root] –-output_dir [output_dir]`即可运行。\n\n该代码块位于文档的“Embed 编译与运行”部分，介绍了如何在TuGraph中使用Python进行图算法分析的具体实例，展示了一段用于加载图数据并执行BFS算法的Python代码。同时，紧接着介绍了“Standalone 编译与运行”的部分，讲解了如何在终端直接加载图数据并运行算法。"
            },
            {
                "content": "```bash\npython3 run_embed.py\n```\n\n输出结果与C++相同。\n\n## 4. Standalone 编译与运行\n\n该文件主要用于在终端处直接加载图数据，并运行打印输出结果。使用方法如下：\n在tugraph-db/build目录下执行`make bfs_standalone` (需要在g++默认include路径中包含boost/sort/sort.hpp)即可得到bfs_standalone文件,该文件生成于tugraph-db/build/output/algo文件夹下。\n运行方式：在tugraph-db/build目录下执行`./output/algo/bfs_standalone -–type [type] –-input_dir [input_dir] --id_mapping [id_mapping] -–vertices [vertices] --root [root] –-output_dir [output_dir]`即可运行。\n\n- `[type]`：表示输入图文件的类型来源，包含text文本文件、BINARY_FILE二进制文件和ODPS源。\n- `[input_dir]`：表示输入图文件的文件夹路径，文件夹下可包含一个或多个输入文件。TuGraph在读取输入文件时会读取[input_dir]下的所有文件，要求[input_dir]下只能包含输入文件，不能包含其它文件。参数不可省略。\n- `[id_mapping]`：当读入边表时，是否对输入数据做id映射，使达到符合算法运行的形式。1为需要做id映射，0为不需要做。该过程会消耗一定时间。参数可省略，默认值为0。\n- `[vertices]`：表示图的点个数，为0时表示用户希望系统自动识别点数量；为非零值时表示用户希望自定义点个数，要求用户自定义点个数需大于最大的点ID。参数可省略，默认值为0。\n- `[root]`：表示进行bfs的起始点id。参数不可省略。\n- `[output_dir]`：表示输出数据保存的文件夹路径，将输出内容保存至该文件中，参数不可省略。\n\n示例：\n\n### C++:\n在tugraph-db/build编译standalone算法程序\n\n```bash\nmake bfs_standalone\n```\n\n在tugraph-db/build/output目录下运行text源文件\n\n本文档介绍了TuGraph的图计算API，主要涵盖图分析引擎的基本操作和三种运行方式。当前段落专注于Standalone模式的编译与运行，提供了如何直接在终端加载图数据并运行BFS算法的详细步骤和示例。"
            },
            {
                "content": "示例：\n\n### C++:\n在tugraph-db/build编译standalone算法程序\n\n```bash\nmake bfs_standalone\n```\n\n在tugraph-db/build/output目录下运行text源文件\n\n```bash\n./output/algo/bfs_standalone --type text --input_dir ../test/integration/data/algo/fb_unweighted --root 0\n```\n\n得到运行结果：\n\n```text\nprepare_cost = 0.10(s)\ncore_cost = 0.02(s)\nfound_vertices = 3829\noutput_cost = 0.00(s)\ntotal_cost = 0.11(s)\nDONE.\n```\n\n结果参数解释同上。\n\n对于新的算法，运行时不了解该算法的所需参数时，可通过`./output/algo/bfs_standalone -h`进行查阅对应参数。\n\n### Python:\nPython语言的bfs拓展编译过程与embed模式无区别，在运行时通过`Standalone`接口调用，示例如下：\n```python\n# tugraph-db/procedures/run_standalone.py\nimport bfs as python_plugin\n\nif __name__ == \"__main__\":\n    python_plugin.Standalone(input_dir=\n                             \"../test/integration/data/algo/fb_unweighted\",\n                             root=0)\n```\n\n通过如下命令执行\n\n```bash\npython3 run_standalone.py\n```\n\n至此，通过TuGraph对上图进行bfs运算的过程已经完成。\n\n该块内容位于文档的第四部分“Standalone 编译与运行”，介绍了如何在终端上编译和运行bfs算法，包括C++和Python的示例代码及其执行过程，旨在帮助用户理解如何在此运行模式下使用TuGraph进行图计算。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_36.md",
        "chunks": [
            {
                "content": "# Framework原理介绍\n\n## 架构图\n\nGeaFlow Framework的架构：\n\n本文档主要介绍GeaFlow Framework的原理，包括其架构图、计算引擎的核心模块、调度模型、运行时执行、容错机制等，帮助读者理解GeaFlow的设计与实现。此部分为文档的开头部分，概述了框架的整体结构和组件。"
            },
            {
                "content": "* **高阶API**：GeaFlow通过Environment接口适配异构的分布式执行环境（K8S、Ray、Local），使用Pipeline封装了用户的数据处理流程，使用Window抽象统一了流处理（无界Window）和批处理（有界Window）。Graph接口提供了静态图和动态图（流图）上的计算API，如append/snapshot/compute/traversal等，Stream接口提供了统一流批处理API，如map/reduce/join/keyBy等。\n* **逻辑执行计划**：逻辑执行计划信息统一封装在PipelineGraph对象内，将高阶API对应的算子（Operator）组织在DAG中，算子一共分为5大类：SourceOperator对应数据源加载、OneInputOperator/TwoInputOperator对应传统的数据处理、IteratorOperator对应静态/动态图计算。DAG中的点（PipelineVertex）记录了算子（Operator）的关键信息，如类型、并发度、算子函数等信息，边（PipelineEdge）则记录了数据shuffle的关键信息，如Partition规则（forward/broadcast/key等）、编解码器等。\n* **物理执行计划**：物理执行计划信息统一封装在ExecutionGraph对象内，并支持二级嵌套结构，以尽可能将可以流水线执行的子图（ExecutionVertexGroup）结构统一调度。图中示例的物理执行计划DAG被划分为三部分子图结构分别执行。\n* **调度器**：GeaFlow设计了基于Cycle的调度器（CycleScheduler）实现对流、批、图的统一调度，调度过程通过事件驱动模型触发。物理执行计划中的每部分子图都会被转换为一个ExecutionCycle对象，调度器会向Cycle的头结点（Head）发送Event，并接收Cycle尾结点（Tail）的发回的Event，形成一个完整的调度闭环。对于流处理，每一轮Cycle调度会完成一个Window的数据的处理，并会一直不停地执行下去。对于批处理，整个Cycle调度仅执行一轮。对于图处理，每一轮Cycle调度会完成一次图计算迭代。\n\n该段落介绍了GeaFlow Framework的高阶API、逻辑执行计划、物理执行计划以及调度器的设计与功能，作为框架原理和架构图的核心内容，为后续关于计算引擎和运行时组件的详细说明奠定了基础。"
            },
            {
                "content": "* **物理执行计划**：物理执行计划信息统一封装在ExecutionGraph对象内，并支持二级嵌套结构，以尽可能将可以流水线执行的子图（ExecutionVertexGroup）结构统一调度。图中示例的物理执行计划DAG被划分为三部分子图结构分别执行。\n* **调度器**：GeaFlow设计了基于Cycle的调度器（CycleScheduler）实现对流、批、图的统一调度，调度过程通过事件驱动模型触发。物理执行计划中的每部分子图都会被转换为一个ExecutionCycle对象，调度器会向Cycle的头结点（Head）发送Event，并接收Cycle尾结点（Tail）的发回的Event，形成一个完整的调度闭环。对于流处理，每一轮Cycle调度会完成一个Window的数据的处理，并会一直不停地执行下去。对于批处理，整个Cycle调度仅执行一轮。对于图处理，每一轮Cycle调度会完成一次图计算迭代。\n* **运行时组件**：GeaFlow运行时会拉起Client、Master、Driver、Container组件。当Client提交Pipeline给Driver后，会触发执行计划构建、分配Task（ResourceManagement提供资源）和调度。每个Container内可以运行多个Worker组件，不同Worker组件之间通过Shuffle模块交换数据，所有的Worker都需要定期向Master上报心跳（HeartbeatManagement），并向时序数据库上报运行时指标信息。另外GeaFlow运行时也提供了故障容忍机制（FailOver），以便在异常/中断后能继续执行。\n\n该段落主要介绍GeaFlow框架中的物理执行计划、调度器及运行时组件的功能和工作机制，属于计算引擎核心模块的详细描述部分，旨在阐明系统如何实现任务调度与执行的具体流程及结构。"
            },
            {
                "content": "## 计算引擎\nGeaFlow计算引擎核心模块主要包括执行计划生成和优化、统一Cycle调度以及Worker运行时执行。下面就这几个核心模块进行介绍说明。\n\n### 执行计划\n针对流图场景提交的PipelineTask，构建统一的执行计划模型，并通过将不同的执行模式，以group方式聚合到一起，为调度提供统一执行单元。\n\n* PipelineGraph\n  将用户api提交的PipeleTask构建出PipelineGraph: 将用户api转换为算子后对应一个vertex，veretx之间的数据依赖以edge表示。PipelineGraph只是将api构建为结构化的逻辑执行计划，没有物理执行的语义。\n\n* ExecutionGraph\n  将PipelineGraph基于不同的计算模型，将一组可重复执行的vertex聚合到一起，构建对应的ExecutionGroup，每个group表示可以独立调度执行的单元，一个group可以由一个或者多个vertex构建，可以看做一个小的执行计划，group内部数据以pipeline模式交换，group之间数据以batch模式交换。group描述了具体的执行模式，支持嵌套，可以只执行一次，也可只执行多次，可以一次执行一个或者多个窗口的数据。group如下图所示。\n  ExecutionGroup最终会转换为调度执行的基本单元cycle。\n\n### 调度模型\n调度将基于ExecutionGraph定义的ExecutionGroup生成调度基本单元cycle。cycle描述为可循环执行的基本单元，包含输入，中间计算和数据交换，输出的描述。调度执行过程主要是：\n1. 将执行计划划分为一组cycle，cycle与cycle之间如果没有数据依赖，可以串行执行，也可以并行执行。\n2. 依据cycle调度数据策略，依次调度执行cycle。\n3. 直到所有cycle执行结束，返回调度执行结果。\n\n该文档主要介绍GeaFlow Framework的架构和原理，包括高阶API、逻辑执行计划、物理执行计划、调度器以及运行时组件。在此背景下，\"计算引擎\"部分详细阐述了GeaFlow的核心模块，重点在于执行计划的生成与优化、调度模型的构建，以及Worker的运行时执行方式，以支持流图场景下的统一调度与执行管理。"
            },
            {
                "content": "### 调度模型\n调度将基于ExecutionGraph定义的ExecutionGroup生成调度基本单元cycle。cycle描述为可循环执行的基本单元，包含输入，中间计算和数据交换，输出的描述。调度执行过程主要是：\n1. 将执行计划划分为一组cycle，cycle与cycle之间如果没有数据依赖，可以串行执行，也可以并行执行。\n2. 依据cycle调度数据策略，依次调度执行cycle。\n3. 直到所有cycle执行结束，返回调度执行结果。\n\n每个cycle包含一组可被执行的ExecutionTask，每个task可以被分发到远程执行。一个cycle内的所有execution task可以分为如下：\nhead task: cycle数据流的起点，调度向head task发送一轮执行的event，然后从source，或者上一个cycle输出中读取数据，处理后发送给下游\ntail task: cycle数据流的结尾，处理完数据后，向调度发送event，表示完成一轮计算。\n其余非head/tail task: 中间执行task，接收上游输入数据，处理后直接发送给下游执行。\n\ncycle调度执行的过程，就是不断发送event给head，并从tail收到返回event的过程，整个过程类似一个“循环”，如下图所示。调度根据不同的cycle类型，初始化调度状态，调度的过程也是状态变迁的过程，根据收到的event，决定下一轮要发送给head的event类型。\n\n该块内容位于文档的“计算引擎”部分，具体介绍了GeaFlow框架中的调度模型。它详细描述了如何基于ExecutionGraph生成执行单元cycle的过程，以及在调度执行中如何处理输入、计算和输出的环节，确保任务的高效调度与执行。"
            },
            {
                "content": "每个cycle包含一组可被执行的ExecutionTask，每个task可以被分发到远程执行。一个cycle内的所有execution task可以分为如下：\nhead task: cycle数据流的起点，调度向head task发送一轮执行的event，然后从source，或者上一个cycle输出中读取数据，处理后发送给下游\ntail task: cycle数据流的结尾，处理完数据后，向调度发送event，表示完成一轮计算。\n其余非head/tail task: 中间执行task，接收上游输入数据，处理后直接发送给下游执行。\n\ncycle调度执行的过程，就是不断发送event给head，并从tail收到返回event的过程，整个过程类似一个“循环”，如下图所示。调度根据不同的cycle类型，初始化调度状态，调度的过程也是状态变迁的过程，根据收到的event，决定下一轮要发送给head的event类型。\n\n### Runtime执行\n#### 整体介绍\nRuntime模块负责GeaFlow所有模式任务（包括流批、静态/动态图）的具体计算和执行。其整个worker流程如下：\n1. Scheduler调度器负责将各种类型的Event发送给Container处理\n2. Dispatcher(继承至AbstractTaskRunner)负责接收来自Scheduler发送的Event，然后将Event按照其workerId分发给指定的TaskRunner进行处理\n3. TaskRunner（也继承至AbstractTaskRunner）负责从taskQueue中获取TASK(Event)，具体Event事件将交由Task进行处理，其整个生命周期包括：创建、处理及结束，对于异常的Task，可以直接中断。\n   a. Task创建和初始化会根据CreateTaskEvent事件来完成，Task生命周期结束会根据DestroyTaskEvent事件来完成。\n   b. 其它类型的Event，都将通过相应的CommandEvent的execute()来完成具体计算语义层面的逻辑（例如：根据InitCycleEvent事件Worker将进行上下游依赖构建；根据LaunchSourceEvent事件Worker将触发source开始读数据等）\n\n该chunk位于文档的“调度模型”部分，详细描述了每个cycle中执行任务的结构，以及cycle调度执行的过程。同时，它紧接着介绍了“Runtime执行”模块的整体流程，包括调度器、Dispatcher和TaskRunner的角色以及它们在处理Event时的工作机制。"
            },
            {
                "content": "当前Task中的TaskContext核心数据结构，主要包括：负责执行计算的Worker、负责下游节点从上游异步读取数据的FetchService以及负责将执行Worker产生的数据向下游输出的EmitterService。\n* Worker：其主要负责流图数据的对齐处理以及将每批处理结束后相应的DoneEvent callback回Scheduler，Scheduler依据相应的DoneEvent进行后续的调度逻辑。\n* FetchService：负责异步的从上游channel中Pull数据，并将其通过worker注册的Listener，将数据放入worker processing队列中。\n* EmitterService：负责将Worker产生的数据进行partition写入到对应的Channel中。\n\n#### Command Event\n* Command Event分为两种：\n    * 普通的Command Event，不带具体的execute执行逻辑，通常用于Trigger Task或Cycle进行生命周期的开始和结束；\n    * 可执行的Command Event，自身具备execute执行逻辑，例如用于Cycle的初始化、Source节点的数据读取、处理节点的计算、Cycle结束后的清理等等。\n* 在调度模块中，会将各种类型的Event构建成一个State Machine，用于整个调度任务的生命周期管理。\n* 开发者可以根据设计需要扩展Event以及实现对应的execute计算逻辑，同时加入到State Machine中，Scheduler就可以自动将其按照期望的方式进行调度和执行。\n\n### 容错和异常恢复\n#### 集群组件容错\n对于运行时的所有组件进程，比如master/driver/container,都基于context初始化和运行。在新创建进程时，首先构建进程需要的context，每个进程在初始化时将context做持久化。当进程异常重启后，首先恢复context，然后基于context重新初始化进程。\n\n该段落主要介绍了GeaFlow框架中的TaskContext核心数据结构及其组成部分，包括Worker、FetchService和EmitterService，以及Command Event的类型和用途。同时，文中还阐述了集群组件的容错机制和作业异常恢复策略，为了解整个运行时组件的功能和可靠性提供了背景。"
            },
            {
                "content": "### 容错和异常恢复\n#### 集群组件容错\n对于运行时的所有组件进程，比如master/driver/container,都基于context初始化和运行。在新创建进程时，首先构建进程需要的context，每个进程在初始化时将context做持久化。当进程异常重启后，首先恢复context，然后基于context重新初始化进程。\n\n#### 作业异常恢复\n* 作业分布式快照\n  调度器根据当前自身调度状态，确定对运行中的任务发送新的windowId，触发对新窗口的计算。当每个算子对应窗口计算结束后，如果需要对当前窗口上下文做快照，则将算子内对应状态持久化到存储中。\n  最终调度器收到某个窗口的所有任务执行结束的消息后，也会按需要对该调度元信息做一次快照并持久化，才标志这个窗口的处理最终成。当调度和算子恢复到这个窗口上下文时，则可以基于该窗口继续执行。\n\n* 快照持久化\n  在一个window计算完成做一次快照时，可以选择快照存储的方式。目前可选MEMORY，ROCKSDB, JDBC。\n\n* 状态恢复\n  快照存储是分布式的，每个组件，调度和算子之间各自存储并持久化。在恢复时，首先调度先从存储中恢复上一次完成执行的windowId，并调度的上下文恢复到对应windowId对应的快照。然后对所有worker发送rollback指令，每个worker恢复到指定窗口上下文。最后由调度开始继续发送执行任务，从恢复状态基础上继续执行。\n\n该段落位于文档的最后部分，主要介绍GeaFlow框架的容错和异常恢复机制，包括集群组件容错的初始化与重启流程，以及作业的分布式快照、快照持久化和状态恢复的具体实现细节。这些内容是对GeaFlow计算引擎运行时组件的重要补充，旨在确保系统在出现异常时能够正确恢复继续执行。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_37.md",
        "chunks": [
            {
                "content": "# Traversal API\n\n> 此文档主要讲解 TuGraph 的存储过程中的Traversal API\n\n## 1. 简介\n\nTuGraph 强大的在线分析处理（OLAP）能力是其区别于其它图数据库的一个重要特性。\n借助 C++ OLAP API（olap_on_db.h），用户可以快速地导出一个需要进行复杂分析的子图，然后在其上运行诸如 PageRank、连通分量、社区发现等迭代式图计算过程，最后根据结果做出相应决策。\n导出和计算的过程都可以通过并行处理的方式进行加速，从而实现几乎实时的分析处理，避免了传统解决方案需要将数据导出、转换、再导入（ETL）到专门的分析系统进行离线处理的冗长步骤。\n\nTuGraph 内置了大量常用的图分析算法和丰富的辅助接口，因此用户几乎不需要自己来实现具体的图计算过程，只需在实现自己的存储过程时将相应算法库的头文件（.h 文件）包含到自己程序中，并在编译时链接相应的动态库文件（.so）即可。\n一般情况下，用户需要自己实现的只有将需要分析的子图抽取出来的过程。\n\n目前 Traversal API 仅支持 C++。\n\n## 2. 接口说明\n\n### 2.1. Snapshot\n\nC++ OLAP API 中的 Snapshot 模版类用于表示抽取出来的静态子图，其中 EdgeData 用来表示该子图上每条边所用权值的数据类型（如果边不需要权值，使用 Empty 作为 EdgeData 即可）。\n\n抽取的子图通过 Snapshot 类的构造函数来描述：\n\n```c\nSnapshot::Snapshot(\n    GraphDB & db,\n    Transaction & txn,\n    size_t flags = 0,\n    std::function vertex_filter = nullptr,\n    std::function out_edge_filter = nullptr\n);\n```\n\n本文档主要介绍TuGraph的Traversal API，强调其在存储过程中的应用，特别是C++ OLAP API的使用。第一部分简介了TuGraph的OLAP能力和用户如何通过该API进行复杂图分析，随后详细讨论了Snapshot类的构造函数及其在静态子图抽取中的作用。"
            },
            {
                "content": "目前 Traversal API 仅支持 C++。\n\n## 2. 接口说明\n\n### 2.1. Snapshot\n\nC++ OLAP API 中的 Snapshot 模版类用于表示抽取出来的静态子图，其中 EdgeData 用来表示该子图上每条边所用权值的数据类型（如果边不需要权值，使用 Empty 作为 EdgeData 即可）。\n\n抽取的子图通过 Snapshot 类的构造函数来描述：\n\n```c\nSnapshot::Snapshot(\n    GraphDB & db,\n    Transaction & txn,\n    size_t flags = 0,\n    std::function vertex_filter = nullptr,\n    std::function out_edge_filter = nullptr\n);\n```\n\n其中，db 为数据库句柄，txn 为事务句柄，flags 为生成时使用的选项，可选值包括以下的组合：SNAPSHOT_PARALLEL 表示导出时使用多个线程进行并行；SNAPSHOT_UNDIRECTED 表示需要将导出的图变为无向图。\nvertex_filter 是面向点的用户自定义过滤函数，返回值为 true 表示该点需要被包含到待抽取的子图中，反之则表示需要被排除。\nout_edge_filter 是面向边的用户自定义过滤函数，返回值为 true 表示该边需要被包含到待抽取的子图中，反之则表示需要被排除。\n当过滤函数为缺省值时，则表示需要将所有点/边都包含进来。\n\nSnapshot 类提供的其它方法请参考详细的 C++ API 文档（olap_on_db.h）。\n\n### 2.2. Traversal\n\n该块内容位于文档的第二部分，介绍了 TuGraph 的 Traversal API 接口，包含 Snapshot 模版类的详细说明以及其构造函数的参数解析，为后续的 Traversal 具体实现提供基础信息。"
            },
            {
                "content": "其中，db 为数据库句柄，txn 为事务句柄，flags 为生成时使用的选项，可选值包括以下的组合：SNAPSHOT_PARALLEL 表示导出时使用多个线程进行并行；SNAPSHOT_UNDIRECTED 表示需要将导出的图变为无向图。\nvertex_filter 是面向点的用户自定义过滤函数，返回值为 true 表示该点需要被包含到待抽取的子图中，反之则表示需要被排除。\nout_edge_filter 是面向边的用户自定义过滤函数，返回值为 true 表示该边需要被包含到待抽取的子图中，反之则表示需要被排除。\n当过滤函数为缺省值时，则表示需要将所有点/边都包含进来。\n\nSnapshot 类提供的其它方法请参考详细的 C++ API 文档（olap_on_db.h）。\n\n### 2.2. Traversal\n\n图数据库中十分常见的一大类分析是基于一个或多个点出发，逐层地拓展并访问邻居。\n尽管这类分析也可以使用 Cypher 完成，但是当访问的层数较深时，其性能会受到串行解释执行的限制。\n使用 C++ Core API 编写存储过程尽管避免了解释执行，但依然受限于单个线程的处理能力。\n为了让用户能够方便地通过并行处理的方式加速这一类应用场景，我们基于 C++ OLAP API 封装了一个 Traversal 框架，用户可以直接使用其中的 FrontierTraversal 和 PathTraversal 类来完成这种逐层遍历的分析任务，具体的使用方法可以参考相应的 C++ API 文档（lgraph_traversal.h）。\n\n```c\nParallelVector FindVertices(\n    GraphDB & db,\n    Transaction & txn,\n    std::function filter,\n    bool parallel = false\n);\n```\n\n该方法可用于找到所有满足条件（filter 返回 true）的点，当 parallel 为 true 时则会并行该查找过程。\n\n该片段位于文档的第二部分，主要介绍了 TuGraph 中的 Snapshot 类及其构造函数的参数说明，包括数据库和事务句柄的定义、选项标志、用户自定义过滤函数等。此外，片段还引入了 Traversal 的概念，解释了针对图数据库中逐层遍历邻居的分析任务，强调了 C++ OLAP API 对该过程的支持和加速方式。"
            },
            {
                "content": "```c\nParallelVector FindVertices(\n    GraphDB & db,\n    Transaction & txn,\n    std::function filter,\n    bool parallel = false\n);\n```\n\n该方法可用于找到所有满足条件（filter 返回 true）的点，当 parallel 为 true 时则会并行该查找过程。\n\n```c\ntemplate \nParallelVector ExtractVertexData(\n    GraphDB & db,\n    Transaction & txn,\n    ParallelVector & frontier,\n    std::function extract,\n    bool parallel = false\n);\n```\n\n该方法可用于从指定点集（frontier）中（通过 extract 方法）抽取（类型为 VertexData 的）属性，当 parallel 为 true 时会并行该抽取过程。\n\nFrontierTraversal 适用于只关注遍历扩展到的点集的情况；当用户在遍历过程或是结果中需要访问路径上的信息（路径上的点/边）时，则需要使用 PathTraversal。\n两类 Traversal 的构造函数均有四个参数，分别为数据库句柄 db、事务句柄 txn、选项 flags 和 初始化数组容量 capacity。\n选项的可选值包括以下的组合：TRAVERSAL_PARALLEL 表示遍历时使用多个线程并行；TRAVERSAL_ALLOW_REVISITS 表示遍历时允许重复地访问点（PathTraversal 隐含了该选项）。capacity 表示初始化时路径集合的容量。\n\n```c\nvoid SetFrontier(size_t root_vid);\nvoid SetFrontier(ParallelVector & root_vids);\nvoid SetFrontier(std::function root_vertex_filter);\n```\n\n两类 Traversal 设置遍历的起始点/点集有上述三种方式，前两种通过点 ID 直接指定，最后一种方式则类似于 FindVertices。\n\n该片段位于文档的第2.2节“Traversal”中，主要介绍了TuGraph中的并行点查找和数据提取方法，包括`FindVertices`和`ExtractVertexData`两个函数的详细说明，以及`FrontierTraversal`和`PathTraversal`两类遍历的构造函数和设置起始点的方法。"
            },
            {
                "content": "```c\nvoid SetFrontier(size_t root_vid);\nvoid SetFrontier(ParallelVector & root_vids);\nvoid SetFrontier(std::function root_vertex_filter);\n```\n\n两类 Traversal 设置遍历的起始点/点集有上述三种方式，前两种通过点 ID 直接指定，最后一种方式则类似于 FindVertices。\n\n两类 Traversal 的遍历都是从当前层的点集合出发，根据使用的扩展函数访问每条出边/入边/出边和入边，通过用户自定义的过滤函数决定扩展是否成功，若成功则将邻居点/追加了该条边的路径加入下一层的点/路径集合。\n\n```c\nvoid ExpandOutEdges(\n    std::function out_edge_filter = nullptr,\n    std::function out_neighbour_filter = nullptr\n);\nvoid ExpandInEdges(\n    std::function in_edge_filter = nullptr,\n    std::function in_neighbour_filter = nullptr\n);\nvoid ExpandEdges(\n    std::function out_edge_filter = nullptr,\n    std::function in_edge_filter = nullptr,\n    std::function out_neighbour_filter = nullptr,\n    std::function in_neighbour_filter = nullptr\n);\n```\n\n上述为 FrontierTraversal 的三种遍历方式，即从当前的点集合出发，对集合中的每个点，依次访问每条出边/入边/出边和入边，若满足用户自定义的过滤条件（其中，edge_filter 为面向边的过滤函数，neighbour_filter 则为面向邻居点的过滤函数），则将邻居点加入新的点集合。\n\n```c\nParallelVector & GetFrontier();\n```\n\n当前点集合的扩展结束后，新的点集合可以通过上述方法取得。\n\n该段落位于 TuGraph 的 Traversal API 说明部分，主要介绍两类遍历方法（FrontierTraversal 和 PathTraversal）中设置遍历起始点的函数和扩展邻居点的函数。这些函数允许用户通过不同方式指定遍历的起点，并描述如何根据用户定义的过滤条件扩展到下一个点集合。"
            },
            {
                "content": "上述为 FrontierTraversal 的三种遍历方式，即从当前的点集合出发，对集合中的每个点，依次访问每条出边/入边/出边和入边，若满足用户自定义的过滤条件（其中，edge_filter 为面向边的过滤函数，neighbour_filter 则为面向邻居点的过滤函数），则将邻居点加入新的点集合。\n\n```c\nParallelVector & GetFrontier();\n```\n\n当前点集合的扩展结束后，新的点集合可以通过上述方法取得。\n\n```c\nvoid ExpandOutEdges(\n    std::function out_edge_filter = nullptr,\n    std::function out_neighbour_filter = nullptr\n);\nvoid ExpandInEdges(\n    std::function in_edge_filter = nullptr,\n    std::function in_neighbour_filter = nullptr\n);\nvoid ExpandEdges(\n    std::function out_edge_filter = nullptr,\n    std::function in_edge_filter = nullptr,\n    std::function out_neighbour_filter = nullptr,\n    std::function in_neighbour_filter = nullptr\n);\n```\n\nPathTraversal 的三种遍历方式与 FrontierTraversal 类似，只是用户自定义的过滤函数中增加了两个参数，其中：Path 包含了到新扩展的这条边之前的路径，IteratorHelper 可用于将路径中的点/边转为数据库中对应的迭代器，相关文档可参考对应的 C++ API 文档。\n\n该段落主要描述了 FrontierTraversal 和 PathTraversal 两类遍历方式的具体实现细节，重点介绍了如何从当前点集合出发，访问出边和入边，并根据用户自定义的过滤条件扩展邻居点的过程。同时提到获取新的点集合的方法及路径扩展中使用的参数。这部分内容位于接口说明的 Traversal 小节，旨在帮助用户理解如何通过 C++ OLAP API 进行图遍历分析。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_38.md",
        "chunks": [
            {
                "content": "# 本地包部署\n\n> 此文档主要介绍 TuGraph 的本地包部署。\n\n## 1. 环境准备\n\nTuGraph本地包部署需要对应的环境，快速验证可以使用精简安装包，几乎不需要任何第三方库。\n\n如果您需要使用完整的TuGraph功能，请参见tugraph-db源码目录 ci/images/tugraph-runtime-*-Dockerfile，该脚本包含完整的环境构建流程。\n\n## 2. 安装包下载\n\n最新版本的安装包地址：\n\n该文档主要介绍了TuGraph的本地包部署过程，包括环境准备、安装包下载、以及在不同操作系统（如CentOS和Ubuntu）上的安装方法。重点在于提供最新版本的安装包下载链接和具体的安装步骤，以便用户能够顺利部署TuGraph。"
            },
            {
                "content": "| 描述                  | 文件                                         | 链接                                                                                                                                                                                              |\n|---------------------|--------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| CentOS7 安装包         | tugraph-4.5.0-1.el7.x86_64.rpm             | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.el7.x86_64.rpm)                                                                                      |\n\n该 chunk 位于文档的第二部分，介绍了不同操作系统下 TuGraph 的安装包下载信息，包括 CentOS7、CentOS8 和 Ubuntu18.04 的安装包及其下载链接。具体而言，该段落列出了 CentOS7 的安装包及其下载链接。"
            },
            {
                "content": "| CentOS7 安装包         | tugraph-4.5.0-1.el7.x86_64.rpm             | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.el7.x86_64.rpm)                                                                                      |\n| CentOS8 安装包         | tugraph-4.5.0-1.el8.x86_64.rpm             | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.el8.x86_64.rpm)                                                                                      |\n| Ubuntu18.04 安装包     | tugraph-4.5.0-1.x86_64.deb                 | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.x86_64.deb)                                                                                          |\n\n该块内容位于文档的第二部分，介绍了针对不同操作系统（CentOS7、CentOS8 和 Ubuntu18.04）的 TuGraph 安装包的信息，包括文件名和下载链接，帮助用户获取所需的安装包进行软件部署。"
            },
            {
                "content": "| Ubuntu18.04 安装包     | tugraph-4.5.0-1.x86_64.deb                 | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.x86_64.deb)                                                                                          |\n| CentOS7 预安装镜像       | tugraph-runtime-centos7-4.5.0.tar          | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-centos7-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-runtime-centos7)                   |\n| CentOS8 预安装镜像       | tugraph-runtime-centos8-4.5.0.tar          | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-centos8-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-runtime-centos8)                   |\n\n本段落包含关于 Ubuntu18.04 操作系统的安装包以及 CentOS7 和 CentOS8 的预安装镜像的详细信息，旨在帮助用户快速下载所需的 TuGraph 安装包与镜像，以便进行本地部署。"
            },
            {
                "content": "| CentOS8 预安装镜像       | tugraph-runtime-centos8-4.5.0.tar          | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-centos8-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-runtime-centos8)                   |\n| Ubuntu18.04 预安装镜像   | tugraph-runtime-ubuntu18.04-4.5.0.tar      | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-ubuntu18.04-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-runtime-ubuntu18.04)           |\n| CentOS7 精简安装包       | tugraph-mini-4.5.0-1.el7.x86_64.rpm        | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.el7.x86_64.rpm)                                                                                 |\n\n该块内容包含了与 TuGraph 软件相关的 CentOS8 和 Ubuntu18.04 的预安装镜像以及 CentOS7 的精简安装包的信息，包括文件名称和对应的下载及访问链接。这些信息属于文档中关于安装包下载的部分，帮助用户获取特定操作系统所需的安装资源。"
            },
            {
                "content": "| CentOS7 精简安装包       | tugraph-mini-4.5.0-1.el7.x86_64.rpm        | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.el7.x86_64.rpm)                                                                                 |\n| CentOS8 精简安装包       | tugraph-mini-4.5.0-1.el8.x86_64.rpm        | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.el8.x86_64.rpm)                                                                                 |\n| Ubuntu18.04 精简安装包   | tugraph-mini-4.5.0-1.x86_64.deb            | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.x86_64.deb)                                                                                     |\n\n该块内容位于文档的安装包下载部分，具体列出了TuGraph软件在CentOS7、CentOS8和Ubuntu18.04操作系统上的精简安装包及其下载链接。"
            },
            {
                "content": "| Ubuntu18.04 精简安装包   | tugraph-mini-4.5.0-1.x86_64.deb            | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.x86_64.deb)                                                                                     |\n| CentOS7 精简预安装镜像     | tugraph-mini-runtime-centos7-4.5.0.tar     | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-centos7-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-centos7)         |\n| CentOS8 精简预安装镜像     | tugraph-mini-runtime-centos8-4.5.0.tar     | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-centos8-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-centos8)         |\n\n该片段摘录自TuGraph本地包部署文档中，主要介绍了Ubuntu18.04精简安装包和CentOS7、CentOS8精简预安装镜像的下载链接和相关信息，方便用户根据需要进行安装。"
            },
            {
                "content": "| CentOS8 精简预安装镜像     | tugraph-mini-runtime-centos8-4.5.0.tar     | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-centos8-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-centos8)         |\n| Ubuntu18.04 精简预安装镜像 | tugraph-mini-runtime-ubuntu18.04-4.5.0.tar | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-ubuntu18.04-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-ubuntu18.04) |\n| CentOS7 编译镜像        | tugraph-compile-centos7-1.3.2.tar          | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-centos7-1.3.2.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-compile-centos7)          |\n\n该片段来自于 TuGraph 本地包部署文档中的安装包下载部分，具体列出了针对 CentOS8 和 Ubuntu18.04 的精简预安装镜像及 CentOS7 的编译镜像，包括下载和访问链接。"
            },
            {
                "content": "| CentOS7 编译镜像        | tugraph-compile-centos7-1.3.2.tar          | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-centos7-1.3.2.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-compile-centos7)          |\n| CentOS8 编译镜像        | tugraph-compile-centos8-1.3.2.tar          | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-centos8-1.3.2.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-compile-centos8)          |\n| Ubuntu18.04 编译镜像    | tugraph-compile-ubuntu18.04-1.3.2.tar      | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-ubuntu18.04-1.3.2.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-compile-ubuntu18.04)  |\n表格内容描述:\n该表格包含三个列名: \"描述\"、\"文件\"、和 \"链接\"。\n\n该块内容位于文档的安装包下载部分， specifically 针对不同操作系统（CentOS7、CentOS8 和 Ubuntu18.04）的编译镜像，包括文件名称及相应的下载和访问链接，为用户提供编译环境的选择。"
            },
            {
                "content": "逐行描述表格中的数据内容如下：\n1. CentOS7 安装包的文件为 \"tugraph-4.5.0-1.el7.x86_64.rpm\"，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.el7.x86_64.rpm)。\n2. CentOS8 安装包的文件为 \"tugraph-4.5.0-1.el8.x86_64.rpm\"，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.el8.x86_64.rpm)。\n3. Ubuntu18.04 安装包的文件为 \"tugraph-4.5.0-1.x86_64.deb\"，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.x86_64.deb)。\n4. CentOS7 预安装镜像的文件为 \"tugraph-runtime-centos7-4.5.0.tar\"，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-centos7-4.5.0.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-runtime-centos7)。\n5. CentOS8 预安装镜像的文件为 \"tugraph-runtime-centos8-4.5.0.tar\"，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-centos8-4.5.0.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-runtime-centos8)。\n\n在本地包部署的文档中，该段落描述了与 TuGraph 软件相关的安装包和预安装镜像的具体信息，包括文件名称和下载链接，帮助用户快速找到所需的资源进行安装。"
            },
            {
                "content": "4. CentOS7 预安装镜像的文件为 \"tugraph-runtime-centos7-4.5.0.tar\"，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-centos7-4.5.0.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-runtime-centos7)。\n5. CentOS8 预安装镜像的文件为 \"tugraph-runtime-centos8-4.5.0.tar\"，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-centos8-4.5.0.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-runtime-centos8)。\n6. Ubuntu18.04 预安装镜像的文件为 \"tugraph-runtime-ubuntu18.04-4.5.0.tar\"，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-ubuntu18.04-4.5.0.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-runtime-ubuntu18.04)。\n7. CentOS7 精简安装包的文件为 \"tugraph-mini-4.5.0-1.el7.x86_64.rpm\"，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.el7.x86_64.rpm)。\n\n在本地包部署文档的第二部分“安装包下载”中，详细列出了不同操作系统（如 CentOS7、CentOS8 和 Ubuntu18.04）的相关安装包和预安装镜像的下载链接。所提供的内容主要涉及 CentOS7 和 CentOS8 的预安装镜像及精简安装包的具体信息，方便用户获取所需文件进行安装。"
            },
            {
                "content": "6. Ubuntu18.04 预安装镜像的文件为 \"tugraph-runtime-ubuntu18.04-4.5.0.tar\"，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-ubuntu18.04-4.5.0.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-runtime-ubuntu18.04)。\n7. CentOS7 精简安装包的文件为 \"tugraph-mini-4.5.0-1.el7.x86_64.rpm\"，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.el7.x86_64.rpm)。\n8. CentOS8 精简安装包的文件为 \"tugraph-mini-4.5.0-1.el8.x86_64.rpm\"，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.el8.x86_64.rpm)。\n9. Ubuntu18.04 精简安装包的文件为 \"tugraph-mini-4.5.0-1.x86_64.deb\"，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.x86_64.deb)。\n\n该段落位于本地包部署文档中，具体介绍了与 Ubuntu18.04 和 CentOS 系统相关的预安装镜像及精简安装包的下载信息和链接，帮助用户根据其操作系统选择合适的安装文件进行下载。"
            },
            {
                "content": "8. CentOS8 精简安装包的文件为 \"tugraph-mini-4.5.0-1.el8.x86_64.rpm\"，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.el8.x86_64.rpm)。\n9. Ubuntu18.04 精简安装包的文件为 \"tugraph-mini-4.5.0-1.x86_64.deb\"，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.x86_64.deb)。\n10. CentOS7 精简预安装镜像的文件为 \"tugraph-mini-runtime-centos7-4.5.0.tar\"，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-centos7-4.5.0.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-centos7)。\n11. CentOS8 精简预安装镜像的文件为 \"tugraph-mini-runtime-centos8-4.5.0.tar\"，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-centos8-4.5.0.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-centos8)。\n\n该段落介绍了TuGraph在不同操作系统（CentOS8和Ubuntu18.04）下的精简安装包及其下载链接，并包含了对应的精简预安装镜像信息，旨在帮助用户快速获取所需的文件以进行本地部署。"
            },
            {
                "content": "11. CentOS8 精简预安装镜像的文件为 \"tugraph-mini-runtime-centos8-4.5.0.tar\"，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-centos8-4.5.0.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-centos8)。\n12. Ubuntu18.04 精简预安装镜像的文件为 \"tugraph-mini-runtime-ubuntu18.04-4.5.0.tar\"，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-ubuntu18.04-4.5.0.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-ubuntu18.04)。\n13. CentOS7 编译镜像的文件为 \"tugraph-compile-centos7-1.3.2.tar\"，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-centos7-1.3.2.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-compile-centos7)。\n\n该文档介绍TuGraph的本地包部署，其中包含不同操作系统下的安装包、预安装镜像和编译镜像的详细信息。上述内容为该文档中关于CentOS8和Ubuntu18.04精简预安装镜像及CentOS7编译镜像的具体描述，包括文件名、下载链接和访问链接，以便用户选择合适的资源进行安装和使用。"
            },
            {
                "content": "13. CentOS7 编译镜像的文件为 \"tugraph-compile-centos7-1.3.2.tar\"，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-centos7-1.3.2.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-compile-centos7)。\n14. CentOS8 编译镜像的文件为 \"tugraph-compile-centos8-1.3.2.tar\"，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-centos8-1.3.2.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-compile-centos8)。\n15. Ubuntu18.04 编译镜像的文件为 \"tugraph-compile-ubuntu18.04-1.3.2.tar\"，下载链接为 [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-ubuntu18.04-1.3.2.tar)，访问链接为 [访问](https://hub.docker.com/r/tugraph/tugraph-compile-ubuntu18.04)。\n\n该片段位于文档的第二部分，关于 TuGraph 的安装包和预安装镜像，具体列出了针对 CentOS7、CentOS8 和 Ubuntu18.04 的编译镜像及其下载和访问链接，帮助用户获取相关资源以进行编译和安装。"
            },
            {
                "content": "总结：\n该表格列出了不同操作系统（CentOS7、CentOS8 和 Ubuntu18.04）下与 \"tugraph\" 软件相关的安装包、预安装镜像和编译镜像，以及相应的下载和访问链接。共有15项内容，涵盖了完整安装、精简安装及编译镜像，方便用户根据需要进行下载和安装。\n\n\n也可以访问Github进行下载：TuGraph Release(https://github.com/TuGraph-family/tugraph-db/releases)\n\n## 3. CentOS 下的安装方法\n\n用于在 CentOS 上安装的 TuGraph 的.rpm 安装包，其中包含了 TuGraph 可执行文件以及编写嵌入式程序和存储过程所需的头文件和相关库文件。\n\n使用已经下载完成的`tugraph_x.y.z.rpm 安装包在终端下安装，只需要运行以下命令：\n\n```shell\n$ rpm -ivh tugraph-x.y.z.rpm\n```\n\n用户也可以通过指定`--prefix`选项指定安装目录。\n\n## 4. Ubuntu 下的安装方法\n\n用于在 Ubuntu 上安装的 TuGraph 的.deb 安装包，其中包含了 TuGraph 可执行文件以及编写嵌入式程序和存储过程所需的头文件和相关库文件。\n\n使用已经下载完成的`tugraph_x.y.z.deb`安装包在终端下安装，只需要运行以下命令：\n\n```shell\n$ sudo dpkg -i tugraph-x.y.z.deb\n```\n\n该命令默认将 TuGraph 安装于`/usr/local`目录下。用户也可以通过指定 `--instdir=` 选项更改安装目录。\n\n该块内容位于文档的总结部分，回顾了与 TuGraph 软件相关的安装包、预安装镜像及编译镜像的信息，并提供了 GitHub 下载链接。随后详细说明了在 CentOS 和 Ubuntu 操作系统下的安装步骤。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_39.md",
        "chunks": [
            {
                "content": "# 技术规划\n\n## 1. 简介\n\n该文档是 TuGraph-DB 未来开发的规划，包括正在开发中、不在开发计划里、已经开发完成但不在开源版本里的功能等。\n\nTuGraph-DB定位开源高性能图数据库，图数据采用集中存储的方式，短期 **不会** 考虑基于分片（Sharding）的数据切分，\n而将支持主备复制的模式来解决高并发读的场景，采用云上存储解决存储容量的问题。\n\n## 2. 已完成功能\n\nTuGraph-DB于2022年9月1日开源，TuGraph-DB在社区的反馈声中，进行日常BUG修复，自身能力得到了完善。\n\n该文档是关于TuGraph-DB未来开发的整体规划，包含已完成功能和未来更新计划。在文档的开头部分，介绍了TuGraph-DB的定位、存储方式以及当前功能的状况，特别强调了其开源特性和高性能目标。"
            },
            {
                "content": "## 2. 已完成功能\n\nTuGraph-DB于2022年9月1日开源，TuGraph-DB在社区的反馈声中，进行日常BUG修复，自身能力得到了完善。\n\n| 版本号   | 功能                               | 时间         |\n|-------|----------------------------------|------------|\n| 3.3.0 | 开源初版                             | 2022.9.1   |\n| 3.3.1 | 图分析引擎重构，多模式支持                    | 2022.10.14 |\n| 3.3.2 | OGM支持，UT覆盖率提升                    | 2022.11.21 |\n| 3.3.3 | 链接认证机制迭代，加入英文文档                  | 2022.12.23 |\n| 3.3.4 | 支持上云，梳理LDBC SNB Audit流程          | 2023.1.28  |\n| 3.4.0 | 支持OLAP Python API, 离线导入升级        | 2023.3.11  |\n| 3.5.0 | 支持POG，前端升级，文档梳理                  | 2023.6.5   |\n| 3.5.1 | 图学习引擎，Procedure Rust API，存储属性分离  | 2023.7.14  |\n| 3.6.0 | 高可用开源，日志系统升级                     | 2023.8.11  |\n| 4.0.0 | ISO GQL支持，新增11个开源图算法，支持m1 Docker | 2023.9.6   |\n| 4.0.1 | 支持时序边排序，新增5个开源图算法                | 2023.9.28  |\n| 4.1.0 | 支持Bolt协议，支持快速在线全量导入，支持地理空间数据类型   | 2023.12.25 |\n表格内容描述：该表格记录了不同版本号的软件更新信息，包含三列：版本号、功能和时间。\n\n该章节具体记录了TuGraph-DB从2022年9月1日开源以来，各版本的已完成功能及更新时间，展示了软件的持续更新和功能增强，为读者提供了对软件发展历程的全面了解。"
            },
            {
                "content": "1. 在版本3.3.0中，发布了开源初版，时间为2022年9月1日。\n2. 版本3.3.1进行了图分析引擎重构，并且支持多模式，发布时间为2022年10月14日。\n3. 版本3.3.2增加了OGM支持，并提升了UT覆盖率，发布时间为2022年11月21日。\n4. 版本3.3.3迭代了链接认证机制，并加入了英文文档，发布日期是2022年12月23日。\n5. 版本3.3.4支持上云，并梳理了LDBC SNB Audit流程，时间为2023年1月28日。\n6. 版本3.4.0支持OLAP Python API，并对离线导入进行了升级，发布时间为2023年3月11日。\n7. 版本3.5.0支持POG，进行了前端升级，并梳理了文档，发布时间为2023年6月5日。\n8. 版本3.5.1发布了图学习引擎，增加了Procedure Rust API，并实现了存储属性分离，时间为2023年7月14日。\n9. 版本3.6.0实现了高可用开源，并升级了日志系统，发布时间为2023年8月11日。\n10. 版本4.0.0支持ISO GQL，并新增了11个开源图算法，还支持m1 Docker，发布时间为2023年9月6日。\n11. 版本4.0.1支持时序边排序，并新增了5个开源图算法，发布时间为2023年9月28日。\n12. 版本4.1.0支持Bolt协议，快速在线全量导入，并支持地理空间数据类型，发布日期是2023年12月25日。\n\n总体来看，该表格展示了该软件从版本3.3.0到4.1.0的发展历程，涵盖了功能的持续增强、支持的新技术、以及版本升级的时间节点。\n\n除此之外，TuGraph-DB搭建了较为完善的质量体系，涵盖自动化的单元测试、集成测试、性能测试等。\n\n更详细的描述可以在源码目录在的 \"[root]/release/CHANGELOG.md\" 文件查看。\n\n## 3. 2024年功能更新\n\n在2024年度，我们计划的功能更新包括：\n\n该片段位于技术规划文档的第二部分，详细记录了TuGraph-DB从版本3.3.0到4.1.0之间的更新历史，涵盖了每个版本的主要功能和发布时间，对软件的发展历程进行了概述，并指出了文档的质量体系和后续功能更新计划。"
            },
            {
                "content": "总体来看，该表格展示了该软件从版本3.3.0到4.1.0的发展历程，涵盖了功能的持续增强、支持的新技术、以及版本升级的时间节点。\n\n除此之外，TuGraph-DB搭建了较为完善的质量体系，涵盖自动化的单元测试、集成测试、性能测试等。\n\n更详细的描述可以在源码目录在的 \"[root]/release/CHANGELOG.md\" 文件查看。\n\n## 3. 2024年功能更新\n\n在2024年度，我们计划的功能更新包括：\n\n| 版本号   | 功能                 | 计划时间    |\n|-------|--------------------|---------|\n| 4.2.x | HA支持Witness角色和管理工具 | 2024.3  |\n| 4.2.x | Bolt支持流处理和参数化查询    | 2024.3  |\n| x.x.x | GeaX支持Cypher       | 2024.6  |\n| x.x.x | 支持组合索引             | 2024.6  |\n| x.x.x | 数据导入功能优化           | 2024.6  |\n| x.x.x | 【社区功能】支持地理数据类型使用   | 2024.6  |\n| x.x.x | Cypher能力提升         | 2024.9  |\n| x.x.x | 支持Schema快速变更       | 2024.9  |\n| x.x.x | 向量化支持              | 2024.12 |\n| x.x.x | RPQ支持              | 2024.12 |\n| x.x.x | 【可选】查询引擎升级         | 2024.12 |\n| x.x.x | 【社区功能】支持GraphAr    | 2024.12 |\n表格内容描述: 该表格包含三个列名：版本号、功能和计划时间。\n\n该段落位于文档的第三部分，介绍了TuGraph-DB在2024年度计划的功能更新，包括新功能的版本号、具体功能描述以及计划实施时间，并附有表格概述相关信息。"
            },
            {
                "content": "- 第一行：版本号为4.2.x，功能为HA支持Witness角色和管理工具，计划时间为2024年3月。\n- 第二行：版本号为4.2.x，功能为Bolt支持流处理和参数化查询，计划时间为2024年3月。\n- 第三行：版本号为x.x.x，功能为GeaX支持Cypher，计划时间为2024年6月。\n- 第四行：版本号为x.x.x，功能为支持组合索引，计划时间为2024年6月。\n- 第五行：版本号为x.x.x，功能为数据导入功能优化，计划时间为2024年6月。\n- 第六行：版本号为x.x.x，功能为支持地理数据类型使用的社区功能，计划时间为2024年6月。\n- 第七行：版本号为x.x.x，功能为Cypher能力提升，计划时间为2024年9月。\n- 第八行：版本号为x.x.x，功能为支持Schema快速变更，计划时间为2024年9月。\n- 第九行：版本号为x.x.x，功能为向量化支持，计划时间为2024年12月。\n- 第十行：版本号为x.x.x，功能为RPQ支持，计划时间为2024年12月。\n- 第十一行：版本号为x.x.x，功能为可选查询引擎升级，计划时间为2024年12月。\n- 第十二行：版本号为x.x.x，功能为支持GraphAr的社区功能，计划时间为2024年12月。\n\n总体来说，该表格概述了不同版本号下计划实施的功能及其对应的时间安排，涵盖了多个功能优化和社区支持，预计执行时间从2024年3月至12月不等。\n\n## 4. 期望社区共创的功能\n\n目前团队研发精力并不能实现我们对TuGraph-DB的全部期望，在功能的梳理中，我们发现有一系列值得挖掘的想法，\n团队也有一些初步的探索，期望下面功能能够在社区中共同研发。\n\n该段落位于文档的第三部分“2024年功能更新”，具体列出了TuGraph-DB在2024年度计划实施的功能及时间安排，涵盖了多个即将推出的特性和功能优化。此外，接下来的内容引入了对社区共同研发的期望，指向可能的未来发展方向。"
            },
            {
                "content": "总体来说，该表格概述了不同版本号下计划实施的功能及其对应的时间安排，涵盖了多个功能优化和社区支持，预计执行时间从2024年3月至12月不等。\n\n## 4. 期望社区共创的功能\n\n目前团队研发精力并不能实现我们对TuGraph-DB的全部期望，在功能的梳理中，我们发现有一系列值得挖掘的想法，\n团队也有一些初步的探索，期望下面功能能够在社区中共同研发。\n\n| 版本号   | 功能                      | 计划时间   |\n|-------|-------------------------|--------|\n| x.x.x | 图算法库丰富                  | 2024.x |\n| x.x.x | 属性默认值支持                 | 2024.x |\n| x.x.x | Embedded TuGraph-DB最佳实践 | 2024.x |\n| x.x.x | Bolt显式事务支持              | 2024.x |\n| x.x.x | List、Map和Decimal等数据类型扩展 | 2024.x |\n| x.x.x | 探索多存储引擎                 | 2024.x |\n表格内容描述：该表格包含三列，分别是“版本号”、“功能”和“计划时间”。 \n\n1. 第一行数据显示，版本号为x.x.x，功能为“图算法库丰富”，计划时间为2024.x。\n2. 第二行数据显示，版本号为x.x.x，功能为“属性默认值支持”，计划时间为2024.x。\n3. 第三行数据显示，版本号为x.x.x，功能为“Embedded TuGraph-DB最佳实践”，计划时间为2024.x。\n4. 第四行数据显示，版本号为x.x.x，功能为“Bolt显式事务支持”，计划时间为2024.x。\n5. 第五行数据显示，版本号为x.x.x，功能为“List、Map和Decimal等数据类型扩展”，计划时间为2024.x。\n6. 第六行数据显示，版本号为x.x.x，功能为“探索多存储引擎”，计划时间为2024.x。\n\n总体而言，该表格展示了即将推出的版本中主要功能的计划时间，所有功能均定于2024年的某个时间实施，涵盖图算法、数据库最佳实践及多种数据类型的支持等方面。\n\n该段落位于文档的第四部分，讨论了2024年度期待在社区共创的功能，包括多个计划中的新功能及其对应的计划时间，反映了团队对社区参与开发的期望和需求。"
            },
            {
                "content": "1. 第一行数据显示，版本号为x.x.x，功能为“图算法库丰富”，计划时间为2024.x。\n2. 第二行数据显示，版本号为x.x.x，功能为“属性默认值支持”，计划时间为2024.x。\n3. 第三行数据显示，版本号为x.x.x，功能为“Embedded TuGraph-DB最佳实践”，计划时间为2024.x。\n4. 第四行数据显示，版本号为x.x.x，功能为“Bolt显式事务支持”，计划时间为2024.x。\n5. 第五行数据显示，版本号为x.x.x，功能为“List、Map和Decimal等数据类型扩展”，计划时间为2024.x。\n6. 第六行数据显示，版本号为x.x.x，功能为“探索多存储引擎”，计划时间为2024.x。\n\n总体而言，该表格展示了即将推出的版本中主要功能的计划时间，所有功能均定于2024年的某个时间实施，涵盖图算法、数据库最佳实践及多种数据类型的支持等方面。\n\n一些更加简单的功能，我们会在github的issue中打上 good first issue 的标签，欢迎对图数据库感兴趣的技术爱好者共同研讨。\n\n该内容位于文档的第4部分，讨论了TuGraph-DB在未来版本中期望社区共同研发的功能，包括图算法库、属性默认值、最佳实践等，计划时间为2024年，并鼓励技术爱好者参与。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_40.md",
        "chunks": [
            {
                "content": "# 运维监控\n\n> 此文档主要介绍 TuGraph 的可视化运维监控\n\n## 1.设计思路\n\n可视化监控并不是TuGraph自身不可或缺的一部分，因此在设计时将可视化监控作为TuGraph周边生态中的一个应用，来减少和TuGraph数据库的耦合度，以及对于TuGraph自身的影响。TuGraph可视化监控采用目前最火热的开源解决方案，TuGraph Monitor + Prometheus + Grafana来实现。其中TuGraph Monitor作为TuGraph服务的客户端，通过TCP链接向TuGraph服务发起Procedure请求，TuGraph服务在接收到请求后收集自身所在机器的cpu，memory，disk，io，以及请求数量等指标的统计结果进行响应。TuGraph Monitor在接收到TuGraph响应的指标数据后，将数据包装成prometheus需要的格式，保存在内存中，等待Prometheus服务通过http请求获取。Prometheus服务会定期通过http请求从TuGraph Monitor获取封装好的请求数据，按照获取的时间保存在自己的时序数据库中。Grafana可以根据用户的配置，从Prometheus处获取某个时间段内的统计数据，并在web界面上绘制浅显易懂的图形来展示最终结果。整个请求链路中，都采用了主动获取，即PULL的模型，好处之一是它能最大限度的避免数据生产者和数据消费者之间的耦合度，使得开发更简单，好处之二是数据生产者不需要考虑数据消费者的数据处理能力，即使某个消费者的数据处理能力较弱，也不会因为生产者生产数据过快而压垮消费者。主动拉取模型的不足之处在于数据的实时性不够，但在这个场景中，数据并没有很高的实时性要求。\n\n### 1.1.TuGraph\n\nTuGraph数据库提供了收集服务所在机器中磁盘，内存，网络IO，以及查询请求等多种数据信息的能力，并通过标准Procedure方式提供查询。收集数据这一动作仅在有用户通过接口查询时才会发生，避免了在用户不需要TuGraph监控服务所在机器的指标时对用户业务查询请求带来的影响。\n\n### 1.2.TuGraph Monitor\n\n该文档主要介绍TuGraph的可视化运维监控解决方案，包括设计思路、组件介绍（TuGraph、TuGraph Monitor、Prometheus、Grafana）以及部署方案。所呈现的内容与如何实现和配置TuGraph的监控系统相关，旨在减少系统耦合，提高监控效率。"
            },
            {
                "content": "### 1.1.TuGraph\n\nTuGraph数据库提供了收集服务所在机器中磁盘，内存，网络IO，以及查询请求等多种数据信息的能力，并通过标准Procedure方式提供查询。收集数据这一动作仅在有用户通过接口查询时才会发生，避免了在用户不需要TuGraph监控服务所在机器的指标时对用户业务查询请求带来的影响。\n\n### 1.2.TuGraph Monitor\n\nTuGraph Monitor是TuGraph周边生态中的一个工具，它作为TuGraph众多用户中的一个，通过C++ RPC Client与TuGraph进行通信，通过Procedure查询接口来查询TuGraph服务所在机器的性能指标，并将TuGraph返回的结果包装成Prometheus需要的数据模型，等待Prometheus获取。用户可以通过设置查询时间间隔来保证获取监控指标对于业务查询的影响最小化。\n\n### 1.3.Prometheus\n\nPrometheus是一个开源的监控平台，并配备有专属的时序数据库，它会定期通过http请求从TuGraph Monitor服务获取统计指标，并保存在自己的时序数据库中。详细信息请参考官网: https://prometheus.io/docs/introduction/first_steps\n\n### 1.4.Grafana\n\nGrafana是一个开源的可视化和分析软件，它可以从包含Prometheus在内的多个数据源中获取数据，并且可以将时序数据库中的数据转换为精美图形和可视化效果的工具。具体信息请参考官网: https://grafana.com/docs/grafana/v7.5/getting-started/\n\n## 2.部署方案\n\n### 2.1.第一步\n\n启动TuGraph服务，详细方法请参考文档: https://github.com/TuGraph-db/tugraph-db/blob/master/doc/zh-CN/1.guide/3.quick-start.md\n\n### 2.2.第二步\n\n启动TuGraph Monitor工具，启动命令如下：\n\n该部分内容介绍了TuGraph监控系统的主要组成部分，包括TuGraph数据库、TuGraph Monitor、Prometheus和Grafana，详细阐述了每个组件的功能与作用，作为运维监控设计思路的一部分，紧接着是具体的部署方案。"
            },
            {
                "content": "Prometheus是一个开源的监控平台，并配备有专属的时序数据库，它会定期通过http请求从TuGraph Monitor服务获取统计指标，并保存在自己的时序数据库中。详细信息请参考官网: https://prometheus.io/docs/introduction/first_steps\n\n### 1.4.Grafana\n\nGrafana是一个开源的可视化和分析软件，它可以从包含Prometheus在内的多个数据源中获取数据，并且可以将时序数据库中的数据转换为精美图形和可视化效果的工具。具体信息请参考官网: https://grafana.com/docs/grafana/v7.5/getting-started/\n\n## 2.部署方案\n\n### 2.1.第一步\n\n启动TuGraph服务，详细方法请参考文档: https://github.com/TuGraph-db/tugraph-db/blob/master/doc/zh-CN/1.guide/3.quick-start.md\n\n### 2.2.第二步\n\n启动TuGraph Monitor工具，启动命令如下：\n\n```shell\n./lgraph_monitor --server_host 127.0.0.1:9091 -u admin -p your_password \\\n\t\t\t--monitor_host 127.0.0.1:9999  --sampling_interval_ms 1000\n```\n\n参数含义如下\n\n该文档主要介绍TuGraph的可视化运维监控方案，其中介绍了运维监控的设计思路、各个组件的功能及部署步骤。在所提供的chunk中，详细描述了Prometheus作为开源监控平台的角色，以及Grafana作为可视化和分析工具的功能，紧接着进入具体的部署方案，包括启动TuGraph服务和TuGraph Monitor工具的步骤。"
            },
            {
                "content": "### 1.4.Grafana\n\nGrafana是一个开源的可视化和分析软件，它可以从包含Prometheus在内的多个数据源中获取数据，并且可以将时序数据库中的数据转换为精美图形和可视化效果的工具。具体信息请参考官网: https://grafana.com/docs/grafana/v7.5/getting-started/\n\n## 2.部署方案\n\n### 2.1.第一步\n\n启动TuGraph服务，详细方法请参考文档: https://github.com/TuGraph-db/tugraph-db/blob/master/doc/zh-CN/1.guide/3.quick-start.md\n\n### 2.2.第二步\n\n启动TuGraph Monitor工具，启动命令如下：\n\n```shell\n./lgraph_monitor --server_host 127.0.0.1:9091 -u admin -p your_password \\\n\t\t\t--monitor_host 127.0.0.1:9999  --sampling_interval_ms 1000\n```\n\n参数含义如下\n\n```shell\nAvailable command line options:\n    --server_host       Host on which the tugraph rpc server runs.\n                        Default=127.0.0.1:9091.\n    -u, --user          DB username.\n    -p, --password      DB password.\n    --monitor_host      Host on which the monitor restful server runs.\n                        Default=127.0.0.1:9999.\n    --sampling_interval_ms\n                        sampling interval in millisecond. Default=1.5e2.\n    -h, --help          Print this help message. Default=0.\n```\n\n该文本块主要介绍了Grafana的功能和作用，作为可视化和分析工具，它与Prometheus等数据源结合使用，随后进入部署方案的第一步和第二步，具体说明如何启动TuGraph服务和TuGraph Monitor工具的命令及其参数说明。"
            },
            {
                "content": "### 2.3.第三步\n\n+ 下载符合您机器架构以及系统版本的Prometheus tar包，下载地址: https://prometheus.io/download/\n\n+ 解压tar包，命令如下\n\n```shell\ntar -zxvf prometheus-2.37.5.linux-amd64.tar.gz\n```\n\n+ 修改配置文件prometheus.yml，新增如下配置，使其可以抓取TuGraph Monitor包装好的性能数据\n\n```yaml\nscrape_configs:\n  # The job name is added as a label `job=` to any timeseries scraped from this config.\n  - job_name: \"tugraph\"\n\n    # metrics_path defaults to '/metrics'\n    # scheme defaults to 'http'.\n\n    static_configs:\n      - targets: [\"localhost:9111\"]\n```\n\n+ 启动prometheus，具体的启动参数可以通过如下命令获取\n\n```shell\n./prometheus -h\n```\n\n+ 验证prometheus服务是否正常，可以通过web端登陆prometheus服务，查询监控指标resources_report是否已经获取到，能成功查询到数据则正确\n\n### 2.4.第四步\n\n+ 下载符合您机器架构以及系统版本的Grafana安装包，下载地址: https://grafana.com/grafana/download\n\n+ 安装Grafana，细节请参考: https://grafana.com/docs/grafana/v7.5/installation/\n\n+ 启动Grafana，细节请参考: https://grafana.com/docs/grafana/v7.5/installation/\n\n+ 配置Grafana，首先在数据源设置中配置Prometheus的IP地址，配置完成后可以通过测试连接功能，验证是否成功连接数据源。然后，导入如下模版，并在页面中根据实际情况，修改正确的接口IP和端口。最后可以根据实际情况设置刷新时间和监控时间范围\n\n该段落位于文档的第二部分“部署方案”中，主要介绍如何下载和配置Prometheus监控工具，以便对TuGraph Monitor收集的性能数据进行抓取和显示，紧接着是关于Grafana的安装与配置说明。"
            },
            {
                "content": "```json\n{\n  \"annotations\": {\n    \"list\": [\n      {\n        \"builtIn\": 1,\n        \"datasource\": {\n          \"type\": \"grafana\"\n        },\n        \"enable\": true,\n        \"hide\": true,\n        \"iconColor\": \"rgba(0, 211, 255, 1)\",\n        \"name\": \"Annotations & Alerts\",\n        \"target\": {\n          \"limit\": 100,\n          \"matchAny\": false,\n          \"tags\": [],\n          \"type\": \"dashboard\"\n        },\n        \"type\": \"dashboard\"\n      }\n    ]\n  },\n  \"editable\": true,\n  \"fiscalYearStartMonth\": 0,\n  \"graphTooltip\": 0,\n  \"id\": 2,\n  \"links\": [],\n  \"liveNow\": false,\n  \"panels\": [\n    {\n      \"datasource\": {\n        \"type\": \"prometheus\"\n      },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": {\n            \"mode\": \"palette-classic\"\n          },\n          \"custom\": {\n            \"hideFrom\": {\n              \"legend\": false,\n              \"tooltip\": false,\n              \"viz\": false\n            }\n          },\n          \"mappings\": [],\n          \"unit\": \"kbytes\"\n        },\n        \"overrides\": [\n\n这个片段是文档中关于Grafana监控面板的JSON配置的一部分，主要描述了面板的注释、数据源，以及如何显示和配置指标数据的可视化效果。它位于监控页面配置的具体实例中，帮助用户理解如何在Grafana中设置TuGraph的监控面板。"
            },
            {
                "content": "\"id\": 2,\n  \"links\": [],\n  \"liveNow\": false,\n  \"panels\": [\n    {\n      \"datasource\": {\n        \"type\": \"prometheus\"\n      },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": {\n            \"mode\": \"palette-classic\"\n          },\n          \"custom\": {\n            \"hideFrom\": {\n              \"legend\": false,\n              \"tooltip\": false,\n              \"viz\": false\n            }\n          },\n          \"mappings\": [],\n          \"unit\": \"kbytes\"\n        },\n        \"overrides\": [\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"D {instance=\\\"localhost:7010\\\", job=\\\"TuGraph\\\", resouces_type=\\\"memory\\\", type=\\\"available\\\"}\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"displayName\",\n                \"value\": \"others\"\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n\n此片段位于文档中关于Grafana配置的部分，具体是在定义一个可视化面板的配置中，涉及到数据源类型、字段配置、颜色设定及覆盖规则，主要用于展示TuGraph服务的内存使用情况。"
            },
            {
                "content": "\"unit\": \"kbytes\"\n        },\n        \"overrides\": [\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"D {instance=\\\"localhost:7010\\\", job=\\\"TuGraph\\\", resouces_type=\\\"memory\\\", type=\\\"available\\\"}\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"displayName\",\n                \"value\": \"others\"\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"D {__name__=\\\"resources_report\\\", instance=\\\"localhost:7010\\\", job=\\\"TuGraph\\\", resouces_type=\\\"memory\\\", type=\\\"available\\\"}\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-green\",\n                  \"mode\": \"fixed\"\n                }\n              },\n              {\n                \"id\": \"displayName\",\n                \"value\": \"others\"\n              }\n            ]\n          },\n          {\n\n该片段位于文档的Grafana配置部分，具体描述了如何通过Grafana设置内存监控的字段配置与覆盖属性，包括单位、显示名称和颜色方案。"
            },
            {
                "content": "},\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-green\",\n                  \"mode\": \"fixed\"\n                }\n              },\n              {\n                \"id\": \"displayName\",\n                \"value\": \"others\"\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"others\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-blue\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"graph_used\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-orange\",\n\n该块内容位于文档中关于Grafana的配置部分，具体是当前仪表板中针对不同资源类型（如内存、已使用图形等）的属性设置，主要设置了颜色和显示名称，以便在监控界面中进行区分和可视化效果增强。"
            },
            {
                "content": "{\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-blue\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"graph_used\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-orange\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          }\n        ]\n      },\n      \"gridPos\": {\n        \"h\": 16,\n        \"w\": 6,\n        \"x\": 0,\n        \"y\": 0\n      },\n      \"id\": 14,\n      \"options\": {\n        \"displayLabels\": [\n          \"name\",\n          \"value\"\n        ],\n        \"legend\": {\n          \"displayMode\": \"table\",\n          \"placement\": \"bottom\",\n          \"values\": [\n            \"percent\",\n            \"value\"\n          ]\n        },\n        \"pieType\": \"pie\",\n\n该代码片段来自于文档中关于Grafana面板配置的部分，具体涉及设置图表的颜色属性和图例显示方式，用于展示TuGraph监控页面中的内存使用情况的饼图。"
            },
            {
                "content": "}\n              }\n            ]\n          }\n        ]\n      },\n      \"gridPos\": {\n        \"h\": 16,\n        \"w\": 6,\n        \"x\": 0,\n        \"y\": 0\n      },\n      \"id\": 14,\n      \"options\": {\n        \"displayLabels\": [\n          \"name\",\n          \"value\"\n        ],\n        \"legend\": {\n          \"displayMode\": \"table\",\n          \"placement\": \"bottom\",\n          \"values\": [\n            \"percent\",\n            \"value\"\n          ]\n        },\n        \"pieType\": \"pie\",\n        \"reduceOptions\": {\n          \"calcs\": [\n            \"lastNotNull\"\n          ],\n          \"fields\": \"\",\n          \"values\": false\n        },\n        \"tooltip\": {\n          \"mode\": \"single\",\n          \"sort\": \"none\"\n        }\n      },\n      \"targets\": [\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"memory\\\",type=\\\"self\\\"}\",\n          \"legendFormat\": \"{ {type} }\",\n\n该块内容为TuGraph监控页面中一部分关于内存监控的配置，主要定义了饼图的面板设置，包括显示标签、图例、目标数据源等信息。"
            },
            {
                "content": "\"calcs\": [\n            \"lastNotNull\"\n          ],\n          \"fields\": \"\",\n          \"values\": false\n        },\n        \"tooltip\": {\n          \"mode\": \"single\",\n          \"sort\": \"none\"\n        }\n      },\n      \"targets\": [\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"memory\\\",type=\\\"self\\\"}\",\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"A\"\n        },\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"memory\\\",type=\\\"available\\\"}\",\n          \"hide\": false,\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"B\"\n        },\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n\n该块内容位于文章的“Grafana”配置部分，具体描述了如何配置Grafana面板以监控TuGraph数据库的内存使用情况，包括查询表达式和数据源设置。"
            },
            {
                "content": "\"range\": true,\n          \"refId\": \"A\"\n        },\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"memory\\\",type=\\\"available\\\"}\",\n          \"hide\": false,\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"B\"\n        },\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"memory\\\",type=\\\"total\\\"}\",\n          \"hide\": true,\n          \"legendFormat\": \"{ {label_name} }\",\n          \"range\": true,\n          \"refId\": \"C\"\n        },\n        {\n          \"datasource\": {\n            \"type\": \"__expr__\"\n          },\n          \"expression\": \"$C -$A - $B\",\n          \"hide\": false,\n          \"refId\": \"D\",\n          \"type\": \"math\"\n        }\n      ],\n      \"title\": \"内存\",\n\n该内容片段位于文档中 Grafana 配置部分，具体描述了如何通过 Prometheus 数据源创建一个名为“内存”的图表面板，展示关于 TuGraph 数据库运行环境中内存使用情况的多个指标，包括可用内存、总内存及计算剩余内存的表达式。此配置是可视化监控的关键一步。"
            },
            {
                "content": "\"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"memory\\\",type=\\\"total\\\"}\",\n          \"hide\": true,\n          \"legendFormat\": \"{ {label_name} }\",\n          \"range\": true,\n          \"refId\": \"C\"\n        },\n        {\n          \"datasource\": {\n            \"type\": \"__expr__\"\n          },\n          \"expression\": \"$C -$A - $B\",\n          \"hide\": false,\n          \"refId\": \"D\",\n          \"type\": \"math\"\n        }\n      ],\n      \"title\": \"内存\",\n      \"type\": \"piechart\"\n    },\n    {\n      \"alert\": {\n        \"alertRuleTags\": {},\n        \"conditions\": [\n          {\n            \"evaluator\": {\n              \"params\": [\n                1000\n              ],\n              \"type\": \"gt\"\n            },\n            \"operator\": {\n              \"type\": \"and\"\n            },\n            \"query\": {\n              \"params\": [\n                \"A\",\n                \"5m\",\n                \"now\"\n              ]\n            },\n            \"reducer\": {\n              \"params\": [],\n\n该片段位于文档中的Grafana监控配置部分，具体讨论了如何在Grafana中为内存使用情况创建饼图，包含查询内存的总量以及计算可用内存的表达式配置。同时，它还涉及了内存使用超过1000的告警条件设置。"
            },
            {
                "content": "},\n    {\n      \"alert\": {\n        \"alertRuleTags\": {},\n        \"conditions\": [\n          {\n            \"evaluator\": {\n              \"params\": [\n                1000\n              ],\n              \"type\": \"gt\"\n            },\n            \"operator\": {\n              \"type\": \"and\"\n            },\n            \"query\": {\n              \"params\": [\n                \"A\",\n                \"5m\",\n                \"now\"\n              ]\n            },\n            \"reducer\": {\n              \"params\": [],\n              \"type\": \"avg\"\n            },\n            \"type\": \"query\"\n          }\n        ],\n        \"executionErrorState\": \"alerting\",\n        \"for\": \"5m\",\n        \"frequency\": \"1m\",\n        \"handler\": 1,\n        \"message\": \"【生产图数据库Grafana】\\n  QPS超过1000\",\n        \"name\": \"请求统计 alert\",\n        \"noDataState\": \"no_data\",\n        \"notifications\": []\n      },\n      \"datasource\": {\n        \"type\": \"prometheus\"\n      },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": {\n            \"mode\": \"palette-classic\"\n\n该段落是关于Grafana监控页面中一个警报配置的JSON结构，具体用于监测每秒请求数（QPS）超过1000的情况。该警报配置是文档中 Grafana 的设置部分的一部分，旨在实现对TuGraph数据库性能指标的监控。"
            },
            {
                "content": "},\n            \"type\": \"query\"\n          }\n        ],\n        \"executionErrorState\": \"alerting\",\n        \"for\": \"5m\",\n        \"frequency\": \"1m\",\n        \"handler\": 1,\n        \"message\": \"【生产图数据库Grafana】\\n  QPS超过1000\",\n        \"name\": \"请求统计 alert\",\n        \"noDataState\": \"no_data\",\n        \"notifications\": []\n      },\n      \"datasource\": {\n        \"type\": \"prometheus\"\n      },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": {\n            \"mode\": \"palette-classic\"\n          },\n          \"custom\": {\n            \"axisLabel\": \"\",\n            \"axisPlacement\": \"auto\",\n            \"barAlignment\": 0,\n            \"drawStyle\": \"line\",\n            \"fillOpacity\": 7,\n            \"gradientMode\": \"none\",\n            \"hideFrom\": {\n              \"legend\": false,\n              \"tooltip\": false,\n              \"viz\": false\n            },\n            \"lineInterpolation\": \"smooth\",\n            \"lineWidth\": 1,\n            \"pointSize\": 5,\n            \"scaleDistribution\": {\n              \"type\": \"linear\"\n\n该片段位于文档的\"Grafana\"配置部分，具体涉及到请求统计的报警设置，包括报警条件、数据源配置以及图形展示的样式设定。这部分内容是针对监控系统中关于请求统计的功能，旨在告知用户如何配置相关的报警信息。"
            },
            {
                "content": "\"axisLabel\": \"\",\n            \"axisPlacement\": \"auto\",\n            \"barAlignment\": 0,\n            \"drawStyle\": \"line\",\n            \"fillOpacity\": 7,\n            \"gradientMode\": \"none\",\n            \"hideFrom\": {\n              \"legend\": false,\n              \"tooltip\": false,\n              \"viz\": false\n            },\n            \"lineInterpolation\": \"smooth\",\n            \"lineWidth\": 1,\n            \"pointSize\": 5,\n            \"scaleDistribution\": {\n              \"type\": \"linear\"\n            },\n            \"showPoints\": \"auto\",\n            \"spanNulls\": false,\n            \"stacking\": {\n              \"group\": \"A\",\n              \"mode\": \"none\"\n            },\n            \"thresholdsStyle\": {\n              \"mode\": \"off\"\n            }\n          },\n          \"mappings\": [],\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              {\n                \"color\": \"green\",\n                \"value\": null\n              },\n              {\n                \"color\": \"red\",\n\n该内容块位于文档的Grafana配置部分，具体描述了图表的绘制样式和属性，包括坐标轴标签、绘制风格、线条平滑度、点大小及颜色阈值等。这是设置Grafana面板展示性能监控数据的重要参数，确保用户能够直观地理解和分析监控信息。"
            },
            {
                "content": "\"showPoints\": \"auto\",\n            \"spanNulls\": false,\n            \"stacking\": {\n              \"group\": \"A\",\n              \"mode\": \"none\"\n            },\n            \"thresholdsStyle\": {\n              \"mode\": \"off\"\n            }\n          },\n          \"mappings\": [],\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              {\n                \"color\": \"green\",\n                \"value\": null\n              },\n              {\n                \"color\": \"red\",\n                \"value\": 80\n              }\n            ]\n          },\n          \"unit\": \" \"\n        },\n        \"overrides\": [\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"write\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-blue\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          }\n        ]\n      },\n\n该片段为Grafana配置中的一部分，主要涉及到图表的显示属性及数据阈值设置，具体包括显示点的自动调整、数据堆叠模式、阈值风格和颜色映射，旨在增强监控页面的可视化效果。这部分内容位于文档的第二部分“部署方案”中的Grafana配置设置的详细说明中。"
            },
            {
                "content": "\"value\": 80\n              }\n            ]\n          },\n          \"unit\": \" \"\n        },\n        \"overrides\": [\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"write\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-blue\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          }\n        ]\n      },\n      \"gridPos\": {\n        \"h\": 16,\n        \"w\": 12,\n        \"x\": 6,\n        \"y\": 0\n      },\n      \"id\": 4,\n      \"options\": {\n        \"legend\": {\n          \"calcs\": [\n            \"min\",\n            \"max\",\n            \"mean\",\n            \"last\"\n          ],\n          \"displayMode\": \"table\",\n          \"placement\": \"bottom\"\n        },\n        \"tooltip\": {\n          \"mode\": \"single\",\n          \"sort\": \"none\"\n        }\n      },\n      \"targets\": [\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n\n该段落位于文档的Grafana配置部分，主要描述了关于请求统计监控图表的设置，包括图表的数据显示方式、图例配置以及数据源的设定，便于用户理解如何在Grafana中实现对TuGraph服务性能指标的可视化展示。"
            },
            {
                "content": "\"h\": 16,\n        \"w\": 12,\n        \"x\": 6,\n        \"y\": 0\n      },\n      \"id\": 4,\n      \"options\": {\n        \"legend\": {\n          \"calcs\": [\n            \"min\",\n            \"max\",\n            \"mean\",\n            \"last\"\n          ],\n          \"displayMode\": \"table\",\n          \"placement\": \"bottom\"\n        },\n        \"tooltip\": {\n          \"mode\": \"single\",\n          \"sort\": \"none\"\n        }\n      },\n      \"targets\": [\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n          \"expr\": \"{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"request\\\",type=~\\\"total|write\\\"}\",\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"A\"\n        }\n      ],\n      \"thresholds\": [\n        {\n          \"colorMode\": \"critical\",\n          \"op\": \"gt\",\n          \"value\": 1000,\n          \"visible\": true\n        }\n      ],\n      \"title\": \"请求统计\",\n      \"type\": \"timeseries\"\n    },\n    {\n      \"datasource\": {\n\n该代码块位于文档的 Grafana 配置部分，具体描述了用于展示请求统计的图表设置，包括图表的尺寸、数据源配置、查询表达式，以及阈值条件。这部分主要用于展示和监控 TuGraph 数据库的请求性能，以便用户可视化观察系统负载情况。"
            },
            {
                "content": "},\n          \"editorMode\": \"code\",\n          \"expr\": \"{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"request\\\",type=~\\\"total|write\\\"}\",\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"A\"\n        }\n      ],\n      \"thresholds\": [\n        {\n          \"colorMode\": \"critical\",\n          \"op\": \"gt\",\n          \"value\": 1000,\n          \"visible\": true\n        }\n      ],\n      \"title\": \"请求统计\",\n      \"type\": \"timeseries\"\n    },\n    {\n      \"datasource\": {\n        \"type\": \"prometheus\"\n      },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": {\n            \"mode\": \"palette-classic\"\n          },\n          \"custom\": {\n            \"hideFrom\": {\n              \"legend\": false,\n              \"tooltip\": false,\n              \"viz\": false\n            }\n          },\n          \"mappings\": [],\n          \"unit\": \"decbits\"\n        },\n        \"overrides\": [\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"graph_used\"\n\n该文本块位于文档中关于Grafana监控配置的部分，具体讨论了请求统计的时序图定义，包括Prometheus作为数据源的配置、查询表达式以及阈值设定。这是实现TuGraph监控页面可视化的重要组成部分，涉及对请求数量的监控和警报设置。"
            },
            {
                "content": "},\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": {\n            \"mode\": \"palette-classic\"\n          },\n          \"custom\": {\n            \"hideFrom\": {\n              \"legend\": false,\n              \"tooltip\": false,\n              \"viz\": false\n            }\n          },\n          \"mappings\": [],\n          \"unit\": \"decbits\"\n        },\n        \"overrides\": [\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"graph_used\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-red\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"available\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-orange\",\n\n该片段属于文档中的Grafana配置部分，具体涉及图表面板的字段配置，定义了颜色映射和单位设置，主要用于展示网络IO相关的数据。"
            },
            {
                "content": "\"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-red\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"available\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-orange\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"D\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"displayName\",\n                \"value\": \"other\"\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"other\"\n            },\n            \"properties\": [\n\n该片段位于文档的Grafana配置部分，具体是用于设置面板的属性，包括颜色和显示名称等。这些配置旨在为监控数据提供可视化效果，帮助用户直观地理解监控指标的状态。"
            },
            {
                "content": "\"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"D\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"displayName\",\n                \"value\": \"other\"\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"other\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-purple\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          }\n        ]\n      },\n      \"gridPos\": {\n        \"h\": 16,\n        \"w\": 6,\n        \"x\": 18,\n        \"y\": 0\n      },\n      \"id\": 12,\n      \"options\": {\n        \"displayLabels\": [\n          \"name\",\n          \"value\"\n        ],\n        \"legend\": {\n          \"displayMode\": \"table\",\n\n该内容片段位于文档的第二部分“监控页面配置”中的Grafana仪表板设置部分，具体描述了如何设置监控指标的颜色、显示名称及其坐标位置。这是整个监控系统可视化的关键组成部分，涉及到用户界面的可视化效果配置。"
            },
            {
                "content": "{\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-purple\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          }\n        ]\n      },\n      \"gridPos\": {\n        \"h\": 16,\n        \"w\": 6,\n        \"x\": 18,\n        \"y\": 0\n      },\n      \"id\": 12,\n      \"options\": {\n        \"displayLabels\": [\n          \"name\",\n          \"value\"\n        ],\n        \"legend\": {\n          \"displayMode\": \"table\",\n          \"placement\": \"bottom\",\n          \"sortBy\": \"Value\",\n          \"sortDesc\": true,\n          \"values\": [\n            \"value\",\n            \"percent\"\n          ]\n        },\n        \"pieType\": \"pie\",\n        \"reduceOptions\": {\n          \"calcs\": [\n            \"lastNotNull\"\n          ],\n          \"fields\": \"\",\n          \"values\": false\n        },\n        \"tooltip\": {\n          \"mode\": \"single\",\n          \"sort\": \"none\"\n        }\n      },\n      \"targets\": [\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n\n该内容片段位于文档的Grafana配置部分，具体描述了一个监控面板的设定，包括图表选项、图例配置和数据源目标，旨在呈现TuGraph的监控数据，以便于可视化展示和分析。"
            },
            {
                "content": "\"sortBy\": \"Value\",\n          \"sortDesc\": true,\n          \"values\": [\n            \"value\",\n            \"percent\"\n          ]\n        },\n        \"pieType\": \"pie\",\n        \"reduceOptions\": {\n          \"calcs\": [\n            \"lastNotNull\"\n          ],\n          \"fields\": \"\",\n          \"values\": false\n        },\n        \"tooltip\": {\n          \"mode\": \"single\",\n          \"sort\": \"none\"\n        }\n      },\n      \"targets\": [\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n          \"exemplar\": false,\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"disk\\\",type=\\\"available\\\"}\",\n          \"format\": \"time_series\",\n          \"instant\": false,\n          \"interval\": \"\",\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"A\"\n        },\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n\n该块内容位于文档的Grafana配置部分，主要描述了一个监控面板的配置细节，包括排序选项、数据源、数据表达式和图表类型。这部分配置用于展示TuGraph监控页面中的可视化效果，特别是与磁盘可用性相关的监控数据。"
            },
            {
                "content": "},\n          \"editorMode\": \"code\",\n          \"exemplar\": false,\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"disk\\\",type=\\\"available\\\"}\",\n          \"format\": \"time_series\",\n          \"instant\": false,\n          \"interval\": \"\",\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"A\"\n        },\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"disk\\\",type=\\\"self\\\"}\",\n          \"hide\": false,\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"B\"\n        },\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"disk\\\",type=\\\"total\\\"}\",\n          \"hide\": true,\n\n该代码块位于文档的Grafana配置部分，主要描述了如何在Grafana中定义从Prometheus数据源中获取磁盘相关性能指标的数据查询表达式，包括可用磁盘、磁盘使用量和总磁盘空间的查询设置。这部分内容是监控页面配置的重要组成部分。"
            },
            {
                "content": "\"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"disk\\\",type=\\\"self\\\"}\",\n          \"hide\": false,\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"B\"\n        },\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"disk\\\",type=\\\"total\\\"}\",\n          \"hide\": true,\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"C\"\n        },\n        {\n          \"datasource\": {\n            \"type\": \"__expr__\"\n          },\n          \"expression\": \"$C - $A - $B\",\n          \"hide\": false,\n          \"refId\": \"D\",\n          \"type\": \"math\"\n        }\n      ],\n      \"title\": \"磁盘\",\n      \"transformations\": [\n        {\n          \"id\": \"configFromData\",\n          \"options\": {\n            \"applyTo\": {\n              \"id\": \"byFrameRefID\"\n            },\n\n该块内容位于文档的Grafana配置部分，具体描述了在监控页面中用于绘制磁盘性能指标的查询表达式和计算逻辑，涵盖了磁盘的自用量、总量及其它相关计算。"
            },
            {
                "content": "\"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"C\"\n        },\n        {\n          \"datasource\": {\n            \"type\": \"__expr__\"\n          },\n          \"expression\": \"$C - $A - $B\",\n          \"hide\": false,\n          \"refId\": \"D\",\n          \"type\": \"math\"\n        }\n      ],\n      \"title\": \"磁盘\",\n      \"transformations\": [\n        {\n          \"id\": \"configFromData\",\n          \"options\": {\n            \"applyTo\": {\n              \"id\": \"byFrameRefID\"\n            },\n            \"configRefId\": \"config\",\n            \"mappings\": []\n          }\n        }\n      ],\n      \"type\": \"piechart\"\n    },\n    {\n      \"alert\": {\n        \"alertRuleTags\": {},\n        \"conditions\": [\n          {\n            \"evaluator\": {\n              \"params\": [\n                90\n              ],\n              \"type\": \"gt\"\n            },\n            \"operator\": {\n              \"type\": \"and\"\n            },\n            \"query\": {\n              \"params\": [\n                \"A\",\n                \"5m\",\n\n该片段位于文档的第2.4节“第四步”中，具体涉及Grafana监控配置的细节，描述了如何设置磁盘监控的图表，包括数据源、查询表达式和图表类型等内容，同时还提到监控警报的条件设置。"
            },
            {
                "content": "\"configRefId\": \"config\",\n            \"mappings\": []\n          }\n        }\n      ],\n      \"type\": \"piechart\"\n    },\n    {\n      \"alert\": {\n        \"alertRuleTags\": {},\n        \"conditions\": [\n          {\n            \"evaluator\": {\n              \"params\": [\n                90\n              ],\n              \"type\": \"gt\"\n            },\n            \"operator\": {\n              \"type\": \"and\"\n            },\n            \"query\": {\n              \"params\": [\n                \"A\",\n                \"5m\",\n                \"now\"\n              ]\n            },\n            \"reducer\": {\n              \"params\": [],\n              \"type\": \"avg\"\n            },\n            \"type\": \"query\"\n          }\n        ],\n        \"executionErrorState\": \"alerting\",\n        \"for\": \"5m\",\n        \"frequency\": \"1m\",\n        \"handler\": 1,\n        \"message\": \"【生产图数据库Grafana】\\nCPU使用率超过90%\",\n        \"name\": \"CPU使用率 alert\",\n        \"noDataState\": \"no_data\",\n        \"notifications\": [\n          {\n          }\n        ]\n      },\n\n该片段位于文档的Grafana配置部分，主要描述了一个用于监控CPU使用率的图表配置，包括相关的警报设置和条件，属于TuGraph的监控数据可视化实现。"
            },
            {
                "content": "\"now\"\n              ]\n            },\n            \"reducer\": {\n              \"params\": [],\n              \"type\": \"avg\"\n            },\n            \"type\": \"query\"\n          }\n        ],\n        \"executionErrorState\": \"alerting\",\n        \"for\": \"5m\",\n        \"frequency\": \"1m\",\n        \"handler\": 1,\n        \"message\": \"【生产图数据库Grafana】\\nCPU使用率超过90%\",\n        \"name\": \"CPU使用率 alert\",\n        \"noDataState\": \"no_data\",\n        \"notifications\": [\n          {\n          }\n        ]\n      },\n      \"datasource\": {\n        \"type\": \"prometheus\"\n      },\n      \"description\": \"\",\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": {\n            \"mode\": \"palette-classic\"\n          },\n          \"custom\": {\n            \"axisLabel\": \"\",\n            \"axisPlacement\": \"auto\",\n            \"barAlignment\": 0,\n            \"drawStyle\": \"line\",\n            \"fillOpacity\": 4,\n            \"gradientMode\": \"none\",\n            \"hideFrom\": {\n              \"legend\": false,\n              \"tooltip\": false,\n\n该片段位于文档的Grafana配置部分，具体涉及CPU使用率的监控告警设置，描述了如何定义告警条件、告警信息及数据源配置等内容。"
            },
            {
                "content": "\"datasource\": {\n        \"type\": \"prometheus\"\n      },\n      \"description\": \"\",\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": {\n            \"mode\": \"palette-classic\"\n          },\n          \"custom\": {\n            \"axisLabel\": \"\",\n            \"axisPlacement\": \"auto\",\n            \"barAlignment\": 0,\n            \"drawStyle\": \"line\",\n            \"fillOpacity\": 4,\n            \"gradientMode\": \"none\",\n            \"hideFrom\": {\n              \"legend\": false,\n              \"tooltip\": false,\n              \"viz\": false\n            },\n            \"lineInterpolation\": \"linear\",\n            \"lineWidth\": 1,\n            \"pointSize\": 5,\n            \"scaleDistribution\": {\n              \"type\": \"linear\"\n            },\n            \"showPoints\": \"auto\",\n            \"spanNulls\": false,\n            \"stacking\": {\n              \"group\": \"A\",\n              \"mode\": \"none\"\n            },\n            \"thresholdsStyle\": {\n              \"mode\": \"off\"\n            }\n          },\n          \"mappings\": [],\n\n该代码块位于文档的Grafana配置部分，主要描述了与Prometheus数据源相关的字段配置，包括默认的颜色、线条样式、点大小等属性设置，旨在帮助用户更好地可视化监控数据。"
            },
            {
                "content": "\"viz\": false\n            },\n            \"lineInterpolation\": \"linear\",\n            \"lineWidth\": 1,\n            \"pointSize\": 5,\n            \"scaleDistribution\": {\n              \"type\": \"linear\"\n            },\n            \"showPoints\": \"auto\",\n            \"spanNulls\": false,\n            \"stacking\": {\n              \"group\": \"A\",\n              \"mode\": \"none\"\n            },\n            \"thresholdsStyle\": {\n              \"mode\": \"off\"\n            }\n          },\n          \"mappings\": [],\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              {\n                \"color\": \"green\",\n                \"value\": null\n              },\n              {\n                \"color\": \"red\",\n                \"value\": 80\n              }\n            ]\n          },\n          \"unit\": \"percent\"\n        },\n        \"overrides\": [\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"graph_used\"\n            },\n            \"properties\": [\n              {\n\n该chunk位于文档的Grafana配置部分，主要包含图表的样式设置、阈值定义和数据映射等内容。这部分配置确保Grafana能够正确展示监控数据的图形效果与反馈。"
            },
            {
                "content": "\"mode\": \"absolute\",\n            \"steps\": [\n              {\n                \"color\": \"green\",\n                \"value\": null\n              },\n              {\n                \"color\": \"red\",\n                \"value\": 80\n              }\n            ]\n          },\n          \"unit\": \"percent\"\n        },\n        \"overrides\": [\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"graph_used\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-orange\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"total_used\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-purple\",\n                  \"mode\": \"fixed\"\n                }\n\n该段落属于文档中Grafana配置部分的详细说明，具体描述了在设置图表显示时的颜色阈值和单位配置，主要用于可视化CPU使用率监控的面板配置。"
            },
            {
                "content": "\"value\": {\n                  \"fixedColor\": \"light-orange\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"total_used\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-purple\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"self\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-green\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"total\"\n            },\n\n该片段处于文档的Grafana配置部分，具体是在设置面板的属性时，用于定义不同监控指标（例如内存使用情况）的颜色属性。该部分涉及如何根据指标名称为不同类型的性能数据分配特定的颜色，以便在Grafana的可视化界面中清晰地呈现这些指标。"
            },
            {
                "content": "]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"self\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-green\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"total\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-purple\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          }\n        ]\n      },\n      \"gridPos\": {\n        \"h\": 14,\n        \"w\": 12,\n        \"x\": 0,\n        \"y\": 16\n      },\n      \"id\": 6,\n      \"options\": {\n        \"legend\": {\n          \"calcs\": [\n            \"min\",\n            \"max\",\n            \"mean\",\n            \"last\"\n          ],\n\n该片段来自文档的Grafana配置部分，具体涉及为CPU使用率可视化面板设置颜色属性的配置，它在面板的网格位置和图表选项中定义了如何显示不同类型的CPU数据（如自用和总用）。此部分属于监控页面的参数配置，旨在提高Grafana的可读性和信息表达。"
            },
            {
                "content": "{\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"light-purple\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          }\n        ]\n      },\n      \"gridPos\": {\n        \"h\": 14,\n        \"w\": 12,\n        \"x\": 0,\n        \"y\": 16\n      },\n      \"id\": 6,\n      \"options\": {\n        \"legend\": {\n          \"calcs\": [\n            \"min\",\n            \"max\",\n            \"mean\",\n            \"last\"\n          ],\n          \"displayMode\": \"table\",\n          \"placement\": \"bottom\"\n        },\n        \"tooltip\": {\n          \"mode\": \"single\",\n          \"sort\": \"none\"\n        }\n      },\n      \"targets\": [\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"cpu\\\",type=~\\\"total|self\\\"}\",\n          \"hide\": false,\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n\n此代码块位于文档的Grafana配置部分，具体是关于生成CPU使用率的图表配置，定义了图表的样式、显示模式、数据源及查询表达式等内容。"
            },
            {
                "content": "\"placement\": \"bottom\"\n        },\n        \"tooltip\": {\n          \"mode\": \"single\",\n          \"sort\": \"none\"\n        }\n      },\n      \"targets\": [\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"code\",\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"cpu\\\",type=~\\\"total|self\\\"}\",\n          \"hide\": false,\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"A\"\n        }\n      ],\n      \"thresholds\": [\n        {\n          \"colorMode\": \"critical\",\n          \"op\": \"gt\",\n          \"value\": 90,\n          \"visible\": true\n        }\n      ],\n      \"title\": \"CPU使用率\",\n      \"type\": \"timeseries\"\n    },\n    {\n      \"alert\": {\n        \"alertRuleTags\": {},\n        \"conditions\": [\n          {\n            \"evaluator\": {\n              \"params\": [\n                10000\n              ],\n              \"type\": \"gt\"\n            },\n            \"operator\": {\n              \"type\": \"and\"\n\n该片段位于文档的第2.4节（第四步）中，具体涵盖了Grafana的面板配置，主要涉及监控TuGraph服务的CPU使用率，包括数据源设置、查询表达式、阈值定义和图表类型等设置。"
            },
            {
                "content": "}\n      ],\n      \"thresholds\": [\n        {\n          \"colorMode\": \"critical\",\n          \"op\": \"gt\",\n          \"value\": 90,\n          \"visible\": true\n        }\n      ],\n      \"title\": \"CPU使用率\",\n      \"type\": \"timeseries\"\n    },\n    {\n      \"alert\": {\n        \"alertRuleTags\": {},\n        \"conditions\": [\n          {\n            \"evaluator\": {\n              \"params\": [\n                10000\n              ],\n              \"type\": \"gt\"\n            },\n            \"operator\": {\n              \"type\": \"and\"\n            },\n            \"query\": {\n              \"params\": [\n                \"A\",\n                \"5m\",\n                \"now\"\n              ]\n            },\n            \"reducer\": {\n              \"params\": [],\n              \"type\": \"avg\"\n            },\n            \"type\": \"query\"\n          }\n        ],\n        \"executionErrorState\": \"alerting\",\n        \"for\": \"5m\",\n        \"frequency\": \"1m\",\n        \"handler\": 1,\n        \"message\": \"【生产图数据库Grafana】\\n  磁盘IO超过10MB/S\",\n        \"name\": \"磁盘IO alert\",\n\n该内容位于文档的第三部分“未来计划”中，具体涉及Grafana监控页面的配置。其中，聚焦于CPU使用率和磁盘IO的告警设定，包括阈值、条件、频率和警报消息等配置，旨在实现对系统性能的实时监控和告警功能。"
            },
            {
                "content": "},\n            \"query\": {\n              \"params\": [\n                \"A\",\n                \"5m\",\n                \"now\"\n              ]\n            },\n            \"reducer\": {\n              \"params\": [],\n              \"type\": \"avg\"\n            },\n            \"type\": \"query\"\n          }\n        ],\n        \"executionErrorState\": \"alerting\",\n        \"for\": \"5m\",\n        \"frequency\": \"1m\",\n        \"handler\": 1,\n        \"message\": \"【生产图数据库Grafana】\\n  磁盘IO超过10MB/S\",\n        \"name\": \"磁盘IO alert\",\n        \"noDataState\": \"no_data\",\n        \"notifications\": []\n      },\n      \"datasource\": {\n        \"type\": \"prometheus\"\n      },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": {\n            \"mode\": \"palette-classic\"\n          },\n          \"custom\": {\n            \"axisLabel\": \"\",\n            \"axisPlacement\": \"auto\",\n            \"barAlignment\": 0,\n            \"drawStyle\": \"line\",\n            \"fillOpacity\": 7,\n            \"gradientMode\": \"none\",\n            \"hideFrom\": {\n\n该段落位于文档的第三部分“未来计划”中的“磁盘IO”告警配置部分，主要描述了当磁盘IO超过10MB/S时触发的告警条件和配置细节，包括查询参数、降低器类型和通知设置，旨在实现对磁盘IO性能的监控与告警。"
            },
            {
                "content": "\"noDataState\": \"no_data\",\n        \"notifications\": []\n      },\n      \"datasource\": {\n        \"type\": \"prometheus\"\n      },\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": {\n            \"mode\": \"palette-classic\"\n          },\n          \"custom\": {\n            \"axisLabel\": \"\",\n            \"axisPlacement\": \"auto\",\n            \"barAlignment\": 0,\n            \"drawStyle\": \"line\",\n            \"fillOpacity\": 7,\n            \"gradientMode\": \"none\",\n            \"hideFrom\": {\n              \"legend\": false,\n              \"tooltip\": false,\n              \"viz\": false\n            },\n            \"lineInterpolation\": \"smooth\",\n            \"lineWidth\": 1,\n            \"pointSize\": 5,\n            \"scaleDistribution\": {\n              \"type\": \"linear\"\n            },\n            \"showPoints\": \"auto\",\n            \"spanNulls\": false,\n            \"stacking\": {\n              \"group\": \"A\",\n              \"mode\": \"none\"\n            },\n            \"thresholdsStyle\": {\n              \"mode\": \"off\"\n            }\n\n这个片段来自文档中关于Grafana监控配置的部分，具体描述了如何定义数据源（Prometheus）以及设置图表的样式和显示属性，包括数据为空时的状态处理、颜色模式、线条样式等。这些配置信息是为了增强监控数据的可视化效果。"
            },
            {
                "content": "\"tooltip\": false,\n              \"viz\": false\n            },\n            \"lineInterpolation\": \"smooth\",\n            \"lineWidth\": 1,\n            \"pointSize\": 5,\n            \"scaleDistribution\": {\n              \"type\": \"linear\"\n            },\n            \"showPoints\": \"auto\",\n            \"spanNulls\": false,\n            \"stacking\": {\n              \"group\": \"A\",\n              \"mode\": \"none\"\n            },\n            \"thresholdsStyle\": {\n              \"mode\": \"off\"\n            }\n          },\n          \"mappings\": [],\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              {\n                \"color\": \"green\",\n                \"value\": null\n              },\n              {\n                \"color\": \"red\",\n                \"value\": 80\n              }\n            ]\n          },\n          \"unit\": \"bps\"\n        },\n        \"overrides\": [\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"read\"\n            },\n\n该块内容位于文档中关于Grafana配置的部分，具体描述了Grafana中图表的外观和行为设置，包括线条插值、线宽、点大小、堆叠配置、阈值样式等参数，以及用来处理数据的映射和阈值定义。这些设置是为了更好地展示TuGraph监控的数据可视化效果。"
            },
            {
                "content": "},\n          \"mappings\": [],\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              {\n                \"color\": \"green\",\n                \"value\": null\n              },\n              {\n                \"color\": \"red\",\n                \"value\": 80\n              }\n            ]\n          },\n          \"unit\": \"bps\"\n        },\n        \"overrides\": [\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"read\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"super-light-green\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"write\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n\n该片段位于文档中的Grafana配置部分，具体针对磁盘IO监控的图表设置。它定义了阈值、单位以及针对读写操作的颜色映射，以便在Grafana仪表板上展示实时的磁盘IO数据。"
            },
            {
                "content": "},\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"super-light-green\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          },\n          {\n            \"matcher\": {\n              \"id\": \"byName\",\n              \"options\": \"write\"\n            },\n            \"properties\": [\n              {\n                \"id\": \"color\",\n                \"value\": {\n                  \"fixedColor\": \"super-light-red\",\n                  \"mode\": \"fixed\"\n                }\n              }\n            ]\n          }\n        ]\n      },\n      \"gridPos\": {\n        \"h\": 14,\n        \"w\": 12,\n        \"x\": 12,\n        \"y\": 16\n      },\n      \"id\": 2,\n      \"options\": {\n        \"legend\": {\n          \"calcs\": [\n            \"min\",\n            \"max\",\n            \"mean\",\n            \"last\"\n          ],\n          \"displayMode\": \"table\",\n          \"placement\": \"bottom\"\n        },\n        \"tooltip\": {\n\n该片段位于文档的Grafana配置部分，主要描述了关于监控图表中颜色属性的设置，具体针对磁盘IO的读写指标进行颜色定制，以增强图形的可视化效果。此部分内容反映了如何在Grafana仪表板中展示和区分不同的数据类型。"
            },
            {
                "content": "\"mode\": \"fixed\"\n                }\n              }\n            ]\n          }\n        ]\n      },\n      \"gridPos\": {\n        \"h\": 14,\n        \"w\": 12,\n        \"x\": 12,\n        \"y\": 16\n      },\n      \"id\": 2,\n      \"options\": {\n        \"legend\": {\n          \"calcs\": [\n            \"min\",\n            \"max\",\n            \"mean\",\n            \"last\"\n          ],\n          \"displayMode\": \"table\",\n          \"placement\": \"bottom\"\n        },\n        \"tooltip\": {\n          \"mode\": \"single\",\n          \"sort\": \"none\"\n        }\n      },\n      \"targets\": [\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"builder\",\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"disk_rate\\\",type=~\\\"read|write\\\"}\",\n          \"hide\": false,\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"A\"\n        }\n      ],\n      \"thresholds\": [\n        {\n          \"colorMode\": \"critical\",\n\n该文本块位于文档中关于Grafana仪表板配置的部分，具体描述了一个监控面板的配置，包括图表的显示选项、数据源和查询表达式，以监控TuGraph数据库服务的磁盘IO性能指标。"
            },
            {
                "content": "\"sort\": \"none\"\n        }\n      },\n      \"targets\": [\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\"\n          },\n          \"editorMode\": \"builder\",\n          \"expr\": \"resources_report{instance=\\\"localhost:7010\\\",job=\\\"TuGraph\\\",resouces_type=\\\"disk_rate\\\",type=~\\\"read|write\\\"}\",\n          \"hide\": false,\n          \"legendFormat\": \"{ {type} }\",\n          \"range\": true,\n          \"refId\": \"A\"\n        }\n      ],\n      \"thresholds\": [\n        {\n          \"colorMode\": \"critical\",\n          \"op\": \"gt\",\n          \"value\": 10000,\n          \"visible\": true\n        }\n      ],\n      \"title\": \"磁盘IO\",\n      \"type\": \"timeseries\"\n    }\n  ],\n  \"refresh\": \"\",\n  \"schemaVersion\": 36,\n  \"style\": \"dark\",\n  \"tags\": [],\n  \"templating\": {\n    \"list\": []\n  },\n  \"time\": {\n    \"from\": \"now-24h\",\n    \"to\": \"now\"\n  },\n  \"timepicker\": {\n    \"hidden\": false,\n    \"refresh_intervals\": [\n      \"10s\"\n    ]\n  },\n  \"timezone\": \"\",\n  \"title\": \"TuGraph监控页面\",\n  \"version\": 20,\n  \"weekStart\": \"\"\n}\n```\n\n该块内容位于文档的Grafana配置部分，具体描述了与磁盘IO监控相关的指标设置、数据源配置以及阈值警报。部分字段包括数据源类型、查询表达式、图表标题及其格式设定等，为整体监控页面的构建提供了重要的数据可视化参数。"
            },
            {
                "content": "验证效果，刷新浏览器页面。如果正确显示饼图和折线图，则配置完成。\n\n## 3.未来计划\n\n目前可视化监控只支持单机监控，能监控服务所在机器的cpu，磁盘，网络io，请求qps等性能指标，未来将会实现监控ha集群的功能，也会将更多有意义的指标纳入监控范围\n\n该段落位于文档的最后部分，主要描述了验证可视化监控配置是否成功的步骤，并提出了未来计划，包括扩展监控功能以支持HA集群和增加更多性能指标的监控。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_41.md",
        "chunks": [
            {
                "content": "# Date\n\nGeaFlow支持以下日期函数：\n* from_unixtime\n* from_unixtime_millis\n* unix_timestamp\n* unix_timestamp_millis\n* isdate\n* now\n* day\n* weekday\n* lastday\n* day_of_month\n* week_of_year\n* date_add\n* date_sub\n* date_diff\n* add_months\n* date_format\n* date_part\n* date_trunc\n\n## from_unixtime\n**Syntax**\n\n```sql\nstring from_unixtime(int unixtime)\nstring from_unixtime(long unixtime)\nstring from_unixtime(int unixtime, string format)\nstring from_unixtime(long unixtime, string format)\nstring from_unixtime(string unixtime, string format)\n```\n**Description**\n将Unix时间戳转换成时间格式， 默认格式为“yyyy-MM-dd HH:mm:ss”。如果任何输入为空，则返回Null。\n\n**Example**\n\n```sql\nfrom_unixtime(11111111) = '1970-05-09 22:25:11'\nfrom_unixtime(11111111, 'yyyy-MM-dd HH:mm:ss.SSSSSS') = '1970-05-09 22:25:11.000000'\n```\n\n## from_unixtime_millis\n**Syntax**\n\n该文档介绍了GeaFlow支持的日期函数，详细列出了各种日期相关函数的语法、描述和示例，以帮助用户理解和使用这些日期函数。所提及的函数包括从Unix时间戳转换、日期格式化、日期计算等功能，内容覆盖了常见的日期处理需求。"
            },
            {
                "content": "```sql\nstring from_unixtime(int unixtime)\nstring from_unixtime(long unixtime)\nstring from_unixtime(int unixtime, string format)\nstring from_unixtime(long unixtime, string format)\nstring from_unixtime(string unixtime, string format)\n```\n**Description**\n将Unix时间戳转换成时间格式， 默认格式为“yyyy-MM-dd HH:mm:ss”。如果任何输入为空，则返回Null。\n\n**Example**\n\n```sql\nfrom_unixtime(11111111) = '1970-05-09 22:25:11'\nfrom_unixtime(11111111, 'yyyy-MM-dd HH:mm:ss.SSSSSS') = '1970-05-09 22:25:11.000000'\n```\n\n## from_unixtime_millis\n**Syntax**\n\n```sql\nstring from_unixtime_millis(int unixtime)\nstring from_unixtime_millis(long unixtime)\nstring from_unixtime_millis(string unixtime)\nstring from_unixtime_millis(int unixtime, string format)\nstring from_unixtime_millis(long unixtime, string format)\n```\n**Description**\n将Unix毫秒时间戳转换成时间格式， 默认格式为“yyyy-MM-dd HH:mm:ss.SSS”。如果任何输入为空，则返回Null。\n**Example**\n\n该段落位于文档的“从Unix时间戳转换为时间格式”部分，详细介绍了`from_unixtime`函数的用法、语法、描述及示例。这个函数是GeaFlow支持的日期函数之一，旨在帮助用户将Unix时间戳转换为可读的日期时间格式。"
            },
            {
                "content": "## from_unixtime_millis\n**Syntax**\n\n```sql\nstring from_unixtime_millis(int unixtime)\nstring from_unixtime_millis(long unixtime)\nstring from_unixtime_millis(string unixtime)\nstring from_unixtime_millis(int unixtime, string format)\nstring from_unixtime_millis(long unixtime, string format)\n```\n**Description**\n将Unix毫秒时间戳转换成时间格式， 默认格式为“yyyy-MM-dd HH:mm:ss.SSS”。如果任何输入为空，则返回Null。\n**Example**\n\n```sql\nfrom_unixtime_millis(11111111) = '1970-01-01 11:05:11.111'\nfrom_unixtime_millis(11111111, 'yyyy-MM-dd HH:mm:ss') = '1970-01-01 11:05:11'\nfrom_unixtime_millis(11111111, 'yyyy-MM-dd HH:mm:ss.SSSSSS') = '1970-01-01 11:05:11.111000'\n```\n\n## unix_timestamp\n**Syntax**\n\n```sql\nlong unix_timestamp()\nlong unix_timestamp(string dateText)\nlong unix_timestamp(string dateText, string patternText)\n```\n**Description**\n返回Unix时间戳。如果未提供任何参数，则返回当前时间戳。如果给出dateText，则返回相应的时间戳。当未指定格式文本patternText时，则使用默认格式“yyyy-MM-dd”、“yyyy-MM-dd HH:mm:ss”或“yyyy-MM-dd HH:mm:ss.SSSSSS”解析dateText。如果任何输入为空，则返回Null。\n\n**Example**\n\n该段落位于文档中关于GeaFlow日期函数的部分，介绍了将Unix毫秒时间戳转换为时间格式的`from_unixtime_millis`函数及其使用示例，紧接着介绍了计算Unix时间戳的`unix_timestamp`函数和相关示例。"
            },
            {
                "content": "## unix_timestamp\n**Syntax**\n\n```sql\nlong unix_timestamp()\nlong unix_timestamp(string dateText)\nlong unix_timestamp(string dateText, string patternText)\n```\n**Description**\n返回Unix时间戳。如果未提供任何参数，则返回当前时间戳。如果给出dateText，则返回相应的时间戳。当未指定格式文本patternText时，则使用默认格式“yyyy-MM-dd”、“yyyy-MM-dd HH:mm:ss”或“yyyy-MM-dd HH:mm:ss.SSSSSS”解析dateText。如果任何输入为空，则返回Null。\n\n**Example**\n\n```sql\nunix_timestamp('1987-06-05 00:11:22') = 549817882\nunix_timestamp('1987-06-05 00:11', 'yyyy-MM-dd HH:mm') = 549817860\n```\n\n## unix_timestamp_millis\n**Syntax**\n\n```sql\nlong unix_timestamp_millis()\nlong unix_timestamp_millis(string dateText)\nlong unix_timestamp_millis(string dateText, string patternText)\n```\n**Description**\n返回Unix毫秒时间戳。类似于函数**unix_timestamp**。\n**Example**\n\n```sql\nunix_timestamp_millis('1987-06-05 00:11:22') = 549817882000\nunix_timestamp_millis('1987-06-05', 'yyyy-mm-dd') = 536774760000\n```\n\n## isdate\n**Syntax**\n\n该块内容位于GeaFlow支持的日期函数部分，具体介绍了`unix_timestamp`和`unix_timestamp_millis`两个函数的语法、描述及示例，用于返回Unix时间戳及其毫秒级别的版本。"
            },
            {
                "content": "## unix_timestamp_millis\n**Syntax**\n\n```sql\nlong unix_timestamp_millis()\nlong unix_timestamp_millis(string dateText)\nlong unix_timestamp_millis(string dateText, string patternText)\n```\n**Description**\n返回Unix毫秒时间戳。类似于函数**unix_timestamp**。\n**Example**\n\n```sql\nunix_timestamp_millis('1987-06-05 00:11:22') = 549817882000\nunix_timestamp_millis('1987-06-05', 'yyyy-mm-dd') = 536774760000\n```\n\n## isdate\n**Syntax**\n\n```sql\nboolean isdate(string date)\nboolean isdate(string date, string format)\n```\n**Description**\n判断字符串是否为指定格式的日期。默认格式为“yyyy-MM-dd HH:mm:ss”。如果任何输入为空，则返回false。\n\n**Example**\n\n```sql\nisdate('1987-06-05 00:11:22') = true\nisdate('xxxxxxxxxxxxx') = false\nisdate('1987-06-05 00:11:22', 'yyyy-MM-dd HH:mm:ss.SSSSSS') = false\n```\n\n## now\n**Syntax**\n\n```sql\nlong now()\nlong now(int offset)\nlong now(long offset)\n```\n**Description**\n返回带有可选偏移量的当前时间戳。\n\n**Example**\n\n```sql\nnow()\nnow(1000)\n```\n\n## day\n**Syntax**\n\n该块内容位于GeaFlow支持的日期函数部分，主要介绍与Unix时间戳相关的函数，包括`unix_timestamp_millis`、`isdate`、`now`和`day`等，用于处理和转换日期与时间的不同格式。"
            },
            {
                "content": "```sql\nboolean isdate(string date)\nboolean isdate(string date, string format)\n```\n**Description**\n判断字符串是否为指定格式的日期。默认格式为“yyyy-MM-dd HH:mm:ss”。如果任何输入为空，则返回false。\n\n**Example**\n\n```sql\nisdate('1987-06-05 00:11:22') = true\nisdate('xxxxxxxxxxxxx') = false\nisdate('1987-06-05 00:11:22', 'yyyy-MM-dd HH:mm:ss.SSSSSS') = false\n```\n\n## now\n**Syntax**\n\n```sql\nlong now()\nlong now(int offset)\nlong now(long offset)\n```\n**Description**\n返回带有可选偏移量的当前时间戳。\n\n**Example**\n\n```sql\nnow()\nnow(1000)\n```\n\n## day\n**Syntax**\n\n```sql\nint day(string dateString)\n```\n**Description**\n返回指定日期的天数。默认格式为“yyyy-MM-dd”或“yyyy-MM-dd HH:mm:ss”。如果任何输入为空，则返回null。\n\n**Example**\n\n```sql\nday('1987-06-05 00:11:22') = 5\n```\n\n## weekday\n**Syntax**\n\n```sql\nint weekday(string dateString)\n```\n**Description**\n返回指定日期的星期几。默认格式为“yyyy-MM-dd”或“yyyy-MM-dd HH:mm:ss”。如果任何输入为空，则返回null。\n\n**Example**\n\n```sql\nweekday('1987-06-05 00:11:22') = 5\n```\n\n## lastday\n**Syntax**\n\n该块内容位于GeaFlow支持的日期函数部分，具体介绍了函数**isdate**的语法、描述及示例，用于判断字符串是否为指定格式的日期。接下来是函数**now**、**day**和**weekday**的相关定义及示例。"
            },
            {
                "content": "**Example**\n\n```sql\nnow()\nnow(1000)\n```\n\n## day\n**Syntax**\n\n```sql\nint day(string dateString)\n```\n**Description**\n返回指定日期的天数。默认格式为“yyyy-MM-dd”或“yyyy-MM-dd HH:mm:ss”。如果任何输入为空，则返回null。\n\n**Example**\n\n```sql\nday('1987-06-05 00:11:22') = 5\n```\n\n## weekday\n**Syntax**\n\n```sql\nint weekday(string dateString)\n```\n**Description**\n返回指定日期的星期几。默认格式为“yyyy-MM-dd”或“yyyy-MM-dd HH:mm:ss”。如果任何输入为空，则返回null。\n\n**Example**\n\n```sql\nweekday('1987-06-05 00:11:22') = 5\n```\n\n## lastday\n**Syntax**\n\n```sql\nstring lastday(string dateString)\n```\n**Description**\n返回指定日期所在月份的最后一天。默认格式为“yyyy-MM-dd”或“yyyy-MM-dd HH:mm:ss”。如果任何输入为空，则返回null。\n\n**Example**\n\n```sql\nlastday('1987-06-05') = '1987-06-30 00:00:00'\n```\n\n## day_of_month\n**Syntax**\n\n```sql\nint day_of_month(string dateString)\n```\n**Description**\n返回指定日期所在月份的日期。默认格式为“yyyy-MM-dd”或“yyyy-MM-dd HH:mm:ss”。如果任何输入为空，则返回null。\n\n**Example**\n\n```sql\nday_of_month('1987-06-05 00:11:22') = 5\n```\n\n## week_of_year\n**Syntax**\n\n该块内容位于GeaFlow日期函数部分，详细描述了函数**now**的用法以及相关的日期操作函数，包括**day**、**weekday**、**lastday**、**day_of_month**和**week_of_year**的语法、描述和示例。"
            },
            {
                "content": "## lastday\n**Syntax**\n\n```sql\nstring lastday(string dateString)\n```\n**Description**\n返回指定日期所在月份的最后一天。默认格式为“yyyy-MM-dd”或“yyyy-MM-dd HH:mm:ss”。如果任何输入为空，则返回null。\n\n**Example**\n\n```sql\nlastday('1987-06-05') = '1987-06-30 00:00:00'\n```\n\n## day_of_month\n**Syntax**\n\n```sql\nint day_of_month(string dateString)\n```\n**Description**\n返回指定日期所在月份的日期。默认格式为“yyyy-MM-dd”或“yyyy-MM-dd HH:mm:ss”。如果任何输入为空，则返回null。\n\n**Example**\n\n```sql\nday_of_month('1987-06-05 00:11:22') = 5\n```\n\n## week_of_year\n**Syntax**\n\n```sql\nint week_of_year(string dateString)\n```\n**Description**\n返回给定日期所在年份的周数。默认格式为“yyyy-MM-dd”或“yyyy-MM-dd HH:mm:ss”。如果任何输入为空，则返回null。\n\n**Example**\n\n```sql\nweek_of_year('1987-06-05 00:11:22') = 23\n```\n\n\n## date_add\n**Syntax**\n\n```sql\nstring date_add(string date, int days)\n```\n**Description**\n将指定日期增加指定天数。默认格式为“yyyy-MM-dd”或“yyyy-MM-dd HH:mm:ss”。如果任何输入为空，则返回Null。\n\n**Example**\n\n```sql\ndate_add('2017-09-25 10:00:00', 1) = '2017-09-26'\ndate_add('2017-09-25', 1) = '2017-09-26'\ndate_add('2017-09-25', -1) = '2017-09-24'\n```\n\n该文档介绍了GeaFlow支持的日期函数，包括如何处理日期和时间格式、转换Unix时间戳、判断日期有效性，以及对日期进行加减操作等功能。所选片段主要涵盖了有关获取特定日期信息（如月份的最后一天、日期在月份中的位置、年份中的周数）和日期的加法操作的函数定义及其示例。"
            },
            {
                "content": "**Example**\n\n```sql\nweek_of_year('1987-06-05 00:11:22') = 23\n```\n\n\n## date_add\n**Syntax**\n\n```sql\nstring date_add(string date, int days)\n```\n**Description**\n将指定日期增加指定天数。默认格式为“yyyy-MM-dd”或“yyyy-MM-dd HH:mm:ss”。如果任何输入为空，则返回Null。\n\n**Example**\n\n```sql\ndate_add('2017-09-25 10:00:00', 1) = '2017-09-26'\ndate_add('2017-09-25', 1) = '2017-09-26'\ndate_add('2017-09-25', -1) = '2017-09-24'\n```\n\n## date_sub\n**Syntax**\n\n```sql\nstring date_sub(string date, int days)\n```\n**Description**\n将指定日期减去指定天数。默认格式为“yyyy-MM-dd”或“yyyy-MM-dd HH:mm:ss”。如果任何输入为空，则返回Null。\n\n**Example**\n\n```sql\ndate_sub('2017-09-25 10:00:00', 1) = '2017-09-24'\ndate_sub('2017-09-25', 1) = '2017-09-24'\ndate_sub('2017-09-25', -1) = '2017-09-26'\n```\n\n## date_diff\n**Syntax**\n\n```sql\nint date_diff(string dateString1, string dateString2)\n```\n**Description**\n返回从dateString2到dateString1的天数。默认格式为“yyyy-MM-dd”或“yyyy-MM-dd HH:mm:ss”。如果任何输入为空，则返回Null。\n\n**Example**\n\n```sql\ndate_diff('2017-09-26', '2017-09-25') = 1\ndate_diff('2017-09-24', '2017-09-25') = -1\n```\n\n该块内容包含了关于`week_of_year`函数的示例及其功能描述，紧接着是`date_add`、`date_sub`和`date_diff`函数的语法、描述和示例，用于日期加减和计算日期差异。"
            },
            {
                "content": "**Example**\n\n```sql\ndate_sub('2017-09-25 10:00:00', 1) = '2017-09-24'\ndate_sub('2017-09-25', 1) = '2017-09-24'\ndate_sub('2017-09-25', -1) = '2017-09-26'\n```\n\n## date_diff\n**Syntax**\n\n```sql\nint date_diff(string dateString1, string dateString2)\n```\n**Description**\n返回从dateString2到dateString1的天数。默认格式为“yyyy-MM-dd”或“yyyy-MM-dd HH:mm:ss”。如果任何输入为空，则返回Null。\n\n**Example**\n\n```sql\ndate_diff('2017-09-26', '2017-09-25') = 1\ndate_diff('2017-09-24', '2017-09-25') = -1\n```\n\n## add_months\n**Syntax**\n\n```sql\nstring add_months(string date, int months)\n```\n**Description**\n将指定日期增加指定月份。默认格式为“yyyy-MM-dd”或“yyyy-MM-dd HH:mm:ss”。如果任何输入为空，则返回Null。\n\n**Example**\n\n```sql\nadd_months('2017-09-25 10:00:00', 1) = '2017-10-25 10:00:00'\nadd_months('2017-09-25', 1) = '2017-10-25'\nadd_months('2017-09-25', -1) = '2017-08-25'\n```\n\n## date_format\n**Syntax**\n\n该块内容位于文档中关于日期函数的部分，主要介绍了**date_sub**、**date_diff**、**add_months**和**date_format**等函数的用法示例及其语法，帮助用户理解如何进行日期的减法、日期差异计算、月份增加和日期格式转换。"
            },
            {
                "content": "**Example**\n\n```sql\ndate_diff('2017-09-26', '2017-09-25') = 1\ndate_diff('2017-09-24', '2017-09-25') = -1\n```\n\n## add_months\n**Syntax**\n\n```sql\nstring add_months(string date, int months)\n```\n**Description**\n将指定日期增加指定月份。默认格式为“yyyy-MM-dd”或“yyyy-MM-dd HH:mm:ss”。如果任何输入为空，则返回Null。\n\n**Example**\n\n```sql\nadd_months('2017-09-25 10:00:00', 1) = '2017-10-25 10:00:00'\nadd_months('2017-09-25', 1) = '2017-10-25'\nadd_months('2017-09-25', -1) = '2017-08-25'\n```\n\n## date_format\n**Syntax**\n\n```sql\nstring date_format(string dateText)\nstring date_format(string dateText, string toFormat)\nstring date_format(string dateText, string fromFormat, string toFormat)\n```\n**Description**\n将日期从一种格式转换为另一种格式。默认的fromFormat为“yyyy-MM-dd HH:mm:ss”或“yyyy-MM-dd HH:mm:ss.SSSSSS”，默认的toFormat为“yyyy-MM-dd HH:mm:ss”。如果任何输入为空，则返回Null。\n\n**Example**\n\n该块内容位于文档中关于日期函数的部分，主要介绍了`date_diff`和`add_months`函数的示例及其语法和描述，用于日期计算和格式转换。"
            },
            {
                "content": "## date_format\n**Syntax**\n\n```sql\nstring date_format(string dateText)\nstring date_format(string dateText, string toFormat)\nstring date_format(string dateText, string fromFormat, string toFormat)\n```\n**Description**\n将日期从一种格式转换为另一种格式。默认的fromFormat为“yyyy-MM-dd HH:mm:ss”或“yyyy-MM-dd HH:mm:ss.SSSSSS”，默认的toFormat为“yyyy-MM-dd HH:mm:ss”。如果任何输入为空，则返回Null。\n\n**Example**\n\n```sql\ndate_format('1987-06-05 00:11:22') = '1987-06-05 00:11:22'\ndate_format('1987-06-05 00:11:22', 'MM-dd-yyyy') = '06-05-1987'\ndate_format('00:11:22 1987-06-05', 'HH:mm:ss yyyy-MM-dd', 'MM-dd-yyyy') = '06-05-1987'\n```\n\n## date_part\n**Syntax**\n\n```sql\nint date_part(string dateText, string datePart)\n```\n**Description**\n按日期部分格式返回日期的部分。默认日期格式为“yyyy-MM-dd HH:mm:ss”或“yyyy-MM-dd”。如果任何输入为空，则返回Null。datePart格式如下表所示。\n\n| Select | datePart |\n| -------- | -------- |\n| 年     | yyyy, year     |\n| 月     | mm, mon, month     |\n| 月中天数     | dd, day     |\n| 一天中小时数     | hh, hour     |\n| 分     | mi, minute     |\n| 秒     | ss, second     |\n表格内容描述：\n\n该块内容位于文档中关于日期函数的部分，具体介绍了`date_format`和`date_part`两个函数的语法、功能以及示例，用于处理和格式化日期数据。"
            },
            {
                "content": "## date_part\n**Syntax**\n\n```sql\nint date_part(string dateText, string datePart)\n```\n**Description**\n按日期部分格式返回日期的部分。默认日期格式为“yyyy-MM-dd HH:mm:ss”或“yyyy-MM-dd”。如果任何输入为空，则返回Null。datePart格式如下表所示。\n\n| Select | datePart |\n| -------- | -------- |\n| 年     | yyyy, year     |\n| 月     | mm, mon, month     |\n| 月中天数     | dd, day     |\n| 一天中小时数     | hh, hour     |\n| 分     | mi, minute     |\n| 秒     | ss, second     |\n表格内容描述：\n\n该表格包含两列，分别是“Select”和“datePart”。\n\n1. 第一行：选择“年”，对应的日期部分表示为“yyyy, year”。\n2. 第二行：选择“月”，对应的日期部分表示为“mm, mon, month”。\n3. 第三行：选择“月中天数”，对应的日期部分表示为“dd, day”。\n4. 第四行：选择“一天中小时数”，对应的日期部分表示为“hh, hour”。\n5. 第五行：选择“分”，对应的日期部分表示为“mi, minute”。\n6. 第六行：选择“秒”，对应的日期部分表示为“ss, second”。\n\n整体而言，该表格列出了日期和时间的不同组成部分及其对应的表示方式，清晰地总结了时间单位的不同形式。\n\n**Example**\n\n在文档中，**date_part**函数属于GeaFlow支持的日期函数部分，主要用于根据指定的日期部分格式返回日期的相应组成部分，文中详细说明了函数的语法、描述、表格列出可选的日期部分，以及若干示例。"
            },
            {
                "content": "该表格包含两列，分别是“Select”和“datePart”。\n\n1. 第一行：选择“年”，对应的日期部分表示为“yyyy, year”。\n2. 第二行：选择“月”，对应的日期部分表示为“mm, mon, month”。\n3. 第三行：选择“月中天数”，对应的日期部分表示为“dd, day”。\n4. 第四行：选择“一天中小时数”，对应的日期部分表示为“hh, hour”。\n5. 第五行：选择“分”，对应的日期部分表示为“mi, minute”。\n6. 第六行：选择“秒”，对应的日期部分表示为“ss, second”。\n\n整体而言，该表格列出了日期和时间的不同组成部分及其对应的表示方式，清晰地总结了时间单位的不同形式。\n\n**Example**\n\n```sql\ndate_part('1987-06-05 00:11:22', 'yyyy') = 1987\ndate_part('1987-06-05 00:11:22', 'mm') = 6\ndate_part('1987-06-05 00:11:22', 'dd') = 5\ndate_part('1987-06-05 00:11:22', 'hh') = 0\ndate_part('1987-06-05 00:11:22', 'mi') = 11\ndate_part('1987-06-05 00:11:22', 'ss') = 22\ndate_part('1987-06-05', 'ss') = 0\n```\n\n## date_trunc\n**Syntax**\n\n```sql\nstring date_trunc(string dateText, string datePart)\n```\n**Description**\n按指定格式将日期截断。默认日期格式为“yyyy-MM-dd HH:mm:ss”或“yyyy-MM-dd”。如果任何输入为空，则返回Null。datePart格式与函数**date_part**相同。\n\n**Example**\n\n该块内容位于文档的“date_part”函数说明部分，主要介绍该函数怎样按照不同的日期部分返回日期的具体值，并提供了相关示例。此外，块中还包含了日期部分的格式对照表和“date_trunc”函数的概述。"
            },
            {
                "content": "## date_trunc\n**Syntax**\n\n```sql\nstring date_trunc(string dateText, string datePart)\n```\n**Description**\n按指定格式将日期截断。默认日期格式为“yyyy-MM-dd HH:mm:ss”或“yyyy-MM-dd”。如果任何输入为空，则返回Null。datePart格式与函数**date_part**相同。\n\n**Example**\n\n```sql\ndate_trunc('1987-06-05 00:11:22', 'yyyy') = '1987-01-01 00:00:00'\ndate_trunc('1987-06-05 00:11:22', 'mm') = '1987-06-01 00:00:00'\ndate_trunc('1987-06-05 00:11:22', 'dd') = '1987-06-05 00:00:00'\ndate_trunc('1987-06-05 00:11:22', 'hh') = '1987-06-05 00:00:00'\ndate_trunc('1987-06-05 00:11:22', 'mi') = '1987-06-05 00:11:00'\ndate_trunc('1987-06-05 00:11:22', 'ss') = '1987-06-05 00:11:22'\ndate_trunc('1987-06-05', 'ss') = '1987-01-01 00:00:00'\n```\n\n该文本段落位于文档中关于日期函数的部分，具体介绍了**date_trunc**函数的语法、功能描述和示例，用于按指定格式截断日期。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_42.md",
        "chunks": [
            {
                "content": "# Pulsar Connector介绍\nGeaFlow 支持从 Pulsar 中读取数据，并向 Pulsar 写入数据。目前支持的 Pulsar 版本为 2.8.1。\n## 语法\n```sql\nCREATE TABLE pulsar_table (\n  id BIGINT,\n  name VARCHAR,\n  age INT\n) WITH (\n\ttype='pulsar',\n    `geaflow.dsl.pulsar.servers` = 'localhost',\n    `geaflow.dsl.pulsar.port` = '6650',\n    `geaflow.dsl.pulsar.topic` = 'persistent://test/test_pulsar_connector/topic_read',\n    `geaflow.dsl.pulsar.subscriptionInitialPosition` = 'latest'\n)\n```\n## 参数\n\n| 参数名 | 是否必须 | 描述 |\n| -------- | -------- | -------- |\n| geaflow.dsl.pulsar.servers     | 是     | Pulsar 的引导服务器（bootstrap）列表     |\n| geaflow.dsl.pulsar.port     | 是     | Pulsar 的引导服务器（bootstrap）端口号     |\n| geaflow.dsl.pulsar.topic     | 是     | Pulsar topic|\n| geaflow.dsl.pulsar.subscriptionInitialPosition     | 否     | Pulsar消费的初始位置，默认是 'latest', 可选择 'earliest‘|\n表格内容描述: \n该表格包含三列，分别是“参数名”、“是否必须”和“描述”。\n\n该文档介绍了GeaFlow中Pulsar Connector的功能和使用方法，包括支持的Pulsar版本、创建表的语法、必要参数的说明以及两个示例。上述chunk部分详细描述了Pulsar Connector的基本语法和参数设置。"
            },
            {
                "content": "| 参数名 | 是否必须 | 描述 |\n| -------- | -------- | -------- |\n| geaflow.dsl.pulsar.servers     | 是     | Pulsar 的引导服务器（bootstrap）列表     |\n| geaflow.dsl.pulsar.port     | 是     | Pulsar 的引导服务器（bootstrap）端口号     |\n| geaflow.dsl.pulsar.topic     | 是     | Pulsar topic|\n| geaflow.dsl.pulsar.subscriptionInitialPosition     | 否     | Pulsar消费的初始位置，默认是 'latest', 可选择 'earliest‘|\n表格内容描述: \n该表格包含三列，分别是“参数名”、“是否必须”和“描述”。 \n\n1. 第一行：参数名为“geaflow.dsl.pulsar.servers”，该参数是必须的，它描述了Pulsar的引导服务器（bootstrap）列表。\n2. 第二行：参数名为“geaflow.dsl.pulsar.port”，该参数也是必须的，描述了Pulsar的引导服务器（bootstrap）端口号。\n3. 第三行：参数名为“geaflow.dsl.pulsar.topic”，该参数同样是必须的，描述的是Pulsar的topic。\n4. 第四行：参数名为“geaflow.dsl.pulsar.subscriptionInitialPosition”，该参数不是必须的，描述了Pulsar消费的初始位置，默认为'latest'，并可选择为'earliest'。\n\n整体总结：该表格列出了与Pulsar相关的重要参数，包括它们的名称、是否必需以及具体的功能描述，主要涉及引导服务器、端口号、topic以及消费初始位置的设置。\n\n注意：pulsar connector不能指定一个分区topic， 如果你要消费某个分区的消息，请选择分区topic的子topic名称。\n\n该块内容位于\"GeaFlow Pulsar Connector介绍\"部分，详细列出了与Pulsar连接相关的重要参数，包括每个参数的名称、是否必需以及具体的功能描述，针对Pulsar数据读取和写入的配置进行说明。"
            },
            {
                "content": "整体总结：该表格列出了与Pulsar相关的重要参数，包括它们的名称、是否必需以及具体的功能描述，主要涉及引导服务器、端口号、topic以及消费初始位置的设置。\n\n注意：pulsar connector不能指定一个分区topic， 如果你要消费某个分区的消息，请选择分区topic的子topic名称。\n\n## 示例1\n示例1是从pulsar从`topic_read`中读取数据并且将数据写入`topic_write`中。\n```sql\nCREATE TABLE pulsar_source (\n    id BIGINT,\n    name VARCHAR,\n    age INT\n) WITH (\n    type='pulsar',\n    `geaflow.dsl.pulsar.servers` = 'localhost',\n    `geaflow.dsl.pulsar.port` = '6650',\n    `geaflow.dsl.pulsar.topic` = 'persistent://test/test_pulsar_connector/topic_read',\n    `geaflow.dsl.pulsar.subscriptionInitialPosition` = 'latest'\n    );\nCREATE TABLE pulsar_sink (\n    id BIGINT,\n    name VARCHAR,\n    age INT\n) WITH (\n    type='pulsar',\n    `geaflow.dsl.pulsar.servers` = 'localhost',\n    `geaflow.dsl.pulsar.port` = '6650',\n    `geaflow.dsl.pulsar.topic` = 'persistent://test/test_pulsar_connector/topic_write'\n    );\nINSERT INTO pulsar_sink\nSELECT * FROM pulsar_source;\n```\n## 示例2\n同样我们也可以进行四度环路检测。\n```sql\nset geaflow.dsl.window.size = 1;\nset geaflow.dsl.ignore.exception = true;\n\n该块内容概述了与Pulsar连接器相关的重要参数总结，并提供了两个SQL示例，展示如何从Pulsar读取数据和进行四度环路检测。"
            },
            {
                "content": "CREATE GRAPH IF NOT EXISTS pulsar_modern (\n  Vertex person (\n    id bigint ID,\n    name varchar\n  ),\n  Edge knows (\n    srcId bigint SOURCE ID,\n    targetId bigint DESTINATION ID,\n    weight double\n  )\n) WITH (storeType='rocksdb',\n  shardCount = 1\n);\n\nCREATE TABLE IF NOT EXISTS pulsar_source (\n    text varchar\n) WITH (\n    type='pulsar',\n    `geaflow.dsl.column.separator` = '#',\n    `geaflow.dsl.pulsar.servers` = 'localhost',\n    `geaflow.dsl.pulsar.port` = '6650',\n    `geaflow.dsl.pulsar.topic` = 'persistent://test/test_pulsar_connector/topic_read',\n    `geaflow.dsl.pulsar.subscriptionInitialPosition` = 'latest'\n    );\n\nCREATE TABLE IF NOT EXISTS pulsar_sink (\n    a_id bigint,\n    b_id bigint,\n    c_id bigint,\n    d_id bigint,\n    a1_id bigint\n) WITH (\n    type='pulsar',\n    `geaflow.dsl.pulsar.servers` = 'localhost',\n    `geaflow.dsl.pulsar.port` = '6650',\n    `geaflow.dsl.pulsar.topic` = 'persistent://test/test_pulsar_connector/topic_write'\n    );\n\nUSE GRAPH pulsar_modern;\n\n该代码块位于文档的示例2部分，展示了如何创建图形结构（`pulsar_modern`）以及源和汇表（`pulsar_source`和`pulsar_sink`），并设置为从Pulsar读写数据。"
            },
            {
                "content": "CREATE TABLE IF NOT EXISTS pulsar_sink (\n    a_id bigint,\n    b_id bigint,\n    c_id bigint,\n    d_id bigint,\n    a1_id bigint\n) WITH (\n    type='pulsar',\n    `geaflow.dsl.pulsar.servers` = 'localhost',\n    `geaflow.dsl.pulsar.port` = '6650',\n    `geaflow.dsl.pulsar.topic` = 'persistent://test/test_pulsar_connector/topic_write'\n    );\n\nUSE GRAPH pulsar_modern;\n\nINSERT INTO pulsar_modern.person(id, name)\nSELECT\n    cast(trim(split_ex(t1, ',', 0)) as bigint),\n    split_ex(trim(t1), ',', 1)\nFROM (\n    Select trim(substr(text, 2)) as t1\n    FROM pulsar_source\n    WHERE substr(text, 1, 1) = '.'\n    );\n\nINSERT INTO pulsar_modern.knows\nSELECT\n    cast(split_ex(t1, ',', 0) as bigint),\n    cast(split_ex(t1, ',', 1) as bigint),\n    cast(split_ex(t1, ',', 2) as double)\nFROM (\n    Select trim(substr(text, 2)) as t1\n    FROM pulsar_source\n    WHERE substr(text, 1, 1) = '-'\n    );\n\n该代码块位于示例2部分，展示了如何创建和使用名为`pulsar_sink`的表，向`pulsar_modern`图中插入数据，以及如何从`pulsar_source`读取特定格式的数据并处理。这一部分主要关注四度环路检测的实现，涉及图数据库操作和Pulsar数据的写入。"
            },
            {
                "content": "INSERT INTO pulsar_modern.knows\nSELECT\n    cast(split_ex(t1, ',', 0) as bigint),\n    cast(split_ex(t1, ',', 1) as bigint),\n    cast(split_ex(t1, ',', 2) as double)\nFROM (\n    Select trim(substr(text, 2)) as t1\n    FROM pulsar_source\n    WHERE substr(text, 1, 1) = '-'\n    );\n\nINSERT INTO pulsar_sink\nSELECT\n    a_id,\n    b_id,\n    c_id,\n    d_id,\n    a1_id\nFROM (\n      MATCH (a:person) -[:knows]->(b:person) -[:knows]-> (c:person)\n          -[:knows]-> (d:person) -> (a:person)\n          RETURN a.id as a_id, b.id as b_id, c.id as c_id, d.id as d_id, a.id as a1_id\n    );\n```\n\n该块代码位于文档的第二个示例中，展示了如何将数据从 Pulsar 的 `pulsar_source` 表中插入到图数据库 `pulsar_modern` 的 `knows` 关系中，并随后将结果插入到 `pulsar_sink` 表中，体现了复杂的数据处理和四度环路检测的实现。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_43.md",
        "chunks": [
            {
                "content": "# 使用 TuGraph 图学习模块进行点分类\n\n## 1.简介\nGNN 是许多图上机器学习任务的强大工具。在本介绍性教程中，您将学习使用 GNN 进行点分类的基本工作流程，即预测图中点的类别。\n\n此文档将展示如何构建一个 GNN 用于在 Cora 数据集上仅使用少量标签进行半监督点分类，这是一个以论文为点、引文为边的引文网络。任务是预测给定论文的类别。\n\n通过完成本教程，您可以\n\n使用 TuGraph 加载 cora 数据集。\n\n使用 TuGraph 提供的采样算子采样，并构建 GNN 模型。\n\n在 CPU 或 GPU 上训练用于点分类的 GNN 模型。\n\n此文档需要对图神经网络、DGL等使用有一定经验。\n\n## 2. 前置条件\n\nTuGraph图学习模块需要TuGraph-db 3.5.1及以上版本。\n\nTuGraph部署推荐采用Docker镜像tugraph-compile 1.2.4及以上版本:\n\ntugraph / tugraph-compile-ubuntu18.04:latest\n\ntugraph / tugraph-compile-centos7:latest\n\ntugraph / tugraph-compile-centos8:latest\n\n以上镜像均可在DockerHub上获取。\n\n## 3. Cora 数据集导入TuGraph数据库\n### 3.1. Cora 数据集介绍\nCora 数据集由 2708 篇论文组成，分为 7 个类别。每篇论文由一个 1433 维的词袋表示，表示论文中的单词是否出现。这些词袋特征已经预处理，以从 0 到 1 的范围归一化。边表示论文之间的引用关系。\n\nTuGraph中已经提供了Cora数据集的导入工具，用户可以直接使用。\n\n### 3.2. 数据导入\nCora数据集在test/integration/data/algo目录下，包含点集cora_vertices和边集cora_edge。\n\n首先需要将Cora数据集导入到TuGraph数据库中。\n\n在build/output目录下执行：\n```bash\ncp -r ../../test/integration/data/ ./ && cp -r ../../learn/examples/* ./\n```\n\n该指令将数据集相关文件拷贝到build/output目录下。\n\n此文档介绍了如何使用TuGraph图学习模块进行点分类，具体通过构建图神经网络（GNN）在Cora数据集上进行半监督学习。该段落涵盖了GNN的基本概念、Cora数据集的介绍及其导入步骤，为接下来的特征转换、模型训练及保存奠定基础。"
            },
            {
                "content": "tugraph / tugraph-compile-centos8:latest\n\n以上镜像均可在DockerHub上获取。\n\n## 3. Cora 数据集导入TuGraph数据库\n### 3.1. Cora 数据集介绍\nCora 数据集由 2708 篇论文组成，分为 7 个类别。每篇论文由一个 1433 维的词袋表示，表示论文中的单词是否出现。这些词袋特征已经预处理，以从 0 到 1 的范围归一化。边表示论文之间的引用关系。\n\nTuGraph中已经提供了Cora数据集的导入工具，用户可以直接使用。\n\n### 3.2. 数据导入\nCora数据集在test/integration/data/algo目录下，包含点集cora_vertices和边集cora_edge。\n\n首先需要将Cora数据集导入到TuGraph数据库中。\n\n在build/output目录下执行：\n```bash\ncp -r ../../test/integration/data/ ./ && cp -r ../../learn/examples/* ./\n```\n\n该指令将数据集相关文件拷贝到build/output目录下。\n\n然后进行数据导入：\n```bash\n./lgraph_import -c ./data/algo/cora.conf --dir ./coradb --overwrite 1\n```\n其中cora.conf为图schema文件，代表图数据的格式,可参考test/integration/data/algo/cora.conf。coradb为导入后的图数据文件名称，代表图数据的存储位置。\n\n## 4. feature特征转换\n由于Cora数据集中的feature特征为长度为1433的float类型数组，TuGraph暂不支持float数组类型加载，因此可将其按照string类型导入后，转换成char*方便后续存取，具体实现可参考feature_float.cpp文件。\n具体执行过程如下：\n\n在build目录下编译导入plugin(如果TuGraph已编译可跳过)：\n`make feature_float_embed`\n\n在build/output目录下执行\n`./algo/feature_float_embed ./coradb`\n即可进行转换。\n\n该块内容位于文档的第三部分，主要介绍如何将Cora数据集导入TuGraph数据库，包括数据集的基本信息和导入步骤，以便后续使用图神经网络进行点分类任务。"
            },
            {
                "content": "该指令将数据集相关文件拷贝到build/output目录下。\n\n然后进行数据导入：\n```bash\n./lgraph_import -c ./data/algo/cora.conf --dir ./coradb --overwrite 1\n```\n其中cora.conf为图schema文件，代表图数据的格式,可参考test/integration/data/algo/cora.conf。coradb为导入后的图数据文件名称，代表图数据的存储位置。\n\n## 4. feature特征转换\n由于Cora数据集中的feature特征为长度为1433的float类型数组，TuGraph暂不支持float数组类型加载，因此可将其按照string类型导入后，转换成char*方便后续存取，具体实现可参考feature_float.cpp文件。\n具体执行过程如下：\n\n在build目录下编译导入plugin(如果TuGraph已编译可跳过)：\n`make feature_float_embed`\n\n在build/output目录下执行\n`./algo/feature_float_embed ./coradb`\n即可进行转换。\n\n## 5. 编译采样算子\n采样算子用于从数据库中获取图数据并转换成所需数据结构，具体执行过程如下(如果TuGraph已编译，可跳过此步骤)：\n在tugraph-db/build文件夹下执行\n`make -j2`\n\n或在tugraph-db/learn/procedures文件夹下执行\n`python3 setup.py build_ext -i`\n\n```python\nfrom lgraph_db_python import *  # 导入tugraph-db的python接口模块\nimport importlib  # 导入importlib模块\ngetdb = importlib.import_module(\"getdb\")  #获取getdb算子\ngetdb.Process(db, olapondb, feature_len, NodeInfo, EdgeInfo) #调用getdb算子\n```\n\n如代码所示，得到算子so文件后，import 导入使用。\n\n该块内容主要介绍了如何将Cora数据集导入TuGraph数据库并进行特征转换及采样算子的编译。这部分紧接在Cora数据集的导入介绍后，详细描述了数据导入命令、特征转换的过程以及如何编译采样算子，为后续模型训练打下基础。"
            },
            {
                "content": "在build/output目录下执行\n`./algo/feature_float_embed ./coradb`\n即可进行转换。\n\n## 5. 编译采样算子\n采样算子用于从数据库中获取图数据并转换成所需数据结构，具体执行过程如下(如果TuGraph已编译，可跳过此步骤)：\n在tugraph-db/build文件夹下执行\n`make -j2`\n\n或在tugraph-db/learn/procedures文件夹下执行\n`python3 setup.py build_ext -i`\n\n```python\nfrom lgraph_db_python import *  # 导入tugraph-db的python接口模块\nimport importlib  # 导入importlib模块\ngetdb = importlib.import_module(\"getdb\")  #获取getdb算子\ngetdb.Process(db, olapondb, feature_len, NodeInfo, EdgeInfo) #调用getdb算子\n```\n\n如代码所示，得到算子so文件后，import 导入使用。\n\n## 6. 模型训练及保存\nTuGraph在python层调用cython层的算子，实现图学习模型的训练。\n使用 TuGraph 图学习模块使用方式介绍如下:\n在build/output文件夹下执行\n`python3 train_full_cora.py --model_save_path ./cora_model`\n即可进行训练。\n最终打印loss数值小于0.9，即为训练成功。至此，图模型训练完成，模型保存在cora_model文件。\n\n训练详细过程如下：\n### 6.1.数据加载\n```python\ngalaxy = PyGalaxy(args.db_path)\ngalaxy.SetCurrentUser(args.username, args.password)\ndb = galaxy.OpenGraph(args.graph_name, False)\n```\n如代码所示，根据图数据路径、用户名、密码和子图名称将数据加载到内存中。TuGraph可以载入多个子图用于图训练，在此处我们只载入一个子图。\n\n该文本块位于文档的第5和第6部分之间，主要介绍了如何在TuGraph中编译采样算子以及如何进行模型训练和保存。这部分内容涵盖了特征转换的执行步骤和模型训练的具体流程，包括数据加载、创建采样器和训练模型的代码示例。"
            },
            {
                "content": "如代码所示，得到算子so文件后，import 导入使用。\n\n## 6. 模型训练及保存\nTuGraph在python层调用cython层的算子，实现图学习模型的训练。\n使用 TuGraph 图学习模块使用方式介绍如下:\n在build/output文件夹下执行\n`python3 train_full_cora.py --model_save_path ./cora_model`\n即可进行训练。\n最终打印loss数值小于0.9，即为训练成功。至此，图模型训练完成，模型保存在cora_model文件。\n\n训练详细过程如下：\n### 6.1.数据加载\n```python\ngalaxy = PyGalaxy(args.db_path)\ngalaxy.SetCurrentUser(args.username, args.password)\ndb = galaxy.OpenGraph(args.graph_name, False)\n```\n如代码所示，根据图数据路径、用户名、密码和子图名称将数据加载到内存中。TuGraph可以载入多个子图用于图训练，在此处我们只载入一个子图。\n\n### 6.2.构建采样器\n训练过程中，首先使用GetDB算子从数据库中获取图数据并转换成所需数据结构，具体代码如下：\n```python\n    GetDB.Process(db_: lgraph_db_python.PyGraphDB, olapondb: lgraph_db_python.PyOlapOnDB, feature_num: size_t, NodeInfo: list, EdgeInfo: list)\n```\n如代码所示，结果存储在NodeInfo和EdgeInfo中。NodeInfo和EdgeInfo是python list结果，其存储的信息结果如下：\n\n| 图数据 | 存储信息位置 |\n| --- | --- |\n| 边起点 | EdgeInfo[0] |\n| 边终点 | EdgeInfo[1] |\n| 顶点ID | NodeInfo[0] |\n| 顶点特征 | NodeInfo[1] |\n| 顶点标签 | NodeInfo[2] |\n表格内容描述: \n此表格包含两列，分别为“图数据”和“存储信息位置”。\n\n该片段位于文档的第6部分，主要介绍使用TuGraph进行GNN模型的训练和保存过程，包括数据加载、采样器构建以及训练细节。此部分是整个教程的重要环节，指导用户如何在Cora数据集上训练图模型并保存模型文件。"
            },
            {
                "content": "### 6.2.构建采样器\n训练过程中，首先使用GetDB算子从数据库中获取图数据并转换成所需数据结构，具体代码如下：\n```python\n    GetDB.Process(db_: lgraph_db_python.PyGraphDB, olapondb: lgraph_db_python.PyOlapOnDB, feature_num: size_t, NodeInfo: list, EdgeInfo: list)\n```\n如代码所示，结果存储在NodeInfo和EdgeInfo中。NodeInfo和EdgeInfo是python list结果，其存储的信息结果如下：\n\n| 图数据 | 存储信息位置 |\n| --- | --- |\n| 边起点 | EdgeInfo[0] |\n| 边终点 | EdgeInfo[1] |\n| 顶点ID | NodeInfo[0] |\n| 顶点特征 | NodeInfo[1] |\n| 顶点标签 | NodeInfo[2] |\n表格内容描述: \n此表格包含两列，分别为“图数据”和“存储信息位置”。 \n\n- 第一行显示边的起点，存储在EdgeInfo数组的第0个索引位置。\n- 第二行显示边的终点，存储在EdgeInfo数组的第1个索引位置。\n- 第三行为顶点ID，存储在NodeInfo数组的第0个索引位置。\n- 第四行显示顶点特征，存储在NodeInfo数组的第1个索引位置。\n- 第五行为顶点标签，存储在NodeInfo数组的第2个索引位置。\n\n总结: 此表格详细列出了图数据中的边和顶点信息，并指明了各项数据在相应存储位置的索引，便于理解数据的结构和存储方式。\n\n然后构建采样器\n```python\n    batch_size = 5\n    count = 2708\n    sampler = TugraphSample(args)\n    dataloader = dgl.dataloading.DataLoader(fake_g,\n        torch.arange(count),\n        sampler,\n        batch_size=batch_size,\n        num_workers=0,\n        )\n```\n\n本节位于模型训练流程的第六部分，主要介绍如何构建采样器以获取图数据并转换成适合训练的格式。这一过程是点分类任务中重要的一步，确保后续的模型可以正确地接收和处理图数据。"
            },
            {
                "content": "- 第一行显示边的起点，存储在EdgeInfo数组的第0个索引位置。\n- 第二行显示边的终点，存储在EdgeInfo数组的第1个索引位置。\n- 第三行为顶点ID，存储在NodeInfo数组的第0个索引位置。\n- 第四行显示顶点特征，存储在NodeInfo数组的第1个索引位置。\n- 第五行为顶点标签，存储在NodeInfo数组的第2个索引位置。\n\n总结: 此表格详细列出了图数据中的边和顶点信息，并指明了各项数据在相应存储位置的索引，便于理解数据的结构和存储方式。\n\n然后构建采样器\n```python\n    batch_size = 5\n    count = 2708\n    sampler = TugraphSample(args)\n    dataloader = dgl.dataloading.DataLoader(fake_g,\n        torch.arange(count),\n        sampler,\n        batch_size=batch_size,\n        num_workers=0,\n        )\n```\n\n### 6.3.对结果进行格式转换\n```python\n    src = EdgeInfo[0].astype('int64')\n    dst = EdgeInfo[1].astype('int64')\n    nodes_idx = NodeInfo[0].astype('int64')\n    remap(src, dst, nodes_idx)\n    features = NodeInfo[1].astype('float32')\n    labels = NodeInfo[2].astype('int64')\n    g = dgl.graph((src, dst))\n    g.ndata['feat'] = torch.tensor(features)\n    g.ndata['label'] = torch.tensor(labels)\n    return g\n```\n对结果进行格式转换，使之符合训练格式\n\n该内容位于第6章“模型训练及保存”中的第6.2节“构建采样器”和第6.3节“对结果进行格式转换”之间，主要描述了图数据中边和顶点信息的存储结构，并介绍了如何构建采样器以便进行后续的训练过程。"
            },
            {
                "content": "### 6.3.对结果进行格式转换\n```python\n    src = EdgeInfo[0].astype('int64')\n    dst = EdgeInfo[1].astype('int64')\n    nodes_idx = NodeInfo[0].astype('int64')\n    remap(src, dst, nodes_idx)\n    features = NodeInfo[1].astype('float32')\n    labels = NodeInfo[2].astype('int64')\n    g = dgl.graph((src, dst))\n    g.ndata['feat'] = torch.tensor(features)\n    g.ndata['label'] = torch.tensor(labels)\n    return g\n```\n对结果进行格式转换，使之符合训练格式\n\n### 6.4.构建GCN模型\n```python\nclass GCN(nn.Module):\n    def __init__(self, in_size, hid_size, out_size):\n        super().__init__()\n        self.layers = nn.ModuleList()\n        # two-layer GCN\n        self.layers.append(dgl.nn.GraphConv(in_size, hid_size, activation=F.relu))\n        self.layers.append(dgl.nn.GraphConv(hid_size, out_size))\n        self.dropout = nn.Dropout(0.5)\n\n    def forward(self, g, features):\n        h = features\n        for i, layer in enumerate(self.layers):\n            if i != 0:\n                h = self.dropout(h)\n            h = layer(g, h)\n        return h\n\n在文档的第6章中，作者详细讲述了使用TuGraph进行点分类的训练过程。在6.3节中，主要介绍了如何对从数据库中获取的图数据进行格式转换，以符合训练的要求。这一过程为后续的模型构建和训练奠定了基础。在6.4节，作者展示了如何构建一个图卷积网络（GCN）模型，这是实现点分类的关键步骤。"
            },
            {
                "content": "def forward(self, g, features):\n        h = features\n        for i, layer in enumerate(self.layers):\n            if i != 0:\n                h = self.dropout(h)\n            h = layer(g, h)\n        return h\n\ndef build_model():\n    in_size = feature_len  #feature_len为feature的长度，在此处为1433\n    out_size = classes  #classes为类别数，在此处为7\n    model = GCN(in_size, 16, out_size)  #16为隐藏层大小\n    return model\n```\n本教程将构建一个两层图卷积网络（GCN）。每层通过聚合邻居信息来计算新的点表示。\n\n在第6.4节“构建GCN模型”中，文档详细介绍了如何构建一个两层的图卷积网络（GCN），包括模型的前向传播函数和初始化过程，以便利用邻居信息进行节点表示的计算。"
            },
            {
                "content": "### 6.5.训练GCN模型\n```python\nloss_fcn = nn.CrossEntropyLoss()\ndef train(graph, model, model_save_path):\n    optimizer = torch.optim.Adam(model.parameters(), lr=1e-2, weight_decay=5e-4)\n    model.train()\n    s = time.time()\n    load_time = time.time()\n    graph = dgl.add_self_loop(graph)\n    logits = model(graph, graph.ndata['feat'])\n    loss = loss_fcn(logits, graph.ndata['label'])\n    optimizer.zero_grad()\n    loss.backward()\n    optimizer.step()\n    train_time = time.time()\n    current_loss = float(loss)\n    if model_save_path != \"\":   #如果需要保存模型，则给出模型保存路径\n        if 'min_loss' not in train.__dict__:\n            train.min_loss = current_loss\n        elif current_loss < train.min_loss:\n            train.min_loss = current_loss\n            model_save_path = 'best_model.pth'\n        torch.save(model.state_dict(), model_save_path)\n    return current_loss\n\n在文档的第6节中，介绍了如何训练图卷积网络（GCN）模型以进行点分类。第6.5节具体描述了训练过程中所需的函数以及模型优化的细节，包括损失函数的定义、优化器的设置和模型训练的迭代过程。该段代码演示了在训练过程中如何计算损失、更新模型参数以及保存最佳模型。"
            },
            {
                "content": "for epoch in range(50):\n    model.train()\n    total_loss = 0\n    loss = train(g, model)\n    if epoch % 5 == 0:\n        print('In epoch', epoch, ', loss', loss)\n    sys.stdout.flush()\n```\n如代码所示，根据定义好的采样器、优化器和模型进行迭代训练50次，训练后的模型保存至model_save_path路径中。\n\n输出结果如下：\n```bash\nIn epoch 0 , loss 1.9586775302886963\nIn epoch 5 , loss 1.543689250946045\nIn epoch 10 , loss 1.160698413848877\nIn epoch 15 , loss 0.8862786889076233\nIn epoch 20 , loss 0.6973256468772888\nIn epoch 25 , loss 0.5770673751831055\nIn epoch 30 , loss 0.5271289348602295\nIn epoch 35 , loss 0.45514997839927673\nIn epoch 40 , loss 0.43748989701271057\nIn epoch 45 , loss 0.3906335234642029\n```\n\n同时，图学习模块可采用GPU进行加速，用户如果需要再GPU上运行，需要用户自行安装相应的GPU驱动和环境。具体可参考learn/README.md。\n\n完整代码可参考learn/examples/train_full_cora.py\n\n该代码块位于模型训练部分，展示了使用定义好的采样器、优化器和模型进行50次迭代训练的过程，同时提供了每5个epoch输出一次损失值的示例，最后提到模型可以在GPU上进行加速。此部分是实现图学习模块训练的关键步骤。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_44.md",
        "chunks": [
            {
                "content": "# Rust 存储过程\n\n## 1. 介绍\nRust 存储过程目前仅支持v1版本，TuGraph能够支持一切编译成动态库的语言作为插件。Rust语言作为系统编程语言的新起之秀，在安全性上、可靠性以及人体工程学上相较于C++具有较大优势。\n\n我们提供了TuGraph的 Rust binding 库来支持在Rust中调用lgrahp api，同时提供 tugraph-plugin-util 工具库来帮助大家更加简洁地编写Rust插件代码。\n\nRust binding 链接: https://crates.io/crates/tugraph\ntugraph-plugin-util 链接: https://crates.io/crates/tugraph-plugin-util\n\n## 2. 如何使用\n\nRust存储过程的使用分三步：\n* 编译，从rust源码编译出so库。我们准备了一份一站式的插件编写教程，从IDE的插件安装，环境配置，到编译，详细参考`rust-tugraph-plugin-tutorial`。\n* 加载，将so库加载到服务端，可以通过REST或RPC接口，这一步和C++库的使用方式类似。\n* 运行，和c++ procdure使用方式相同，不在赘述。\n\n## 3.API文档\nRust社区习惯，所有的代码和文档都可以从[`crates.io`](https://crates.io/crates/tugraph )以及[`docs.rs`](https://docs.rs/tugraph/latest/tugraph )找到。\n\n该文档主要介绍Rust语言在TuGraph中的存储过程应用，涵盖了Rust存储过程的介绍、使用步骤以及API文档的链接，对希望在TuGraph中使用Rust作为插件开发的用户提供了必要的信息和资源。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_45.md",
        "chunks": [
            {
                "content": "# DCL\n\n## Use Graph\n用户在执行Match语句之前需要通过Use Graph语句指定当前查询的图。\n### Syntax\n\n```sql\nUSE GRAPH Identifier\n```\n### Example\n\n```sql\n-- Set current using graph.\nUSE GRAPH modern;\n\nINSERT INTO tbl_result\nSELECT\n\ta.id,\n\tb.id,\n\tc.id,\n\tc.kind,\n\td.id,\n\td.type\nFROM (\n  MATCH (a) -> (b) where b.id > 0 and a.lang is null\n  MATCH (a) <- (c) where label(c) = 'person'\n  Let c.kind = 'k' || cast(c.age / 10 as varchar)\n  MATCH (c) -> (d) where d != b\n  Let d.type = if (label(d) = 'person', 1, 0)\n  RETURN a, b, c, d\n)\n;\n```\n## Use Instance\nInstance类似于Hive/Mysql中的Database的概念。我们可以通过**Use Instance**命令指定当前语句的实例。\n### Syntax\n\n```sql\nUSE INSTANCE Identifier\n```\n### Example\n\n```sql\nUse instance geaflow;\nUSE GRAPH modern;\n\n该文档主要介绍DCL（数据控制语言）的使用，包括如何通过USE GRAPH和USE INSTANCE命令指定当前查询的图和实例，提供了相应的语法和示例。"
            },
            {
                "content": "```sql\nUSE INSTANCE Identifier\n```\n### Example\n\n```sql\nUse instance geaflow;\nUSE GRAPH modern;\n\nINSERT INTO tbl_result\nSELECT\n\ta.id,\n\tb.id,\n\tc.id,\n\tc.kind,\n\td.id,\n\td.type\nFROM (\n  MATCH (a) -> (b) where b.id > 0 and a.lang is null\n  MATCH (a) <- (c) where label(c) = 'person'\n  Let c.kind = 'k' || cast(c.age / 10 as varchar)\n  MATCH (c) -> (d) where d != b\n  Let d.type = if (label(d) = 'person', 1, 0)\n  RETURN a, b, c, d\n);\n```\n\n该代码块位于文档中关于“使用实例”的部分，展示了如何通过 `USE INSTANCE` 命令指定当前数据库实例，并提供了相应的示例查询，涉及图数据的操作和插入结果。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_46.md",
        "chunks": [
            {
                "content": "# Match\nGeaFlow支持以下语法 ：\n* Match\n* Regex-Match\n* Return\n* Let\n* SubQuery\n* Continue-Match\n\n## Syntax\n\n```sql\nMatchStatement: MATCH PathPatthern (',' PathPatthern)* [WHERE boolExpr]\n\nPathPatthern: Node ([Edge] Node)*\nNode: '(' Identifier [ ':' StringLiteral ] [ WHERE boolExpr] ')'\nEdge: '-' '[' Identifier [ ':' StringLiteral ] [ WHERE boolExpr] ']' '-'\n\t\t | '-' '[' Identifier [ ':' StringLiteral ] [ WHERE boolExpr] ']' '->'\n\t\t | '<-' '[' Identifier [ ':' StringLiteral ] [ WHERE boolExpr] ']' '-'\n```\n### Node\n匹配图上的点,可以指定点的类型以及对点的过滤条件。\n### Edge\n匹配图上的边，类似Node节点可以指定边的类型以及对边的过滤条件。和Node不同的是,边需要指定方向，边的方向包括入边、出边和双向边。\n### Edge Direction\n\n| 边类型 | 语法 | 说明 |\n| -------- | -------- | -------- |\n| 入边 |  <-[edge]- | 匹配图中指向点的边|\n| 出边 | -[edge]-> | 匹配图中从点指出的边 |\n| 双向边 | -[edge]- | 匹配图中点的出边和入边|\n表格内容描述: 该表格包含三列，分别为“边类型”、“语法”和“说明”。\n\n第一行数据表示“入边”，其语法为“<-[edge]-”，表示匹配图中指向某个点的边。  \n第二行数据表示“出边”，其语法为“- [edge] ->”，表示匹配图中从某个点指出的边。  \n第三行数据表示“双向边”，其语法为“- [edge]-”，表示匹配图中某个点的出边和入边。\n\n总结来看，表格详细列出了图论中三种边的类型及其对应的语法表示，分别针对入边、出边和双向边进行说明。\n\n## Example\n\n该块内容主要介绍了GeaFlow中的基本语法和匹配操作，包括Match语法、节点与边的定义及其方向、以及相关的示例。此部分是文档的开头，奠定了后续对其他语法（如Regex-Match、Return、Let等）的理解基础。"
            },
            {
                "content": "| 边类型 | 语法 | 说明 |\n| -------- | -------- | -------- |\n| 入边 |  <-[edge]- | 匹配图中指向点的边|\n| 出边 | -[edge]-> | 匹配图中从点指出的边 |\n| 双向边 | -[edge]- | 匹配图中点的出边和入边|\n表格内容描述: 该表格包含三列，分别为“边类型”、“语法”和“说明”。\n\n第一行数据表示“入边”，其语法为“<-[edge]-”，表示匹配图中指向某个点的边。  \n第二行数据表示“出边”，其语法为“- [edge] ->”，表示匹配图中从某个点指出的边。  \n第三行数据表示“双向边”，其语法为“- [edge]-”，表示匹配图中某个点的出边和入边。\n\n总结来看，表格详细列出了图论中三种边的类型及其对应的语法表示，分别针对入边、出边和双向边进行说明。\n\n## Example\n\n* Basic Mathch\n```sql\n-- Match all node \nMATCH (a)\n\n-- Match all person node\nMATCH (a:person)\n\n-- Match node where id = 1\nMATCH (a:person where id = 1)\n\n-- One hop match\nMATCH (a:person where id = 1)-[e:knows where e.weight > 0.4]->(b:person)\n\n-- Tow hop match\nMATCH (a:person)-(b:person) <- (c)\n\n-- Match in-vertex for node a\nMATCH (a:person)<-[e:knows]-(b)\n```\n* Match With Filter\n\n```sql\nMATCH (a:person)<-[e:knows]-(b) Where a.id = b.id\n\n```\n* Match Join\n  Match two path pattern and join them with the common label.\n  e.g.\n\n```sql\nMATCH (a) -> (b), (a) -> (c)\n```\nThe output is **p1 = (a, b) join p2 = (a, c) on p1.a = p2.a**.\n\n该片段位于文档的“Edge Direction”部分，详细介绍了图论中三种边的类型（入边、出边和双向边），并提供了相应的语法和示例。此外，片段还总结了这些边类型及其在图匹配中的应用。"
            },
            {
                "content": "-- One hop match\nMATCH (a:person where id = 1)-[e:knows where e.weight > 0.4]->(b:person)\n\n-- Tow hop match\nMATCH (a:person)-(b:person) <- (c)\n\n-- Match in-vertex for node a\nMATCH (a:person)<-[e:knows]-(b)\n```\n* Match With Filter\n\n```sql\nMATCH (a:person)<-[e:knows]-(b) Where a.id = b.id\n\n```\n* Match Join\n  Match two path pattern and join them with the common label.\n  e.g.\n\n```sql\nMATCH (a) -> (b), (a) -> (c)\n```\nThe output is **p1 = (a, b) join p2 = (a, c) on p1.a = p2.a**.\n\n# Regex-Match\n不定跳数匹配，类似正则表达式写法指定跳数。\n## Syntax\n\n```sql\nPathPatthern: Node Edge '{' minHop ',' [ maxHop] '}' Node\n```\n## Example\n\n```sql\nMATCH (a) -[e]->{1,5} (b)\n\nMATCH (a) -[e]->{1,}  (b)\n```\n# Return\n## Syntax\n```sql\nRETURN expr {',' expr}* \n[ GROUP BY expr {',' expr}* ] \n[ ORDER BY expr [ASC|DESC] {',' expr [ASC|DESC]} ]\n[ LIMIT number ]\n```\n## Example\n\n```sql\nMATCH (a:person WHERE a.id = '1')-[e:knows]->(b:person)\nRETURN a.name as name, b.id as b_id\n\nMATCH (a:person WHERE a.id = '1')-[e:knows]->(b:person)\nRETURN a, b\n\n该块内容主要介绍了GeaFlow数据库中匹配图数据的SQL语法，包括单跳和双跳匹配示例，过滤条件的使用，以及如何连接不同的模式。同时，还展示了正则表达式匹配和返回查询的语法示例。这部分内容属于文档的“Match”及“Return”部分，在图查询的实现中起着重要的作用。"
            },
            {
                "content": "```sql\nPathPatthern: Node Edge '{' minHop ',' [ maxHop] '}' Node\n```\n## Example\n\n```sql\nMATCH (a) -[e]->{1,5} (b)\n\nMATCH (a) -[e]->{1,}  (b)\n```\n# Return\n## Syntax\n```sql\nRETURN expr {',' expr}* \n[ GROUP BY expr {',' expr}* ] \n[ ORDER BY expr [ASC|DESC] {',' expr [ASC|DESC]} ]\n[ LIMIT number ]\n```\n## Example\n\n```sql\nMATCH (a:person WHERE a.id = '1')-[e:knows]->(b:person)\nRETURN a.name as name, b.id as b_id\n\nMATCH (a:person WHERE a.id = '1')-[e:knows]->(b:person)\nRETURN a, b\n\n-- GROUP BY\nMATCH (a:person)-[e:knows where e.weight > 0.4]->(b:person)\nRETURN a.id, SUM(e.weight) * 10 as amt GROUP BY a.id\n\n-- ORDER BY\nMATCH (a:person WHERE a.id = '1')-[e:knows]->(b:person)\nRETURN a, b order by a.age DESC, b.age ASC\n\n-- LIMIT\nMATCH (a:person WHERE a.id = '1')-[e:knows]->(b:person)\nRETURN a, b order by a.age DESC, b.age ASC LIMIT 10\n```\n# Let\nLet语句用于在图匹配过程中修改路径上的点和边的属性值。\n## Syntax\n\n```sql\nLET Identifier '.' Identifier = expr\n```\n## Example\n\n该代码块包含了GeaFlow中关于Regex-Match语法的定义及示例，紧接着是Return语句的语法结构和示例，此外还包含了Let语句的定义和用法示例。"
            },
            {
                "content": "-- GROUP BY\nMATCH (a:person)-[e:knows where e.weight > 0.4]->(b:person)\nRETURN a.id, SUM(e.weight) * 10 as amt GROUP BY a.id\n\n-- ORDER BY\nMATCH (a:person WHERE a.id = '1')-[e:knows]->(b:person)\nRETURN a, b order by a.age DESC, b.age ASC\n\n-- LIMIT\nMATCH (a:person WHERE a.id = '1')-[e:knows]->(b:person)\nRETURN a, b order by a.age DESC, b.age ASC LIMIT 10\n```\n# Let\nLet语句用于在图匹配过程中修改路径上的点和边的属性值。\n## Syntax\n\n```sql\nLET Identifier '.' Identifier = expr\n```\n## Example\n\n```sql\n MATCH (a:person where a.id = 1) -[e:knows]->(b:person)\n LET a.weight = a.age / cast(100.0 as double),\n LET b.weight = b.age / cast(100.0 as double)\n\n\nMATCH (a:person where a.id = 1) -[e:knows]->(b:person)\nLET a.weight = a.age / cast(100.0 as double),\nLET a.weight = a.weight * 2,\nLET b.weight = 1.0,\nLET b.age = 20\n\n```\n# SubQuery\n## Syntax\n### Scalar Query\n\n```sql\nAggregateFunction '(' PathPatthern '=>' expr ')'\n```\n### Exists Query\n\n```sql\nEXISTS PathPatthern\n```\n## Example\n### Scalar Query Example\n\n该块内容主要介绍了图匹配语言中的数据处理功能，包括如何使用GROUP BY、ORDER BY和LIMIT语句来进行结果的聚合、排序和限制，同时还引入了LET语句用于修改路径上点和边的属性值，紧接着则讲解了子查询的用法和示例。这部分内容位于文档中关于图匹配的操作部分之后，主要用于增强图数据查询的灵活性和有效性。"
            },
            {
                "content": "MATCH (a:person where a.id = 1) -[e:knows]->(b:person)\nLET a.weight = a.age / cast(100.0 as double),\nLET a.weight = a.weight * 2,\nLET b.weight = 1.0,\nLET b.age = 20\n\n```\n# SubQuery\n## Syntax\n### Scalar Query\n\n```sql\nAggregateFunction '(' PathPatthern '=>' expr ')'\n```\n### Exists Query\n\n```sql\nEXISTS PathPatthern\n```\n## Example\n### Scalar Query Example\n\n```sql\nMATCH (a:person WHERE id = 1)-[e]->(b)\nWhere COUNT((b) ->(c) => c) >= 1\nRETURN a, e, b\n\nMATCH (a:person WHERE id = 1)-[e]->(b)\nLet b.out_cnt = COUNT((b) ->(c) => c),\nLet b.out_weight = SUM((b) -[e1]-> (c) => e1.weight)\nRETURN a, e, b\n```\n### Exists Query Example\n\n```sql\nMATCH (a:person WHERE id = 1)-[e]->(b)\nWhere EXISTS (b) -> (c)\n      And SUM((b) -[e1]-> (c) => e1.weight) > 1\nRETURN a, e, b\n```\n\n# Continue-Match\n用户可以将一段复杂的Match拆分成多段Match，多段Match的结果为各个Match路径的join关联。\n## Syntax\n\n```sql\nMatchStatement\nMatchStatement\n```\n## Example\n\n该片段包含一个MATCH语句示例，演示了如何在图中匹配“person”节点并计算相关属性的权重和年龄。同时，接下来的部分介绍了子查询的语法和示例，说明了如何使用聚合函数和存在查询来进行更复杂的数据检索。"
            },
            {
                "content": "MATCH (a:person WHERE id = 1)-[e]->(b)\nLet b.out_cnt = COUNT((b) ->(c) => c),\nLet b.out_weight = SUM((b) -[e1]-> (c) => e1.weight)\nRETURN a, e, b\n```\n### Exists Query Example\n\n```sql\nMATCH (a:person WHERE id = 1)-[e]->(b)\nWhere EXISTS (b) -> (c)\n      And SUM((b) -[e1]-> (c) => e1.weight) > 1\nRETURN a, e, b\n```\n\n# Continue-Match\n用户可以将一段复杂的Match拆分成多段Match，多段Match的结果为各个Match路径的join关联。\n## Syntax\n\n```sql\nMatchStatement\nMatchStatement\n```\n## Example\n\n```sql\nMATCH (a:person where a.id = 1) -[e:knows]->(b:person)\nLET a.weight = a.age / cast(100.0 as double),\nLET a.weight = a.weight * 2\nMATCH(b) -[]->(c)\nRETURN a.id as a_id, a.weight as a_weight, b.id as b_id, c.id as c_id\n\n\nMATCH (a) -> (b) where b.id > 0 and a.lang is null\nMATCH (a) <- (c) where label(c) = 'person'\nLet c.kind = 'k' || cast(c.age / 10 as varchar)\nMATCH (c) -> (d) where d != b\nLet d.type = if (label(d) = 'person', 1, 0)\nRETURN a, b, c, d\n```\n\n此块内容位于文档中关于子查询和继续匹配的部分，展示了如何在图数据库中进行复杂的匹配与聚合操作，包括计算节点的属性、存在查询以及拆分多段匹配的用法。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_47.md",
        "chunks": [
            {
                "content": "# Learn Tutorial\n\n> 本文档是为 TuGraph 的用户设计的引导程序，用户在阅读详细的文档之前，应该首先阅读该文档，对 TuGraph 的图学习运行流程有一个大致的了解，之后再阅读详细文档会更加方便。引导程序是基于 Tugraph 的一个简单的程序实例，我们将重点介绍其使用方式。\n\n## 1.TuGraph 图学习模块简介\n图学习是一种机器学习方法，其核心思想是利用图结构中的拓扑信息，通过顶点之间的联系及规律来进行数据分析和建模。不同于传统机器学习方法，图学习利用的数据形式为图结构，其中顶点表示数据中的实体，而边则表示实体之间的关系。通过对这些顶点和边进行特征提取和模式挖掘，可以揭示出数据中深层次的关联和规律，从而用于各种实际应用中。\n\nTuGraph图学习模块依赖于TuGraph的数据库管理系统。TuGraph图学习模块是一个基于图数据库的图学习模块，主要提供了四种采样算子：Neighbor Sampling、Edge Sampling、Random Walk Sampling 和 Negative Sampling。这些算子可以用于对图中的顶点和边进行采样，从而生成训练数据。采样过程是在并行计算环境下完成的，具有高效性和可扩展性。\n\n在采样后，我们可以使用得到的训练数据来训练一个模型。该模型可以用于各种图学习任务，比如预测、分类等。通过训练，模型可以学习到图中的顶点和边之间的关系，从而能够对新的顶点和边进行预测和分类。在实际应用中，这个模块可以被用来处理各种大规模的图数据，比如社交网络、推荐系统、生物信息学等。\n\n## 2. 运行流程\nTuGraph 图学习模块将TuGraph中的图数据采样，采样后的顶点和边作为图学习的特征，进行学习训练。运行流程如下所示：\n\n1. 图数据导入Tugraph db\n2. 预处理：feature特征转换\n3. cpython层：采样算子实现\n4. python层：采样算子调用生成子图\n5. 训练过程：子图传入dgl框架\n6. 输出结果\n\n## 3.TuGraph编译及数据准备\n\n在build/output目录下执行：\n```bash\ncp -r ../../test/integration/data/ ./ && cp -r ../../learn/examples/* ./\n```\n\n该指令将数据集相关文件拷贝到build/output目录下。\n\n该文档是TuGraph用户的引导程序，主要介绍TuGraph图学习模块的概念、运行流程，以及数据准备和导入的步骤。具体内容涵盖了图学习的基本原理、采样算子的类型及其编译、模型训练与加载等，以帮助用户在使用TuGraph进行图数据分析时更为高效和便利。"
            },
            {
                "content": "在采样后，我们可以使用得到的训练数据来训练一个模型。该模型可以用于各种图学习任务，比如预测、分类等。通过训练，模型可以学习到图中的顶点和边之间的关系，从而能够对新的顶点和边进行预测和分类。在实际应用中，这个模块可以被用来处理各种大规模的图数据，比如社交网络、推荐系统、生物信息学等。\n\n## 2. 运行流程\nTuGraph 图学习模块将TuGraph中的图数据采样，采样后的顶点和边作为图学习的特征，进行学习训练。运行流程如下所示：\n\n1. 图数据导入Tugraph db\n2. 预处理：feature特征转换\n3. cpython层：采样算子实现\n4. python层：采样算子调用生成子图\n5. 训练过程：子图传入dgl框架\n6. 输出结果\n\n## 3.TuGraph编译及数据准备\n\n在build/output目录下执行：\n```bash\ncp -r ../../test/integration/data/ ./ && cp -r ../../learn/examples/* ./\n```\n\n该指令将数据集相关文件拷贝到build/output目录下。\n\n## 4. 数据导入\n\n导入过程以cora数据集为例：\n\n在build/output目录下执行\n```bash\n./lgraph_import -c ./data/algo/cora.conf --dir ./coradb --overwrite 1\n```\n其中cora.conf为图schema文件，代表图数据的格式。coradb为导入后的图数据文件名称，代表图数据的存储位置。\n## 5. feature特征转换\n由于图学习中的feature特征一般表示为较长的float类型数组，TuGraph暂不支持float数组类型加载，因此可将其按照string类型导入后，转换成char*方便后续存取，具体实现可参考feature_float.cpp文件。\n具体执行过程如下：\n\n在build目录下编译导入plugin(如果TuGraph已编译可跳过)：\n`make feature_float_embed`\n\n该chunk主要介绍了TuGraph图学习模块的运行流程和相关步骤，包括模型训练的背景信息，以及图数据的导入与特征转换的具体操作。它位于文档的第二部分和第三部分之间，强调了从数据采样到模型训练的核心流程，适合需要了解TuGraph工作机制的用户。"
            },
            {
                "content": "该指令将数据集相关文件拷贝到build/output目录下。\n\n## 4. 数据导入\n\n导入过程以cora数据集为例：\n\n在build/output目录下执行\n```bash\n./lgraph_import -c ./data/algo/cora.conf --dir ./coradb --overwrite 1\n```\n其中cora.conf为图schema文件，代表图数据的格式。coradb为导入后的图数据文件名称，代表图数据的存储位置。\n## 5. feature特征转换\n由于图学习中的feature特征一般表示为较长的float类型数组，TuGraph暂不支持float数组类型加载，因此可将其按照string类型导入后，转换成char*方便后续存取，具体实现可参考feature_float.cpp文件。\n具体执行过程如下：\n\n在build目录下编译导入plugin(如果TuGraph已编译可跳过)：\n`make feature_float_embed`\n\n在build/output目录下执行\n`./algo/feature_float_embed ./coradb`\n即可进行转换。\n## 6. 采样算子及编译\nTuGraph在cython层实现了一种获取全图数据的算子及4种采样算子，具体如下：\n### 6.1.采样算子介绍\n| 采样算子 | 采样方式 |\n| --- | --- |\n| GetDB | 从数据库中获取图数据并转换成所需数据结构 |\n| Neighbor Sampling | 根据给定的顶点采样其邻居顶点，得到采样子图 |\n| Edge Sampling | 根据采样率采样图中的边，得到采样子图 |\n| Random Walk Sampling | 根据给定的顶点，进行随机游走，得到采样子图 |\n| Negative Sampling | 生成不存在边的子图。 |\n表格内容描述：表格包含两列，分别为“采样算子”和“采样方式”。\n\n该chunk位于文档的第4节和第5节，主要介绍了数据导入的具体步骤以及feature特征转换的相关操作，说明如何将数据集文件导入到TuGraph中并进行特征转换，为后续的图学习模块采样和训练奠定基础。"
            },
            {
                "content": "在build目录下编译导入plugin(如果TuGraph已编译可跳过)：\n`make feature_float_embed`\n\n在build/output目录下执行\n`./algo/feature_float_embed ./coradb`\n即可进行转换。\n## 6. 采样算子及编译\nTuGraph在cython层实现了一种获取全图数据的算子及4种采样算子，具体如下：\n### 6.1.采样算子介绍\n| 采样算子 | 采样方式 |\n| --- | --- |\n| GetDB | 从数据库中获取图数据并转换成所需数据结构 |\n| Neighbor Sampling | 根据给定的顶点采样其邻居顶点，得到采样子图 |\n| Edge Sampling | 根据采样率采样图中的边，得到采样子图 |\n| Random Walk Sampling | 根据给定的顶点，进行随机游走，得到采样子图 |\n| Negative Sampling | 生成不存在边的子图。 |\n表格内容描述：表格包含两列，分别为“采样算子”和“采样方式”。\n\n逐行描述表格中的数据内容：\n1. GetDB：该采样算子通过从数据库中获取图数据并将其转换成所需的数据结构来进行图采样。\n2. Neighbor Sampling：该采样方式是根据给定的顶点，采样其邻居顶点以生成采样子图。\n3. Edge Sampling：此方法通过设定采样率对图中的边进行随机采样，以获取采样子图。\n4. Random Walk Sampling：依据某个指定的顶点，该方法进行随机游走，生成相应的采样子图。\n5. Negative Sampling：这一方式用于生成不存在边的子图，从而获取负样本。\n\n表格整体内容的概要总结：该表格列出了五种不同的图数据采样算子及其相应的采样方式，涵盖从数据库获取图数据、邻居顶点采样、边的随机采样到负采样等多种技术，展示了图数据采样的多样化方法。\n\n### 6.2.编译\n如果TuGraph已编译，可跳过此步骤。\n在tugraph-db/build文件夹下执行\n`make -j2`\n\n或在tugraph-db/learn/procedures文件夹下执行\n`python3 setup.py build_ext -i`\n\n得到算子so后，在Python中import 即可使用。\n\n该块内容位于文档的第5部分和第6部分之间，主要介绍了TuGraph中feature特征转换的步骤及相关命令，并紧接着详细描述了采样算子及其编译过程，为用户理解图学习模块的采样操作和实现提供了必要的信息。"
            },
            {
                "content": "表格整体内容的概要总结：该表格列出了五种不同的图数据采样算子及其相应的采样方式，涵盖从数据库获取图数据、邻居顶点采样、边的随机采样到负采样等多种技术，展示了图数据采样的多样化方法。\n\n### 6.2.编译\n如果TuGraph已编译，可跳过此步骤。\n在tugraph-db/build文件夹下执行\n`make -j2`\n\n或在tugraph-db/learn/procedures文件夹下执行\n`python3 setup.py build_ext -i`\n\n得到算子so后，在Python中import 即可使用。\n\n## 7. 模型训练及保存\nTuGraph在python层调用cython层的算子，实现图学习模型的训练。\n使用 TuGraph 图学习模块使用方式介绍如下:\n在build/output文件夹下执行\n`python3 train_full_cora.py --model_save_path ./cora_model`\n即可进行训练。\n最终打印loss数值小于0.9，即为训练成功。至此，图模型训练完成，模型保存在cora_model文件。\n\n## 8. 模型加载\n```python\nmodel = build_model()\nmodel.load_state_dict(torch.load(model_save_path))\nmodel.eval()\n```\n在使用保存的模型之前，首先需要对其进行加载。代码中，使用如上的代码对已训练模型进行加载。\n\n加载之后，我们可以使用模型对新的顶点和边进行预测和分类。在预测时，我们可以输入一个或多个顶点，模型将输出相应的预测结果。在分类时，我们可以将整个图作为输入，模型将对图中的顶点和边进行分类，以实现任务的目标。\n使用已训练的模型可以避免重新训练模型的时间和资源消耗。此外，由于模型已经学习到了图数据中顶点和边之间的关系，它可以很好地适应新的数据，从而提高预测和分类的准确度。\n\n该段落位于文档的第6.2节和第7节之间，主要总结了不同图数据采样算子的特点和采样方式，并接着介绍了TuGraph模型的编译、训练及保存过程，是理解TuGraph图学习模块操作流程的重要部分。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_48.md",
        "chunks": [
            {
                "content": "# Text2GQL语法提示手册\n本手册列出了GQL常见的语法点以及参考的提示方法，用户可参考提问示例让模型生成对应的语法的GQL语句。\n\n该文档是关于GQL（图查询语言）的语法提示手册，旨在通过列出常见的语法点和提问示例，帮助用户生成对应的GQL查询语句。"
            },
            {
                "content": "| 语法 | 提问示例 | 结果 |\n| --- | --- | --- |\n| 查找点 | 请找出的类型为person**的点** | match(a:person) return a |\n| 查找边 | 返回图中所有的标签为knows**的边** | match(a)-[e:knows]->(b) return e |\n| 查找关系 | 查询10个属于北京的大学找出5个和小张老师**有关系**的学生 | match(a:city where a.name = '北京')<-[:belong]-(b:university) return b limit 10match(a:teacher where a.name='小张')-[e]-(b:student) return b limit 5 |\n| 查找多度关系 | 查找小王同学的朋友认识的人请帮我找出和标签为大学的点有拥有关系的部门,并且和这些部门有拥有关系的学生,并且和这些学生有选择关系的课程请查找腾讯和谷歌公司共同创建的软件的名称，返回5个。 | match(a:student where a.name = '小王')-[e:friend]->(b)-[e2:knows]->(c:person) return cmatch(a:university)-[e:has]->(b:department)-[e2:has]->(c:student)-[e3:selects]->(d:course) return dmatch(a:company where a.name='腾讯')-[e:creates]->(b:software)<-[e2:creates]-(c:company where c.name='谷歌') return b.name limit 5 |\n| Loop | 查询从person张思琪出发，经过类型为支付的边，**走2到4度到达的点** | match(a:person where a.name='张思琪')-[e:pay]->{2,4}(b:person) return b |\n\n该块内容位于文本手册的开头部分，主要展示了GQL语法的基本用法，包括如何查找节点、边、关系及多度关系的示例查询。这些示例通过提问与结果的对照，帮助用户理解如何在图数据库中进行相应的查询操作。"
            },
            {
                "content": "| Loop | 查询从person张思琪出发，经过类型为支付的边，**走2到4度到达的点** | match(a:person where a.name='张思琪')-[e:pay]->{2,4}(b:person) return b |\n| Loop(环) | 找出与person李红有knows关系的**3跳以内的环** | match(a:person where name = '李红')-[e:knows]->{1,2}(b)->(a) return a.id, b.id as b_id |\n| 过滤条件 | 找出小红认识的年龄大于20，工资大于5000的人请帮我找出10个性别不是famale且身高小于160,或id大于5的节点 | match(a:person where a.name='小红')-[e:knows]->(b:person where b.age > 20 and b.salary > 5000) return bmatch(a where (a.gender <> 'female' and a.height < 160) or a.id > 5) return a limit 10 |\n| Let单值 | 查询蚂蚁集团创造的软件, **令**软件的minPrice**等于**软件的价格的最小值, 返回公司的id, 软件的minPrice | match(a:company where a.name = '蚂蚁集团')-[e:creates]->(b:software) let b.minPrice = MIN(b.price) return a.id, b.minPrice |\n\n该块内容位于《Text2GQL语法提示手册》中，主要介绍了图数据库查询中的循环（Loop）、环（Loop(环)）、过滤条件以及Let单值的用法和示例查询，帮助用户理解如何在图查询中有效使用这些语法。"
            },
            {
                "content": "| 过滤条件 | 找出小红认识的年龄大于20，工资大于5000的人请帮我找出10个性别不是famale且身高小于160,或id大于5的节点 | match(a:person where a.name='小红')-[e:knows]->(b:person where b.age > 20 and b.salary > 5000) return bmatch(a where (a.gender <> 'female' and a.height < 160) or a.id > 5) return a limit 10 |\n| Let单值 | 查询蚂蚁集团创造的软件, **令**软件的minPrice**等于**软件的价格的最小值, 返回公司的id, 软件的minPrice | match(a:company where a.name = '蚂蚁集团')-[e:creates]->(b:software) let b.minPrice = MIN(b.price) return a.id, b.minPrice |\n| Let子查询 | 请帮我查找公司蚂蚁集团雇佣的person, **令**这个person的countSalary**的值等于**认识他的人的薪资的和, 再查找他购买的软件给出id为10的城市所属于的国家, 并将国家有关的公司的人数的平均值**赋值**给国家的avgCnt | match(a:company where a.name = '蚂蚁集团')-[e:employee]->(b:person) let b.countSalary = SUM((b:person)<-[e2:knows]-(c:person) => c.salary) match(b:person)-[e3:buy]->(d:software) return b.countSalary, dmatch(a:city where id = '10')-[e:belong]->(b:country)<-[e2:belong]-(c:company) let b.avgCnt = AVG(c.peopleNumber) return b |\n\n该段落包含了关于图数据库查询中“过滤条件”和“Let语句”的语法示例，展示了如何在GQL中使用过滤器和计算逻辑以获得特定数据。具体示例包括查找小红认识的特定人群及蚂蚁集团相关的软件和薪资计算。这部分内容位于手册的中间部分，继续深入图数据库查询的技术细节。"
            },
            {
                "content": "| Let子查询 | 请帮我查找公司蚂蚁集团雇佣的person, **令**这个person的countSalary**的值等于**认识他的人的薪资的和, 再查找他购买的软件给出id为10的城市所属于的国家, 并将国家有关的公司的人数的平均值**赋值**给国家的avgCnt | match(a:company where a.name = '蚂蚁集团')-[e:employee]->(b:person) let b.countSalary = SUM((b:person)<-[e2:knows]-(c:person) => c.salary) match(b:person)-[e3:buy]->(d:software) return b.countSalary, dmatch(a:city where id = '10')-[e:belong]->(b:country)<-[e2:belong]-(c:company) let b.avgCnt = AVG(c.peopleNumber) return b |\n| 函数调用 | **调用SSSP函数**,以'arg1', 10**作为输入**,返回id, distance | match(a:person) call sssp(a, 10) yield (id, distance) return id, distance |\n| order | 返回公司创造的软件，并根据公司的规格从大到小、软件的价格**从小到大排序** | match(a:company)-[e:creates]->(b:software) return a.scale,b.price order by a.scale desc, b.price asc |\n\n该块内容位于手册的中部，涵盖了图数据库查询中的复杂查询操作，包括Let子查询、函数调用以及排序，旨在为用户提供实用的GQL语法示例，以便在进行多重关联数据检索时的参考。"
            },
            {
                "content": "| 函数调用 | **调用SSSP函数**,以'arg1', 10**作为输入**,返回id, distance | match(a:person) call sssp(a, 10) yield (id, distance) return id, distance |\n| order | 返回公司创造的软件，并根据公司的规格从大到小、软件的价格**从小到大排序** | match(a:company)-[e:creates]->(b:software) return a.scale,b.price order by a.scale desc, b.price asc |\n| group by  | 找出小红认识的人，**根据**这些人的性别**分组**，返回工资的最大值帮我找出与北京大学有关联的公司，返回公司**以**规模**进行分组**的人数的平均值 | match(a:person where person.name = '小红')-[e:knows]->(b:person) return MAX(b.salary) group by b.gendermatch(a:university where a.name='北京大学')-[e]-(b:company) return AVG(b.peopleNumber) group by b.scale |\n| join | 找出郑伟喜欢的所有人，以及认识郑伟的所有人，并将它们**一起返回**请帮我找出和person alice有关联的学校,**称为X**,再帮我找出**和这个X有关联**的其他公司,以及和X有关联的person | match(a:person where a.name = '郑伟')-[e:likes]->(b:person),(a:person where a.name = '郑伟')<-[e2:knows]-(c:person) return a, b, cmatch(a:person where a.name = 'alice')-[e]-(b:school), (b:school)-[e2]-(c:company),(b:school)-[e3]-(d:person) return a, b, c, d |\n\n该块内容位于文本中关于GQL语法提示的部分，主要介绍了函数调用、排序、分组和连接等高级查询语法与对应的提问示例及结果，以帮助用户更好地理解和使用图数据库查询功能。"
            },
            {
                "content": "| 带图的schema单条查询**（在Console中开启“附带图schema”开关会自动拼接，不需要用户自己输入**） | 使用这个图:CREATE GRAPH g ( Vertex film ( id int ID, name varchar, category varchar, value int ), Vertex cinema ( id int ID, name varchar, address varchar, size int ), Vertex person ( id int ID, name varchar, age int, gender varchar, height int, salary int ), Vertex comment ( id int ID, name varchar, createTime bigint, wordCount int ), Vertex tag ( id int ID, name varchar, value int ), Edge person_likes_comment ( srcId int FROM person SOURCE ID, targetId int FROM comment DESTINATION ID, weight double, f0 int, f1 boolean ), Edge cinema_releases_film ( srcId int FROM cinema SOURCE ID, targetId int FROM film DESTINATION ID, weight double, f0 int, f1 boolean ), Edge person_watch_film ( srcId int FROM person SOURCE ID, targetId int FROM film DESTINATION ID, weight double, f0 int, f1 boolean, timeStamp bigint ), Edge film_has_tag ( srcId int FROM film SOURCE ID, targetId int FROM tag DESTINATION ID, weight double, f0 int, f1 boolean ), Edge\n\n该段落是一部分关于图数据库查询语法的说明，具体聚焦于带图的schema单条查询的语法示例，包括创建图的定义，涉及的点和边，以及如何通过特定的查询返回与特定person相关的comment信息。这部分内容旨在帮助用户理解如何在图数据库中进行复杂的查询操作。"
            },
            {
                "content": "SOURCE ID, targetId int FROM comment DESTINATION ID, weight double, f0 int, f1 boolean ), Edge cinema_releases_film ( srcId int FROM cinema SOURCE ID, targetId int FROM film DESTINATION ID, weight double, f0 int, f1 boolean ), Edge person_watch_film ( srcId int FROM person SOURCE ID, targetId int FROM film DESTINATION ID, weight double, f0 int, f1 boolean, timeStamp bigint ), Edge film_has_tag ( srcId int FROM film SOURCE ID, targetId int FROM tag DESTINATION ID, weight double, f0 int, f1 boolean ), Edge person_creates_comment ( srcId int FROM person SOURCE ID, targetId int FROM comment DESTINATION ID, weight double, f0 int, f1 boolean, timeStamp bigint ), Edge comment_belong_film ( srcId int FROM comment SOURCE ID, targetId int FROM film DESTINATION ID, weight double, f0 int, f1 boolean ));找出和person孙梅有person_creates_comment关系的comment,以及和person孙建聪有person_likes_comment关系的comment,将它们都返回 | atch(a:person where a.name = '孙梅')-[e:person_creates_comment]->(b:comment),(c:person where c.name =\n\n该chunk包含图数据库的schema定义部分，具体描述了边的类型及其属性，并提供了一个查询示例，旨在展示如何查找与特定人物有关的评论关系。这部分内容位于介绍各种GQL查询语法和示例的文档中，帮助用户理解如何在图数据库中执行相关操作。"
            },
            {
                "content": "f1 boolean ), Edge person_creates_comment ( srcId int FROM person SOURCE ID, targetId int FROM comment DESTINATION ID, weight double, f0 int, f1 boolean, timeStamp bigint ), Edge comment_belong_film ( srcId int FROM comment SOURCE ID, targetId int FROM film DESTINATION ID, weight double, f0 int, f1 boolean ));找出和person孙梅有person_creates_comment关系的comment,以及和person孙建聪有person_likes_comment关系的comment,将它们都返回 | atch(a:person where a.name = '孙梅')-[e:person_creates_comment]->(b:comment),(c:person where c.name = '孙建聪')-[e2:person_likes_comment]->(d:comment)return a, b, c, d |\n\n该部分内容属于GQL查询语法提示手册中的“带图的schema单条查询”部分，旨在展示如何根据图数据库中不同节点和边的关系查找相关的评论。具体示例涉及查找与特定人物之间存在关系的评论，并返回相关结果。"
            },
            {
                "content": "| 带图的schema多条查询 | 使用这个图:CREATE GRAPH g ( Vertex book ( id int ID, name varchar, id int ID, name varchar, category varchar, price int, wordCount int, createTime bigint ), Vertex publisher ( id int ID, name varchar, age int, gender varchar, height int, salary int ), Vertex reader ( id int ID, name varchar, age int, gender varchar, height int, salary int ), Vertex author ( id int ID, name varchar, age int, gender varchar, height int, salary int ), Edge author_write_book ( srcId int FROM author SOURCE ID, targetId int FROM book DESTINATION ID, weight double, f0 int, f1 boolean, timeStamp bigint ), Edge publisher_publish_book ( srcId int FROM publisher SOURCE ID, targetId int FROM book DESTINATION ID, weight double, f0 int, f1 boolean, timeStamp bigint ), Edge book_refers_book ( srcId int FROM book SOURCE ID, targetId int FROM book DESTINATION ID, weight double, f0 int, f1 boolean ), Edge reader_likes_book ( srcId int FROM reader SOURCE ID, targetId int FROM book DESTINATION ID, weight double, f0 int, f1 boolean\n\n该段落位于文档的最后部分，涉及图数据库中的多条带图schema查询示例，展示了如何使用不同的查询语法来检索与书籍、出版社、读者和作者相关的数据。这一部分特别强调了如何构建复杂的查询，以提取图数据库中多个节点和边的关系信息。"
            },
            {
                "content": "int FROM book DESTINATION ID, weight double, f0 int, f1 boolean, timeStamp bigint ), Edge publisher_publish_book ( srcId int FROM publisher SOURCE ID, targetId int FROM book DESTINATION ID, weight double, f0 int, f1 boolean, timeStamp bigint ), Edge book_refers_book ( srcId int FROM book SOURCE ID, targetId int FROM book DESTINATION ID, weight double, f0 int, f1 boolean ), Edge reader_likes_book ( srcId int FROM reader SOURCE ID, targetId int FROM book DESTINATION ID, weight double, f0 int, f1 boolean ), Edge author_knows_author ( srcId int FROM author SOURCE ID, targetId int FROM author DESTINATION ID, weight double, f0 int, f1 boolean ));执行以下4个查询:1: 找出被作家黄建聪认识的作家;2: 返回源点标签为作家,目标点标签为作家,标签为author_knows_author的边;3: 请帮我查找所有与book计算机网络有关系的book的id;4: 请帮我查找152个与何雪和张建聪都存在关系的书节点; | 查询语句为:1: match(a:author)<-[e:author_knows_author]-(b:author where b.name='黄建聪') return a, b;2: match(a:author)-[e:author_knows_author]->(b:author) return e;3: match(a:book where a.name='计算机网络')-[e]-(b:book) return b.id;4: match(a where\n\n该块内容是关于一个图数据库的边定义及相应的查询示例，属于文档中的多条查询部分，展示了如何使用GQL语法查询与书籍、作者及其关系相关的数据，包括作家之间的关系、书籍关联及特定书籍的查询等。"
            },
            {
                "content": "Edge author_knows_author ( srcId int FROM author SOURCE ID, targetId int FROM author DESTINATION ID, weight double, f0 int, f1 boolean ));执行以下4个查询:1: 找出被作家黄建聪认识的作家;2: 返回源点标签为作家,目标点标签为作家,标签为author_knows_author的边;3: 请帮我查找所有与book计算机网络有关系的book的id;4: 请帮我查找152个与何雪和张建聪都存在关系的书节点; | 查询语句为:1: match(a:author)<-[e:author_knows_author]-(b:author where b.name='黄建聪') return a, b;2: match(a:author)-[e:author_knows_author]->(b:author) return e;3: match(a:book where a.name='计算机网络')-[e]-(b:book) return b.id;4: match(a where a.name='何雪')-[e]->(b:book)<-[e2]-(c where c.name='张建聪') return b limit 152; |\n\n该块内容位于文本“Text2GQL语法提示手册”的后半部分，具体介绍了图数据库中“author_knows_author”关系的边，以示例形式展示了与作家之间的关系查询以及与图书相关的其他查询。"
            },
            {
                "content": "表格内容描述:\n该表格包含三列，分别为“语法”、“提问示例”和“结果”。\n\n本手册概述了GQL语法的常见用法和示例，表格内容描述部分具体解释了表格中的三列：语法、提问示例和结果，以帮助用户理解每种查询的具体含义和用途。"
            },
            {
                "content": "1. 第一行数据表示查找点的语法，其中提问示例为“请找出的类型为person的点”，结果为“match(a:person) return a”。\n2. 第二行数据表示查找边的语法，提问示例为“返回图中所有的标签为knows的边”，结果为“match(a)-[e:knows]->(b) return e”。\n3. 第三行数据包含查找关系的语法，提问示例为“查询10个属于北京的大学，找出5个和小张老师有关系的学生”，结果为“match(a:city where a.name = '北京')<-[:belong]-(b:university) return b limit 10; match(a:teacher where a.name='小张')-[e]-(b:student) return b limit 5”。\n4. 第四行数据表示查找多度关系的语法，提问示例涉及查找小王的朋友及与大学相关的关系，结果为相应的查询语句。\n5. 第五行数据涵盖循环查询的语法，提问示例要求从张思琪出发通过支付关系查找相应的点，结果为“match(a:person where a.name='张思琪')-[e:pay]->{2,4}(b:person) return b”。\n6. 第六行数据处理环的查询，提问示例要求找到与李红有knows关系的3跳以内的环，结果为相关查询。\n7. 后续行数据均包含相应的提问示例和结果，逐条描述过滤条件、Let语句、函数调用、排序、分组、连接以及带图的schema查询等。\n\n总结：该表格通过多种语法和提问示例展示了图数据库中常见的查询方式，每一行数据均给出了相应的提问及其对应的查询结果。这些示例涵盖了基础的查找、过滤、分组、连接以及复杂的子查询等操作，帮助用户理解如何使用图数据库进行信息检索。\n\n该内容为《Text2GQL语法提示手册》中关于GQL常见语法和提问示例的详细说明，旨在帮助用户理解和运用图数据库查询语言，包括查找点、边、关系及更复杂的查询方法的实际例子。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_49.md",
        "chunks": [
            {
                "content": "# Union \n\n## Syntax\n\n```sql\nselect_statement\nUNION [ ALL ]\nselect_statement\n\n```\n## Example\n\n```sql\nSELECT * FROM (\n\tSELECT * FROM user WHERE id < 10\n\tUNION ALL\n\tSELECT * FROM user WHERE id > 15\n);\n\nSELECT * FROM (\n\tSELECT * FROM user WHERE id < 10\n\tUNION\n\tSELECT * FROM user WHERE id > 15\n);\n\nSELECT * FROM (\n\tSELECT * FROM user WHERE id % 3 = 0\n\tUNION ALL\n\tSELECT * FROM user WHERE id % 3 = 1\n\tUNION ALL\n\tSELECT * FROM user WHERE id % 3 = 2\n);\n\n```\n\n该文档主要介绍 SQL 中的 UNION 操作，包括其语法和多个示例，展示了如何使用 UNION 和 UNION ALL 进行查询结果的合并。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_50.md",
        "chunks": [
            {
                "content": "# 联系方式\n\n您有任何对产品的意见和建议，欢迎通过以下联系方式加入讨论，或提出建议。\n\n官网: https://tugraph.tech\n\nGithub Issue (错误反馈、功能讨论)\nhttps://github.com/TuGraph-db/tugraph-db/issues\n\nGithub Discussions (技术讨论)\nhttps://github.com/TuGraph-db/tugraph-db/discussions\n\nSlack (在线开发沟通):\nhttps://join.slack.com/t/tugraph/shared_invite/zt-1hha8nuli-bqdkwn~w4zH1vlk0QvqIfg\n\n通过钉钉群、微信群、微信公众号、邮箱和电话联系我们:\n\n微信公众号: TuGraph\n\n邮箱（商务沟通等其他问题）: tugraph@service.alipay.com\n\n电话：400-903-0809\n\n该文档提供了TuGraph产品的联系方式，包含官方网站、Github反馈渠道、Slack沟通链接以及其他交流方式，如微信公众号、邮箱和客服电话，以便用户提出意见和建议或进行技术讨论。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_51.md",
        "chunks": [
            {
                "content": "# 数据迁移\n\n## 1. 简介\n数据迁移是指将数据从一个系统、存储介质或应用程序迁移到另一个系统、存储介质或应用程序的过程。当TuGraph要升级或者系统硬件环境发生变化时，需要对原TuGraph服务中的数据进行迁移。以系统硬件环境和软件版本为依据进行划分，本文将数据迁移分为三种方案：\n1. 兼容迁移：当迁移前后系统环境一致且TuGraph软件兼容时，可以直接使用备份恢复的方式迁移数据；\n2. 升级迁移：当迁移前后系统环境不一致或TuGraph软件不兼容时，需要使用先导出数据再重新导入的方式迁移数据；\n3. 在线迁移：当对高可用集群进行数据迁移且集群网络环境良好时，可以使用增删节点的的方式将原集群平滑切换到新集群。\n接下来本文将详细介绍这三种方案。\n\n## 2. 兼容迁移\n兼容迁移指的是在系统环境不变，且TuGraph软件版本兼容时，原服务的数据和存储过程可以在新服务中使用，所以可以直接迁移。\n用户可以先使用`lgraph_backup`工具备份数据，然后将数据传输到新机器中并重启服务。具体迁移步骤如下：\n\n### 2.1. 备份数据\n使用`lgraph_backup`工具备份数据\n```bash\n  lgraph_backup -s db -d db.bck\n```\n本步骤也可以直接使用`cp`命令，不过`cp`命令会拷贝一些多余的元数据，HA模式下也会拷贝raft的元数据导致迁移之后集群重启失败，\n因此建议数据迁移时使用`lgraph_backup`工具替代`cp`命令。\n\n### 2.2. 启动新服务\n使用如下命令启动新服务，存储过程会自动加载到新服务中\n```bash\n  lgraph_server -c /usr/local/etc/lgraph.json --directory db.bck -d start\n```\n\n### 2.3. 停止原服务\n使用如下命令停止原服务\n```bash\n  lgraph_server -c /usr/local/etc/lgraph.json --directory db.bck -d stop\n```\n\n该文档主要介绍TuGraph的数据迁移过程，包括兼容迁移、升级迁移和在线迁移三种方案。此处的内容为“兼容迁移”部分，详细说明了在系统环境和软件版本一致的情况下，如何使用`lgraph_backup`工具备份数据、启动新服务和停止原服务的具体步骤。"
            },
            {
                "content": "### 2.1. 备份数据\n使用`lgraph_backup`工具备份数据\n```bash\n  lgraph_backup -s db -d db.bck\n```\n本步骤也可以直接使用`cp`命令，不过`cp`命令会拷贝一些多余的元数据，HA模式下也会拷贝raft的元数据导致迁移之后集群重启失败，\n因此建议数据迁移时使用`lgraph_backup`工具替代`cp`命令。\n\n### 2.2. 启动新服务\n使用如下命令启动新服务，存储过程会自动加载到新服务中\n```bash\n  lgraph_server -c /usr/local/etc/lgraph.json --directory db.bck -d start\n```\n\n### 2.3. 停止原服务\n使用如下命令停止原服务\n```bash\n  lgraph_server -c /usr/local/etc/lgraph.json --directory db.bck -d stop\n```\n\n## 3. 升级迁移\n当用户要把原始服务迁移到一个差异化环境中（比如从centos7迁移到ubuntu18.04），或者TuGraph版本变化较大前后不兼容时（如3.4.0和3.6.0），\n用户可以先使用`lgraph_export`工具将数据导出成文件，传输到新机器中，再使用`lgraph_import`工具重新导入并重启集群。\n这样可以保证在新环境上能够使用，但是效率较低，存储过程也需要重新加载。具体的迁移步骤如下：\n\n### 3.1. 导出数据\n使用`lgraph_export`工具导出数据，并将数据传输到新机器上\n```bash\n  lgraph_export -d db -e db.export\n```\n\n### 3.2. 导入数据\n使用`lgraph_import`工具导入数据，并手动加载存储过程。\n```bash\n  lgraph_import -c db.export/import.config -d db\n```\n\n### 3.3. 启动新服务\n使用如下命令启动新服务\n```bash\n   lgraph_server -c /usr/local/etc/lgraph.json --directory db.export -d start\n```\n\n该块内容主要讲述了数据迁移过程中的\"兼容迁移\"部分，具体包括如何备份数据、启动新服务和停止原服务的具体步骤。此外，紧接着该块内容的是关于\"升级迁移\"的介绍，涉及在不同环境中迁移数据的流程和命令。"
            },
            {
                "content": "### 3.1. 导出数据\n使用`lgraph_export`工具导出数据，并将数据传输到新机器上\n```bash\n  lgraph_export -d db -e db.export\n```\n\n### 3.2. 导入数据\n使用`lgraph_import`工具导入数据，并手动加载存储过程。\n```bash\n  lgraph_import -c db.export/import.config -d db\n```\n\n### 3.3. 启动新服务\n使用如下命令启动新服务\n```bash\n   lgraph_server -c /usr/local/etc/lgraph.json --directory db.export -d start\n```\n\n### 3.4. 停止原服务\n使用如下命令停止原服务\n```bash\n   lgraph_server -c /usr/local/etc/lgraph.json --directory db.export -d stop\n```\n\n## 4. 在线迁移\n当对TuGraph高可用版本部署的服务器集群进行数据迁移时，如果网络带宽充足，可以直接使用增删节点的方式对服务进行在线迁移。具体迁移步骤如下所示：\n\n本文档介绍了TuGraph的数据迁移过程，包含三种主要迁移方案：兼容迁移、升级迁移和在线迁移。本段落位于升级迁移部分，具体描述了如何使用`lgraph_export`和`lgraph_import`工具导出和导入数据，以及在新环境中启动和停止服务的步骤。"
            },
            {
                "content": "### 3.2. 导入数据\n使用`lgraph_import`工具导入数据，并手动加载存储过程。\n```bash\n  lgraph_import -c db.export/import.config -d db\n```\n\n### 3.3. 启动新服务\n使用如下命令启动新服务\n```bash\n   lgraph_server -c /usr/local/etc/lgraph.json --directory db.export -d start\n```\n\n### 3.4. 停止原服务\n使用如下命令停止原服务\n```bash\n   lgraph_server -c /usr/local/etc/lgraph.json --directory db.export -d stop\n```\n\n## 4. 在线迁移\n当对TuGraph高可用版本部署的服务器集群进行数据迁移时，如果网络带宽充足，可以直接使用增删节点的方式对服务进行在线迁移。具体迁移步骤如下所示：\n\n### 4.1. 拷贝数据\n使用如下命令拷贝leader节点上的数据，并且传输到新集群的机器节点上。由于leader节点上有最完整的raft日志，拷贝leader的数据可以最大程度地减少\n日志追赶的时间。\n```bash\n  cp -r db db.cp\n```\n### 4.2. 启动新节点\n使用如下命令将新节点加入集群，加入集群后，增量数据自动同步到新节点\n```bash\n  lgraph_server -c /usr/local/etc/lgraph_ha.json --directory db.cp --ha_conf 192.168.0.1:9090,192.168.0.2:9090,192.168.0.3:9090 -d start\n```\n### 4.3. 停止原节点\n停止原节点服务，后续应用请求直接发给新集群\n```bash\n  lgraph_server -c /usr/local/etc/lgraph_ha.json --directory db.cp --ha_conf 192.168.0.1:9090,192.168.0.2:9090,192.168.0.3:9090 -d stop\n```\n\n该块内容位于\"升级迁移\"部分，详细描述了使用`lgraph_import`工具导入数据及启动和停止新旧服务的具体步骤，属于数据迁移方案的第二种情况。紧接着是关于\"在线迁移\"的介绍，分为拷贝数据、启动新节点和停止原节点的步骤。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_52.md",
        "chunks": [
            {
                "content": "# UDAF介绍\nUDAF（User Define Aggregate Function）将多行数据聚合为单个值。\n## 接口\n\n```java\npublic abstract class UserDefinedFunction implements Serializable {\n\n   /**\n     * Init method for the user defined function.\n     */\n    public void open(FunctionContext context) {\n    }\n\n    /**\n     * Close method for the user defined function.\n     */\n    public void close() {\n    }\n}\n\npublic abstract class UDAF extends UserDefinedFunction {\n\n    /**\n     * Create aggregate accumulator for aggregate function to store the aggregate value.\n     */\n    public abstract AccumT createAccumulator();\n\n    /**\n     * Accumulate the input to the accumulator.\n     */\n    public abstract void accumulate(AccumT accumulator, InputT input);\n\n    /**\n     * Merge the accumulator iterator to the accumulator.\n     * @param accumulator The accumulator to merged to.\n     * @param its The accumulator iterators to merge from.\n     */\n    public abstract void merge(AccumT accumulator, Iterable its);\n\n该文档介绍了用户定义聚合函数（UDAF）的概念和接口，包括其基本结构、方法以及示例实现，如计算平均值的自定义聚合函数。上述代码片段具体描述了用户定义函数和UDAF的抽象类及其相关方法。"
            },
            {
                "content": "/**\n     * Accumulate the input to the accumulator.\n     */\n    public abstract void accumulate(AccumT accumulator, InputT input);\n\n    /**\n     * Merge the accumulator iterator to the accumulator.\n     * @param accumulator The accumulator to merged to.\n     * @param its The accumulator iterators to merge from.\n     */\n    public abstract void merge(AccumT accumulator, Iterable its);\n\n    /**\n     * Reset the accumulator to init value.\n     */\n    public abstract void resetAccumulator(AccumT accumulator);\n\n    /**\n     * Get aggregate function result from the accumulator.\n     */\n    public abstract OutputT getValue(AccumT accumulator);\n\n}\n\n```\n\n## 示例\n\n```java\npublic class AvgDouble extends UDAF {\n\n    @Override\n    public Accumulator createAccumulator() {\n        return new Accumulator();\n    }\n\n    @Override\n    public void accumulate(Accumulator accumulator, Double input) {\n        if (null != input) {\n            accumulator.sum += input;\n            accumulator.count ++;\n        }\n    }\n\n该代码块包含了UDAF（用户定义聚合函数）类中的四个抽象方法：`accumulate`、`merge`、`resetAccumulator`和`getValue`，用于定义如何累加数据、合并累加器、重置累加器及获取聚合结果。这些方法是实现自定义聚合功能的核心，后续示例类`AvgDouble`则基于这些方法实现了计算平均值的功能。"
            },
            {
                "content": "/**\n     * Get aggregate function result from the accumulator.\n     */\n    public abstract OutputT getValue(AccumT accumulator);\n\n}\n\n```\n\n## 示例\n\n```java\npublic class AvgDouble extends UDAF {\n\n    @Override\n    public Accumulator createAccumulator() {\n        return new Accumulator();\n    }\n\n    @Override\n    public void accumulate(Accumulator accumulator, Double input) {\n        if (null != input) {\n            accumulator.sum += input;\n            accumulator.count ++;\n        }\n    }\n\n    @Override\n    public void merge(Accumulator merged, Iterable accumulators) {\n        for (Accumulator accumulator : accumulators) {\n            merged.sum += accumulator.sum;\n            merged.count += accumulator.count;\n        }\n    }\n\n    @Override\n    public void resetAccumulator(Accumulator accumulator) {\n        accumulator.sum = 0.0;\n        accumulator.count = 0L;\n    }\n\n该代码块位于UDAF（用户定义聚合函数）类的定义部分，具体是在`getValue`方法的描述与实现的前后。它涉及如何从累加器中获取聚合函数的结果，并在示例中实现了一个计算平均值的聚合函数`AvgDouble`。"
            },
            {
                "content": "@Override\n    public void merge(Accumulator merged, Iterable accumulators) {\n        for (Accumulator accumulator : accumulators) {\n            merged.sum += accumulator.sum;\n            merged.count += accumulator.count;\n        }\n    }\n\n    @Override\n    public void resetAccumulator(Accumulator accumulator) {\n        accumulator.sum = 0.0;\n        accumulator.count = 0L;\n    }\n\n    @Override\n    public Double getValue(Accumulator accumulator) {\n        return accumulator.count == 0 ? null : \n\t\t\t(accumulator.sum / (double) accumulator.count);\n    }\n\n    public static class Accumulator implements Serializable {\n        public double sum = 0.0;\n        public long count = 0;\n    }\n}\n```\n\n```sql\nCREATE Function my_avg AS 'com.antgroup.geaflow.dsl.udf.table.agg.AvgDouble';\n\nSELECT my_avg(age) from user;\n```\n\n该代码块位于UDAF示例中，具体实现了合并累加器、重置累加器和获取最终结果的方法，以及定义了累加器的内部类。相关的SQL示例展示了如何注册和使用自定义聚合函数my_avg，该函数计算年龄的平均值。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_53.md",
        "chunks": [
            {
                "content": "# 为什么使用图进行关联运算比表Join更具吸引力？\n\n## 关系模型并不适合处理关系\n\n关系模型被广泛应用于数据库和数仓等数据处理系统的数据建模，**然而名称里带有关系一词的模型却并不适合处理关系**。\n\n在关系模型所用的表结构建模下，关系的运算通过Join运算来处理。但在实际使用中，特别是在流式更新的数据中，这种方式存在诸多痛点。\n\n### 痛点一：关系运算成本高\n\n表模型的重点在于多条记录统一描述为表，但本身缺乏关系描述能力，**只能通过Join运算来完成关系的计算**。\n\n无论是在批或流的计算系统中，Join操作都涉及大量shuffle和计算开销。同时，Join产生的中间结果由于关联会放大多份，造成数据量指数级膨胀和冗余，存储消耗大。\n\n在下图的实验中，我们模拟了依次执行一跳、两跳和三跳关系运算的场景。足以见得，越是复杂的多跳关系计算，关系模型中Join的性能表现越差。在总时间对比中，利用图的Match计算能够节约超过90%的耗时。\n![total_time](../../../static/img/vs_join_total_time_cn.jpg)\n图1\n\n### 痛点二：数据冗余，时效性低\n\n在很多数仓分析的场景中，为了提高数据查询性能，往往将多张表提前物化成一张大宽表。\n\n大宽表虽然可以加速查询性能，然而其数据膨胀和冗余非常严重。由于表与表之间一对多的关联关系，导致一张表的数据通过关联会放大多份，造成数据量指数级膨胀和冗余。\n\n而且宽表一经生成就难以更改，否则需要重新生成新宽表，费时费力，不够灵活。\n\n此时利用图模型建模，可以轻易解决这个问题。 图是对关系的一种天然描述，以点代表实体，以边代表关系。\n\n比如在人际关系图里面，每一个人可以用一个点来表示，人和人之间的关系通过边来表示，人与人之间可以存在各种各样的复杂关系，这些关系都可以通过不同的边来表示。\n\n显然，**构造图的过程本质上是对事物之间关系的提炼，在数据存储层面实质是对关系做了物化，以获取更好的关联计算性能**。\n\n相比宽表的关系物化方式，由于图结构本身的点边聚合性，构图表现得十分节约。 下图是GeaFlow中高性能构图的表现，可见构图操作本身极为迅速，且由于图可以分片的特性，具有十分良好的可扩展性。\n\n![insert_throuput](../../../static/img/insert_throuput_cn.jpg)\n图2\n\n该部分内容探讨了为何图模型在处理关联运算时比传统的关系模型（表Join）更具优势。通过分析关系模型的痛点，如高成本的关系运算、数据冗余以及复杂关系查询的困难，指出图模型在描述和处理关系方面的自然优势，以及其在实际应用中的效率提升。"
            },
            {
                "content": "在很多数仓分析的场景中，为了提高数据查询性能，往往将多张表提前物化成一张大宽表。\n\n大宽表虽然可以加速查询性能，然而其数据膨胀和冗余非常严重。由于表与表之间一对多的关联关系，导致一张表的数据通过关联会放大多份，造成数据量指数级膨胀和冗余。\n\n而且宽表一经生成就难以更改，否则需要重新生成新宽表，费时费力，不够灵活。\n\n此时利用图模型建模，可以轻易解决这个问题。 图是对关系的一种天然描述，以点代表实体，以边代表关系。\n\n比如在人际关系图里面，每一个人可以用一个点来表示，人和人之间的关系通过边来表示，人与人之间可以存在各种各样的复杂关系，这些关系都可以通过不同的边来表示。\n\n显然，**构造图的过程本质上是对事物之间关系的提炼，在数据存储层面实质是对关系做了物化，以获取更好的关联计算性能**。\n\n相比宽表的关系物化方式，由于图结构本身的点边聚合性，构图表现得十分节约。 下图是GeaFlow中高性能构图的表现，可见构图操作本身极为迅速，且由于图可以分片的特性，具有十分良好的可扩展性。\n\n![insert_throuput](../../../static/img/insert_throuput_cn.jpg)\n图2\n\n在图一的实验中也可以发现，实质上我们用少量的插入图(青色的insert to graph部分开销)耗时，换取了图建模方式对之后关联查询的加速效果。\n\n\n### 痛点三：复杂关系查询难以描述\n\n使用表建模的分析系统只支持SQL join一种方式进行关系分析，这在复杂场景中能力十分局限。 比如查询一个人4度以内所有好友，或者查询最短路径等，这些复杂关联关系通过SQL表的join方式很难描述。\n\nGeaFlow提供融合GQL和SQL样式的查询语言，这是一种图表一体的数据分析语言，继承自标准SQL+ISO/GQL，可以方便进行图表分析。\n\n![code_style](../../../static/img/code_style.jpg)\n图3\n\n**在融合DSL中，图计算的结果与表查询等价，都可以像表数据一样做关系运算处理。**这意味着图3中GQL和SQL两种描述都可以达到类似的效果，极大灵活了用户的查询表达能力。\n\nGeaFlow DSL引擎层还将支持SQL中的Join自动转化为GQL执行，用户可以自由混用SQL和GQL样式查询，同时做图匹配、图算法和表查询。\n\n该段落位于讨论图模型相较于关系模型在数据查询中的优势的文档中，具体阐述了在数仓分析场景中使用宽表导致的数据膨胀和冗余问题，同时指出图模型通过点和边的方式提供了更有效的关系描述解决方案，并强调了构造图的高效性和可扩展性。"
            },
            {
                "content": "在图一的实验中也可以发现，实质上我们用少量的插入图(青色的insert to graph部分开销)耗时，换取了图建模方式对之后关联查询的加速效果。\n\n\n### 痛点三：复杂关系查询难以描述\n\n使用表建模的分析系统只支持SQL join一种方式进行关系分析，这在复杂场景中能力十分局限。 比如查询一个人4度以内所有好友，或者查询最短路径等，这些复杂关联关系通过SQL表的join方式很难描述。\n\nGeaFlow提供融合GQL和SQL样式的查询语言，这是一种图表一体的数据分析语言，继承自标准SQL+ISO/GQL，可以方便进行图表分析。\n\n![code_style](../../../static/img/code_style.jpg)\n图3\n\n**在融合DSL中，图计算的结果与表查询等价，都可以像表数据一样做关系运算处理。**这意味着图3中GQL和SQL两种描述都可以达到类似的效果，极大灵活了用户的查询表达能力。\n\nGeaFlow DSL引擎层还将支持SQL中的Join自动转化为GQL执行，用户可以自由混用SQL和GQL样式查询，同时做图匹配、图算法和表查询。\n\n## 流图计算引擎TuGraph-Analytics\n\nGeaFlow(品牌名TuGraph-Analytics)是蚂蚁集团开源的分布式流式图计算引擎。在蚂蚁内部，目前已广泛应用于数仓加速、金融风控、知识图谱以及社交网络等大量场景。\n\nTuGraph-Analytics已经于2023年6月正式对外开源，开放其以图为数据模型的流批一体计算核心能力。相比传统的流式计算引擎，如Flink、Storm这些以表为模型的实时处理系统，GeaFlow以自研图存储为底座，流批一体计算引擎为矛，融合GQL/SQL DSL语言为旗帜，在复杂多度的关系运算上具备极大的优势。\n\n\n![insert_throuput](../../../static/img/query_throuput_cn.jpg)\n图4\n\n图4展示了GeaFlow使用Match算子在图上进行多跳关联查询，相比Flink的Join算子带来的实时吞吐提升。在复杂多跳场景下，现有的流式计算引擎已经基本不能胜任实时处理。而图模型的存在，则突破这一限制，扩展了实时流计算的应用场景。\n\n该段落主要讨论了表建模在复杂关系查询中的局限性，强调了GeaFlow通过融合GQL和SQL的查询语言，提高用户在复杂关系分析中的表达能力和灵活性。此外，文中还介绍了TuGraph-Analytics作为一个分布式流式图计算引擎的优势，包括其在多跳关联查询中的实时吞吐提升。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_54.md",
        "chunks": [
            {
                "content": "# RESTful API Legacy\n\n> 此文档主要介绍 TuGrpah 的 Rest API 的调用详情。\n\n## 1.简介\n\nTuGraph 提供遵从 REST 规范的 HTTP API，以供开发者通过 HTTP 请求远程调用 TuGraph 提供的服务。\n\n本文档描述 TuGraph 的 HTTP API 使用方式。\n\n**注意：除\"登陆\"、\"查询\"和\"存储过程\"外，其余接口自 **2023年4月30日** 起将不再提供支持，统一使用Cypher接口提供服务。**\n\n## 2.请求与数据格式\n\n### 2.1请求\n\nTuGraph 支持 HTTP GET/POST/PUT/DELETE 请求。其中：\n\n- GET 请求用于只读请求，如读取点属性，边属性等操作；\n- POST 请求用于创建实体，提交 Cypher，以及加载和调用存储过程；\n- PUT 请求用于修改已有实体，如修改点属性，边属性等；\n- DELETE 请求用于删除已有实体，如删除点，边等。\n\n在高可用模式下，用户可以在请求的报头(request header)中设置 `server_version` 来保证请求的服务器有足够新的数据。\n当前的 `server_version` 可以从服务器返回的报头中获取。\n\n### 2.2.数据格式\n\n客户端与服务端数据交互的格式是 JSON。在发送请求时，请将发送数据的请求的报头设置为 `Accept:application/json, Content-Type:application/json`。\n例如在创建一个点时，请求报头包含以下内容：\n\n```\n    Accept: application/json; charset=UTF-8\n    Content-Type: application/json\n    server_version: 12\n```\n\n### 2.3.返回值\n\nTuGraph 返回的 HTTP 状态码包含以下四种：\n\n- 200 OK: 操作成功\n- 307 Temporary Redirect: 操作被重定向，一般用于高可用模式下，把操作重定向到 master 上\n- 400 Bad Request: 输入有误，例如 URI 错误，或者请求中的 JSON 参数错误\n- 500 Internal Server Error: 服务器端错误\n\n该段落介绍了 TuGraph 的 RESTful API 的基本信息，包括 API 的请求类型、数据格式、返回值及其意义，尤其强调了自2023年4月30日起部分接口的支持变更。这部分内容为用户理解如何使用 TuGraph 的 HTTP API 提供了重要基础。"
            },
            {
                "content": "### 2.2.数据格式\n\n客户端与服务端数据交互的格式是 JSON。在发送请求时，请将发送数据的请求的报头设置为 `Accept:application/json, Content-Type:application/json`。\n例如在创建一个点时，请求报头包含以下内容：\n\n```\n    Accept: application/json; charset=UTF-8\n    Content-Type: application/json\n    server_version: 12\n```\n\n### 2.3.返回值\n\nTuGraph 返回的 HTTP 状态码包含以下四种：\n\n- 200 OK: 操作成功\n- 307 Temporary Redirect: 操作被重定向，一般用于高可用模式下，把操作重定向到 master 上\n- 400 Bad Request: 输入有误，例如 URI 错误，或者请求中的 JSON 参数错误\n- 500 Internal Server Error: 服务器端错误\n\n当操作成功时，返回的 JSON 中包含操作的返回值。当操作重定向时，返回的 HTTP 报头中的 `location` 域包含重定向目的地址。\n当发生输入错误或者服务器错误时，返回的 JSON 中包含 `error_message` 域，其内容是错误提示。\n\n在高可用模式下，服务器还会在报头中设置 `server_version`，以告知客户端当前服务器的数据版本号。当客户端在不同的服务器之间切换时，该数据版本号可以保证客户端不会读到错误的历史数据。\n\n### 2.4.URI格式\n\nTuGraph REST API 提供以下功能：Service Root, login, info, label, index, node, relationship, cypher, cpp_plugin, 以及 python_plugin。\n各功能使用的 URI 格式如下：\n\n该块内容位于文档的第二部分，详细描述了TuGraph REST API的数据格式和返回值规范，包括客户端与服务端的JSON交互格式、HTTP状态码、以及URI格式的说明，这是用户在使用API时必须遵循的基本规则和标准。"
            },
            {
                "content": "当操作成功时，返回的 JSON 中包含操作的返回值。当操作重定向时，返回的 HTTP 报头中的 `location` 域包含重定向目的地址。\n当发生输入错误或者服务器错误时，返回的 JSON 中包含 `error_message` 域，其内容是错误提示。\n\n在高可用模式下，服务器还会在报头中设置 `server_version`，以告知客户端当前服务器的数据版本号。当客户端在不同的服务器之间切换时，该数据版本号可以保证客户端不会读到错误的历史数据。\n\n### 2.4.URI格式\n\nTuGraph REST API 提供以下功能：Service Root, login, info, label, index, node, relationship, cypher, cpp_plugin, 以及 python_plugin。\n各功能使用的 URI 格式如下：\n\n| URI     | 说明                 |\n| ------- | -------------------- |\n| /web    | web 可视化界面       |\n| /cypher | cypher 请求          |\n| /acl    | 权限控制             |\n| /user   | 用户管理             |\n| /login  | 用户登录             |\n| /info   | 数据库状态及提示信息 |\n| /task   | 任务管理             |\n| /db     | 子图操作             |\n表格内容描述:\n该表格包含两列，分别为“URI”和“说明”。\n\n该块文字位于文档的第二部分中，主要描述了TuGraph REST API的返回值格式及相关状态码，并介绍了API的URI格式，涵盖了系统中各个功能模块的URI及其对应说明。"
            },
            {
                "content": "### 2.4.URI格式\n\nTuGraph REST API 提供以下功能：Service Root, login, info, label, index, node, relationship, cypher, cpp_plugin, 以及 python_plugin。\n各功能使用的 URI 格式如下：\n\n| URI     | 说明                 |\n| ------- | -------------------- |\n| /web    | web 可视化界面       |\n| /cypher | cypher 请求          |\n| /acl    | 权限控制             |\n| /user   | 用户管理             |\n| /login  | 用户登录             |\n| /info   | 数据库状态及提示信息 |\n| /task   | 任务管理             |\n| /db     | 子图操作             |\n表格内容描述:\n该表格包含两列，分别为“URI”和“说明”。\n\n逐行描述表格中的数据内容：\n1. URI \"/web\" 的说明为 \"web 可视化界面\"，用于展示网站的可视化内容。\n2. URI \"/cypher\" 的说明为 \"cypher 请求\"，指用于发送 cypher 查询的接口。\n3. URI \"/acl\" 的说明为 \"权限控制\"，涉及对系统权限进行管理和控制的功能。\n4. URI \"/user\" 的说明为 \"用户管理\"，用于处理与用户相关的各种操作。\n5. URI \"/login\" 的说明为 \"用户登录\"，是用户进入系统的登录界面。\n6. URI \"/info\" 的说明为 \"数据库状态及提示信息\"，用于显示数据库的当前状态和相关提示信息。\n7. URI \"/task\" 的说明为 \"任务管理\"，涉及任务的创建、查看和管理功能。\n8. URI \"/db\" 的说明为 \"子图操作\"，用于对数据子图进行相关操作。\n\n概要总结：\n该表格汇总了系统中各个功能模块的URI及其对应的说明，涵盖了可视化界面、查询请求、权限控制、用户管理、登录功能、数据库状态提示、任务管理以及子图操作，为用户理解系统功能提供了清晰的指引。\n\n其中子图操作又分为：\n\n该内容位于文档的第二部分，主要介绍了 TuGraph REST API 的 URI 格式及其对应功能。这一小节详细列出了各个功能模块的 URI 及其说明，为用户提供清晰的接口调用指引。"
            },
            {
                "content": "概要总结：\n该表格汇总了系统中各个功能模块的URI及其对应的说明，涵盖了可视化界面、查询请求、权限控制、用户管理、登录功能、数据库状态提示、任务管理以及子图操作，为用户理解系统功能提供了清晰的指引。\n\n其中子图操作又分为：\n\n| URI                              | 说明                 |\n| -------------------------------- | -------------------- |\n| /db                              | 子图的创建，删除     |\n| /db/_{graph_name}_/node          | 点操作             |\n| /db/_{graph_name}_/relationship  | 边操作               |\n| /db/_{graph_name}_/label         | Label 相关操作       |\n| /db/_{graph_name}_/index         | 索引相关操作         |\n| /db/_{graph_name}_/cypher        | 子图相关 cypher 操作 |\n| /db/_{graph_name}_/cpp_plugin    | C++存储过程          |\n| /db/_{graph_name}_/python_plugin | Python 存储过程      |\n| /db/_{graph_name}_/import        | 在线导入             |\n| /db/_{graph_name}_/misc          | 其它操作             |\n表格内容描述：\n\n该表格包含两列，分别为“URI”和“说明”。\n\n该段落位于文档的第二部分，主要介绍了 TuGraph REST API 的各个功能模块及其对应的 URI 和说明，旨在帮助用户快速理解和定位系统中不同操作的接口。"
            },
            {
                "content": "该表格包含两列，分别为“URI”和“说明”。 \n\n每一行的数据内容如下：\n1. \"/db\" - 该URI用于图的创建和删除操作。\n2. \"/db/_{graph_name}_/node\" - 该URI用于执行与节点相关的操作。\n3. \"/db/_{graph_name}_/relationship\" - 该URI用于处理边的相关操作。\n4. \"/db/_{graph_name}_/label\" - 该URI用于与标签相关的操作。\n5. \"/db/_{graph_name}_/index\" - 该URI用于执行索引的相关操作。\n6. \"/db/_{graph_name}_/cypher\" - 该URI用于进行子图相关的Cypher操作。\n7. \"/db/_{graph_name}_/cpp_plugin\" - 该URI用于调用C++存储过程。\n8. \"/db/_{graph_name}_/python_plugin\" - 该URI用于调用Python存储过程。\n9. \"/db/_{graph_name}_/import\" - 该URI用于在线导入操作。\n10. \"/db/_{graph_name}_/misc\" - 该URI用于其它操作。\n\n总体而言，该表格概述了与图数据库相关的不同操作及其对应的URI，涵盖创建、删除、节点和边操作、标签与索引管理、Cypher查询、存储过程调用及数据导入等多种功能。\n\n## 3.登录\n\nTuGraph 提供基于 JWT 的用户认证方式，可以使用 HTTP 或 HTTPS 协议进行传输。系统默认使用 HTTP 协议，如果需要使用 HTTPS，需要在 lgraph.json 配置文件中将 ssl_auth 设为 1。\n\n### 3.1.登录\n\n用户通过用户名和密码发送登录请求。登录成功会收到带有签名的令牌(Json Web Token)和判断是否为默认密码的布尔型变量，客户端储存该令牌，并且用于以后的每次发送请求。如果登录失败会收到“Authentication failed”错误。\n\n- **URI**: `/login`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | user | 用户名 | 字符串 |\n  | password | 密码 | 字符串 |\n\n该块内容位于文档的第二部分，描述了与图数据库相关的不同操作及其对应的URI，特别是子图操作的URI以及其功能摘要，接着文档将进入用户登录的相关信息和接口说明。"
            },
            {
                "content": "总体而言，该表格概述了与图数据库相关的不同操作及其对应的URI，涵盖创建、删除、节点和边操作、标签与索引管理、Cypher查询、存储过程调用及数据导入等多种功能。\n\n## 3.登录\n\nTuGraph 提供基于 JWT 的用户认证方式，可以使用 HTTP 或 HTTPS 协议进行传输。系统默认使用 HTTP 协议，如果需要使用 HTTPS，需要在 lgraph.json 配置文件中将 ssl_auth 设为 1。\n\n### 3.1.登录\n\n用户通过用户名和密码发送登录请求。登录成功会收到带有签名的令牌(Json Web Token)和判断是否为默认密码的布尔型变量，客户端储存该令牌，并且用于以后的每次发送请求。如果登录失败会收到“Authentication failed”错误。\n\n- **URI**: `/login`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | user | 用户名 | 字符串 |\n  | password | 密码 | 字符串 |\n\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | jwt | 令牌 | 字符串 |\n  | default_password | 是否为默认密码 | 布尔值 |\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/login\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n      \"user\":\"admin\",\n      \"password\":\"73@TuGraph\"\n    }\n```\n\n**Example response.**\n\n该段落位于文档的第三部分，主要介绍用户登录功能及其实现方式，包括使用 JWT 进行用户认证的详细说明、登录请求和响应格式，以及成功和失败的示例。这一部分紧接在对图数据库相关操作和URI概述之后，为读者提供了关于如何进行用户身份验证和访问控制的具体信息。"
            },
            {
                "content": "- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | jwt | 令牌 | 字符串 |\n  | default_password | 是否为默认密码 | 布尔值 |\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/login\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n      \"user\":\"admin\",\n      \"password\":\"73@TuGraph\"\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        \"jwt\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\",\n        \"default_password\": true\n    }\n```\n\n### 3.2.身份刷新\nToken失效后，前端发起刷新token接口，后端验证token合法性。初次登录后，1小时内有效，需刷新使用。即使刷新，24小时后也会强制退出，需要重新登陆。\n验证通过，生成新的token；验证失败返回状态码401。\n\n- **URI**: `/refresh`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | Authorization | 令牌 | 字符串 |\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | jwt | 令牌 | 字符串 |\n\n\n**Example request.**\n\n该块内容位于文档的第三部分“登录”中，具体描述了用户登录请求的响应格式，以及登录成功后的返回值，包括JWT令牌和是否为默认密码的标识。此外，还介绍了身份刷新接口的URI、请求方式以及请求和响应的格式。"
            },
            {
                "content": "### 3.2.身份刷新\nToken失效后，前端发起刷新token接口，后端验证token合法性。初次登录后，1小时内有效，需刷新使用。即使刷新，24小时后也会强制退出，需要重新登陆。\n验证通过，生成新的token；验证失败返回状态码401。\n\n- **URI**: `/refresh`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | Authorization | 令牌 | 字符串 |\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | jwt | 令牌 | 字符串 |\n\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/refresh\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n        \"Authorization\": \"Bearer eyJhbGciOiJIUz32NiIsInR5cCI6IkpXVDJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byj3fYVAH4D88dfTD_zYQ_uAvdizTMek\"\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        \"jwt\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\"\n    }\n```\n\n该块内容位于文档的第三部分，讲述关于用户认证的身份刷新机制，具体介绍了刷新令牌的请求URI、请求方法、请求和响应的数据格式及示例。此部分是关于如何在令牌失效后续用新令牌进行身份验证的重要机制。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        \"jwt\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\"\n    }\n```\n\n### 3.3.修改Token有效期\n修改Token有效期，需要传输jwt，refresh_time和expire_time三个参数，其中jwt用于校验用户身份，refresh_time和expire_time等于0时，有效期为无期限，超过refresh_time时，需要调用refresh接口获取新的Token;超过expire_time时，需要重新登录。\n\n- **URI**: `/update_token_time`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | Authorization | 令牌 | 字符串 |\n  | refresh_time | 有效时间（默认设置为0） | Int64 |\n  | expire_time | 有效时间（默认设置为0） | Int64 |\n\n- **RESPONSE**:  如果成功，返回代码 200。\n\n**Example request.**\n\n此片段来自于文档的第3节“登录”中的“修改Token有效期”部分，详细说明了如何修改JWT令牌的有效期，包括请求的URI、方法、请求和响应的格式示例。"
            },
            {
                "content": "### 3.3.修改Token有效期\n修改Token有效期，需要传输jwt，refresh_time和expire_time三个参数，其中jwt用于校验用户身份，refresh_time和expire_time等于0时，有效期为无期限，超过refresh_time时，需要调用refresh接口获取新的Token;超过expire_time时，需要重新登录。\n\n- **URI**: `/update_token_time`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | Authorization | 令牌 | 字符串 |\n  | refresh_time | 有效时间（默认设置为0） | Int64 |\n  | expire_time | 有效时间（默认设置为0） | Int64 |\n\n- **RESPONSE**:  如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/update_token_time\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n        \"Authorization\" : \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJmbWEuYWkiLCJwYXNzd29yZCI6IjczQFR1R3JhcGgiLCJ1c2VyIjoiYWRtaW4ifQ.o_yb5veSJkuy-ieBp4MqTk-tC1grcKotgVbgNJ0TyTU\",\n        \"refresh_time\":0,\n        \"expire_time\":0\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n该段落位于文档的第三部分，专门介绍如何修改Token的有效期。它详细说明了调用URI、请求和响应的格式，以及相关示例，旨在帮助用户操作和管理JWT令牌的有效时间设置。"
            },
            {
                "content": "**Example request.**\n\n```\n    • POST http://localhost:7070/update_token_time\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n        \"Authorization\" : \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJmbWEuYWkiLCJwYXNzd29yZCI6IjczQFR1R3JhcGgiLCJ1c2VyIjoiYWRtaW4ifQ.o_yb5veSJkuy-ieBp4MqTk-tC1grcKotgVbgNJ0TyTU\",\n        \"refresh_time\":0,\n        \"expire_time\":0\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n### 3.4.查询Token有效期\n查询Token有效期，需要传输jwt，用于校验用户身份，返回，refresh_time和expire_time，其中refresh_time表示刷新时间，超过时需要调用refresh接口获取新的Token;expire_time表示过期时间，超过时需要重新登录。\n- **URI**: `/get_token_time`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | Authorization | 令牌 | 字符串 |\n\n- **RESPONSE**:  如果成功，返回\"refresh_time\"和\"expire_time\"。\n\n**Example request.**\n\n该片段位于文档的第3部分，涉及Token的管理，具体为修改Token有效期和查询Token有效期的示例请求与响应。这部分内容提供了关于如何通过RESTful API接口与TuGraph进行用户认证及Token管理的详细示例。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n### 3.4.查询Token有效期\n查询Token有效期，需要传输jwt，用于校验用户身份，返回，refresh_time和expire_time，其中refresh_time表示刷新时间，超过时需要调用refresh接口获取新的Token;expire_time表示过期时间，超过时需要重新登录。\n- **URI**: `/get_token_time`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | Authorization | 令牌 | 字符串 |\n\n- **RESPONSE**:  如果成功，返回\"refresh_time\"和\"expire_time\"。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/get_token_time\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n        \"Authorization\" : \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJmbWEuYWkiLCJwYXNzd29yZCI6IjczQFR1R3JhcGgiLCJ1c2VyIjoiYWRtaW4ifQ.o_yb5veSJkuy-ieBp4MqTk-tC1grcKotgVbgNJ0TyTU\",\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        \"refresh_time\":600,\n        \"expire_time\":3600\n    }\n```\n\n### 3.5.登出\n用户登出，同时删除token。\n\n该片段位于文档的\"登录\"部分，具体介绍了查询Token有效期的接口和请求响应示例，包括如何验证用户身份，获取Token的刷新和过期时间。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        \"refresh_time\":600,\n        \"expire_time\":3600\n    }\n```\n\n### 3.5.登出\n用户登出，同时删除token。\n\n- **URI**: `/logout`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | Authorization | 令牌 | 字符串 |\n- **RESPONSE**:  如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/logout\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n        \"Authorization\" : \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJmbWEuYWkiLCJwYXNzd29yZCI6IjczQFR1R3JhcGgiLCJ1c2VyIjoiYWRtaW4ifQ.o_yb5veSJkuy-ieBp4MqTk-tC1grcKotgVbgNJ0TyTU\"\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n## 4.查询\n\nURI 格式为\n\n```\n    http://{host}:{port}/cypher\n```\n\n### 4.1.调用Cypher\n\n- **URI**: `/cypher`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | graph | 数据库 | 字符串 |\n  | cypher | 查询语句 | 字符串 |\n\n该内容块位于文档的第3部分，主要介绍了用户登出功能及其请求和响应示例。具体包括登出请求的URI、HTTP方法、请求参数和成功响应的示例。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n## 4.查询\n\nURI 格式为\n\n```\n    http://{host}:{port}/cypher\n```\n\n### 4.1.调用Cypher\n\n- **URI**: `/cypher`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | graph | 数据库 | 字符串 |\n  | cypher | 查询语句 | 字符串 |\n\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | result | 运行结果 | 列表 |\n  | elapsed | 运行时间（秒） | 浮点数 |\n  | header | 返回结果的表头 | 列表 |\n  | size | 结果数 | 整型 |\n\n其中 header 是一个列表，每一元素格式如下：\n\n| 域名 | 说明                                        | 类型   |\n| ---- | ------------------------------------------- | ------ |\n| name | 列名                                        | 字符串 |\n| type | 列数据类型，0 为标量，1 为点 id，2 为向量 |        |\n表格内容描述: 该表格包含三列，分别为“域名”、“说明”和“类型”。\n\n- 第一行数据：域名为“name”，说明为“列名”，类型为“字符串”。\n- 第二行数据：域名为“type”，说明为“列数据类型，0 为标量，1 为点 id，2 为向量”，类型字段留空。\n\n总结：该表格详细描述了两个字段的域名、说明及数据类型，旨在提供有关数据结构的信息。其中，第一行定义了列名的类型，第二行则详细说明了列数据类型的可能性。\n\n**Example request.**\n\n该片段位于文档的第4节“查询”中，具体介绍了如何调用Cypher接口进行数据库查询，包括请求URI、方法、请求参数及响应格式示例。这部分内容为开发者提供了使用Cypher进行数据操作的详细指导。"
            },
            {
                "content": "其中 header 是一个列表，每一元素格式如下：\n\n| 域名 | 说明                                        | 类型   |\n| ---- | ------------------------------------------- | ------ |\n| name | 列名                                        | 字符串 |\n| type | 列数据类型，0 为标量，1 为点 id，2 为向量 |        |\n表格内容描述: 该表格包含三列，分别为“域名”、“说明”和“类型”。\n\n- 第一行数据：域名为“name”，说明为“列名”，类型为“字符串”。\n- 第二行数据：域名为“type”，说明为“列数据类型，0 为标量，1 为点 id，2 为向量”，类型字段留空。\n\n总结：该表格详细描述了两个字段的域名、说明及数据类型，旨在提供有关数据结构的信息。其中，第一行定义了列名的类型，第二行则详细说明了列数据类型的可能性。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/cypher\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n        \"graph\": \"default\",\n        \"script\": \"MATCH (n) RETURN n,n.name LIMIT 10\"\n    }\n```\n\n**Example response.**\n\n该片段位于文档的“调用Cypher”部分，详细描述了返回结果中的header字段结构，包括列名和列数据类型的说明。这部分内容是对Cypher查询返回结果格式的具体阐述，对用户理解数据结构及使用Cypher接口至关重要。"
            },
            {
                "content": "总结：该表格详细描述了两个字段的域名、说明及数据类型，旨在提供有关数据结构的信息。其中，第一行定义了列名的类型，第二行则详细说明了列数据类型的可能性。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/cypher\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n        \"graph\": \"default\",\n        \"script\": \"MATCH (n) RETURN n,n.name LIMIT 10\"\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        \"elapsed\": 0.001224517822265625,\n        \"header\": [\n            {\n                \"name\": \"n\",\n                \"type\": 1\n            },\n            {\n                \"name\": \"n.name\",\n                \"type\": 0\n            }\n        ]\n        \"result\": [\n            [\n                0,\n                \"Rachel Kempson\"\n            ],\n            [\n                1,\n                \"Michael Redgrave\"\n            ],\n            [\n                2,\n                \"Vanessa Redgrave\"\n            ]\n        ],\n        \"size\": 3\n    }\n```\n\n### 4.2.调用带参数的 Cypher\n\n该段落位于文档的第4节“查询”，具体是4.1节“调用Cypher”的内容，详细描述了如何通过HTTP POST请求调用Cypher查询，包括请求格式、示例请求和响应格式。"
            },
            {
                "content": "### 4.2.调用带参数的 Cypher\n\nCypher 支持使用参数进行查询。当调用带参数的 Cypher 查询时，TuGraph 会缓存该查询的\n执行计划（execution plan），以加速后续同类查询的速度。\n\n- **URI**: `/cypher`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | graph | 数据库 | 字符串 |\n  | cypher | 查询语句 | 字符串 |\n  | parameters | 参数 | 列表 |\n\n- **RESPONSE**:\n\n与 [调用 Cypher](#%E8%B0%83%E7%94%A8Cypher) 相同。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/graph1/cypher\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n      \"graph\": \"default\",\n      \"script\": \"MATCH (n:Person {name:$param1}) RETURN n.birthyear\",\n      \"parameters\": {\n        \"$param1\": \"Lindsay Lohan\"\n      }\n    }\n```\n\n**Example response.**\n\n该信息块位于文档的第4节\"查询\"下，具体描述了如何调用带参数的Cypher查询。文本中提供了URI、请求方法、请求和回应的格式示例，以帮助用户了解如何高效使用参数化查询及其在TuGraph中的实现。"
            },
            {
                "content": "- **RESPONSE**:\n\n与 [调用 Cypher](#%E8%B0%83%E7%94%A8Cypher) 相同。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/graph1/cypher\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n      \"graph\": \"default\",\n      \"script\": \"MATCH (n:Person {name:$param1}) RETURN n.birthyear\",\n      \"parameters\": {\n        \"$param1\": \"Lindsay Lohan\"\n      }\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        \"elapsed\": 0.005886077880859375,\n        \"header\": [\n            {\n                \"name\": \"n.birthyear\",\n                \"type\": 0\n            }\n        ],\n        \"result\": [\n            [\n                1986\n            ]\n        ],\n        \"size\": 1\n    }\n```\n\n\n## 5.存储过程\n\nURI 格式为\n\n```\n    http://{host}:{port}/db/{graph_name}/cpp_plugin|python_plugin\n```\n\n### 5.1.加载存储过程\n\nTuGraph 服务启动时，如果 load_plugins 为真，则会自动加载 plugin 目录下的所有 plugin。否则需要手动加载。此外，如果服务器运行过程中，管理员更新了 plugin 文件，也需要手动重新加载。重新加载 plugin 的调用格式为：\n\n该片段位于文档的第4节和第5节之间，介绍了调用Cypher的响应格式和示例请求及响应，随后进入存储过程的相关内容。此片段的主要功能是展示如何通过Cypher查询获取数据，并包括实际的代码示例。"
            },
            {
                "content": "## 5.存储过程\n\nURI 格式为\n\n```\n    http://{host}:{port}/db/{graph_name}/cpp_plugin|python_plugin\n```\n\n### 5.1.加载存储过程\n\nTuGraph 服务启动时，如果 load_plugins 为真，则会自动加载 plugin 目录下的所有 plugin。否则需要手动加载。此外，如果服务器运行过程中，管理员更新了 plugin 文件，也需要手动重新加载。重新加载 plugin 的调用格式为：\n\n- **URI**: `/db/{graph_name}/cpp_plugin|python_plugin`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | name | 插件名称 | 字符串 |\n  | description | 插件说明 | 字符串 |\n  | code_base64 | 插件代码 | 字符串，使用 base64 编码 |\n  | read_only | 是否为只读存储过程 | 布尔值 |\n  | code_type | 上传代码的类型，C++类型可选 zip/so/cpp，Python 为 py | 字符串 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/graph1/cpp_plugin\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n        \"name\" : \"echo\",\n        \"description\" : \"A test plugin that returns the input\",\n        \"code_base64\" : \"{base64 encoded echo.zip}\",\n        \"read_only\" : true,\n        \"code_type\" : \"zip\"\n    }\n```\n\n该内容位于文档的第五部分，介绍了TuGraph中的存储过程操作，包括加载存储过程的URI格式、请求和响应格式，以及示例请求。此部分旨在指导用户如何使用C++或Python插件扩展TuGraph的功能。"
            },
            {
                "content": "- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/graph1/cpp_plugin\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n        \"name\" : \"echo\",\n        \"description\" : \"A test plugin that returns the input\",\n        \"code_base64\" : \"{base64 encoded echo.zip}\",\n        \"read_only\" : true,\n        \"code_type\" : \"zip\"\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n### 5.2.列出所有存储过程\n\n- **URI**: `/db/{graph_name}/cpp_plugin|python_plugin`\n- **METHOD**: GET\n- **RESPONSE**: 存储过程列表，其中每个元素是一个 plugin 的描述，其格式为：\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | name | 存储过程名 | 字符串 |\n  | description | 存储过程描述 | 字符串 |\n  | read_only | 存储过程是否只读 | 布尔值 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/cpp_plugin\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n该块内容位于文档的第五部分“存储过程”中，具体描述了如何加载存储过程以及列出所有存储过程的相关API调用，包括请求格式、响应格式和示例。这部分为开发者提供了有关在TuGraph中管理和使用存储过程的详细信息。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n### 5.2.列出所有存储过程\n\n- **URI**: `/db/{graph_name}/cpp_plugin|python_plugin`\n- **METHOD**: GET\n- **RESPONSE**: 存储过程列表，其中每个元素是一个 plugin 的描述，其格式为：\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | name | 存储过程名 | 字符串 |\n  | description | 存储过程描述 | 字符串 |\n  | read_only | 存储过程是否只读 | 布尔值 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/cpp_plugin\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        [\n            {\n                \"description\":\"adds a vertex label to the db\",\n                \"name\":\"add_label\",\n                \"read_only\":false\n            },\n            {\n                \"description\": \"scans graph and get number of edges\",\n                \"name\": \"scan_graph\",\n                \"read_only\": true\n            }\n        ]\n    }\n```\n\n### 5.3.获取存储过程的详细信息\n\n该片段位于文档的第五部分，介绍了TuGraph中的存储过程管理，包括列出所有存储过程及其描述、列出存储过程的请求和响应示例。此部分对开发者理解如何使用和管理存储过程至关重要。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        [\n            {\n                \"description\":\"adds a vertex label to the db\",\n                \"name\":\"add_label\",\n                \"read_only\":false\n            },\n            {\n                \"description\": \"scans graph and get number of edges\",\n                \"name\": \"scan_graph\",\n                \"read_only\": true\n            }\n        ]\n    }\n```\n\n### 5.3.获取存储过程的详细信息\n\n- **URI**: `/db/{graph_name}/cpp_plugin|python_plugin/{plugin_name}`\n- **METHOD**: GET\n- **RESPONSE**: 存储过程信息，包括代码，其格式为：\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | name | 存储过程名 | 字符串 |\n  | description | 存储过程描述 | 字符串 |\n  | read_only | 存储过程是否只读 | 布尔值 |\n  | code_base64 | 存储过程的代码 | 字符串，使用 base64 编码 |\n  | code_type | 上传代码的类型，C++类型可选 zip/so/cpp，Python 为 py | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/cpp_plugin/echo\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n该片段位于文档的第五部分“存储过程”中，具体描述了获取存储过程详细信息的API接口，包含请求URI、请求方式及响应格式示例。"
            },
            {
                "content": "**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/cpp_plugin/echo\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        \"name\" : \"echo\",\n        \"description\" : \"A test plugin that returns the input\",\n        \"code_base64\" : \"{base64 encoded echo.zip}\",\n        \"read_only\" : true,\n        \"code_type\" : \"zip\"\n    }\n```\n\n### 5.4.调用存储过程\n\n- **URI**: `/db/{graph_name}/cpp_plugin|python_plugin/{plugin_name}`\n- **METHOD**: POST\n- **REQUEST**: 字符串输入\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | data | 输入数据 | 字符串 |\n  | timeout | 超时长度（秒，可选，缺省值为 0） | 浮点 |\n  | in_process | 是否在本进程调用（可选，缺省值为 false） | 布尔值 |\n\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | result | 运行结果 | 字符串 |\n\n**Example request.**\n\n该块内容位于文档的第5章\"存储过程\"中，具体介绍了调用存储过程的 URI、请求方法及请求和响应格式，提供了示例请求和响应，以说明如何通过 API 调用 C++ 或 Python 存储过程的具体操作。"
            },
            {
                "content": "### 5.4.调用存储过程\n\n- **URI**: `/db/{graph_name}/cpp_plugin|python_plugin/{plugin_name}`\n- **METHOD**: POST\n- **REQUEST**: 字符串输入\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | data | 输入数据 | 字符串 |\n  | timeout | 超时长度（秒，可选，缺省值为 0） | 浮点 |\n  | in_process | 是否在本进程调用（可选，缺省值为 false） | 布尔值 |\n\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | result | 运行结果 | 字符串 |\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/graph1/python_plugin/echo\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n        data : \"Hello!\\n你好！\\nKonichiwa!\",\n        timeout : 0,\n        in_process : true\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n      \"result\": \"Hello!\\n你好！\\nKonichiwa!\"\n    }\n```\n\n### 5.5.删除存储过程\n\n- **URI**: `/db/{graph_name}/cpp_plugin|python_plugin/{plugin_name}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n该段落位于文档的第五部分，主要介绍了TuGraph中存储过程的相关操作，包括如何调用和删除存储过程。具体而言，5.4节详细说明了调用存储过程的URI、请求格式和响应结构，而5.5节则介绍了如何删除存储过程的相关信息。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n      \"result\": \"Hello!\\n你好！\\nKonichiwa!\"\n    }\n```\n\n### 5.5.删除存储过程\n\n- **URI**: `/db/{graph_name}/cpp_plugin|python_plugin/{plugin_name}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/db/graph1/cpp_plugin/example_plugin\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n## 6.Deprecated\n\n以下接口将在4/30/2023之后被删除。\n\n### 6.1.用户管理\n\n系统默认创建一个管理员，管理员用户名为 _admin_，密码为 _73@TuGraph_。为了安全起见，请用户在第一次启动服务器后更改密码。\n\n\n#### 6.1.1.添加用户\n\n添加一个新的用户，并为其设置初始密码。只有管理员有权限进行此操作。其中用户名只能由字母，数字以及下划线构成，密码则可以包含任意字符。用户名和密码长度不能超过 64 字节。添加用户时还可以为用户增加一个描述，用户描述可以包含任意字符，最长不超过 512 字节。\n\n新用户默认拥有同名的角色，不具备任何图的权限。\n\n- **URI**: `/user`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | user | 用户名 | 字符串 |\n  | password | 密码 | 字符串 |\n  | description | 用户描述 | 字符串 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n该内容位于文档的第5章“存储过程”中，具体描述了删除存储过程的API接口，包括请求格式、示例请求和响应。该部分内容整体上为开发者提供了关于如何管理和删除存储过程的详细信息，便于对TuGraph系统中的存储过程进行操作。"
            },
            {
                "content": "以下接口将在4/30/2023之后被删除。\n\n### 6.1.用户管理\n\n系统默认创建一个管理员，管理员用户名为 _admin_，密码为 _73@TuGraph_。为了安全起见，请用户在第一次启动服务器后更改密码。\n\n\n#### 6.1.1.添加用户\n\n添加一个新的用户，并为其设置初始密码。只有管理员有权限进行此操作。其中用户名只能由字母，数字以及下划线构成，密码则可以包含任意字符。用户名和密码长度不能超过 64 字节。添加用户时还可以为用户增加一个描述，用户描述可以包含任意字符，最长不超过 512 字节。\n\n新用户默认拥有同名的角色，不具备任何图的权限。\n\n- **URI**: `/user`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | user | 用户名 | 字符串 |\n  | password | 密码 | 字符串 |\n  | description | 用户描述 | 字符串 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/user\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n    Input:\n    {\n        \"user\": \"USER1\",\n        \"password\": \"AN_INITIAL_PASSWORD\",\n        \"description\": \"This is a user\"\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n该块内容位于文档的第6章“Deprecated”，主要介绍在2023年4月30日后将被删除的用户管理相关接口，包括添加用户的具体操作、请求和响应格式。这部分内容旨在提醒用户未来不再支持的功能，以便进行相应的调整和迁移。"
            },
            {
                "content": "```\n    • POST http://localhost:7070/user\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n    Input:\n    {\n        \"user\": \"USER1\",\n        \"password\": \"AN_INITIAL_PASSWORD\",\n        \"description\": \"This is a user\"\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.1.2.列出所有用户\n\n列出数据库的所有用户。只有管理员拥有该操作权限。\n\n- **URI**: `/user/`\n- **METHOD**: GET\n- **RESPONSE**: 所有用户及其信息。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/user\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n这个块包含了在 TuGraph 中添加用户的示例请求和响应，属于用户管理部分，主要说明如何通过 REST API 创建新用户以及列出所有用户的相关请求格式和要求。"
            },
            {
                "content": "```\n    • 200: OK\n```\n\n#### 6.1.2.列出所有用户\n\n列出数据库的所有用户。只有管理员拥有该操作权限。\n\n- **URI**: `/user/`\n- **METHOD**: GET\n- **RESPONSE**: 所有用户及其信息。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/user\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n• 200: OK\nOutput:\n{\n    \"admin\": {\n        \"disabled\": false,\n        \"description\": \"Builtin admin user\",\n        \"roles\": [\"admin\"]\n    },\n    \"guest1\": {\n        \"disabled\": true,\n        \"description\": \"\",\n        \"roles\": [\"guest1\", \"some_other_role\"]\n    }\n}\n```\n\n#### 6.1.3.获取用户信息\n\n列出给定用户的信息。\n\n- **URI**: `/user/{user_name}`\n- **METHOD**: GET\n- **RESPONSE**: 用户信息。\n\n**Example request.**\n\n该块内容位于文档第6.1节中，具体讨论了用户管理相关的操作，包括列出所有用户的API接口及其请求和响应示例。"
            },
            {
                "content": "**Example response.**\n\n```\n• 200: OK\nOutput:\n{\n    \"admin\": {\n        \"disabled\": false,\n        \"description\": \"Builtin admin user\",\n        \"roles\": [\"admin\"]\n    },\n    \"guest1\": {\n        \"disabled\": true,\n        \"description\": \"\",\n        \"roles\": [\"guest1\", \"some_other_role\"]\n    }\n}\n```\n\n#### 6.1.3.获取用户信息\n\n列出给定用户的信息。\n\n- **URI**: `/user/{user_name}`\n- **METHOD**: GET\n- **RESPONSE**: 用户信息。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/user/guest1\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n• 200: OK\nOutput:\n{\n    \"disabled\": true,\n    \"description\": \"A guest user\"\n    \"roles\": [\"guest1\", \"some_other_role\"]\n}\n```\n\n#### 6.1.4.列出用户权限\n\n列出给定用户有权限访问的所有图及相应权限。\n\n- **URI**: `/user/{user_name}/graph`\n- **METHOD**: GET\n- **RESPONSE**: 用户信息。\n\n该段内容位于文档的第6节“Deprecated”中的“6.1.3.获取用户信息”部分，主要讲述如何通过REST API获取特定用户的详细信息，包括用户的状态、描述和角色，同时也提供了相关的请求和响应示例。此内容有助于了解用户管理和权限控制的相关接口。"
            },
            {
                "content": "**Example response.**\n\n```\n• 200: OK\nOutput:\n{\n    \"disabled\": true,\n    \"description\": \"A guest user\"\n    \"roles\": [\"guest1\", \"some_other_role\"]\n}\n```\n\n#### 6.1.4.列出用户权限\n\n列出给定用户有权限访问的所有图及相应权限。\n\n- **URI**: `/user/{user_name}/graph`\n- **METHOD**: GET\n- **RESPONSE**: 用户信息。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/user/guest1/graph\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n• 200: OK\nOutput:\n{\n    \"graph1\" : \"FULL\",\n    \"graph2\" : \"READ\"\n}\n```\n\n#### 6.1.5.更改用户密码\n\n用户可以更改自己的密码，更改密码时需要同时提供原密码。管理员可以更改所有用户的密码。管理员更改其它用户密码时，可以不提供当前密码。\n\n- **URI**: `/user/{user_name}/password`\n- **METHOD**: PUT\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | current_password | 当前密码 | 字符串 |\n  | new_password | 新密码 | 字符串 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n此块内容位于文档的第6.1节中，主要介绍用户管理相关的API接口，包括列出用户权限和更改用户密码的具体请求和响应示例。"
            },
            {
                "content": "**Example response.**\n\n```\n• 200: OK\nOutput:\n{\n    \"graph1\" : \"FULL\",\n    \"graph2\" : \"READ\"\n}\n```\n\n#### 6.1.5.更改用户密码\n\n用户可以更改自己的密码，更改密码时需要同时提供原密码。管理员可以更改所有用户的密码。管理员更改其它用户密码时，可以不提供当前密码。\n\n- **URI**: `/user/{user_name}/password`\n- **METHOD**: PUT\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | current_password | 当前密码 | 字符串 |\n  | new_password | 新密码 | 字符串 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/user/user1/password\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n    Input:\n    {\n        \"current_password\": \"THE_CURRENT_PASSWORD\"\n        \"new_password\": \"A_NEW_PASSWORD\"\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.1.6.修改用户描述\n\n用户可以修改自己的描述。管理员可以修改任意用户的描述。\n\n该块内容位于文档的第6.1节，涉及用户管理功能中的更改用户密码操作，具体说明了修改密码的请求方法、请求参数以及示例响应，适用于管理员和用户在系统中更改账户密码的场景。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.1.6.修改用户描述\n\n用户可以修改自己的描述。管理员可以修改任意用户的描述。\n\n- **URI**: `/user/{user_name}/description`\n- **METHOD**: PUT\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | description | 用户描述 | 字符串 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/user/user1/description\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n    Input:\n    {\n        \"description\": \"New description for this user.\"\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.1.7.删除用户\n\n删除用户及其所有相关权限，只有管理员拥有该操作权限。\n\n- **URI**: `/user/{user_name}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n该内容片段位于文档的 \"用户管理\" 部分，具体介绍了用户描述的修改和删除操作，包括相关请求格式、响应示例以及所需的 URI 和方法。这部分信息主要用于指导用户如何进行用户描述的更新和删除操作。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.1.7.删除用户\n\n删除用户及其所有相关权限，只有管理员拥有该操作权限。\n\n- **URI**: `/user/{user_name}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/user/guest1\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.1.8.禁用用户\n\n用户可以被禁用。被禁用的用户将不能登陆，但是其资料仍然保存。被禁用的用户可以被重新启用。\n\n- **URI**: `/user/{user_name}/disable`\n- **METHOD**: POST\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n该区块位于文档的“用户管理”部分，具体介绍了删除用户的操作，包括请求的URI、使用的HTTP方法、请求和响应格式，以及示例请求和响应内容。这一部分旨在指导管理员如何在TuGraph中管理用户，特别是关于如何删除用户及其相关权限的步骤和注意事项。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.1.8.禁用用户\n\n用户可以被禁用。被禁用的用户将不能登陆，但是其资料仍然保存。被禁用的用户可以被重新启用。\n\n- **URI**: `/user/{user_name}/disable`\n- **METHOD**: POST\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/user/guest1/disable\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.1.9.启用用户\n\n启用一个被禁用的用户。\n\n- **URI**: `/user/{user_name}/enable`\n- **METHOD**: POST\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n该片段位于文档的第6.1节“用户管理”中，具体讲述了禁用和启用用户的操作，包括相应的URI、请求方法及示例请求和响应。这部分内容主要关注用户权限管理，适用于系统管理员进行用户状态的管理。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.1.9.启用用户\n\n启用一个被禁用的用户。\n\n- **URI**: `/user/{user_name}/enable`\n- **METHOD**: POST\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/user/guest1/enable\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.1.10.设置用户角色\n\n为指定用户设置角色。只有管理员可以执行此操作。\n\n用户角色列表必须是“全量列表”，即该列表需要包含该用户需要的所有角色。唯一的例外是用户的同名角色，即使列表中不含该角色，它也会被加到用户角色中。\n\n- **URI**: `/user/{user_name}/role`\n- **METHOD**: POST\n- **REQUEST**: 角色列表\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n该片段位于文档的用户管理部分，具体描述了启用被禁用用户的操作，包括相关的URI、请求方法、请求和响应示例。这一部分是对用户权限和管理操作的详细指导，帮助用户理解如何有效地管理系统用户。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.1.10.设置用户角色\n\n为指定用户设置角色。只有管理员可以执行此操作。\n\n用户角色列表必须是“全量列表”，即该列表需要包含该用户需要的所有角色。唯一的例外是用户的同名角色，即使列表中不含该角色，它也会被加到用户角色中。\n\n- **URI**: `/user/{user_name}/role`\n- **METHOD**: POST\n- **REQUEST**: 角色列表\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/user/guest1\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n    Input:\n        [\"role1\", \"role2\"]\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n此时用户`guest1`拥有角色`guest1`, `role1`和`role2`。\n\n### 6.2.角色管理\n\nTuGraph 使用基于角色的权限管理。\n\n同一用户可以拥有多个角色。新用户默认拥有与其同名的角色。删除用户时，同名角色也会被删除。如果新建用户时同名角色已经存在，则创建失败。\n\n同一角色可以对多个图有不同的权限。用户对某张图的权限由其所有角色对该图的最高权限决定。\n\nTuGraph 使用四级权限，不用的用户对不同的子图可以有不同的权限，四种权限及其说明如下：\n\n该块内容位于文档的第六部分，主要介绍了用户管理中的角色设置及角色管理功能，涵盖了为用户分配角色的接口、请求和响应示例，以及角色权限的管理机制。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n此时用户`guest1`拥有角色`guest1`, `role1`和`role2`。\n\n### 6.2.角色管理\n\nTuGraph 使用基于角色的权限管理。\n\n同一用户可以拥有多个角色。新用户默认拥有与其同名的角色。删除用户时，同名角色也会被删除。如果新建用户时同名角色已经存在，则创建失败。\n\n同一角色可以对多个图有不同的权限。用户对某张图的权限由其所有角色对该图的最高权限决定。\n\nTuGraph 使用四级权限，不用的用户对不同的子图可以有不同的权限，四种权限及其说明如下：\n\n| 权限  | 说明                                                                             |\n| ----- | -------------------------------------------------------------------------------- |\n| NONE  | 无权限                                                                           |\n| READ  | 只读                                                                             |\n| WRITE | 可读写子图中的点和边                                                           |\n| FULL  | 完全权限，包括更改元数据（label, index），管理存储过程，以及删除子图中的所有数据 |\n表格内容描述: \n\n该表格包含两列，分别是“权限”和“说明”。\n\n该段落位于文档的第六部分“Deprecated”中，具体是关于角色管理的内容。它讨论了TuGraph系统中如何通过基于角色的权限管理来管理用户权限，以及用户与角色之间的关系和权限层级的定义。"
            },
            {
                "content": "该表格包含两列，分别是“权限”和“说明”。 \n\n- 第一行：权限为“NONE”，说明为“无权限”，表示用户没有任何访问权限。\n- 第二行：权限为“READ”，说明为“只读”，表示用户只能查看数据，无法进行修改。\n- 第三行：权限为“WRITE”，说明为“可读写子图中的点和边”，表示用户可以对子图中的点和边进行读写操作。\n- 第四行：权限为“FULL”，说明为“完全权限，包括更改元数据（label, index），管理存储过程，以及删除子图中的所有数据”，表示用户具有全面的访问权限，能够进行所有操作。\n\n总体而言，该表格概述了不同权限级别及其对应的功能和限制，从无权限到完全权限，清晰地定义了用户在系统中可以Perform的操作。\n\n管理员对所有子图都有完全权限，新建的用户对所有子图都没有权限。将用户加入管理员角色中可以将用户提升为管理员。\n\n#### 6.2.1.添加角色\n\n添加一个新的角色，并设置其描述。只有管理员有权限进行此操作。\n\n角色名只能由字母，数字以及下划线构成，密码则可以包含任意字符。角色名长度不能超过 64 字节。\n\n角色描述可以是任意字符串，长度不超过 512 字节。\n\n- **URI**: `/role`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | role | 角色名 | 字符串 |\n  | description | 角色描述 | 字符串 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n该段落位于文档的第6.2节“角色管理”中，详细描述了不同权限级别的功能和限制，并介绍了添加角色的相关信息，包括角色的命名规则、描述及请求格式。这为用户管理和权限设置提供了清晰的指导。"
            },
            {
                "content": "总体而言，该表格概述了不同权限级别及其对应的功能和限制，从无权限到完全权限，清晰地定义了用户在系统中可以Perform的操作。\n\n管理员对所有子图都有完全权限，新建的用户对所有子图都没有权限。将用户加入管理员角色中可以将用户提升为管理员。\n\n#### 6.2.1.添加角色\n\n添加一个新的角色，并设置其描述。只有管理员有权限进行此操作。\n\n角色名只能由字母，数字以及下划线构成，密码则可以包含任意字符。角色名长度不能超过 64 字节。\n\n角色描述可以是任意字符串，长度不超过 512 字节。\n\n- **URI**: `/role`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | role | 角色名 | 字符串 |\n  | description | 角色描述 | 字符串 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/role\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n    Input:\n    {\n        \"role\": \"new_role\",\n        \"description\": \"This is a new role.\",\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.2.2.修改角色描述\n\n修改角色的描述。只有管理员有权限进行此操作。角色描述可以是任意字符串，长度不超过 512 字节。\n\n该段落位于文档的\"角色管理\"部分，具体介绍了系统中用户角色的权限级别及其管理方式，包括添加角色和修改角色描述的相关操作。这部分内容旨在帮助管理员理解如何管理用户角色及其对应的权限设置。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.2.2.修改角色描述\n\n修改角色的描述。只有管理员有权限进行此操作。角色描述可以是任意字符串，长度不超过 512 字节。\n\n- **URI**: `/role/{role_name}/description`\n- **METHOD**: PUT\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | description | 新描述 | 字符串 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/role/role1/description\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n    Input:\n    {\n        \"description\": \"modified description\"\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.2.3.列出所有角色\n\n列出数据库的所有角色。只有管理员拥有该操作权限。\n\n- **URI**: `/role/`\n- **METHOD**: GET\n- **RESPONSE**: 所有角色及其信息。\n\n**Example request.**\n\n该块内容位于文档的第6.2节“角色管理”中的修改角色描述部分，主要介绍了如何通过REST API修改角色的描述信息，包括请求URI、请求方法、请求和响应格式等细节。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.2.3.列出所有角色\n\n列出数据库的所有角色。只有管理员拥有该操作权限。\n\n- **URI**: `/role/`\n- **METHOD**: GET\n- **RESPONSE**: 所有角色及其信息。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/role\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n• 200: OK\nOutput:\n{\n    \"admin\": {\n        \"disabled\": false,\n        \"description\": \"Builtin administrator group.\",\n        \"permissions\": {\"default\":\"FULL\", \"graph1\":\"FULL\"}\n    },\n    \"role1\": {\n        \"disabled\": true,\n        \"description\": \"Another role\",\n        \"permissions\": {\"default\":\"READ\"}\n    }\n}\n```\n\n#### 6.2.4.获取角色信息\n\n列出给定角色的信息。\n\n- **URI**: `/role/{role_name}`\n- **METHOD**: GET\n- **RESPONSE**: 角色信息。\n\n**Example request.**\n\n该代码块位于文档的第6.2节，主要涉及角色管理功能中的部分内容。具体来说，此处描述了如何列出所有角色以及获取特定角色的信息，包括API的URI、请求方法、请求和响应示例，适用于管理员对系统角色的管理操作。"
            },
            {
                "content": "**Example response.**\n\n```\n• 200: OK\nOutput:\n{\n    \"admin\": {\n        \"disabled\": false,\n        \"description\": \"Builtin administrator group.\",\n        \"permissions\": {\"default\":\"FULL\", \"graph1\":\"FULL\"}\n    },\n    \"role1\": {\n        \"disabled\": true,\n        \"description\": \"Another role\",\n        \"permissions\": {\"default\":\"READ\"}\n    }\n}\n```\n\n#### 6.2.4.获取角色信息\n\n列出给定角色的信息。\n\n- **URI**: `/role/{role_name}`\n- **METHOD**: GET\n- **RESPONSE**: 角色信息。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/role/role1\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n• 200: OK\nOutput:\n{\n    \"disabled\": true,\n    \"description\": \"Another role\",\n    \"permissions\": {\"default\":\"READ\"}\n}\n```\n\n#### 6.2.5.删除角色\n\n删除指定角色，只有管理员拥有该操作权限。\n\n该内容位于文档的第6.2节“角色管理”下，具体介绍了获取角色信息的接口及其请求和响应示例，涉及角色的详细权限和描述信息的获取。"
            },
            {
                "content": "```\n    • GET http://localhost:7070/role/role1\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n• 200: OK\nOutput:\n{\n    \"disabled\": true,\n    \"description\": \"Another role\",\n    \"permissions\": {\"default\":\"READ\"}\n}\n```\n\n#### 6.2.5.删除角色\n\n删除指定角色，只有管理员拥有该操作权限。\n\n- **URI**: `/role/{role_name}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/role/role1\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.2.6.禁用角色\n\n该块内容位于文档的“角色管理”部分，主要介绍了如何获取角色信息以及删除和禁用角色的相关操作，包括具体的请求格式、响应示例和请求中的授权信息。"
            },
            {
                "content": "- **URI**: `/role/{role_name}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/role/role1\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.2.6.禁用角色\n\n角色可以被禁用。角色被禁用后，具有该角色的用户将不再从该角色中获得任何权限。只有管理员可以执行此操作。\n\n- **URI**: `/role/{role_name}/disable`\n- **METHOD**: POST\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/role/role1/disable\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n该段落位于文档的第6.2节“角色管理”中，具体描述了删除角色的接口信息，包括URI、请求方法、响应和示例请求与响应，以帮助用户理解如何在TuGraph中管理角色。"
            },
            {
                "content": "- **URI**: `/role/{role_name}/disable`\n- **METHOD**: POST\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/role/role1/disable\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.2.7.启用角色\n\n启用一个被禁用的角色。\n\n- **URI**: `/role/{role_name}/enable`\n- **METHOD**: POST\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/role/role1/enable\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n该片段位于文档的第6.2节“角色管理”中，具体描述了禁用和启用角色的API接口及其请求和响应示例。这部分内容为管理员提供了管理用户角色权限的功能。"
            },
            {
                "content": "启用一个被禁用的角色。\n\n- **URI**: `/role/{role_name}/enable`\n- **METHOD**: POST\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/role/role1/enable\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.2.8.设置角色权限\n\n为指定角色设置权限。只有管理员可以执行此操作。\n\n角色权限列表必须是“全量列表”，即该列表需要包含该角色能操作的所有图及其权限。\n\n- **URI**: `/role/{role_name}/permissions`\n- **METHOD**: POST\n- **REQUEST**: 图名称及相应权限的字典。\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n该片段位于文档的第6.2节“角色管理”中，具体描述了如何启用被禁用的角色，以及相关的URI、请求方法、请求和响应示例。这部分内容详尽地介绍了角色管理的权限设置和角色操作，帮助用户理解如何管理角色及其权限。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.2.8.设置角色权限\n\n为指定角色设置权限。只有管理员可以执行此操作。\n\n角色权限列表必须是“全量列表”，即该列表需要包含该角色能操作的所有图及其权限。\n\n- **URI**: `/role/{role_name}/permissions`\n- **METHOD**: POST\n- **REQUEST**: 图名称及相应权限的字典。\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/role/role1/permissions\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    • Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek\n    Input:\n    {\n        \"graph1\" : \"FULL\",\n        \"graph2\" : \"READ\"\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n\n### 6.3.服务器状态\n\n#### 6.3.1.修改服务器配置\n\n修改服务器配置，配置修改后立即生效，并将影响所有服务器。这些配置的优先级高于配置文件以及命令行参数。\n\n- **URI**: `/config`\n- **METHOD**: PUT\n- **REQUEST**:\n\n请求为一个字典，使用 `{\"opt1\":v1}` 可以将名为`opt1`的配置修改为`v1`。\n\n该段落位于文档的第六部分，主要描述角色管理中的设置角色权限接口，包括请求和响应格式、示例请求及其相应的成功返回代码，旨在指导管理员如何为角色配置访问权限。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n\n### 6.3.服务器状态\n\n#### 6.3.1.修改服务器配置\n\n修改服务器配置，配置修改后立即生效，并将影响所有服务器。这些配置的优先级高于配置文件以及命令行参数。\n\n- **URI**: `/config`\n- **METHOD**: PUT\n- **REQUEST**:\n\n请求为一个字典，使用 `{\"opt1\":v1}` 可以将名为`opt1`的配置修改为`v1`。\n\n| 配置名               | 说明                   | 值类型 |\n| -------------------- | ---------------------- | ------ |\n| OPT_DB_ASYNC         | 是否启用异步模式       | 布尔值 |\n| OPT_TXN_OPTIMISTIC   | 是否默认使用乐观事务锁 | 布尔值 |\n| OPT_AUDIT_LOG_ENABLE | 是否启用审计日志       | 布尔值 |\n表格内容描述: \n\n该表格包含三列，分别为“配置名”、“说明”和“值类型”。\n\n- 第一行数据是“OPT_DB_ASYNC”，其说明为“是否启用异步模式”，值类型为“布尔值”。\n- 第二行数据是“OPT_TXN_OPTIMISTIC”，其说明为“是否默认使用乐观事务锁”，值类型为“布尔值”。\n- 第三行数据是“OPT_AUDIT_LOG_ENABLE”，其说明为“是否启用审计日志”，值类型为“布尔值”。\n\n总体来看，此表格列出了三项配置选项及其相应的说明和数据类型，这些配置主要涉及数据库的异步处理、事务锁的使用方式及审计日志的启用情况，均为布尔值类型的设置。\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n该chunk位于文档的第6章“服务器状态”中的6.3.1节“修改服务器配置”部分，描述了如何通过PUT请求修改服务器的配置选项及其响应示例。"
            },
            {
                "content": "该表格包含三列，分别为“配置名”、“说明”和“值类型”。\n\n- 第一行数据是“OPT_DB_ASYNC”，其说明为“是否启用异步模式”，值类型为“布尔值”。\n- 第二行数据是“OPT_TXN_OPTIMISTIC”，其说明为“是否默认使用乐观事务锁”，值类型为“布尔值”。\n- 第三行数据是“OPT_AUDIT_LOG_ENABLE”，其说明为“是否启用审计日志”，值类型为“布尔值”。\n\n总体来看，此表格列出了三项配置选项及其相应的说明和数据类型，这些配置主要涉及数据库的异步处理、事务锁的使用方式及审计日志的启用情况，均为布尔值类型的设置。\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • PUT http://localhost:7070/config\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n        \"OPT_DB_ASYNC\": true,\n        \"OPT_AUDIT_LOG_ENABLE\": false\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.3.2.当前服务器状态\n\n该片段位于文档的第6.3节“服务器状态”中，具体描述了修改服务器配置的相关选项及其说明，并举例说明如何通过API请求修改这些配置。"
            },
            {
                "content": "```\n    • 200: OK\n```\n\n#### 6.3.2.当前服务器状态\n\n- **URI**: `/info`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | lgraph_version | 服务器版本号 | 字符串 |\n  | git_branch | 服务器代码分支 | 字符串 |\n  | git_commit | 服务器代码版本 | 字符串 |\n  | web_commit | 前端码版本 | 字符串 |\n  | cpp_id | CPP 编译器 ID | 字符串 |\n  | cpp_version | CPP 编译器版本 | 字符串 |\n  | python_version | PYTHON 版本 | 字符串 |\n  | node | 点 uri | 字符串 |\n  | relationship | 边 uri | 字符串 |\n  | cpu | cpu 信息 | 字典，格式参见[服务器 CPU 状态](#%E6%9C%8D%E5%8A%A1%E5%99%A8CPU%E7%8A%B6%E6%80%81) |\n  | disk | 硬盘 IO 信息 | 字典，格式参见[服务器硬盘状态](#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A1%AC%E7%9B%98%E7%8A%B6%E6%80%81) |\n  | memory | 内存信息 | 字典，格式参见[服务器内存状态](#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E5%AD%98%E7%8A%B6%E6%80%81) |\n  | db_space | 图数据库占用空间 | 字典，格式参见[图数据库占用空间](#%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4) |\n  | db_config | 图数据库配置信息 | 字典，格式参见[图数据库配置信息](#%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF) |\n  | up_time | 数据库在线时长（秒） | 整型 |\n\n该块内容位于文档的第六部分，主要介绍服务器的当前状态及其相关信息，包括服务器版本、代码分支、编译器版本、CPU和内存信息等，这些信息有助于用户了解服务器的运行情况和性能。"
            },
            {
                "content": "**Example request.**\n\n```\n    • GET http://localhost:7070/info\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n该块内容位于文档第6.3.2节，描述了如何通过GET请求获取当前服务器的状态信息，包括服务器版本、代码分支、CPU和内存使用情况等。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n      \"lgraph_version\": \"1.2.0\",\n      \"git_branch\": \"master\",\n      \"git_commit\": \"9e2977d\",\n      \"web_commit\": \"1e2823d\",\n      \"cpu_id\": \"GUN\",\n      \"cpu_version\": \"4.8.5\",\n      \"python_version\": \"3.2\",\n      \"node\": \"/node\",\n      \"relationship\": \"/relationship\",\n      \"cpu\": {\n        \"self\": 25,\n        \"server\": 35,\n        \"unit\": \"%\"\n      },\n      \"disk\": {\n        \"read\": 2000,\n        \"write\": 2000,\n        \"unit\": \"B/s\"\n      },\n      \"memory\": {\n        \"self\": 25016,\n        \"server_avail\": 46865636,\n        \"server_total\": 65860552,\n        \"unit\": \"KB\"\n      },\n      \"db_space\": {\n        \"space\": 57344,\n        \"unit\": \"B\"\n      },\n      \"db_config\": {\n        \"db_async\": false,\n        \"disable_auth\": false,\n        \"enable_ha\": false,\n        ...\n      },\n      \"up_time\": 3235\n    }\n```\n\n#### 6.3.3.服务器 CPU 状态\n\n该块内容位于文档的“6.3.2.当前服务器状态”部分，描述了服务器的详细状态信息，包括版本号、CPU使用率、内存状态和数据库占用空间等关键指标，属于服务器状态查询的返回结果。"
            },
            {
                "content": "#### 6.3.3.服务器 CPU 状态\n\n- **URI**: `/info/cpu`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | self | 图数据库应用程序 CPU 使用率 | 整型 |\n  | server | 服务器 CPU 使用率 | 整型 |\n  | unit | 单位 | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/cpu\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n      \"self\": 25,\n      \"server\": 35,\n      \"unit\": \"%\"\n    }\n```\n\n#### 6.3.4.服务器硬盘状态\n\n- **URI**: `/info/disk`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | read | 服务器硬盘读速率 | 整型 |\n  | write | 服务器硬盘写速率 | 整型 |\n  | unit | 单位 | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/disk\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n      \"read\": 2000,\n      \"write\": 2000,\n      \"unit\": \"B/s\"\n    }\n```\n\n该文段位于文档的第6.3节，涉及服务器的状态监控，包括CPU和硬盘的使用情况。它详细描述了通过RESTful API调用获取CPU使用率和硬盘读写速率的方式及其响应格式。"
            },
            {
                "content": "#### 6.3.4.服务器硬盘状态\n\n- **URI**: `/info/disk`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | read | 服务器硬盘读速率 | 整型 |\n  | write | 服务器硬盘写速率 | 整型 |\n  | unit | 单位 | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/disk\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n      \"read\": 2000,\n      \"write\": 2000,\n      \"unit\": \"B/s\"\n    }\n```\n\n#### 6.3.5.服务器内存状态\n\n- **URI**: `/info/memory`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | self | 图数据库应用程序内存使用量 | 整型 |\n  | server_avail | 服务器可用内存 | 整型 |\n  | server_total | 服务器总内存 | 整型 |\n  | unit | 单位 | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/memory\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n该块内容位于文档的第6章，主要描述服务器状态的相关信息，包括硬盘状态和内存状态的查询接口，允许用户获取服务器的硬盘读写速率和内存使用情况，适用于监控和优化服务器性能。"
            },
            {
                "content": "#### 6.3.5.服务器内存状态\n\n- **URI**: `/info/memory`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | self | 图数据库应用程序内存使用量 | 整型 |\n  | server_avail | 服务器可用内存 | 整型 |\n  | server_total | 服务器总内存 | 整型 |\n  | unit | 单位 | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/memory\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n      \"self\": 25016,\n      \"server_avail\": 46865636,\n      \"server_total\": 65860552,\n      \"unit\": \"KB\"\n    }\n```\n\n#### 6.3.6.图数据库占用空间\n\n- **URI**: `/info/db_space`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | space | 图数据库占用空间 | 整型 |\n  | disk_avail | 图数据库可用空间 | 整型 |\n  | disk_total | 服务器硬盘总空间 | 整型 |\n  | unit | 单位 | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/db_space\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n该段落位于文档的第6章，主要介绍服务器状态监控的相关接口。具体内容涵盖了服务器内存状态和图数据库占用空间的查询，包括相应的URI、请求方法、响应格式及示例请求和响应。"
            },
            {
                "content": "#### 6.3.6.图数据库占用空间\n\n- **URI**: `/info/db_space`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | space | 图数据库占用空间 | 整型 |\n  | disk_avail | 图数据库可用空间 | 整型 |\n  | disk_total | 服务器硬盘总空间 | 整型 |\n  | unit | 单位 | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/db_space\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n      \"disk_avail\"::360074579968,\n      \"disk_total\"::984373800960,\n      \"space\": 57344,\n      \"unit\": \"B\"\n    }\n```\n\n#### 6.3.7.图数据库配置信息\n\n该块内容位于文档的第6章“Deprecated”部分，专注于图数据库的状态查询，具体描述了如何获取图数据库占用空间的信息及其相关的请求和响应格式。"
            },
            {
                "content": "**Example request.**\n\n```\n    • GET http://localhost:7070/info/db_space\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n      \"disk_avail\"::360074579968,\n      \"disk_total\"::984373800960,\n      \"space\": 57344,\n      \"unit\": \"B\"\n    }\n```\n\n#### 6.3.7.图数据库配置信息\n\n- **URI**: `/info/db_config`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | db_async | 图数据库工作模式（同步或异步） | 布尔值 |\n  | disable_auth | 是否禁用身份验证 | 布尔值 |\n  | enable_ha | 是否启用高可用模式 | 布尔值 |\n  | enable_rpc | 是否启用 RPC 服务器 | 布尔值 |\n  | bind_host | REST 服务器的主机 | 字符串 |\n  | enable_audit_log | 是否启用日志审计 | 布尔值 |\n  | port | REST 服务器的端口 | 整型 |\n  | rpc_port | RPC 服务器的端口 | 整型 |\n  | optimistic_txn | 是否默认使用乐观事务锁 | 布尔值 |\n  | thread_limit | 图数据库应用程序的可用线程数 | 整型 |\n  | enable_ssl | 是否使用 SSL 进行身份验证 | 布尔值 |\n  | verbose | 输出的详细程度 | 整型 |\n\n**Example request.**\n\n该片段位于文档的“服务器状态”部分，主要描述了如何查询图数据库的存储空间信息和配置信息，包括相应的请求示例和响应格式。这些信息对于用户了解数据库的存储情况和配置设置非常重要。"
            },
            {
                "content": "**Example request.**\n\n```\n    • GET http://localhost:7070/info/db_config\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n      \"db_async\":false,\n      \"disable_auth\":false,\n      \"enable_ha\":false,\n      \"enable_rpc\":false,\n      \"bind_host\":\"127.0.0.1\",\n      \"enable_audit_log\":false,\n      \"port\":7070,\n      \"optimistic_txn\":false,\n      \"rpc_port\":9091,\n      \"thread_limit\":0,\n      \"enable_ssl\":false,\n      \"verbose\":2\n    }\n```\n\n#### 6.3.8.高可用服务器列表\n\n_(仅在高可用模式下有效)_\n\n- **URI**: `/info/peers`\n- **METHOD**: GET\n- **RESPONSE**: 如果成功，则返回 200 代码，并返回一个服务器信息列表，其中每个服务器信息格式为：\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | rpc_address | 服务器 RPC 地址 | 字符串 |\n  | rest_address | 服务器 REST 地址 | 字符串 |\n  | state | 服务器状态 | 字符串 |\n\n其中服务器状态可为 `MASTER`,`SLAVE`,`OFFLINE`。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/peers\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n该片段位于文档的\"6.3.7.图数据库配置信息\"部分，具体示例展示了如何通过GET请求获取图数据库的配置信息，包括数据库工作模式、身份验证设置和服务器端口等内容。这些配置信息对于用户理解和管理数据库的运行参数至关重要。"
            },
            {
                "content": "#### 6.3.8.高可用服务器列表\n\n_(仅在高可用模式下有效)_\n\n- **URI**: `/info/peers`\n- **METHOD**: GET\n- **RESPONSE**: 如果成功，则返回 200 代码，并返回一个服务器信息列表，其中每个服务器信息格式为：\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | rpc_address | 服务器 RPC 地址 | 字符串 |\n  | rest_address | 服务器 REST 地址 | 字符串 |\n  | state | 服务器状态 | 字符串 |\n\n其中服务器状态可为 `MASTER`,`SLAVE`,`OFFLINE`。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/peers\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n      [\n          {\n              \"rest_address\":\"192.168.1.22:17071\",\n              \"rpc_address\":\"192.168.1.22:19091\",\n              \"state\":\"MASTER\"\n          },\n          {\n              \"rest_address\":\"192.168.1.22:17072\",\n              \"rpc_address\":\"192.168.1.22:19092\",\n              \"state\":\"SLAVE\"\n          }\n      ]\n    }\n```\n\n#### 6.3.9.当前 Leader 信息\n\n_(仅在高可用模式下有效)_\n\n该块内容位于文档的第6.3节，主要介绍了高可用模式下的服务器信息获取，包括获取高可用服务器列表和当前Leader信息的API接口及其响应格式。这部分内容适用于开发者在实现高可用部署时的服务器监控与管理。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n      [\n          {\n              \"rest_address\":\"192.168.1.22:17071\",\n              \"rpc_address\":\"192.168.1.22:19091\",\n              \"state\":\"MASTER\"\n          },\n          {\n              \"rest_address\":\"192.168.1.22:17072\",\n              \"rpc_address\":\"192.168.1.22:19092\",\n              \"state\":\"SLAVE\"\n          }\n      ]\n    }\n```\n\n#### 6.3.9.当前 Leader 信息\n\n_(仅在高可用模式下有效)_\n\n- **URI**: `/info/leader`\n- **METHOD**: GET\n- **RESPONSE**: 如果成功，则返回 200 代码，并返回当前 leader 服务器信息，格式为：\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | rpc_address | 服务器 RPC 地址 | 字符串 |\n  | rest_address | 服务器 REST 地址 | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/leader\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n该块内容位于文档的第6.3.9节，介绍了当前Leader信息的获取，包括相关的URI、请求方法和响应格式，适用于高可用模式下的服务器状态管理。"
            },
            {
                "content": "#### 6.3.9.当前 Leader 信息\n\n_(仅在高可用模式下有效)_\n\n- **URI**: `/info/leader`\n- **METHOD**: GET\n- **RESPONSE**: 如果成功，则返回 200 代码，并返回当前 leader 服务器信息，格式为：\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | rpc_address | 服务器 RPC 地址 | 字符串 |\n  | rest_address | 服务器 REST 地址 | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/leader\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n      \"rest_address\":\"192.168.1.22:17071\",\n      \"rpc_address\":\"192.168.1.22:19091\"\n    }\n```\n\n#### 6.3.10.服务器统计信息\n\n- **URI**: `/info/statistics`\n- **METHOD**: GET\n- **RESPONSE**: 如果成功，则返回 200 代码，并返回当前服务器统计信息，格式为：\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | requests/second | 每秒处理的请求数量 | 浮点型 |\n  | writes/second | 每秒处理的写请求数量 | 浮点型 |\n  | running_tasks | 正在执行的请求数量 | 整型 |\n  | failure_rate | 请求失败率 | 浮点型 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/statistics\n    • Accept: application/json; charset=UTF-8\n```\n\n该内容块位于文档的第6.3节，主要介绍了在高可用模式下的服务器状态监控，包括当前Leader信息及服务器统计信息。这些接口用于获取服务器的实时领导者和性能指标，帮助用户了解系统的运行状态。"
            },
            {
                "content": "#### 6.3.10.服务器统计信息\n\n- **URI**: `/info/statistics`\n- **METHOD**: GET\n- **RESPONSE**: 如果成功，则返回 200 代码，并返回当前服务器统计信息，格式为：\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | requests/second | 每秒处理的请求数量 | 浮点型 |\n  | writes/second | 每秒处理的写请求数量 | 浮点型 |\n  | running_tasks | 正在执行的请求数量 | 整型 |\n  | failure_rate | 请求失败率 | 浮点型 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/statistics\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"failure_rate\": 2.3,\n        \"requests/second\": 122.3,\n        \"running_tasks\": 10,\n        \"writes/second\": 12.4\n    }\n```\n\n#### 6.3.11.审计日志信息\n\n该段落位于文档的第六部分“6.3.服务器状态”中，具体介绍了服务器的统计信息，包括每秒处理的请求数量、写请求数量、正在执行的任务数量以及请求失败率等关键指标，并提供了相应的请求和响应示例。"
            },
            {
                "content": "**Example request.**\n\n```\n    • GET http://localhost:7070/info/statistics\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"failure_rate\": 2.3,\n        \"requests/second\": 122.3,\n        \"running_tasks\": 10,\n        \"writes/second\": 12.4\n    }\n```\n\n#### 6.3.11.审计日志信息\n\n- **URI**: `/info/log/?begin_time={begin_time}&end_time={end_time}&user={user}#_log={num_log}&descending_order={descending_order}`\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | begin_time | 查询日志的起始时间(必填，格式为 YYYY-mm-dd HH:MM:SS) | 时间戳 |\n  | end_time | 查询日志的结束时间(默认为当前时间，格式为 YYYY-mm-dd HH:MM:SS) | 时间戳 |\n  | user | 查询日志的操作者(管理员可查询所有用户的日志，普通用户只能查询本人日志) | 字符串 |\n  | num_log | 查询日志的数量(默认为 100) | 整型 |\n  | descending_order | 查询结果是否降序输出(默认为 true) | 布尔值 |\n\n该代码块位于文档的第6.3节，主要介绍服务器统计信息的查询接口，包括获取服务器每秒处理请求数量、写请求数量、正在执行的任务数量及请求失败率的示例请求和响应。"
            },
            {
                "content": "#### 6.3.11.审计日志信息\n\n- **URI**: `/info/log/?begin_time={begin_time}&end_time={end_time}&user={user}#_log={num_log}&descending_order={descending_order}`\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | begin_time | 查询日志的起始时间(必填，格式为 YYYY-mm-dd HH:MM:SS) | 时间戳 |\n  | end_time | 查询日志的结束时间(默认为当前时间，格式为 YYYY-mm-dd HH:MM:SS) | 时间戳 |\n  | user | 查询日志的操作者(管理员可查询所有用户的日志，普通用户只能查询本人日志) | 字符串 |\n  | num_log | 查询日志的数量(默认为 100) | 整型 |\n  | descending_order | 查询结果是否降序输出(默认为 true) | 布尔值 |\n\n- **METHOD**: GET\n- **RESPONSE**: 如果成功，则返回 200 代码，并返回审计日志列表，其中每个元素是一条操作日志，其格式为：\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | index | 该操作的索引值 | 整型 |\n  | begin_time | 该操作的开始时间 | 字符串 |\n  | end_time | 该操作的结束时间 | 字符串 |\n  | user | 该操作的发起者 | 字符串 |\n  | graph | 该操作的图 | 字符串 |\n  | type | 该操作的类型 | 字符串 |\n  | read_write | 该操作为读操作或者写操作 | 字符串 |\n  | success | 该操作是否成功 | 布尔值 |\n  | content | 该操作的简要内容 | 字符串 |\n\n**Example request.**\n\n该段落位于文档的第六部分“Deprecated”，具体细分为“6.3.11.审计日志信息”，主要描述了如何查询系统的审计日志，包括请求的URI格式、方法、请求参数及响应格式。此部分属于系统管理和监控功能的实施，确保用户行为和操作的可追溯性。"
            },
            {
                "content": "- **METHOD**: GET\n- **RESPONSE**: 如果成功，则返回 200 代码，并返回审计日志列表，其中每个元素是一条操作日志，其格式为：\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | index | 该操作的索引值 | 整型 |\n  | begin_time | 该操作的开始时间 | 字符串 |\n  | end_time | 该操作的结束时间 | 字符串 |\n  | user | 该操作的发起者 | 字符串 |\n  | graph | 该操作的图 | 字符串 |\n  | type | 该操作的类型 | 字符串 |\n  | read_write | 该操作为读操作或者写操作 | 字符串 |\n  | success | 该操作是否成功 | 布尔值 |\n  | content | 该操作的简要内容 | 字符串 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/info/log/?begin_time=2020-02-17%2015:00:00&end_time=2020-02-20%2012:00:00&user=admin#_log=100&descending_order=false\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n该内容位于文档的第6.3.11节，专门描述了审计日志信息的查询接口。通过GET请求，可以获取特定时间范围内的操作日志，返回中包含操作的详细信息及其状态。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        [\n            {\n                \"begin_time\": \"2020-02-17 15:27:15\",\n                \"content\": \"post /login    Successful\",\n                \"end_time\": \"2020-02-17 15:27:15\",\n                \"graph\": \"\",\n                \"index\": 1,\n                \"read_write\": \"read\",\n                \"success\": true,\n                \"type\": \"Security\",\n                \"user\":\"admin\"\n            },\n            {\n                \"begin_time\": \"2020-02-17 15:27:15\",\n                \"content\": \"Load plugin : `echo`    Successful\",\n                \"end_time\": \"2020-02-17 15:27:15\",\n                \"graph\": \"default\",\n                \"index\": 2,\n                \"read_write\": \"write\",\n                \"success\": true,\n                \"type\": \"Plugin\",\n                \"user\": \"admin\"\n            },\n            ...\n        ]\n    }\n```\n\n### 6.4.任务管理\n\n该内容片段位于文档的“6.4.任务管理”部分，主要介绍了如何查询当前正在执行的任务及其相关信息，包括示例响应格式，展示了任务执行的时间、类型及成功状态。这部分内容有助于用户了解和管理后台任务的状态。"
            },
            {
                "content": "### 6.4.任务管理\n\nTuGraph 提供长任务的跟踪和中止功能。用户可以通过 REST API 来查询当前正在运行的在 Cypher 和存储过程查询，并选择中止正在执行的查询。\n\n任务管理对应的 URI 格式为\n\n```\n    http://{host}:{port}/task/{thread_id}/{task_id}\n```\n\n#### 6.4.1.查询正在执行的任务\n\n- **URI**: `/task`\n- **METHOD**: GET\n- **RESPONSE**:\n\n返回的 JSON 为一个数组，其中每一个元素格式如下：\n\n| 域名         | 说明                         | 类型   |\n| ------------ | ---------------------------- | ------ |\n| description  | 任务描述                     | 字符串 |\n| time_elapsed | 任务已经执行的时间，单位为秒 | 浮点   |\n| task_id      | 任务 ID                      | 字符串 |\n表格内容描述: 该表格包含三列，分别为“域名”、“说明”和“类型”。\n\n- 第一行: 域名为“description”，其说明是“任务描述”，数据类型为字符串。\n- 第二行: 域名为“time_elapsed”，其说明是“任务已经执行的时间，单位为秒”，数据类型为浮点数。\n- 第三行: 域名为“task_id”，其说明是“任务 ID”，数据类型为字符串。\n\n总体来看，该表格定义了与任务相关的三个字段，包括对任务的描述、执行时间及其标识符。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/task\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n该段落位于文档的第6节，主要介绍TuGraph的任务管理功能，包括如何查询当前正在执行的任务和获取相关信息。这部分内容详细说明了如何使用REST API进行任务跟踪和中止操作，适合开发者在进行长时间运算时监控任务状态。"
            },
            {
                "content": "- 第一行: 域名为“description”，其说明是“任务描述”，数据类型为字符串。\n- 第二行: 域名为“time_elapsed”，其说明是“任务已经执行的时间，单位为秒”，数据类型为浮点数。\n- 第三行: 域名为“task_id”，其说明是“任务 ID”，数据类型为字符串。\n\n总体来看，该表格定义了与任务相关的三个字段，包括对任务的描述、执行时间及其标识符。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/task\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        [\n            {\n                \"description\" : \"[CPP_PLUGIN] scan_graph\",\n                \"time_elapsed\" : 13.987,\n                \"task_id\" : \"3_10\"\n            },\n            {\n                \"description\" : \"[CYPHER] MATCH(n) return n\",\n                \"time_elapsed\" : 30.887,\n                \"task_id\" : \"2_6\"\n            }\n        ]\n    }\n```\n\n#### 6.4.2.中止任务\n\n- **URI**: `/task/{task_id}`\n  其中 `{task_id}` 是 `GET /task` 返回结果中的 `task_id`。\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n该块内容位于文档的第6.4节“任务管理”中，具体描述了查询正在执行的任务的请求与响应格式，包括任务的描述、执行时间和任务ID。该部分还提供了示例请求和响应，以帮助开发者理解如何通过API接口管理和查看任务。"
            },
            {
                "content": "#### 6.4.2.中止任务\n\n- **URI**: `/task/{task_id}`\n  其中 `{task_id}` 是 `GET /task` 返回结果中的 `task_id`。\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/task/3_10\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n### 6.5.子图管理\n\nTuGraph 支持多子图，子图之间完全独立，不同的子图可以对不同用户开放不同权限。管理员可以添加和删除子图。\n\n#### 6.5.1.创建新子图\n\n- **URI**: `/db`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | name | 子图名 | 字符串 |\n  | config | 配置 | 字典，格式为 { {列名 1}:{列值 1},... } |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n        \"name\":\"graph1\",\n        \"config\" : {\n            \"max_size_GB\":2048,\n            \"description\": \"description of graph1\"\n        }\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.5.2.删除子图\n\n该片段位于文档的第6部分，主要讨论任务管理和子图管理。在中止任务部分，介绍了如何通过特定的URI和HTTP方法删除正在执行的任务，并提供了示例请求和响应。接下来的子图管理部分则详细说明了TuGraph对多子图的支持，包括创建和删除子图的具体操作及其请求格式。"
            },
            {
                "content": "- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n        \"name\":\"graph1\",\n        \"config\" : {\n            \"max_size_GB\":2048,\n            \"description\": \"description of graph1\"\n        }\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.5.2.删除子图\n\n- **URI**: `/db/{graph_name}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/db/graph1\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.5.3.列出所有子图\n\n- **URI**: `/db`\n- **METHOD**: GET\n- **RESPONSE**: 子图列表\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"graph1\": {\n            \"max_size_GB\":1024,\n            \"description\":\"description of graph1\"\n        }\n    }\n```\n\n#### 6.5.4.获取子图信息\n\n该片段位于文档的第6.5节，主要介绍子图管理相关的API，包括创建子图、删除子图、列出所有子图以及获取特定子图的信息。这部分内容详细描述了不同API请求的URI、请求方式、请求与响应格式示例，旨在帮助开发者理解如何操作和管理子图。"
            },
            {
                "content": "```\n    • DELETE http://localhost:7070/db/graph1\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.5.3.列出所有子图\n\n- **URI**: `/db`\n- **METHOD**: GET\n- **RESPONSE**: 子图列表\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"graph1\": {\n            \"max_size_GB\":1024,\n            \"description\":\"description of graph1\"\n        }\n    }\n```\n\n#### 6.5.4.获取子图信息\n\n- **URI**: `/db/{graph_name}`\n- **METHOD**: GET\n- **RESPONSE**: 子图列表\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"max_size_GB\":1024,\n        \"description\":\"description of graph1\"\n    }\n```\n\n### 6.6.元数据管理\n\nTuGraph 是一个具备多图能力的强模式属性图数据库。在每一张子图中，每种点和边都需要有预定义的数据格式。数据格式由 Label 决定，每种 Label 都有自己的数据格式。用户可以使用 REST API 添加，删除和查询 Label 及其对应的数据格式。\n\nLabel 操作对应的 URI 格式为\n\n该块内容位于文档的第6.5节\"子图管理\"中，具体描述了子图的删除、列出所有子图以及获取特定子图信息的API接口及示例请求和响应，属于TuGraph RESTful API的操作部分。"
            },
            {
                "content": "- **URI**: `/db/{graph_name}`\n- **METHOD**: GET\n- **RESPONSE**: 子图列表\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"max_size_GB\":1024,\n        \"description\":\"description of graph1\"\n    }\n```\n\n### 6.6.元数据管理\n\nTuGraph 是一个具备多图能力的强模式属性图数据库。在每一张子图中，每种点和边都需要有预定义的数据格式。数据格式由 Label 决定，每种 Label 都有自己的数据格式。用户可以使用 REST API 添加，删除和查询 Label 及其对应的数据格式。\n\nLabel 操作对应的 URI 格式为\n\n```\n    http://{host}:{port}/db/{graph_name}/label/{type}/{label_name}\n```\n\n其中{type}可以是 node 或者 relationship。\n\n#### 6.6.1.创建Label\n\n创建 Label 的过程同时也是定义其数据类型的过程。只有创建了 Label 才能在图中插入相应类型的点或者边。\n\n- **URI**: `/db/{graph_name}/label`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | name | Label 名 | 字符串 |\n  | fields | 数据列定义 | 列表 |\n  | is_vertex | 是否是点 Label | 布尔值 |\n  | primary | 点的主键属性 | 字符串 |\n  | edge_constraints | 边的约束 | 列表 |\n\n`primary` 在 `is_vertex` 为 `true` 的时候设置，这个字段只有点才有, 创建点的时候必须设置。\n\n该内容片段位于文档的第6.5节\"子图管理\"和第6.6节\"元数据管理\"之间，详细描述了获取单个子图信息的请求格式及示例，主要涵盖URI、请求方法和预期的响应内容，以便用户理解如何通过API访问和管理子图。"
            },
            {
                "content": "其中{type}可以是 node 或者 relationship。\n\n#### 6.6.1.创建Label\n\n创建 Label 的过程同时也是定义其数据类型的过程。只有创建了 Label 才能在图中插入相应类型的点或者边。\n\n- **URI**: `/db/{graph_name}/label`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | name | Label 名 | 字符串 |\n  | fields | 数据列定义 | 列表 |\n  | is_vertex | 是否是点 Label | 布尔值 |\n  | primary | 点的主键属性 | 字符串 |\n  | edge_constraints | 边的约束 | 列表 |\n\n`primary` 在 `is_vertex` 为 `true` 的时候设置，这个字段只有点才有, 创建点的时候必须设置。\n\n`edge_constraints` 在 `is_vertex` 为 `false` 的时候设置，这个字段只有边有。这个字段限制了该边的起点和终点只能是哪些点的组合，比如：`[[\"vertex_label1\",\"vertex_label2\"],[\"vertex_label3\",\"vertex_label4\"]]`，限制了该边只能是从 `vertex_label1` 到 `vertex_label2` 和 从 `vertex_label3` 到 `vertex_label4`。如果不想有任何限制，不设置该字段即可。\n\n其中`fields`为一个数组，其中每个元素定义数据的一列，内容如下：\n\n该段落位于文档的第6章“元数据管理”中，具体介绍了如何创建一个Label（标签）以定义节点或边的数据类型。在此部分，详细列出了创建Label所需的URI、HTTP方法、请求参数以及相关约束，强调了Label在图数据库中插入相应类型的点或边的重要性。"
            },
            {
                "content": "其中`fields`为一个数组，其中每个元素定义数据的一列，内容如下：\n\n| 域名     | 说明                                     | 类型                                                                                                |\n| -------- | ---------------------------------------- | --------------------------------------------------------------------------------------------------- |\n| name     | 列名                                     | 字符串                                                                                              |\n| type     | 列数据类型                               | 字符串，有以下类型： int8, int16, int32, int64, float, double, string, date, datetime, binary, bool |\n| optional | 数据是否可以为空（可选，缺省值为 false） | 布尔值                                                                                              |\n表格内容描述: \n\n该表格包含三个列名：域名、说明和类型。\n\n该文本块位于文档的第6.6.1节，主要介绍了创建Label时所需的字段`fields`的详细定义，包括每列的名称、类型及其说明。这部分内容对于理解如何在TuGraph中定义数据模型至关重要。"
            },
            {
                "content": "该表格包含三个列名：域名、说明和类型。 \n\n第一行数据为“name”，其说明为“列名”，数据类型为“字符串”。 \n第二行数据为“type”，其说明为“列数据类型”，数据类型为“字符串”，可取的值包括：int8、int16、int32、int64、float、double、string、date、datetime、binary 和 bool。 \n第三行数据为“optional”，其说明为“数据是否可以为空（可选，缺省值为 false）”，数据类型为“布尔值”。 \n\n总体来看，这个表格定义了一些数据字段的基本信息，包括字段名称、其说明以及数据类型和可选性的信息。\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/{graph_name}/label\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n        \"name\":\"Actor\",\n        \"fields\": [\n                {\"name\":\"uid\", \"type\":\"int64\", \"optional\":false},\n                {\"name\":\"name\", \"type\":\"string\", \"optional\":true}\n        ],\n        \"is_vertex\":true,\n        \"primary\" : \"uid\"\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.6.2.列出所有 Label\n\n- **URI**: `/db/{graph_name}/label`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | edge | 边 Label 列表 | 列表 |\n  | vertex | 点 Label 列表 | 列表 |\n\n**Example request.**\n\n该信息来自于文档的第6.6节，主要描述了创建和管理图数据库中Label的相关操作，包括Label的字段定义及其数据类型，具体阐释了在创建Label时需要提供的参数及示例请求和响应格式。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.6.2.列出所有 Label\n\n- **URI**: `/db/{graph_name}/label`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | edge | 边 Label 列表 | 列表 |\n  | vertex | 点 Label 列表 | 列表 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/label\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"edge\": [\n            \"HAS_CHILD\",\n            \"MARRIED\",\n            \"BORN_IN\",\n            \"DIRECTED\",\n            \"WROTE_MUSIC_FOR\",\n            \"ACTED_IN\"\n        ],\n        \"vertex\": [\n            \"Person\",\n            \"City\",\n            \"Film\"\n        ]\n    }\n```\n\n#### 6.6.3.获取 Label 的数据格式定义\n\n- **URI**: `/db/{graph_name}/label/{[node|relationship]}/{label_name}`\n- **METHOD**: GET\n- **RESPONSE**: 数据列定义表，类型是一个词典，key 为列名，value 为列定义，列定义见如下：\n-\n\n该部分内容位于文档的第6.6节，主要介绍了TuGraph图数据库中Label的管理，包括如何列出所有Label以及获取特定Label的数据格式定义。这段内容提供了相关的URI、请求方法及示例，请求和响应的格式，帮助用户理解如何操作和查询Label信息。"
            },
            {
                "content": "#### 6.6.3.获取 Label 的数据格式定义\n\n- **URI**: `/db/{graph_name}/label/{[node|relationship]}/{label_name}`\n- **METHOD**: GET\n- **RESPONSE**: 数据列定义表，类型是一个词典，key 为列名，value 为列定义，列定义见如下：\n-\n\n| 域名     | 说明             | 类型   |\n| -------- | ---------------- | ------ |\n| optional | 该列值是否可为空 | 布尔值 |\n| type     | 列值类型         | 字符串 |\n表格内容描述:\n该表格包含三列，分别为：域名、说明和类型。\n\n第一行数据：\n- 域名为 \"optional\"，说明为 \"该列值是否可为空\"，类型为 \"布尔值\"。\n\n第二行数据：\n- 域名为 \"type\"，说明为 \"列值类型\"，类型为 \"字符串\"。\n\n总体来看，这个表格主要用于定义两个字段的属性信息，其中\"optional\"字段表示该值是否可以为空，数据类型为布尔值；而\"type\"字段则描述列值的数据类型，数据类型为字符串。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/label/node/person\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n该块内容位于文档的第6.6节，专注于获取图数据库中Label的数据格式定义。它详细描述了如何通过HTTP GET请求获取特定Label的列定义，包括每列的可空性和数据类型，旨在帮助用户理解和使用图数据库的标签结构。"
            },
            {
                "content": "第一行数据：\n- 域名为 \"optional\"，说明为 \"该列值是否可为空\"，类型为 \"布尔值\"。\n\n第二行数据：\n- 域名为 \"type\"，说明为 \"列值类型\"，类型为 \"字符串\"。\n\n总体来看，这个表格主要用于定义两个字段的属性信息，其中\"optional\"字段表示该值是否可以为空，数据类型为布尔值；而\"type\"字段则描述列值的数据类型，数据类型为字符串。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/label/node/person\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"age\":{\n            \"optional\":false,\n            \"type\":\"int16\"\n        },\n        \"id\":{\n            \"optional\":false,\n            \"type\":\"int8\"\n        },\n        \"name\":{\n            \"optional\":false,\n            \"type\":\"string\"\n        }\n    }\n```\n\n#### 6.6.4.Schema 导入\n\n- **URI**: `/db/{graph_name}/schema/text`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | description | 文件内容描述 | 字符串 |\n\ndescription 的具体描述方法见《TuGraph 操作手册》中数据导入配置文件的相关内容。\n\n- **RESPONSE**:\n\n该块内容位于文档的第6节“元数据管理”下，具体涉及到创建Label时的数据格式定义，包括字段的可为空性和数据类型。此部分解释了Label的结构和相应的数据约束，有助于用户理解点和边的属性设置。"
            },
            {
                "content": "#### 6.6.4.Schema 导入\n\n- **URI**: `/db/{graph_name}/schema/text`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | description | 文件内容描述 | 字符串 |\n\ndescription 的具体描述方法见《TuGraph 操作手册》中数据导入配置文件的相关内容。\n\n- **RESPONSE**:\n\nSchema 导入会根据 description 比较新的 Schema 和数据库中原有的 Schema 是否兼容，检查的粒度为 Label。如果不一致则出错，如果一致则添加原先 Schema 中不存在的 Label，返回 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/graph1/schema/text\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n      \"description\": \"{\\\\\"schema\\\\\":[{\\\\\"label\\\\\":\\\\\"actor\\\\\",\\\\\"primary\\\\\":\\\\\"aid\\\\\",\\\\\"properties\\\\\":[{\\\\\"name\\\\\":\\\\\"aid\\\\\",\\\\\"type\\\\\":\\\\\"STRING\\\\\"}],\\\\\"type\\\\\":\\\\\"VERTEX\\\\\"}]}\"\n    }\n```\n\n上述 description 的值是如下 json 序列化后的字符串:\n\n```json\n{\n  \"schema\": [\n    {\n      \"label\": \"actor\",\n      \"type\": \"VERTEX\",\n      \"properties\": [{ \"name\": \"aid\", \"type\": \"STRING\" }],\n      \"primary\": \"aid\"\n    }\n  ]\n}\n```\n\n**Example response.**\n\n该段落位于文档的\"6.6.元数据管理\"部分，具体描述了如何通过REST API导入图数据库的Schema，包括文件内容描述的格式要求及响应示例，适用于用户在创建或修改图的结构时使用。"
            },
            {
                "content": "上述 description 的值是如下 json 序列化后的字符串:\n\n```json\n{\n  \"schema\": [\n    {\n      \"label\": \"actor\",\n      \"type\": \"VERTEX\",\n      \"properties\": [{ \"name\": \"aid\", \"type\": \"STRING\" }],\n      \"primary\": \"aid\"\n    }\n  ]\n}\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        \"log\": \"\"\n    }\n```\n\n### 6.7.点操作\n\nURI 格式为\n\n```\n    http://{host}:{port}/db/{graph_name}/node/{vid}\n```\n\nNodes 提供节点（Vertex）的 CRUD 操作，接受 GET/POST/PUT/DELETE 请求。\n\n#### 6.7.1.列出点数量和label数量\n\n- **URI**: `/db/{graph_name}/node`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | num_label | 点 label 数量 | 整数 |\n  | num_vertex | 点数量 | 整数 |\n\n_注意 num_vertex 返回的并不是准确的点数量，只是一个估计值。_\n\n#### 6.7.2.创建一个点\n\n向数据库中插入一个点。\n\n- **URI**: `/db/{graph_name}/node`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | label | Label 名 | 字符串 |\n  | property | 点属性 | 字典，其中 key 是列名，value 是相应值。value 必须是与列类型相应的类型，如列为 int32，则 value 只能是整数。 |\n\n- **RESPONSE**: 如果成功，返回代码 200。并在 JSON 内容中返回新点 vid。该 ID 可用于后续的点操作中。\n\n该文本块位于文档的第6.10节中，讨论了在TuGraph中进行数据导入的示例，包括JSON格式的描述信息，以及对节点操作（点的创建、数量查询等）的说明。这部分内容紧接着描述数据导入的示例，涵盖了与图数据库中节点相关的各种操作指令和响应格式。"
            },
            {
                "content": "_注意 num_vertex 返回的并不是准确的点数量，只是一个估计值。_\n\n#### 6.7.2.创建一个点\n\n向数据库中插入一个点。\n\n- **URI**: `/db/{graph_name}/node`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | label | Label 名 | 字符串 |\n  | property | 点属性 | 字典，其中 key 是列名，value 是相应值。value 必须是与列类型相应的类型，如列为 int32，则 value 只能是整数。 |\n\n- **RESPONSE**: 如果成功，返回代码 200。并在 JSON 内容中返回新点 vid。该 ID 可用于后续的点操作中。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/{graph_name}/node\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n        \"label\" : \"Person\",\n        \"property\" : {\n            \"name\" : \"Passerby A\",\n            \"birthyear\" : 1989\n        }\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        21\n    }\n```\n\n#### 6.7.3.批量创建点\n\nTuGraph 允许一次性插入多个点，以减少网络开销。\n\n此段落位于文档的第6.7节，专注于图数据库中点的操作，具体描述了如何创建一个点以及批量创建点的请求格式和示例，提供了点的URI、请求方法、请求参数与响应格式的详细信息。同时提醒用户关于返回点数量的注意事项。"
            },
            {
                "content": "**Example request.**\n\n```\n    • POST http://localhost:7070/db/{graph_name}/node\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n        \"label\" : \"Person\",\n        \"property\" : {\n            \"name\" : \"Passerby A\",\n            \"birthyear\" : 1989\n        }\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        21\n    }\n```\n\n#### 6.7.3.批量创建点\n\nTuGraph 允许一次性插入多个点，以减少网络开销。\n\n- **URI**: `/db/{graph_name}/node`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | label | Label 名 | 字符串 |\n  | fields | 点属性 | 列表 |\n  | values | 点数据 | 列表 |\n\n其中 fields 是一个字符串列表，列出一系列列名；values 是一个列表，其中每个元素是一个列表，列表中每个元素是列数据。\n\n- **RESPONSE**: 如果成功，返回代码 200。并在 JSON 内容中返回新增加的点的 vid 列表，该列表中每一个 vid 按顺序对应请求中的每一个点。\n\n**Example request.**\n\n该内容位于文档的第六章（6.7.2）中，介绍了在 TuGraph 数据库中创建一个点的示例请求和响应，紧接着是批量创建点的操作说明及其相关示例。这一部分详细描述了如何通过 RESTful API 向数据库中插入单个或多个点。"
            },
            {
                "content": "#### 6.7.3.批量创建点\n\nTuGraph 允许一次性插入多个点，以减少网络开销。\n\n- **URI**: `/db/{graph_name}/node`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | label | Label 名 | 字符串 |\n  | fields | 点属性 | 列表 |\n  | values | 点数据 | 列表 |\n\n其中 fields 是一个字符串列表，列出一系列列名；values 是一个列表，其中每个元素是一个列表，列表中每个元素是列数据。\n\n- **RESPONSE**: 如果成功，返回代码 200。并在 JSON 内容中返回新增加的点的 vid 列表，该列表中每一个 vid 按顺序对应请求中的每一个点。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/{graph_name}/node\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n        \"label\" : \"Person\",\n        \"fields\" : [\"name\", \"birthyear\"],\n        \"values\" : [[\"alex\", 2000],\n                    [\"bob\", 1999]]\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        [\n            22,\n            23\n        ]\n    }\n```\n\n#### 6.7.4.获取点\n\n该段落位于文档的第6.7节，主要描述如何在TuGraph中批量创建多个点，以减少网络开销。这部分内容详细说明了相关的URI、请求方法、请求参数及响应格式，为开发者提供了具体的操作示例。此节是关于点操作的子部分，接下来介绍获取点的操作。"
            },
            {
                "content": "```\n    • POST http://localhost:7070/db/{graph_name}/node\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n        \"label\" : \"Person\",\n        \"fields\" : [\"name\", \"birthyear\"],\n        \"values\" : [[\"alex\", 2000],\n                    [\"bob\", 1999]]\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        [\n            22,\n            23\n        ]\n    }\n```\n\n#### 6.7.4.获取点\n\n- **URI**: `/db/{graph_name}/node/{vertex_id}`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | label | Label 名 | 字符串 |\n  | property | 属性 | 字典，格式为 { {列名 1}:{列值 1},...} |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/node/5\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n该块内容位于文档的第六部分“6.7.2.批量创建点”下，具体描述了如何通过 REST API 批量创建图数据库中的点，并提供了相应的请求示例和响应格式。此部分紧接着批量创建点的介绍，进一步说明获取特定点信息的请求和响应格式。"
            },
            {
                "content": "#### 6.7.4.获取点\n\n- **URI**: `/db/{graph_name}/node/{vertex_id}`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | label | Label 名 | 字符串 |\n  | property | 属性 | 字典，格式为 { {列名 1}:{列值 1},...} |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/node/5\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"property\": {\n            \"birthyear\": 1963,\n            \"name\": \"Natasha Richardson\"\n        },\n        \"label\": \"Person\"\n    }\n```\n\n#### 6.7.5.删除点\n\n- **URI**: `/db/{graph_name}/node/{vertex_id}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | in | 被删掉的点的入边数量 | 整数值 |\n  | out | 被删掉的点的出边数量 | 整数值 |\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/db/{graph_name}/node/4\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n该块内容位于文档的第6.7节，主要描述了在TuGraph中获取和删除点的操作，包括获取指定点的信息及其属性，以及通过点的ID删除该点，从而帮助用户理解如何管理图数据库中的节点。"
            },
            {
                "content": "#### 6.7.5.删除点\n\n- **URI**: `/db/{graph_name}/node/{vertex_id}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | in | 被删掉的点的入边数量 | 整数值 |\n  | out | 被删掉的点的出边数量 | 整数值 |\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/db/{graph_name}/node/4\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"in\": 0,\n        \"out\": 0\n    }\n```\n\n#### 6.7.6.获取点所有属性\n\n- **URI**: `/db/{graph_name}/node/{vertex_id}/property`\n- **METHOD**: GET\n- **RESPONSE**: Node 所有属性（字典）\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/node/5/property\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"birthyear\": 1963,\n        \"name\": \"Natasha Richardson\"\n    }\n```\n\n#### 6.7.7.获取点属性\n\n该片段位于文档的第6.7节，主要描述了与点（节点）操作相关的API，包括删除点、获取点所有属性以及获取特定点属性的请求和响应格式。这部分内容有助于用户理解如何通过TuGraph的RESTful API对图数据库中的节点进行管理和操作。"
            },
            {
                "content": "#### 6.7.6.获取点所有属性\n\n- **URI**: `/db/{graph_name}/node/{vertex_id}/property`\n- **METHOD**: GET\n- **RESPONSE**: Node 所有属性（字典）\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/node/5/property\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"birthyear\": 1963,\n        \"name\": \"Natasha Richardson\"\n    }\n```\n\n#### 6.7.7.获取点属性\n\n- **URI**: `/db/{graph_name}/node/{vertex_id}/property/{field}`\n- **METHOD**: GET\n- **RESPONSE**: Node 某一属性\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/node/5/property/name\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"Natasha Richardson\"\n    }\n```\n\n#### 6.7.8.更新点属性\n\n该块内容位于文档的第六部分\"子图管理\"中的第七小节\"点操作\"部分，具体描述了如何获取节点的所有属性和单个属性，以及如何更新节点属性的相关API请求和响应示例。这部分内容帮助用户了解在TuGraph数据库中进行节点属性的检索和更新操作。"
            },
            {
                "content": "#### 6.7.7.获取点属性\n\n- **URI**: `/db/{graph_name}/node/{vertex_id}/property/{field}`\n- **METHOD**: GET\n- **RESPONSE**: Node 某一属性\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/node/5/property/name\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"Natasha Richardson\"\n    }\n```\n\n#### 6.7.8.更新点属性\n\n- **URI**: `/db/{graph_name}/node/{vertex_id}`\n- **METHOD**: PUT\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | property | 点属性 | 字典 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • PUT http://localhost:7070/db/{graph_name}/node/5\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n      \"property\" : {\n        \"birthyear\" : 1964,\n        \"mobile\" : \"********\"\n      }\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n### 6.8.边操作\n\nURI 格式为\n\n该块内容位于文档的第6章\"点操作\"部分，主要介绍如何获取和更新图数据库中节点的属性，包括获取单个属性的URI与响应示例，以及更新节点属性的具体请求格式和示例响应。"
            },
            {
                "content": "- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • PUT http://localhost:7070/db/{graph_name}/node/5\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n      \"property\" : {\n        \"birthyear\" : 1964,\n        \"mobile\" : \"********\"\n      }\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n### 6.8.边操作\n\nURI 格式为\n\n```\n    http://{host}:{port}/db/{graph_name}/relationship/{euid}\n```\n\n与 Nodes 功能类似，Relationships 提供边（edge）的 CRUD 操作，接受 GET/POST/PUT/DELETE 请求。每一条边都可以由一个唯一 ID（euid）来标识。这个 ID 可以从在插入边时获得，或者在 [列出所有边](#%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E8%BE%B9) 操作中得到。\n\n#### 6.8.1.创建一条边\n\n- **URI**: `/db/{graph_name}/node/{src}/relationship`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | label | 边 Label | 字符串 |\n  | destination | 目的点 ID | 整数值 |\n  | property | 边属性 | 字典 |\n\n- **RESPONSE**: 如果成功，返回代码 200，同时返回新建立的边的 euid（字符串）。\n\n**Example request.**\n\n该片段位于文档的第6.8节，介绍了边操作的相关API，包括创建边、属性更新及获取等功能的请求和响应格式。此部分内容为用户如何操作图数据库中的边提供具体示例和详细说明。"
            },
            {
                "content": "与 Nodes 功能类似，Relationships 提供边（edge）的 CRUD 操作，接受 GET/POST/PUT/DELETE 请求。每一条边都可以由一个唯一 ID（euid）来标识。这个 ID 可以从在插入边时获得，或者在 [列出所有边](#%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E8%BE%B9) 操作中得到。\n\n#### 6.8.1.创建一条边\n\n- **URI**: `/db/{graph_name}/node/{src}/relationship`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | label | 边 Label | 字符串 |\n  | destination | 目的点 ID | 整数值 |\n  | property | 边属性 | 字典 |\n\n- **RESPONSE**: 如果成功，返回代码 200，同时返回新建立的边的 euid（字符串）。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/{graph_name}/node/{src}/relationship\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n      \"destination\" : 14,\n      \"label\" : \"BORN_IN\",\n      \"property\" : {}\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"1_14_1_0\"\n    }\n```\n\n#### 6.8.2.批量创建边\n\n该段落位于文档的第6.8节，主要描述了TuGraph数据库中关于边（edge）的操作，包括边的创建、批量创建等CRUD功能。此部分紧接着介绍点的操作后，强调了边是如何与点建立联系并进行管理的。"
            },
            {
                "content": "- **RESPONSE**: 如果成功，返回代码 200，同时返回新建立的边的 euid（字符串）。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/{graph_name}/node/{src}/relationship\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n      \"destination\" : 14,\n      \"label\" : \"BORN_IN\",\n      \"property\" : {}\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"1_14_1_0\"\n    }\n```\n\n#### 6.8.2.批量创建边\n\n- **URI**: `/db/{graph_name}/relationship`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | label | 边 Label | 字符串 |\n  | fields | 数据列名 | 列表 |\n  | edge | 边数据 | 列表 |\n\n其中 edge 是一个数据列表，其中每个元素都是一条边，其定义如下：\n\n该段落位于有关边操作的部分，主要描述了如何创建一条边及其响应示例，属于TuGraph REST API文档中与边的增删改查相关的功能描述。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"1_14_1_0\"\n    }\n```\n\n#### 6.8.2.批量创建边\n\n- **URI**: `/db/{graph_name}/relationship`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | label | 边 Label | 字符串 |\n  | fields | 数据列名 | 列表 |\n  | edge | 边数据 | 列表 |\n\n其中 edge 是一个数据列表，其中每个元素都是一条边，其定义如下：\n\n| 域名        | 说明     | 类型                                                   |\n| ----------- | -------- | ------------------------------------------------------ |\n| source      | 起点 id  | 整数                                                   |\n| destination | 终点 id  | 整数                                                   |\n| values      | 数据列表 | 列表，每列对应 fields 中的一个列，类型是该列对应的类型 |\n表格内容描述：该表格包含三个列名，分别是“域名”、“说明”和“类型”。 \n\n- 第一行数据为“source”，说明为“起点 id”，其类型为“整数”。\n- 第二行数据为“destination”，说明为“终点 id”，同样类型为“整数”。\n- 第三行数据为“values”，说明为“数据列表”，其类型为“列表”，并且每列数据对应于“fields”中的一个列，类型为该列对应的类型。\n\n该块内容位于“6.8.边操作”章节中，具体描述了通过 POST 请求批量创建边的操作流程以及请求和响应的格式，旨在指导用户如何在 TuGraph 数据库中一次性插入多条边数据。"
            },
            {
                "content": "- 第一行数据为“source”，说明为“起点 id”，其类型为“整数”。\n- 第二行数据为“destination”，说明为“终点 id”，同样类型为“整数”。\n- 第三行数据为“values”，说明为“数据列表”，其类型为“列表”，并且每列数据对应于“fields”中的一个列，类型为该列对应的类型。\n\n总体而言，该表格概述了源和目的地的标识符（均为整数）以及与之相关的数据列表的结构，这些数据列表中每列的具体类型取决于所涉及的字段。\n\n- **RESPONSE**: 如果成功，返回代码 200，同时返回新建立的边的 euid 列表。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/{graph_name}/relationship\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n      \"label\" : \"knows\",\n      \"fields\" : [\"from_year\", \"weight\"],\n      \"edge\" : [\n          {\"source\":0, \"destination\":1, \"values\":[2011, 0.8]},\n          {\"source\":1, \"destination\":2, \"values\":[2008, 0.9]}\n      ]\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        [\n            \"0_1_0_0\",\n            \"1_2_0_0\"\n        ]\n    }\n```\n\n#### 6.8.3.列出所有出边（outgoing relationships）\n\n该段落位于文档的第6.8节“边操作”中，具体描述了在创建边时的请求格式及其属性定义，包括起点和终点的标识符、数据列的结构，以及成功响应时返回的边的唯一标识符（euid）列表。这一部分为用户提供了创建边及其属性的详细指导，帮助实现图数据库中的边操作。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        [\n            \"0_1_0_0\",\n            \"1_2_0_0\"\n        ]\n    }\n```\n\n#### 6.8.3.列出所有出边（outgoing relationships）\n\n- **URI**: `/db/{graph_name}/node/{src}/relationship/out`\n- **METHOD**: GET\n- **RESPONSE**: 点 src 的所有出边 euid 列表\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/node/4/relationship/out\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        [\n            \"4_5_0_0\",\n            \"4_7_1_2\"\n        ]\n    }\n```\n\n#### 6.8.4.列出所有入边（incoming relationships）\n\n- **URI**: `/db/{graph_name}/node/{dst}/relationship/in`\n- **METHOD**: GET\n- **RESPONSE**: 点 dst 的所有入边 euid 列表\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/node/4/relationship/in\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n该块内容位于文档的第6.8节，专门介绍与边操作相关的API，包括如何列出指定节点的出边和入边，以及相应的示例请求和响应格式。此部分提供了API使用者获取边信息的基本方法。"
            },
            {
                "content": "```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        [\n            \"4_5_0_0\",\n            \"4_7_1_2\"\n        ]\n    }\n```\n\n#### 6.8.4.列出所有入边（incoming relationships）\n\n- **URI**: `/db/{graph_name}/node/{dst}/relationship/in`\n- **METHOD**: GET\n- **RESPONSE**: 点 dst 的所有入边 euid 列表\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/node/4/relationship/in\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        [\n            \"0_4_0_0\",\n            \"3_4_3_1\"\n        ]\n    }\n```\n\n#### 6.8.5.列出所有边\n\n- **URI**: `/db/{graph_name}/node/{src}/relationship/all`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | in | 入边 | 列表 |\n  | out | 出边 | 列表 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/node/4/relationships/all\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n该片段位于文档第6.8节“边操作”中，具体描述了通过URI获取点的所有入边和出边的请求和响应示例，进一步阐明了如何列出与特定节点相关的所有边的操作。"
            },
            {
                "content": "#### 6.8.5.列出所有边\n\n- **URI**: `/db/{graph_name}/node/{src}/relationship/all`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | in | 入边 | 列表 |\n  | out | 出边 | 列表 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/{graph_name}/node/4/relationships/all\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"out\": [\n            \"4_5_0_0\",\n            \"4_7_1_2\"\n        ],\n        \"in\": [\n            \"0_4_0_0\",\n            \"3_4_3_1\"\n        ]\n    }\n```\n\n#### 6.8.6.获取边\n\n- **URI**: `/db/{graph_name}/relationship/{euid}`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | label | 边 Label | 字符串 |\n  | property | 边属性 | 字典 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/relationship/0_4_0_0\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n该块内容位于文档的第6.8节，主要介绍了图数据库中边操作的相关接口，包括列出所有边、获取边的详细信息等功能，属于对数据库中实体之间关系的管理部分。"
            },
            {
                "content": "#### 6.8.6.获取边\n\n- **URI**: `/db/{graph_name}/relationship/{euid}`\n- **METHOD**: GET\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | label | 边 Label | 字符串 |\n  | property | 边属性 | 字典 |\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/relationship/0_4_0_0\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"property\": {\n        },\n        \"label\": \"MARRIED\"\n    }\n```\n\n#### 6.8.7.删除边\n\n- **URI**: `/db/{graph_name}/relationship/{euid}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/db/graph1/relationship/14_0_1_0\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.8.8.获取边的所有属性\n\n- **URI**: `/db/{graph_name}/relationship/{euid}/property`\n- **METHOD**: GET\n- **RESPONSE**: 边属性字典\n\n**Example request.**\n\n该摘要位于文档的第6.8节，主要介绍了TuGraph中边操作的相关接口，包括获取边的详细信息、删除边、获取边的所有属性等。"
            },
            {
                "content": "#### 6.8.7.删除边\n\n- **URI**: `/db/{graph_name}/relationship/{euid}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/db/graph1/relationship/14_0_1_0\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.8.8.获取边的所有属性\n\n- **URI**: `/db/{graph_name}/relationship/{euid}/property`\n- **METHOD**: GET\n- **RESPONSE**: 边属性字典\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/relationship/14_0_2_0/property\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        {\n            \"weight\": 0.8,\n            \"begin\": 20180922\n        }\n    }\n```\n\n#### 6.8.9.获取边的属性\n\n- **URI**: `/db/{graph_name}/relationship/{euid}/property/{field}`\n- **METHOD**: GET\n- **RESPONSE**: 如果成功,返回代码 200,同时返回边的属性。如果失败,返回代码 400,同时返回 \"Illegal field.\"。\n\n**Example request.**\n\n该块内容位于文档的第6.8节，主要介绍边操作的相关接口，包括删除边、获取边的所有属性以及获取边的特定属性。这些操作允许用户对图数据库中的边进行管理和查询，适用于在图数据库中进行边的维护和数据访问。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        {\n            \"weight\": 0.8,\n            \"begin\": 20180922\n        }\n    }\n```\n\n#### 6.8.9.获取边的属性\n\n- **URI**: `/db/{graph_name}/relationship/{euid}/property/{field}`\n- **METHOD**: GET\n- **RESPONSE**: 如果成功,返回代码 200,同时返回边的属性。如果失败,返回代码 400,同时返回 \"Illegal field.\"。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/relationship/17_0_2_2/property/charactername\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"Henri Ducard\"\n    }\n```\n\n#### 6.8.10.更新边的属性\n\n- **URI**: `/db/{graph_name}/relationship/{euid}`\n- **METHOD**: PUT\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | property | 边属性 | 字典 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n该chunk位于文档第6.8节“边操作”中，详细描述了获取边的属性和更新边属性的API接口。它提供了获取指定边的属性值的示例响应，以及更新边属性的URI和请求格式，展示了如何使用RESTful API进行边的管理。"
            },
            {
                "content": "```\n    • GET http://localhost:7070/db/graph1/relationship/17_0_2_2/property/charactername\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        \"Henri Ducard\"\n    }\n```\n\n#### 6.8.10.更新边的属性\n\n- **URI**: `/db/{graph_name}/relationship/{euid}`\n- **METHOD**: PUT\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | property | 边属性 | 字典 |\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • PUT http://localhost:7070/db/graph1/relationship/17_0_2_2\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n      \"property\" : {\n        \"charactername\" : \"Henri Ducard/passer a\"\n      }\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n### 6.9.索引\n\nURI 格式为\n\n```\n    http://{host}:{port}/db/{graph_name}/index/{label}/{field}\n```\n\n提供索引操作，接受 GET/POST 请求。\n\n#### 6.9.1.创建索引\n\n该操作会启动一个创建索引的后台任务，用户可以通过列出该 Label 相关的所有索引来检查新建索引的状态。\n\n该片段位于文档的第6.8节“边操作”中，具体介绍了如何获取边的某个属性和更新边的属性，包括相关的请求示例和响应示例。这一部分主要展示了对于图数据库中边的管理和操作方法。"
            },
            {
                "content": "```\n    • PUT http://localhost:7070/db/graph1/relationship/17_0_2_2\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n      \"property\" : {\n        \"charactername\" : \"Henri Ducard/passer a\"\n      }\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n### 6.9.索引\n\nURI 格式为\n\n```\n    http://{host}:{port}/db/{graph_name}/index/{label}/{field}\n```\n\n提供索引操作，接受 GET/POST 请求。\n\n#### 6.9.1.创建索引\n\n该操作会启动一个创建索引的后台任务，用户可以通过列出该 Label 相关的所有索引来检查新建索引的状态。\n\n- **URI**: `/db/{graph_name}/index`\n- **METHOD**: POST\n- **REQUEST**:\n\n| 域名    | 说明     | 类型                                  |\n|-------|--------|-------------------------------------|\n| label | Label 名 | 字符串                                 |\n| field | 域名     | 字符串                                 |\n| type  | 索引类型   | int类型，0表示非唯一索引，1表示全局唯一索引，2表示两点间唯一索引 |\n表格内容描述:\n该表格包含三列，分别为“域名”、“说明”和“类型”。\n\n该碎片位于文档的第六部分“6.8.边操作”中，具体描述了更新边属性的API调用示例及相关响应格式，紧接着是关于索引操作的介绍。此部分为用户提供如何修改边的属性信息的具体方法与请求示例。"
            },
            {
                "content": "提供索引操作，接受 GET/POST 请求。\n\n#### 6.9.1.创建索引\n\n该操作会启动一个创建索引的后台任务，用户可以通过列出该 Label 相关的所有索引来检查新建索引的状态。\n\n- **URI**: `/db/{graph_name}/index`\n- **METHOD**: POST\n- **REQUEST**:\n\n| 域名    | 说明     | 类型                                  |\n|-------|--------|-------------------------------------|\n| label | Label 名 | 字符串                                 |\n| field | 域名     | 字符串                                 |\n| type  | 索引类型   | int类型，0表示非唯一索引，1表示全局唯一索引，2表示两点间唯一索引 |\n表格内容描述:\n该表格包含三列，分别为“域名”、“说明”和“类型”。 \n\n- 第一行数据：域名为“label”，说明是“Label 名”，类型为“字符串”。\n- 第二行数据：域名为“field”，说明为“域名”，类型为“字符串”。\n- 第三行数据：域名为“type”，说明为“索引类型”，类型为“int类型，0表示非唯一索引，1表示全局唯一索引，2表示两点间唯一索引”。\n\n总体而言，该表格提供了关于不同域名的定义和数据类型的详细说明，其中“label”和“field”是字符串类型，而“type”提供了一种索引标识，用于区分索引的不同特性。\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/graph1/index\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n      \"label\": \"Person\",\n      \"field\": \"birthyear\",\n      \"is_unique\" : false\n    }\n```\n\n该块内容位于文档的第六章“索引”部分，详细说明了如何创建索引，包括相关的URI、请求方法、请求格式和响应说明，旨在指导用户如何在TuGraph中进行索引操作。"
            },
            {
                "content": "总体而言，该表格提供了关于不同域名的定义和数据类型的详细说明，其中“label”和“field”是字符串类型，而“type”提供了一种索引标识，用于区分索引的不同特性。\n\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/graph1/index\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json\n    Input:\n    {\n      \"label\": \"Person\",\n      \"field\": \"birthyear\",\n      \"is_unique\" : false\n    }\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.9.2.列出所有索引\n\n- **URI**: `/db/{graph_name}/index`\n- **METHOD**: GET\n- **RESPONSE**: 索引列表，其中每一个元素是一个索引描述，格式与[创建索引](#indexspec)时使用格式相同。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/index\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n该块内容位于文档的第6.9节，主要介绍了索引的创建和查询操作，包括如何创建索引、列出所有索引及其响应示例，目的是帮助用户理解和使用TuGraph中索引管理功能。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.9.2.列出所有索引\n\n- **URI**: `/db/{graph_name}/index`\n- **METHOD**: GET\n- **RESPONSE**: 索引列表，其中每一个元素是一个索引描述，格式与[创建索引](#indexspec)时使用格式相同。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/index\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        [\n            {\n                \"field\": \"name\",\n                \"label\": \"City\",\n                \"is_unique\": false\n            },\n            {\n                \"field\": \"title\",\n                \"label\": \"Film\",\n                \"is_unique\": false\n            },\n            {\n                \"field\": \"name\",\n                \"label\": \"Person\",\n                \"is_unique\": true\n            },\n            {\n                \"label\": \"Person\",\n                \"field\": \"age\",\n                \"is_unique\": false\n            }\n        ]\n    }\n```\n\n#### 6.9.3.列出所有与某个 Label 相关的索引\n\n该块内容位于文档的第6.9节中，具体讲述了关于索引的操作，包括列出所有索引的请求和响应示例，并提供详细的URI格式、请求方法及相应的返回数据结构。"
            },
            {
                "content": "#### 6.9.3.列出所有与某个 Label 相关的索引\n\n- **URI**: `/db/{graph_name}/index/{label}`\n- **METHOD**: GET\n- **RESPONSE**: 索引列表，其中每一个元素是一个索引描述，格式与[创建索引](#indexspec)时使用格式相同。\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/index/Person\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    • Content-Type: application/json; charset=UTF-8\n    Output:\n    {\n        [\n            {\n                \"label\": \"Person\",\n                \"field\": \"name\",\n                \"is_unique\": true\n            },\n            {\n                \"label\": \"Person\",\n                \"field\": \"age\",\n                \"is_unique\": false\n            }\n        ]\n    }\n```\n\n#### 6.9.4.删除索引\n\n- **URI**: `/db/{graph_name}/index/{label}/{field}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/db/graph1/index/Person/name\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.9.5.根据索引获取点\n\n该块内容位于文档的第6.9节，涵盖与图数据库中的索引管理相关的操作，包括列出所有与特定Label相关的索引、删除索引以及根据索引获取点的功能。"
            },
            {
                "content": "#### 6.9.4.删除索引\n\n- **URI**: `/db/{graph_name}/index/{label}/{field}`\n- **METHOD**: DELETE\n- **RESPONSE**: 如果成功，返回代码 200。\n\n**Example request.**\n\n```\n    • DELETE http://localhost:7070/db/graph1/index/Person/name\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.9.5.根据索引获取点\n\n- **URI**: `/db/{graph_name}/index/{label}/?field={field}&value={value}`\n- **METHOD**: GET\n- **RESPONSE**: 点 vid 列表\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/index/Person/?field=birthyear&value=1986\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        [\n            1,\n            8\n        ]\n    }\n```\n\n\n### 6.10.在线增量导入\n\n#### 6.10.1.指定文件内容导入\n\n该段落位于文档的第6部分，主要介绍了索引管理的相关操作，包括删除索引和根据索引获取点的功能。这些功能允许用户对图数据库中的索引进行管理，从而提高数据的检索效率。"
            },
            {
                "content": "**Example response.**\n\n```\n    • 200: OK\n```\n\n#### 6.9.5.根据索引获取点\n\n- **URI**: `/db/{graph_name}/index/{label}/?field={field}&value={value}`\n- **METHOD**: GET\n- **RESPONSE**: 点 vid 列表\n\n**Example request.**\n\n```\n    • GET http://localhost:7070/db/graph1/index/Person/?field=birthyear&value=1986\n    • Accept: application/json; charset=UTF-8\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        [\n            1,\n            8\n        ]\n    }\n```\n\n\n### 6.10.在线增量导入\n\n#### 6.10.1.指定文件内容导入\n\n- **URI**: `/db/{graph_name}/import/text`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | description | 文件内容描述 | 字符串 |\n  | data | 要导入的文件内容（建议最大在 16MB 左右，最长不超过 17MB） | 字符串 / 数组 / 对象 |\n  | continue_on_error | 出错后是否继续导入（可选，默认为`false`\n  ） | 布尔值 |\n  | delimiter | 分隔符（可选，默认为`“,”`\n  ） | 字符串 |\n\ndescription 的具体描述方法见《TuGraph 操作手册》中数据导入配置文件的相关内容。\n\n分隔符可以是单字符，也可以是字符串，但不能包含`\\r`或者`\\n`。\n\ndata 可以是如下形式之一：\n\n该代码段位于文档的第6.9节与索引相关的操作中，具体描述了根据索引获取点的功能及其请求和响应示例，紧接着是关于在线增量导入的相关内容，涵盖了如何指定文件内容进行导入。"
            },
            {
                "content": "### 6.10.在线增量导入\n\n#### 6.10.1.指定文件内容导入\n\n- **URI**: `/db/{graph_name}/import/text`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | description | 文件内容描述 | 字符串 |\n  | data | 要导入的文件内容（建议最大在 16MB 左右，最长不超过 17MB） | 字符串 / 数组 / 对象 |\n  | continue_on_error | 出错后是否继续导入（可选，默认为`false`\n  ） | 布尔值 |\n  | delimiter | 分隔符（可选，默认为`“,”`\n  ） | 字符串 |\n\ndescription 的具体描述方法见《TuGraph 操作手册》中数据导入配置文件的相关内容。\n\n分隔符可以是单字符，也可以是字符串，但不能包含`\\r`或者`\\n`。\n\ndata 可以是如下形式之一：\n\n- 字符串如 `\"1,2\\n3,4\\n\"`\n- ASCII 码组成的数组如 `[49,44,50,10,51,44,52,10]`\n- 形如上述数组的字典如 `{\"0\":49,\"1\":44,\"2\":50,\"3\":10,\"4\":51,\"5\":44,\"6\":52,\"7\":10}`\n\n- **RESPONSE**:\n\n系统**不会**自动执行新建 label、添加索引等操作。在此操作之前需要保证涉及的 label 已经存在并具有适当的索引。\n\n如果成功导入完毕，返回代码 200，并在 `log` 字段返回一些日志信息（可能为空）；否则，保证所有的数据均未被导入，并在 `error_message` 字段返回错误信息。\n\n**Example request.**\n\n该块内容位于文档第6章“在线增量导入”部分，主要介绍如何通过指定文件内容导入数据到TuGraph图数据库，包括请求的URI、方法、请求和响应的详细说明。"
            },
            {
                "content": "description 的具体描述方法见《TuGraph 操作手册》中数据导入配置文件的相关内容。\n\n分隔符可以是单字符，也可以是字符串，但不能包含`\\r`或者`\\n`。\n\ndata 可以是如下形式之一：\n\n- 字符串如 `\"1,2\\n3,4\\n\"`\n- ASCII 码组成的数组如 `[49,44,50,10,51,44,52,10]`\n- 形如上述数组的字典如 `{\"0\":49,\"1\":44,\"2\":50,\"3\":10,\"4\":51,\"5\":44,\"6\":52,\"7\":10}`\n\n- **RESPONSE**:\n\n系统**不会**自动执行新建 label、添加索引等操作。在此操作之前需要保证涉及的 label 已经存在并具有适当的索引。\n\n如果成功导入完毕，返回代码 200，并在 `log` 字段返回一些日志信息（可能为空）；否则，保证所有的数据均未被导入，并在 `error_message` 字段返回错误信息。\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/graph1/import/text\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n      \"description\": \"{\\\\\"files\\\\\":[{\\\\\"columns\\\\\":[\\\\\"SRC_ID\\\\\",\\\\\"role\\\\\",\\\\\"DST_ID\\\\\"],\\\\\"format\\\\\":\\\\\"CSV\\\\\",\\\\\"label\\\\\":\\\\\"role\\\\\",\\\\\"SRC_ID\\\\\":\\\\\"actor\\\\\",\\\\\"DST_ID\\\\\":\\\\\"movie\\\\\"}]}\"}\",\n      \"data\": \"1,Role1,2\\n3,Role2,4\\n\",\n      \"continue_on_error\": true,\n      \"delimiter\": \",\"\n    }\n```\n\n上述 description 的值是如下 json 序列化后的字符串\n\n该片段位于文档的第6.10节，主要涉及TuGraph数据库中的在线增量导入功能，特别是如何指定文件内容进行导入的详细说明，包括允许的数据格式和响应内容，并提供了示例请求和响应的具体形式。"
            },
            {
                "content": "```\n    • POST http://localhost:7070/db/graph1/import/text\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n      \"description\": \"{\\\\\"files\\\\\":[{\\\\\"columns\\\\\":[\\\\\"SRC_ID\\\\\",\\\\\"role\\\\\",\\\\\"DST_ID\\\\\"],\\\\\"format\\\\\":\\\\\"CSV\\\\\",\\\\\"label\\\\\":\\\\\"role\\\\\",\\\\\"SRC_ID\\\\\":\\\\\"actor\\\\\",\\\\\"DST_ID\\\\\":\\\\\"movie\\\\\"}]}\"}\",\n      \"data\": \"1,Role1,2\\n3,Role2,4\\n\",\n      \"continue_on_error\": true,\n      \"delimiter\": \",\"\n    }\n```\n\n上述 description 的值是如下 json 序列化后的字符串\n\n```json\n{\n  \"files\": [\n    {\n      \"format\": \"CSV\",\n      \"label\": \"role\",\n      \"SRC_ID\": \"actor\",\n      \"DST_ID\": \"movie\",\n      \"columns\": [\"SRC_ID\", \"role\", \"DST_ID\"]\n    }\n  ]\n}\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        \"log\": \"Missing src uid 1\\n\"\n    }\n```\n\n由于请求中指定了在出错时继续，该返回信息说明 SRC_ID 为 1 的边没有被导入，而其他信息导入成功。\n\n### 6.11.其他\n\nURI 格式为\n\n```\n    http://{host}:{port}/db/{graph_name}/misc\n```\n\n#### 6.11.1.提取子图\n\n给出点 id 集合，返回包含该集合的最小子图。\n\n该内容片段位于文档的第6.10节，介绍了TuGraph中在线增量导入的操作，具体示例展示了如何使用POST请求将文本数据导入到指定的子图中，同时包括了请求格式、请求示例及响应示例，以便用户了解数据导入的具体格式和结果反馈。"
            },
            {
                "content": "上述 description 的值是如下 json 序列化后的字符串\n\n```json\n{\n  \"files\": [\n    {\n      \"format\": \"CSV\",\n      \"label\": \"role\",\n      \"SRC_ID\": \"actor\",\n      \"DST_ID\": \"movie\",\n      \"columns\": [\"SRC_ID\", \"role\", \"DST_ID\"]\n    }\n  ]\n}\n```\n\n**Example response.**\n\n```\n    • 200: OK\n    Output:\n    {\n        \"log\": \"Missing src uid 1\\n\"\n    }\n```\n\n由于请求中指定了在出错时继续，该返回信息说明 SRC_ID 为 1 的边没有被导入，而其他信息导入成功。\n\n### 6.11.其他\n\nURI 格式为\n\n```\n    http://{host}:{port}/db/{graph_name}/misc\n```\n\n#### 6.11.1.提取子图\n\n给出点 id 集合，返回包含该集合的最小子图。\n\n- **URI**: `/db/{graph_name}/misc/sub_graph`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | vertex_ids | 点 id 集合 | 列表 |\n\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | nodes | 点数据 | 列表，每元素包含 vid, label, 以及属性 |\n  | relationships | 边数据 | 列表，每元素包含 src, dst, euid, label, 以及属性 |\n\n**Example request.**\n\n该chunk位于文档的第6.10节，描述了在线增量导入操作中的示例请求，包括如何通过指定文件内容进行导入，以及请求的响应示例，展示了在导入过程中可能发生的错误处理和相关信息。"
            },
            {
                "content": "### 6.11.其他\n\nURI 格式为\n\n```\n    http://{host}:{port}/db/{graph_name}/misc\n```\n\n#### 6.11.1.提取子图\n\n给出点 id 集合，返回包含该集合的最小子图。\n\n- **URI**: `/db/{graph_name}/misc/sub_graph`\n- **METHOD**: POST\n- **REQUEST**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | vertex_ids | 点 id 集合 | 列表 |\n\n- **RESPONSE**:\n  | 域名 | 说明 | 类型 |\n  | --- | --- | --- |\n  | nodes | 点数据 | 列表，每元素包含 vid, label, 以及属性 |\n  | relationships | 边数据 | 列表，每元素包含 src, dst, euid, label, 以及属性 |\n\n**Example request.**\n\n```\n    • POST http://localhost:7070/db/graph1/misc/sub_graph\n    • Accept: application/json; charset=UTF-8\n    • Content-Type: application/json; charset=UTF-8\n    Input:\n    {\n      \"vertex_ids\": [2, 5, 14, 20]\n    }\n```\n\n**Example response.**\n\n该块内容位于文档的第6章\"其他\"下，具体描述了如何通过给定的点ID集合提取包含这些点的最小子图的API接口和请求响应格式。这部分内容是关于图数据库操作的详细指南，适用于用户在使用TuGraph进行数据管理时的实际应用场景。"
            },
            {
                "content": "```\n• 200: OK\n    Output:\n    {\n        \"nodes\": [\n            {\n                \"label\": \"Person\",\n                \"properties\": {\n                    \"birthyear\": 1937,\n                    \"name\": \"Vanessa Redgrave\"\n                },\n                \"vid\": 2\n            },\n            {\n                \"label\": \"Person\",\n                \"properties\": {\n                    \"birthyear\": 1963,\n                    \"name\": \"Natasha Richardson\"\n                },\n                \"vid\": 5\n            },\n            {\n                \"label\": \"City\",\n                \"properties\": {\n                    \"name\": \"London\"\n                },\n                \"vid\": 14\n            },\n            {\n                \"label\": \"Film\",\n                \"properties\": {\n                    \"title\": \"Camelot\"\n                },\n                \"vid\": 20\n            }\n        ],\n        \"relationships\": [\n            {\n                \"destination\": 5,\n                \"label\": \"HAS_CHILD\",\n                \"properties\": {\n\n该块内容位于文档的第6.11节\"其他\"中的子图提取接口描述，具体对应于请求成功后返回的最小子图数据结构，包含提取到的节点和边的信息。"
            },
            {
                "content": "{\n                \"label\": \"City\",\n                \"properties\": {\n                    \"name\": \"London\"\n                },\n                \"vid\": 14\n            },\n            {\n                \"label\": \"Film\",\n                \"properties\": {\n                    \"title\": \"Camelot\"\n                },\n                \"vid\": 20\n            }\n        ],\n        \"relationships\": [\n            {\n                \"destination\": 5,\n                \"label\": \"HAS_CHILD\",\n                \"properties\": {\n                    \"birthyear\": 1937,\n                    \"name\": \"Vanessa Redgrave\"\n                },\n                \"source\": 2\n            },\n            {\n                \"destination\": 14,\n                \"label\": \"BORN_IN\",\n                \"properties\": {\n                    \"birthyear\": 1937,\n                    \"name\": \"Vanessa Redgrave\"\n                },\n                \"source\": 2\n            },\n            {\n                \"destination\": 20,\n                \"label\": \"ACTED_IN\",\n\n该块内容来自文档的第6.11.1节，描述了提取子图的操作结果。具体包括提取出的节点（例如\"City\"和\"Film\"）及其属性，以及与之相关的边（关系）的详细信息，包括每条边的目的地、标签和属性。该信息用于展示从给定点ID集合中形成的最小子图结构。"
            },
            {
                "content": "\"birthyear\": 1937,\n                    \"name\": \"Vanessa Redgrave\"\n                },\n                \"source\": 2\n            },\n            {\n                \"destination\": 14,\n                \"label\": \"BORN_IN\",\n                \"properties\": {\n                    \"birthyear\": 1937,\n                    \"name\": \"Vanessa Redgrave\"\n                },\n                \"source\": 2\n            },\n            {\n                \"destination\": 20,\n                \"label\": \"ACTED_IN\",\n                \"properties\": {\n                    \"birthyear\": 1937,\n                    \"charactername\": \"Guenevere\",\n                    \"name\": \"Vanessa Redgrave\"\n                },\n                \"source\": 2\n            },\n            {\n                \"destination\": 14,\n                \"label\": \"BORN_IN\",\n                \"properties\": {\n                    \"birthyear\": 1963,\n                    \"name\": \"Natasha Richardson\"\n                },\n                \"source\": 5\n            }\n        ]\n    }\n```\n\n该片段位于文档的第6.11.1节“提取子图”中的示例响应部分，描述了在给定点ID集合时返回的最小子图的数据结构，具体展现了点和边的信息，包括属性和标签。在示例中，涉及的点包含“Vanessa Redgrave”和“Natasha Richardson”，以及它们之间的边关系。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_55.md",
        "chunks": [
            {
                "content": "# Training\n\n> 本文档详细介绍了如何使用TuGraph进行图神经网络（GNN）的训练。\n\n## 1. 训练\n使用TuGraph 图学习模块进行训练时，可以分为全图训练和mini-batch训练。\n全图训练即把全图从TuGraph db加载到内存中，再进行GNN的训练。而mini-batch训练则使用上面提到的TuGraph 图学习模块的采样算子，将全图数据进行采样后，再送入训练框架中进行训练。\n## 2. Mini-Batch训练\nMini-Batch训练需要使用TuGraph 图学习模块的采样算子，目前支持Neighbor Sampling、Edge Sampling、Random Walk Sampling和Negative Sampling。\nTuGraph 图学习模块的采样算子进行采样后的结果以List的形式返回。\n下面以Neighbor Sampling为例，介绍如何将采样后的结果，进行格式转换，送入到训练框架中进行训练。\n用户需要提供一个Sample类：\n```python\nclass TuGraphSample(object):\n    def __init__(self, args=None):\n        super(TuGraphSample, self).__init__()\n        self.args = args\n\n    def sample(self, g, seed_nodes):\n        args = self.args\n        # 1. 加载图数据\n        galaxy = PyGalaxy(args.db_path)\n        galaxy.SetCurrentUser(args.username, args.password)\n        db = galaxy.OpenGraph(args.graph_name, False)\n\n        sample_node = seed_nodes.tolist()\n        length = args.randomwalk_length\n        NodeInfo = []\n        EdgeInfo = []\n\n该文档主要介绍如何使用TuGraph进行图神经网络（GNN）的训练，分为全图训练和mini-batch训练两个部分。该chunk详细说明了mini-batch训练的步骤，重点在于使用TuGraph图学习模块的采样算子和如何将采样结果格式化为适合DGL训练框架的输入。"
            },
            {
                "content": "def sample(self, g, seed_nodes):\n        args = self.args\n        # 1. 加载图数据\n        galaxy = PyGalaxy(args.db_path)\n        galaxy.SetCurrentUser(args.username, args.password)\n        db = galaxy.OpenGraph(args.graph_name, False)\n\n        sample_node = seed_nodes.tolist()\n        length = args.randomwalk_length\n        NodeInfo = []\n        EdgeInfo = []\n\n        # 2. 采样方法，结果存储在NodeInfo和EdgeInfo中\n        if args.sample_method == 'randomwalk':\n            randomwalk.Process(db, 100, sample_node, length, NodeInfo, EdgeInfo)\n        elif args.sample_method == 'negative':\n            negativesample.Process(db, 100)\n        else:\n            neighborsample(db, 100, sample_node, args.nbor_sample_num, NodeInfo, EdgeInfo)\n        del db\n        del galaxy\n\n该代码块位于对Mini-Batch训练的详细说明部分，主要描述了如何在TuGraph中实现采样功能。具体来说，它展示了如何加载图数据并使用不同的采样方法（如随机游走、负采样和邻居采样）对数据进行采样，为后续的图神经网络训练准备数据。"
            },
            {
                "content": "# 2. 采样方法，结果存储在NodeInfo和EdgeInfo中\n        if args.sample_method == 'randomwalk':\n            randomwalk.Process(db, 100, sample_node, length, NodeInfo, EdgeInfo)\n        elif args.sample_method == 'negative':\n            negativesample.Process(db, 100)\n        else:\n            neighborsample(db, 100, sample_node, args.nbor_sample_num, NodeInfo, EdgeInfo)\n        del db\n        del galaxy\n\n        # 3. 对结果进行格式转换，使之符合训练格式\n        remap(EdgeInfo[0], EdgeInfo[1], NodeInfo[0])\n        g = dgl.graph((EdgeInfo[0], EdgeInfo[1]))\n        g.ndata['feat'] = torch.tensor(NodeInfo[1])\n        g.ndata['label'] = torch.tensor(NodeInfo[2])\n        return g\n```\n如代码所示，首先将图数据加载到内存中。然后使用采样算子对图数据进行采样，结果存储在NodeInfo和EdgeInfo中。NodeInfo和EdgeInfo是python list结果，其存储的信息结果如下：\n\n| 图数据 | 存储信息位置 |\n| --- | --- |\n| 边起点 | EdgeInfo[0] |\n| 边终点 | EdgeInfo[1] |\n| 顶点ID | NodeInfo[0] |\n| 顶点特征 | NodeInfo[1] |\n| 顶点标签 | NodeInfo[2] |\n表格内容描述: 该表格包含两列，分别为“图数据”和“存储信息位置”。\n\n该块内容位于文档的第二部分，主要讨论Mini-Batch训练中如何使用不同的采样方法对图数据进行采样，并将采样结果存储在NodeInfo和EdgeInfo中，以及如何将这些结果转换为适合训练的格式。此部分为用户提供了具体的代码示例和数据结构说明，以帮助理解采样过程及其在图神经网络训练中的应用。"
            },
            {
                "content": "| 图数据 | 存储信息位置 |\n| --- | --- |\n| 边起点 | EdgeInfo[0] |\n| 边终点 | EdgeInfo[1] |\n| 顶点ID | NodeInfo[0] |\n| 顶点特征 | NodeInfo[1] |\n| 顶点标签 | NodeInfo[2] |\n表格内容描述: 该表格包含两列，分别为“图数据”和“存储信息位置”。\n\n- 第一行数据为“边起点”，其存储位置信息为“EdgeInfo[0]”。\n- 第二行数据为“边终点”，其存储位置信息为“EdgeInfo[1]”。\n- 第三行数据为“顶点ID”，其存储位置信息为“NodeInfo[0]”。\n- 第四行数据为“顶点特征”，其存储位置信息为“NodeInfo[1]”。\n- 第五行数据为“顶点标签”，其存储位置信息为“NodeInfo[2]”。\n\n总体而言，该表格描述了图数据的不同组成部分及其所对应的存储信息位置，主要包括边的起点和终点，以及顶点的ID、特征和标签。\n\n该表格位于文档中，主要用于说明在使用TuGraph进行图神经网络训练时，NodeInfo和EdgeInfo中存储的图数据不同组成部分及其对应的位置。这个信息在Mini-Batch训练部分被详细介绍，帮助用户理解采样结果的格式转换过程。"
            },
            {
                "content": "最后对结果进行格式转换，使之符合训练格式。这里我们使用的是DGL训练框架，因此使用结果数据构造了DGL Graph，最终将DGL Graph返回。\n我们提供TuGraphSample类之后，就可以使用它进行Mini-Batch训练了。\n令DGL的数据加载部分使用TuGraphSample的实例sampler：\n```python\n    sampler = TugraphSample(args)\n    fake_g = construct_graph() # just make dgl happy\n    dataloader = dgl.dataloading.DataLoader(fake_g,\n        torch.arange(train_nids),\n        sampler,\n        batch_size=batch_size,\n        device=device,\n        use_ddp=True,\n        num_workers=0,\n        drop_last=False,\n        )\n```\n使用DGL进行模型训练：\n```python\ndef train(dataloader, model):\n    optimizer = torch.optim.Adam(model.parameters(), lr=1e-2, weight_decay=5e-4)\n    model.train()\n    s = time.time()\n    for graph in dataloader:\n        load_time = time.time()\n        graph = dgl.add_self_loop(graph)\n        logits = model(graph, graph.ndata['feat'])\n        loss = loss_fcn(logits, graph.ndata['label'])\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n        train_time = time.time()\n\n该片段位于文档的第二部分，主要介绍如何使用TuGraph进行Mini-Batch训练，具体包括结果格式转换、DGL数据加载和模型训练的代码示例。此部分强调了如何构建DGL图并进行有效的训练。"
            },
            {
                "content": ")\n```\n使用DGL进行模型训练：\n```python\ndef train(dataloader, model):\n    optimizer = torch.optim.Adam(model.parameters(), lr=1e-2, weight_decay=5e-4)\n    model.train()\n    s = time.time()\n    for graph in dataloader:\n        load_time = time.time()\n        graph = dgl.add_self_loop(graph)\n        logits = model(graph, graph.ndata['feat'])\n        loss = loss_fcn(logits, graph.ndata['label'])\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n        train_time = time.time()\n        print('load time', load_time - s, 'train_time', train_time - load_time)\n        s = time.time()\n    return float(loss)\n```\n\n该代码块位于文档的第三部分，介绍了如何使用DGL框架进行图神经网络（GNN）的模型训练。它紧接在描述Mini-Batch训练后，详细说明了训练过程中的优化器设置、损失计算和模型更新步骤。"
            },
            {
                "content": "## 3. 全图训练\nGNN（图神经网络）的全图训练是一种涉及一次处理整个训练数据集的训练。它是 GNN 最简单、最直接的训练方法之一，整个图被视为单个实例。 在全图训练中，整个数据集被加载到内存中，模型在整个图上进行训练。这种类型的训练对于中小型图特别有用，并且主要用于不随时间变化的静态图。\n在算子调用时，使用以下方式：\n```python\ngetdb.Process(db, olapondb, feature_len, NodeInfo, EdgeInfo)\n```\n获取全图数据，然后将全图送入训练框架中进行训练。\n完整代码：请参考learn/examples/train_full_cora.py。\n\n本文档详细介绍了如何使用TuGraph进行图神经网络的训练，分为全图训练和mini-batch训练。该chunk主要讲述了全图训练的方法和适用场景，并提供了获取全图数据的代码示例。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_56.md",
        "chunks": [
            {
                "content": "# 文档地图\n\n> 这里是文档地图，帮助用户快速学习和使用TuGraph社区版。\n\n\n## 主要仓库\n\n> TuGraph-DB 仓库:（https://github.com/TuGraph-family/tugraph-db)。TuGraph 是支持大数据容量、低延迟查找和快速图分析功能的高效图数据库。\n\n> 可视化界面: tugraph-db-browser(https://github.com/TuGraph-family/tugraph-db-browser)。TuGraph DB BROWSER 是 TuGraph 图数据库的可视化平台。可以完成图谱、模型、数据等的创建和导入。同时可用使用 TuGraph Cypher 进行数据的操作。\n\n> 基于twitter数据的简单测试方法: gdbms-microbenchmark(https://github.com/TuGraph-family/gdbms-microbenchmark)。本项目提供一个benchmark对TuGraph进行测试。\n\n> 基于标准LDBC-SNB的测试方法: tugraph-snb-interactive(https://github.com/TuGraph-family/tugraph-snb-interactive)。\n\n> TuGraph-Analytics 仓库: (https://github.com/TuGraph-family/tugraph-analytics)。TuGraph Analytics (别名：GeaFlow) 是蚂蚁集团开源的流图计算引擎，支持万亿级图存储、图表混合处理、实时图计算、交互式图分析等核心能力，目前广泛应用于数仓加速、金融风控、知识图谱以及社交网络等场景。\n\n\n## 视频中心\n\n> TuGraph快速上手：https://space.bilibili.com/1196053065/channel/seriesdetail?sid=2593741\n\n> TuGraph技术分享集合：https://space.bilibili.com/1196053065/channel/seriesdetail?sid=3009777\n\n> 3分钟读懂图计算：https://www.bilibili.com/video/BV15U4y1r7AW/\n\n## TuGraph最新版本\n\n该段落为文档的开头部分，介绍了TuGraph社区版的文档地图，包括主要仓库、视频中心以及最新版本的信息，帮助用户快速学习和使用TuGraph图数据库。"
            },
            {
                "content": "| 描述                  | 文件                                         | 链接                                                                                                                                                                                              |\n|---------------------|--------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| CentOS7 安装包         | tugraph-4.5.0-1.el7.x86_64.rpm             | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.el7.x86_64.rpm)                                                                                      |\n\n该内容位于文档“TuGraph最新版本”部分，列出了不同操作系统下的安装包、预安装镜像和编译镜像的详细信息，尤其是针对CentOS7的安装包。"
            },
            {
                "content": "| CentOS7 安装包         | tugraph-4.5.0-1.el7.x86_64.rpm             | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.el7.x86_64.rpm)                                                                                      |\n| CentOS8 安装包         | tugraph-4.5.0-1.el8.x86_64.rpm             | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.el8.x86_64.rpm)                                                                                      |\n| Ubuntu18.04 安装包     | tugraph-4.5.0-1.x86_64.deb                 | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.x86_64.deb)                                                                                          |\n\n该块内容展示了TuGraph数据库最新版本4.5.0的安装包信息，包括针对CentOS7、CentOS8和Ubuntu18.04操作系统的安装包名称及下载链接，属于文档中关于TuGraph最新版本的部分。"
            },
            {
                "content": "| Ubuntu18.04 安装包     | tugraph-4.5.0-1.x86_64.deb                 | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.x86_64.deb)                                                                                          |\n| CentOS7 预安装镜像       | tugraph-runtime-centos7-4.5.0.tar          | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-centos7-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-runtime-centos7)                   |\n| CentOS8 预安装镜像       | tugraph-runtime-centos8-4.5.0.tar          | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-centos8-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-runtime-centos8)                   |\n\n该块内容位于“TuGraph最新版本”部分，列出了针对Ubuntu18.04及CentOS7、CentOS8的预安装镜像和安装包的文件名及下载链接，帮助用户快速获取和安装TuGraph图数据库的相关资源。"
            },
            {
                "content": "| CentOS8 预安装镜像       | tugraph-runtime-centos8-4.5.0.tar          | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-centos8-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-runtime-centos8)                   |\n| Ubuntu18.04 预安装镜像   | tugraph-runtime-ubuntu18.04-4.5.0.tar      | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-ubuntu18.04-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-runtime-ubuntu18.04)           |\n| CentOS7 精简安装包       | tugraph-mini-4.5.0-1.el7.x86_64.rpm        | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.el7.x86_64.rpm)                                                                                 |\n\n该段落包含了TuGraph 4.5.0版本下，针对CentOS8和Ubuntu18.04操作系统的预安装镜像以及CentOS7的精简安装包的相关信息，包括文件名和下载链接。"
            },
            {
                "content": "| CentOS7 精简安装包       | tugraph-mini-4.5.0-1.el7.x86_64.rpm        | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.el7.x86_64.rpm)                                                                                 |\n| CentOS8 精简安装包       | tugraph-mini-4.5.0-1.el8.x86_64.rpm        | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.el8.x86_64.rpm)                                                                                 |\n| Ubuntu18.04 精简安装包   | tugraph-mini-4.5.0-1.x86_64.deb            | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.x86_64.deb)                                                                                     |\n\n该部分内容位于文档地图的“TuGraph最新版本”章节中，专门列出了针对不同操作系统（CentOS7、CentOS8和Ubuntu18.04）的精简安装包的文件名及其下载链接，旨在帮助用户轻松获取适用于相应操作系统的安装软件。"
            },
            {
                "content": "| Ubuntu18.04 精简安装包   | tugraph-mini-4.5.0-1.x86_64.deb            | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.x86_64.deb)                                                                                     |\n| CentOS7 精简预安装镜像     | tugraph-mini-runtime-centos7-4.5.0.tar     | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-centos7-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-centos7)         |\n| CentOS8 精简预安装镜像     | tugraph-mini-runtime-centos8-4.5.0.tar     | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-centos8-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-centos8)         |\n\n该片段列出了针对Ubuntu18.04和CentOS7、CentOS8的精简安装包和预安装镜像的文件名及相应的下载和访问链接，属于TuGraph最新版本部分的内容，适用于用户部署和开发图数据库的需求。"
            },
            {
                "content": "| CentOS8 精简预安装镜像     | tugraph-mini-runtime-centos8-4.5.0.tar     | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-centos8-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-centos8)         |\n| Ubuntu18.04 精简预安装镜像 | tugraph-mini-runtime-ubuntu18.04-4.5.0.tar | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-ubuntu18.04-4.5.0.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-ubuntu18.04) |\n| CentOS7 编译镜像        | tugraph-compile-centos7-1.3.2.tar          | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-centos7-1.3.2.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-compile-centos7)          |\n\n该块内容位于文档的“TuGraph最新版本”部分，主要列出了针对CentOS8和Ubuntu18.04的精简预安装镜像及CentOS7的编译镜像的文件名、下载链接和访问链接，适用于用户获取和使用最新版本的TuGraph软件。"
            },
            {
                "content": "| CentOS7 编译镜像        | tugraph-compile-centos7-1.3.2.tar          | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-centos7-1.3.2.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-compile-centos7)          |\n| CentOS8 编译镜像        | tugraph-compile-centos8-1.3.2.tar          | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-centos8-1.3.2.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-compile-centos8)          |\n| Ubuntu18.04 编译镜像    | tugraph-compile-ubuntu18.04-1.3.2.tar      | [下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-ubuntu18.04-1.3.2.tar) 、[访问](https://hub.docker.com/r/tugraph/tugraph-compile-ubuntu18.04)  |\n表格内容描述:\n\n该块内容位于文档的“TuGraph最新版本”部分，具体列出了针对不同操作系统（CentOS7、CentOS8和Ubuntu18.04）的编译镜像文件及其下载和访问链接，提供了用户在开发过程中所需的资源。"
            },
            {
                "content": "本表格包含三列，分别为“描述”、“文件”和“链接”。\n\n该chunk位于文档的“TuGraph最新版本”部分，主要介绍了表格的结构和内容，以便用户了解不同操作系统下的安装包和镜像信息。"
            },
            {
                "content": "逐行描述数据内容如下：\n1. CentOS7 安装包，文件名为 tugraph-4.5.0-1.el7.x86_64.rpm，下载链接为[下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.el7.x86_64.rpm)。\n2. CentOS8 安装包，文件名为 tugraph-4.5.0-1.el8.x86_64.rpm，下载链接为[下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.el8.x86_64.rpm)。\n3. Ubuntu18.04 安装包，文件名为 tugraph-4.5.0-1.x86_64.deb，下载链接为[下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-4.5.0-1.x86_64.deb)。\n4. CentOS7 预安装镜像，文件名为 tugraph-runtime-centos7-4.5.0.tar，下载链接为[下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-centos7-4.5.0.tar)，访问链接为[访问](https://hub.docker.com/r/tugraph/tugraph-runtime-centos7)。\n5. CentOS8 预安装镜像，文件名为 tugraph-runtime-centos8-4.5.0.tar，下载链接为[下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-centos8-4.5.0.tar)，访问链接为[访问](https://hub.docker.com/r/tugraph/tugraph-runtime-centos8)。\n\n该chunk包含了TuGraph最新版本在不同操作系统（CentOS7、CentOS8和Ubuntu18.04）下的安装包和预安装镜像的逐行描述，包括文件名和下载链接，旨在帮助用户快速获取和安装所需的TuGraph软件。"
            },
            {
                "content": "4. CentOS7 预安装镜像，文件名为 tugraph-runtime-centos7-4.5.0.tar，下载链接为[下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-centos7-4.5.0.tar)，访问链接为[访问](https://hub.docker.com/r/tugraph/tugraph-runtime-centos7)。\n5. CentOS8 预安装镜像，文件名为 tugraph-runtime-centos8-4.5.0.tar，下载链接为[下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-centos8-4.5.0.tar)，访问链接为[访问](https://hub.docker.com/r/tugraph/tugraph-runtime-centos8)。\n6. Ubuntu18.04 预安装镜像，文件名为 tugraph-runtime-ubuntu18.04-4.5.0.tar，下载链接为[下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-ubuntu18.04-4.5.0.tar)，访问链接为[访问](https://hub.docker.com/r/tugraph/tugraph-runtime-ubuntu18.04)。\n7. CentOS7 精简安装包，文件名为 tugraph-mini-4.5.0-1.el7.x86_64.rpm，下载链接为[下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.el7.x86_64.rpm)。\n\n该块内容位于文档的“TuGraph最新版本”部分，具体列出了不同操作系统（CentOS7、CentOS8和Ubuntu18.04）下的预安装镜像及其下载链接和访问链接，以及CentOS7的精简安装包，旨在提供用户下载和部署TuGraph图数据库所需的具体文件信息。"
            },
            {
                "content": "6. Ubuntu18.04 预安装镜像，文件名为 tugraph-runtime-ubuntu18.04-4.5.0.tar，下载链接为[下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-runtime-ubuntu18.04-4.5.0.tar)，访问链接为[访问](https://hub.docker.com/r/tugraph/tugraph-runtime-ubuntu18.04)。\n7. CentOS7 精简安装包，文件名为 tugraph-mini-4.5.0-1.el7.x86_64.rpm，下载链接为[下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.el7.x86_64.rpm)。\n8. CentOS8 精简安装包，文件名为 tugraph-mini-4.5.0-1.el8.x86_64.rpm，下载链接为[下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.el8.x86_64.rpm)。\n9. Ubuntu18.04 精简安装包，文件名为 tugraph-mini-4.5.0-1.x86_64.deb，下载链接为[下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.x86_64.deb)。\n\n该片段包含了针对Ubuntu18.04及CentOS操作系统的预安装镜像和精简安装包的详细信息，包括文件名和下载链接，属于文档中关于TuGraph最新版本安装包的部分。"
            },
            {
                "content": "8. CentOS8 精简安装包，文件名为 tugraph-mini-4.5.0-1.el8.x86_64.rpm，下载链接为[下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.el8.x86_64.rpm)。\n9. Ubuntu18.04 精简安装包，文件名为 tugraph-mini-4.5.0-1.x86_64.deb，下载链接为[下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-4.5.0-1.x86_64.deb)。\n10. CentOS7 精简预安装镜像，文件名为 tugraph-mini-runtime-centos7-4.5.0.tar，下载链接为[下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-centos7-4.5.0.tar)，访问链接为[访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-centos7)。\n11. CentOS8 精简预安装镜像，文件名为 tugraph-mini-runtime-centos8-4.5.0.tar，下载链接为[下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-centos8-4.5.0.tar)，访问链接为[访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-centos8)。\n\n该块内容位于“TuGraph最新版本”部分，列出了针对CentOS8和Ubuntu18.04的精简安装包以及CentOS7和CentOS8的精简预安装镜像的文件名和下载链接，适合有针对性地获取相关软件版本以进行部署和开发。"
            },
            {
                "content": "11. CentOS8 精简预安装镜像，文件名为 tugraph-mini-runtime-centos8-4.5.0.tar，下载链接为[下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-centos8-4.5.0.tar)，访问链接为[访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-centos8)。\n12. Ubuntu18.04 精简预安装镜像，文件名为 tugraph-mini-runtime-ubuntu18.04-4.5.0.tar，下载链接为[下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-4.5.0/tugraph-mini-runtime-ubuntu18.04-4.5.0.tar)，访问链接为[访问](https://hub.docker.com/r/tugraph/tugraph-mini-runtime-ubuntu18.04)。\n13. CentOS7 编译镜像，文件名为 tugraph-compile-centos7-1.3.2.tar，下载链接为[下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-centos7-1.3.2.tar)，访问链接为[访问](https://hub.docker.com/r/tugraph/tugraph-compile-centos7)。\n\n该内容块包含了TuGraph版本4.5.0在CentOS8和Ubuntu18.04操作系统下的精简预安装镜像及CentOS7编译镜像的信息，具体包括文件名、下载链接和访问链接，属于文档中关于最新版本和安装文件的部分。"
            },
            {
                "content": "13. CentOS7 编译镜像，文件名为 tugraph-compile-centos7-1.3.2.tar，下载链接为[下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-centos7-1.3.2.tar)，访问链接为[访问](https://hub.docker.com/r/tugraph/tugraph-compile-centos7)。\n14. CentOS8 编译镜像，文件名为 tugraph-compile-centos8-1.3.2.tar，下载链接为[下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-centos8-1.3.2.tar)，访问链接为[访问](https://hub.docker.com/r/tugraph/tugraph-compile-centos8)。\n15. Ubuntu18.04 编译镜像，文件名为 tugraph-compile-ubuntu18.04-1.3.2.tar，下载链接为[下载](https://tugraph-web.oss-cn-beijing.aliyuncs.com/tugraph/tugraph-docker-compile/tugraph-compile-ubuntu18.04-1.3.2.tar)，访问链接为[访问](https://hub.docker.com/r/tugraph/tugraph-compile-ubuntu18.04)。\n\n该块内容位于文档的“TuGraph最新版本”部分，具体介绍了与不同操作系统相关的编译镜像，包括CentOS7、CentOS8和Ubuntu18.04的下载链接和访问链接。这些信息对于用户在部署和开发TuGraph时选择合适的编译版本至关重要。"
            },
            {
                "content": "总的来说，该表格列出了不同操作系统（CentOS7、CentOS8和Ubuntu18.04）下的多种安装包、预安装镜像和编译镜像的文件名及下载链接，适用于部署和开发使用的图数据库软件版本4.5.0及相关精简版本。\n\n该段落概括了文档中关于TuGraph最新版本的表格内容，内容涵盖了不同操作系统提供的安装包、预安装镜像和编译镜像的详细信息及下载链接，以便用户进行部署和开发。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_57.md",
        "chunks": [
            {
                "content": "# 部署高可用模式\n\n> 此文档主要介绍了高可用模式的原理、准备工作、以及服务器的操作说明\n\n## 1.原理\n\nTuGraph 通过多机热备份来提供高可用（HA）模式。在高可用模式下，对数据库的写操作会被同步到所有服务器（非witness）上，这样即使有部分服务器宕机也不会影响服务的可用性。\n\n高可用模式启动时，多个 TuGraph 服务器组成一个备份组，即高可用集群。每个备份组由三个或更多 TuGraph 服务器组成，其中某台服务器会作为`leader`，而其他复制组服务器则作为`follower`。写入请求由`leader`\n提供服务，该`leader`将每个请求复制同步到`follower`，并在请求同步到服务器后才能响应客户端。这样，如果任何服务器发生故障，其他服务器仍将具有到目前为止已写入的所有数据。如果`leader`\n服务器发生故障，其他服务器将自动选择出新的`leader`。\n\nTuGraph的高可用模式提供两种类型的节点：`replica`节点和`witness`节点。其中，`replica`节点是普通节点，有日志有数据，可对外提供服务。\n而`witness`节点是一种只接收心跳和日志但不保存数据的节点。根据部署需求，`leader`节点和`follower`节点可以灵活的部署为`replica`节点或`witness`节点。\n基于此，TuGraph高可用模式的部署方式有两种：一是普通部署模式，二是带witness的简约部署模式。\n\n对于普通部署模式，`leader`和所有`follower`均为`replica`类型的节点。写入请求由`leader`提供服务，该`leader`将每个请求复制同步到`follower`，\n并在请求同步到超过半数的服务器后才能响应客户端。这样，如果少于半数的服务器发生故障，其他服务器仍将具有到目前为止已写入的所有数据。如果`leader`\n服务器发生故障，其他服务器将自动选举出新的`leader`，通过这种方式保证数据的一致性和服务的可用性。\n\n本段落介绍了TuGraph高可用模式的原理，包括其工作机制、节点类型及部署方式，为后续的准备工作和服务器操作说明奠定基础。"
            },
            {
                "content": "TuGraph的高可用模式提供两种类型的节点：`replica`节点和`witness`节点。其中，`replica`节点是普通节点，有日志有数据，可对外提供服务。\n而`witness`节点是一种只接收心跳和日志但不保存数据的节点。根据部署需求，`leader`节点和`follower`节点可以灵活的部署为`replica`节点或`witness`节点。\n基于此，TuGraph高可用模式的部署方式有两种：一是普通部署模式，二是带witness的简约部署模式。\n\n对于普通部署模式，`leader`和所有`follower`均为`replica`类型的节点。写入请求由`leader`提供服务，该`leader`将每个请求复制同步到`follower`，\n并在请求同步到超过半数的服务器后才能响应客户端。这样，如果少于半数的服务器发生故障，其他服务器仍将具有到目前为止已写入的所有数据。如果`leader`\n服务器发生故障，其他服务器将自动选举出新的`leader`，通过这种方式保证数据的一致性和服务的可用性。\n\n然而，在用户服务器资源不够或者发生网络分区时，不能建立正常的HA集群。此时，由于`witness`节点没有数据，对资源占用小，可以将`witness`节点和`replica`节点部署在一台机器上。\n例如，当只有2台机器的情况下，可以在一台机器上部署`replica`节点，在另一台机器上部署`replica`节点和`witness`节点，不仅节省资源，而且不需要把日志应用到状态机上，\n也不需要生成和安装快照，因此响应请求的速度很快，可以在集群崩溃或网络分区时协助快速选举出新的`leader`，这就是TuGraph HA集群的简约部署模式。\n尽管`witness`节点有诸多好处，但是由于没有数据，集群实际上增加了一个不能成为`leader`的节点，因此可用性会略有降低。为提高集群的可用性，\n可通过指定`ha_enable_witness_to_leader`参数为`true`，允许`witness`节点临时当主。`witness`节点在把新日志同步到其他节点之后，\n会将leader角色主动切换到有最新日志的节点。\n\nv3.6及以上版本支持此功能。\n\n## 2.准备工作\n\n要启用高可用模式，用户需要：\n\n- 三台及以上的 TuGraph 服务器实例。\n\n该段落主要介绍了TuGraph高可用模式中的节点类型，包括`replica`和`witness`节点，以及这两种节点在普通部署模式和带`witness`的简约部署模式中的作用和配置方式。此部分紧接在高可用模式原理的描述后，属于准备工作和部署方式的前期说明。"
            },
            {
                "content": "v3.6及以上版本支持此功能。\n\n## 2.准备工作\n\n要启用高可用模式，用户需要：\n\n- 三台及以上的 TuGraph 服务器实例。\n\n- 在启动 lgraph_server 时打开高可用模式，可以使用配置文件或者命令行将`enable_ha`选项设置为`true`。\n\n- 设置正确的`rpc_port`，可通过配置文件或者命令行设置。\n\n## 3.启动初始备份组\n\n安装好TuGraph之后，可以使用`lgraph_server`命令在不同的机器上启动高可用集群。本节主要讲解高可用集群的启动方式。\n\n### 3.1.初始数据一致\n\n当启动时所有服务器中的数据相同或没有数据时，用户可以通过指定`--ha_conf host1:port1,host2:port2`启动服务器。\n这种方式可以将准备好的所有TuGraph实例一次性加入初始备份组，由备份组中的所有服务器根据raft协议选举出`leader`，并将其他服务器以`follower`的角色加入备份组。\n\n启动初始备份组的命令示例如下所示：\n\n```bash\n$ ./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090\n```\n\n### 3.2.初始数据不一致\n\n如果第一台服务器中已有数据（以`lgraph_import`工具导入或从非高可用模式的服务器传输得到），\n并且之前并未在高可用模式下使用，则用户应使用boostrap方式启动。\n以`ha_bootstrap_role`参数为1在bootstrap模式下启动有数据的服务器，并通过`ha_conf`参数指定本机为`leader`。\n在bootstrap模式下，服务器在将新加入的服务器添加到备份组之前会将自己的\n数据复制到新服务器中，以使每个服务器中的数据保持一致。\n\n启动有数据服务器的命令示例如下所示：\n\n该文档的主要内容是关于TuGraph数据库的高可用模式的原理、准备工作及操作说明。所选的这一部分具体介绍了启用高可用模式所需的准备工作，包括服务器数量要求、启动配置及端口设置。同时，文中接着阐述了如何启动初始备份组、包括在数据一致和不一致情况下的启动方法。"
            },
            {
                "content": "启动初始备份组的命令示例如下所示：\n\n```bash\n$ ./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090\n```\n\n### 3.2.初始数据不一致\n\n如果第一台服务器中已有数据（以`lgraph_import`工具导入或从非高可用模式的服务器传输得到），\n并且之前并未在高可用模式下使用，则用户应使用boostrap方式启动。\n以`ha_bootstrap_role`参数为1在bootstrap模式下启动有数据的服务器，并通过`ha_conf`参数指定本机为`leader`。\n在bootstrap模式下，服务器在将新加入的服务器添加到备份组之前会将自己的\n数据复制到新服务器中，以使每个服务器中的数据保持一致。\n\n启动有数据服务器的命令示例如下所示：\n\n```bash\n$ ./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090 --ha_bootstrap_role 1\n```\n\n其他无数据的服务器需要指定`ha_bootstrap_role`参数为2，并通过`ha_conf`参数指定`leader`即可，命令示例如下所示\n\n```bash\n$ ./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090 --ha_bootstrap_role 2\n```\n\n该段落位于文档的第3部分，主要介绍如何启动初始备份组的命令，分为两种情况：初始数据一致和初始数据不一致。在数据一致的情况下，提供了简单的启动命令；而在数据不一致的情况下，说明了如何使用bootstrap方式启动已有数据的服务器，并确保新加入服务器的数据一致性。"
            },
            {
                "content": "启动有数据服务器的命令示例如下所示：\n\n```bash\n$ ./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090 --ha_bootstrap_role 1\n```\n\n其他无数据的服务器需要指定`ha_bootstrap_role`参数为2，并通过`ha_conf`参数指定`leader`即可，命令示例如下所示\n\n```bash\n$ ./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090 --ha_bootstrap_role 2\n```\n\n**使用bootstrap启动HA集群时需要注意两点：**\n1. 需要等待`leader`节点生成snapshot并且成功启动之后再加入`follower`节点，否则`follower`节点可能加入失败。在启动`follower`节点时可以将`ha_node_join_group_s`参数配置的稍大，以在加入HA集群时多次等待和超时重试。\n2. HA集群只有在第一次启动时可以使用bootstrap模式，后续再启动时只能使用普通模式(见3.1节)启动，尤其不能让同一个集群的多个节点以bootstrap模式启动，否则可能产生数据不一致的情况\n\n## 4.启动witness节点\n\n### 4.1.不允许witness节点成为leader\n\n`witness`节点的启动方式和普通节点的启动方式一致，只需要设置`ha_is_witness`参数为`true`即可。需注意，witness节点的数量应少于集群节点总数量的一半。\n\n启动`witness`节点服务器的命令示例如下所示：\n\n该部分内容位于文档的第3节，讨论如何启动高可用集群中的服务器，特别是有数据的服务器和无数据的服务器的启动命令及注意事项。紧接其后是第4节，介绍如何启动witness节点及其相关参数设置。"
            },
            {
                "content": "**使用bootstrap启动HA集群时需要注意两点：**\n1. 需要等待`leader`节点生成snapshot并且成功启动之后再加入`follower`节点，否则`follower`节点可能加入失败。在启动`follower`节点时可以将`ha_node_join_group_s`参数配置的稍大，以在加入HA集群时多次等待和超时重试。\n2. HA集群只有在第一次启动时可以使用bootstrap模式，后续再启动时只能使用普通模式(见3.1节)启动，尤其不能让同一个集群的多个节点以bootstrap模式启动，否则可能产生数据不一致的情况\n\n## 4.启动witness节点\n\n### 4.1.不允许witness节点成为leader\n\n`witness`节点的启动方式和普通节点的启动方式一致，只需要设置`ha_is_witness`参数为`true`即可。需注意，witness节点的数量应少于集群节点总数量的一半。\n\n启动`witness`节点服务器的命令示例如下所示：\n\n```bash\n$ ./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090 --ha_is_witness 1\n```\n\n注：默认不允许`witness`节点成为`leader`节点，这可以提高集群的性能，但是在`leader`节点崩溃时会降低集群的可用性。\n\n### 4.2.允许witness节点成为leader\n\n可以通过指定`ha_enable_witness_to_leader`参数为`true`，使得`witness`节点可以临时成为`leader`节点，在将新日志同步完成之后再主动切主\n\n启动允许成为`leader`节点的`witness`节点服务器的命令示例如下所示：\n\n该块内容位于文档的第3节和第4节之间，主要强调在使用bootstrap模式启动高可用(HAV)集群时需要注意的两点，接着介绍如何启动witness节点，包括不允许和允许witness节点成为leader的两种情况，提供具体的命令示例。"
            },
            {
                "content": "启动`witness`节点服务器的命令示例如下所示：\n\n```bash\n$ ./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090 --ha_is_witness 1\n```\n\n注：默认不允许`witness`节点成为`leader`节点，这可以提高集群的性能，但是在`leader`节点崩溃时会降低集群的可用性。\n\n### 4.2.允许witness节点成为leader\n\n可以通过指定`ha_enable_witness_to_leader`参数为`true`，使得`witness`节点可以临时成为`leader`节点，在将新日志同步完成之后再主动切主\n\n启动允许成为`leader`节点的`witness`节点服务器的命令示例如下所示：\n\n```bash\n$ ./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090 --ha_is_witness 1 --ha_enable_witness_to_leader 1\n```\n\n注：尽管允许`witness`节点成为`leader`节点可以提高集群的可用性，但是在极端情况下可能会影响数据的一致性。因此一般应保证`witness`节点数量+1少于集群节点总数量的一半。\n\n## 5.横向扩展其他服务器\n\n启动初始备份组后，如果想对备份组进行横向扩展，要将新服务器添加到备份组，\n应使用`--ha_conf HOST：PORT`选项，其中`HOST`可以是该备份组中已有的任何服务器的 IP 地址，\n而`PORT`是其 RPC 端口。例如：\n\n```bash\n./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090\n```\n\n该段落位于文档的第四部分，主要介绍如何启动`witness`节点，包括不允许和允许`witness`节点成为`leader`的启动命令示例及其相关注意事项。这部分内容为高可用模式中的节点配置提供了具体的操作指导，特别是针对`witness`节点的角色和功能的说明，与文档的整体高可用模式部署和管理主题密切相关。"
            },
            {
                "content": "注：尽管允许`witness`节点成为`leader`节点可以提高集群的可用性，但是在极端情况下可能会影响数据的一致性。因此一般应保证`witness`节点数量+1少于集群节点总数量的一半。\n\n## 5.横向扩展其他服务器\n\n启动初始备份组后，如果想对备份组进行横向扩展，要将新服务器添加到备份组，\n应使用`--ha_conf HOST：PORT`选项，其中`HOST`可以是该备份组中已有的任何服务器的 IP 地址，\n而`PORT`是其 RPC 端口。例如：\n\n```bash\n./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090\n```\n\n此命令将启动一台高可用模式的 TuGraph 服务器，并尝试将其添加到包含服务器`172.22.224.15:9090`的备份组中。\n请注意，加入备份组需要服务器将其数据与备份组的`leader`服务器同步，此过程可能需要相当长的时间，具体取决于数据的大小。\n\n## 6.停止服务器\n\n当服务器通过`CTRL-C`下线时，它将通知当前的`leader`服务器，告知其从备份组中删除该下线的服务器。如果`leader`服务器下线，\n它将在下线前将`leader`身份权限传给另一台服务器。\n\n如果服务器被终止或者与备份组中的其他服务器失去连接，则该服务器将被视为失败节点，`leader`服务器将在特定时限后将其从备份组中删除。\n\n如果任何服务器离开备份组并希望重新加入，则必须从`--ha_conf HOST:PORT`选项开始，其中`HOST`是当前备份组中的某台服务器的 IP 地址。\n\n## 7.重启服务器\n\n不建议重新启动整个备份组，因为它会中断服务。如果需要，可以关闭所有服务器。但在重新启动时，\n必须保证关闭时的备份组中至少有N/2+1的服务器能正常启动，否则启动失败。 并且，\n无论初始启动复制组时是否指定`enable_bootstrap`为true，重启服务器时都只需通过\n指定`--ha_conf host1:port1,host2:port2`参数一次性重启所有服务器即可，命令示例如下所示：\n\n该段落位于文档的第4部分和第5部分之间，讨论了允许`witness`节点成为`leader`节点的注意事项，以及在成功启动高可用集群后如何进行横向扩展和新增服务器的相关操作和注意事项。"
            },
            {
                "content": "## 6.停止服务器\n\n当服务器通过`CTRL-C`下线时，它将通知当前的`leader`服务器，告知其从备份组中删除该下线的服务器。如果`leader`服务器下线，\n它将在下线前将`leader`身份权限传给另一台服务器。\n\n如果服务器被终止或者与备份组中的其他服务器失去连接，则该服务器将被视为失败节点，`leader`服务器将在特定时限后将其从备份组中删除。\n\n如果任何服务器离开备份组并希望重新加入，则必须从`--ha_conf HOST:PORT`选项开始，其中`HOST`是当前备份组中的某台服务器的 IP 地址。\n\n## 7.重启服务器\n\n不建议重新启动整个备份组，因为它会中断服务。如果需要，可以关闭所有服务器。但在重新启动时，\n必须保证关闭时的备份组中至少有N/2+1的服务器能正常启动，否则启动失败。 并且，\n无论初始启动复制组时是否指定`enable_bootstrap`为true，重启服务器时都只需通过\n指定`--ha_conf host1:port1,host2:port2`参数一次性重启所有服务器即可，命令示例如下所示：\n\n```bash\n$ ./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090\n```\n\n## 8.docker部署高可用集群\n\n在真实业务场景中，很可能遇到在多种操作系统或架构上部署高可用集群的需求。\n差异化的环境可能导致编译TuGraph时缺少某些依赖。因此，\n在docker中编译软件并部署高可用集群是非常有应用价值的。以centos7版本的docker为例，\n部署高可用集群的步骤如下所示。\n\n### 8.1.安装镜像\n使用如下命令下载TuGraph的编译docker镜像环境\n```shell\ndocker pull tugraph/tugraph-compile-centos7\n```\n然后拉取TuGraph源码并编译安装\n\n该段落主要介绍了停止和重启高可用集群中的服务器的操作方法以及在Docker中部署高可用集群的步骤。它紧接在关于高可用模式的其他重要管理操作之后，提供了如何在维护和故障情况下有效管理服务器的指导，同时也说明了在不同环境中部署的实用方法。"
            },
            {
                "content": "```bash\n$ ./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090\n```\n\n## 8.docker部署高可用集群\n\n在真实业务场景中，很可能遇到在多种操作系统或架构上部署高可用集群的需求。\n差异化的环境可能导致编译TuGraph时缺少某些依赖。因此，\n在docker中编译软件并部署高可用集群是非常有应用价值的。以centos7版本的docker为例，\n部署高可用集群的步骤如下所示。\n\n### 8.1.安装镜像\n使用如下命令下载TuGraph的编译docker镜像环境\n```shell\ndocker pull tugraph/tugraph-compile-centos7\n```\n然后拉取TuGraph源码并编译安装\n\n### 8.2.创建容器\n使用如下命令创建容器，使用`--net=host`使得容器运行在host模式，此模式下\ndocker和宿主机和共享网络namespace，即共用同一个IP。\n```shell\ndocker run --net=host -itd -p -v {src_dir}:{dst_dir} --name tugraph_ha tugraph/tugraph-compile-centos7 /bin/bash\n```\n\n### 8.3.启动服务\n在每台服务器上使用如下命令启动服务，因为docker和宿主机共享IP，所以可以直接指定在宿主机IP上启动服务\n```shell\n$ lgraph_server -c lgraph.json --host 172.22.224.15 --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090\n```\n\n## 9.查看服务器状态\n\n备份组的当前状态可以在 TuGraph 可视化工具、REST API 以及 Cypher 查询中获取。\n\n在 TuGraph 可视化工具中，可以在 DBInfo 部分中找到备份组中的服务器及其角色列表。\n\n该段落位于文档的第8部分，主要介绍在Docker环境中部署TuGraph高可用集群的步骤，包括安装镜像、创建容器以及启动服务的具体命令和操作说明。前面的部分则详细讲解了高可用模式的原理、准备工作和其他相关操作。"
            },
            {
                "content": "### 8.3.启动服务\n在每台服务器上使用如下命令启动服务，因为docker和宿主机共享IP，所以可以直接指定在宿主机IP上启动服务\n```shell\n$ lgraph_server -c lgraph.json --host 172.22.224.15 --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090\n```\n\n## 9.查看服务器状态\n\n备份组的当前状态可以在 TuGraph 可视化工具、REST API 以及 Cypher 查询中获取。\n\n在 TuGraph 可视化工具中，可以在 DBInfo 部分中找到备份组中的服务器及其角色列表。\n\n使用 REST API 时，可以使用`GET /info/peers` 请求获取信息。\n\n在 Cypher 中，使用`CALL dbms.listServers()`语句来查询当前备份组的状态信息。\n\n## 10.高可用模式下数据同步问题\n\n在高可用模式下，同一备份组中的不同服务器可能并不总是处于相同的状态。出于性能原因，如果请求已同步到超过一半的服务器，则`leader`服务器将认为该请求属于`committed`状态。尽管其余服务器最终将收到新请求，但服务器的状态不一致将持续一段时间。客户端也可能向刚刚重新启动的服务器发送请求，从而具有较旧的状态。\n\n为了确保客户端看到一致连续的数据，特别是为了摆脱`反向时间旅行`问题（其中客户端读取比以前看到的状态更旧的状态），每个 TuGraph 服务器都会保持一个单调增加的数据版本号。备份组中数据版本号到数据库状态的映射全局一致，这意味着如果两台服务器具有相同的数据版本号，则它们必须具有相同的数据。响应请求时，服务器在响应中包含了其数据版本号。因此，客户端可以知道它看到了哪个版本。客户端收到旧版本的数据之后可以重新向Leader发送请求，从而获取到最新的数据。\n\n该块内容位于文档的第八部分和第九部分之间，主要介绍了在Docker环境中启动TuGraph高可用集群服务的命令以及查看服务器状态的方法。这涵盖了服务启动后的状态查询和高可用模式下的数据同步问题，强调了集群中服务器状态一致性的重要性。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_58.md",
        "chunks": [
            {
                "content": "# C++存储过程接口（C++开发存储过程接口）\r\n\r\n## base64_encode\r\nBase64编码和解码。简单实现，用于BLOB字段。如果性能很重要，请寻找优化后的实现。\r\n\r\n### namespace lgraph_api\r\n### namespace base64\r\n\r\n#### Functions\r\n\r\n```cpp\r\ninline std::string Encode(const char *p, size_t s)\r\n```\r\nEncodes a string to Base64.  \r\n将字符串编码为Base64。\r\n\r\n**参数**  \r\np – 要编码的字符串。  \r\ns – 字符串的大小。  \r\n\r\n**返回**  \r\nThe encoded string.  \r\n编码后的字符串。\r\n\r\n```cpp\r\ninline std::string Encode(const std::string &str)\r\n```\r\nEncodes a string to Base64.  \r\n将字符串编码为Base64。\r\n\r\n**参数**  \r\nstr – 要编码的字符串。  \r\n\r\n**返回**  \r\nThe decoded string.  \r\n编码后的字符串。\r\n\r\n```cpp\r\ninline bool TryDecode(const char *p, size_t s, std::string &ret)\r\n```\r\nTries to decode a Base64 string.  \r\n尝试解码Base64字符串。\r\n\r\n**参数**  \r\np – 要解码的字符串。  \r\ns – 字符串的大小。  \r\nret – [out] 解码后的字符串。  \r\n\r\n**返回**  \r\nTrue if the string was decoded successfully, false otherwise.  \r\n如果字符串成功解码则返回true，否则返回false。\r\n\r\n```cpp\r\ninline bool TryDecode(const std::string &str, std::string &out)\r\n```\r\nTries to decode a Base64 string.  \r\n尝试解码Base64字符串。\r\n\r\n**参数**  \r\nstr – 要解码的字符串。\n\n该文档详细介绍了C++存储过程接口，包括Base64编码和解码的实现。在\"base64_encode\"部分，描述了如何对字符串进行Base64编码和解码，以及相关的函数定义与参数说明，如Encode和TryDecode等。这些功能用于处理BLOB字段，适合需要在数据库操作中进行数据编码的场景。"
            },
            {
                "content": "**返回**  \r\nThe decoded string.  \r\n编码后的字符串。\r\n\r\n```cpp\r\ninline bool TryDecode(const char *p, size_t s, std::string &ret)\r\n```\r\nTries to decode a Base64 string.  \r\n尝试解码Base64字符串。\r\n\r\n**参数**  \r\np – 要解码的字符串。  \r\ns – 字符串的大小。  \r\nret – [out] 解码后的字符串。  \r\n\r\n**返回**  \r\nTrue if the string was decoded successfully, false otherwise.  \r\n如果字符串成功解码则返回true，否则返回false。\r\n\r\n```cpp\r\ninline bool TryDecode(const std::string &str, std::string &out)\r\n```\r\nTries to decode a Base64 string.  \r\n尝试解码Base64字符串。\r\n\r\n**参数**  \r\nstr – 要解码的字符串。  \r\nout – [out] 解码后的字符串。  \r\n\r\n**返回**  \r\nTrue if the string was decoded successfully, false otherwise.  \r\n如果字符串成功解码则返回true，否则返回false。\r\n\r\n```cpp\r\ninline std::string Decode(const char *p, size_t s)\r\n```\r\nDecode a Base64 string and throw exception if fails.  \r\n解码Base64字符串，如果失败则抛出异常。\r\n\r\n**抛出**  \r\nInputError – 如果字符串不是有效的Base64字符串，则抛出。\r\n\r\n**参数**  \r\np – 要解码的字符串。  \r\ns – 字符串的大小。  \r\n\r\n**返回**  \r\nThe decoded string.  \r\n解码后的字符串。\r\n\r\n```cpp\r\ninline std::string Decode(const std::string &str)\r\n```\n\n该块内容位于文档的**C++存储过程接口**部分，具体属于**base64**命名空间下的函数定义，主要描述了Base64编码和解码的相关函数，包括尝试解码和直接解码的功能及其参数说明和返回值。"
            },
            {
                "content": "**参数**  \r\nstr – 要解码的字符串。  \r\nout – [out] 解码后的字符串。  \r\n\r\n**返回**  \r\nTrue if the string was decoded successfully, false otherwise.  \r\n如果字符串成功解码则返回true，否则返回false。\r\n\r\n```cpp\r\ninline std::string Decode(const char *p, size_t s)\r\n```\r\nDecode a Base64 string and throw exception if fails.  \r\n解码Base64字符串，如果失败则抛出异常。\r\n\r\n**抛出**  \r\nInputError – 如果字符串不是有效的Base64字符串，则抛出。\r\n\r\n**参数**  \r\np – 要解码的字符串。  \r\ns – 字符串的大小。  \r\n\r\n**返回**  \r\nThe decoded string.  \r\n解码后的字符串。\r\n\r\n```cpp\r\ninline std::string Decode(const std::string &str)\r\n```\r\nDecode a Base64 string and throw exception if fails.  \r\n解码Base64字符串，如果失败则抛出异常。\r\n\r\n**抛出**  \r\nInputError – 如果字符串不是有效的Base64字符串，则抛出。\r\n\r\n**参数**  \r\nstr – 要解码的字符串。  \r\n\r\n**返回**  \r\nThe decoded string.  \r\n解码后的字符串。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph\r\n\r\n### Defines\r\n\r\n#### LGAPI\r\nnamespace lgraph_api\r\n\r\n### Typedefs\r\n\r\n```cpp\r\ntypedef bool GetSignature(SigSpec &sig_spec) \r\n```\r\n这行代码定义了一个函数指针类型 `GetSignature`，它接受一个 `SigSpec` 类型的引用作为参数，并返回一个布尔值。\r\n\r\n```cpp\n\n该片段位于文档中关于Base64编码和解码函数的部分，具体描述了两个解码函数的参数、返回值和可能抛出的异常。此部分主要介绍`Decode`函数的功能，以及如何处理Base64字符串的解码操作，属于lgraph_api命名空间中的一部分。"
            },
            {
                "content": "```cpp\r\ninline std::string Decode(const std::string &str)\r\n```\r\nDecode a Base64 string and throw exception if fails.  \r\n解码Base64字符串，如果失败则抛出异常。\r\n\r\n**抛出**  \r\nInputError – 如果字符串不是有效的Base64字符串，则抛出。\r\n\r\n**参数**  \r\nstr – 要解码的字符串。  \r\n\r\n**返回**  \r\nThe decoded string.  \r\n解码后的字符串。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph\r\n\r\n### Defines\r\n\r\n#### LGAPI\r\nnamespace lgraph_api\r\n\r\n### Typedefs\r\n\r\n```cpp\r\ntypedef bool GetSignature(SigSpec &sig_spec) \r\n```\r\n这行代码定义了一个函数指针类型 `GetSignature`，它接受一个 `SigSpec` 类型的引用作为参数，并返回一个布尔值。\r\n\r\n```cpp\r\ntypedef bool Process(lgraph_api::GraphDB &db, const std::string &input, std::string &output) \r\n```\r\n这行代码定义了一个函数指针类型 `Process`，它接受一个 `lgraph_api::GraphDB` 的引用、一个常量字符串和一个字符串的引用作为参数，并返回一个布尔值。\r\n\r\n```cpp\r\ntypedef bool ProcessInTxn(lgraph_api::Transaction &txn, const std::string &input, lgraph_api::Result &output) \r\n```\r\n这行代码定义了一个函数指针类型 `ProcessInTxn`，它接受一个 `lgraph_api::Transaction` 的引用、一个常量字符串和一个 `lgraph_api::Result` 的引用作为参数，并返回一个布尔值。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_atomic\n\n该代码段中的 `Decode` 函数定义位于 C++ 存储过程接口文档的 **base64** 部分，专门用于对 Base64 编码字符串进行解码，并在解码失败时抛出异常。其后跟随的是**lgraph** 命名空间的定义，包含类型定义和函数指针类型的定义，这些类型和函数用于在图数据库中处理图的签名和过程。"
            },
            {
                "content": "```cpp\r\ntypedef bool Process(lgraph_api::GraphDB &db, const std::string &input, std::string &output) \r\n```\r\n这行代码定义了一个函数指针类型 `Process`，它接受一个 `lgraph_api::GraphDB` 的引用、一个常量字符串和一个字符串的引用作为参数，并返回一个布尔值。\r\n\r\n```cpp\r\ntypedef bool ProcessInTxn(lgraph_api::Transaction &txn, const std::string &input, lgraph_api::Result &output) \r\n```\r\n这行代码定义了一个函数指针类型 `ProcessInTxn`，它接受一个 `lgraph_api::Transaction` 的引用、一个常量字符串和一个 `lgraph_api::Result` 的引用作为参数，并返回一个布尔值。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_atomic\r\nImplementation of atomic operations, used in lgraph_traversal.\r\n实现原子操作，用于 lgraph_traversal。\r\n\r\n### namespace lgraph_api\r\n\r\n### Functions\r\n\r\n```cpp\r\ntemplate\r\ninline bool cas(T *ptr, T oldv, T newv) \r\n```\r\n这个模板函数定义了一个原子 Compare-And-Swap 操作，接受指针 `ptr`、旧值 `oldv` 和新值 `newv` 作为参数。\r\n\r\n```cpp\r\ntemplate\r\ninline bool write_min(T *a, T b) \r\n```\r\n这个模板函数定义了一个原子最小写操作，接受指针 `a` 和一个值 `b`，将 `a` 的值更新为 `b` 和 `*a` 中的较小值。\r\n\r\n```cpp\r\ntemplate\r\ninline bool write_max(T *a, T b) \r\n```\r\n这个模板函数定义了一个原子最大写操作，接受指针 `a` 和一个值 `b`，将 `a` 的值更新为 `b` 和 `*a` 中的较大值。\n\n在文档中，此代码块位于lgraph模块定义部分，定义了函数指针类型`Process`和`ProcessInTxn`，用于处理图数据库和事务的数据处理逻辑。这些函数指针允许开发者在C++中方便地定义和实现自定义的处理流程。"
            },
            {
                "content": "实现原子操作，用于 lgraph_traversal。\r\n\r\n### namespace lgraph_api\r\n\r\n### Functions\r\n\r\n```cpp\r\ntemplate\r\ninline bool cas(T *ptr, T oldv, T newv) \r\n```\r\n这个模板函数定义了一个原子 Compare-And-Swap 操作，接受指针 `ptr`、旧值 `oldv` 和新值 `newv` 作为参数。\r\n\r\n```cpp\r\ntemplate\r\ninline bool write_min(T *a, T b) \r\n```\r\n这个模板函数定义了一个原子最小写操作，接受指针 `a` 和一个值 `b`，将 `a` 的值更新为 `b` 和 `*a` 中的较小值。\r\n\r\n```cpp\r\ntemplate\r\ninline bool write_max(T *a, T b) \r\n```\r\n这个模板函数定义了一个原子最大写操作，接受指针 `a` 和一个值 `b`，将 `a` 的值更新为 `b` 和 `*a` 中的较大值。\r\n\r\n```cpp\r\ntemplate\r\ninline void write_add(T *a, T b) \r\n```\r\n这个模板函数定义了一个原子加法操作，将值 `b` 添加到指针 `a` 指向的值上。\r\n\r\n```cpp\r\ninline void write_add(uint64_t *a, uint64_t b) \r\n```\r\n这个函数定义了一个针对 `uint64_t` 类型的原子加法操作，将值 `b` 添加到指针 `a` 指向的值上。\r\n\r\n```cpp\r\ninline void write_add(uint32_t *a, uint32_t b) \r\n```\r\n这个函数定义了一个针对 `uint32_t` 类型的原子加法操作，将值 `b` 添加到指针 `a` 指向的值上。\r\n\r\n```cpp\r\ninline void write_add(int64_t *a, int64_t b) \r\n```\r\n这个函数定义了一个针对 `int64_t` 类型的原子加法操作，将值 `b` 添加到指针 `a` 指向的值上。\r\n\r\n```cpp\r\ninline void write_add(int32_t *a, int32_t b) \r\n```\n\n该块内容位于文档的“lgraph_atomic”部分，介绍了原子操作的实现，主要用于图遍历过程中的并发控制。内容涵盖了多个模板函数和具体操作，如Compare-And-Swap、原子最小和最大写操作，以及原子加法等。这些功能在多线程环境下确保数据操作的安全性和一致性。"
            },
            {
                "content": "inline void write_add(T *a, T b) \r\n```\r\n这个模板函数定义了一个原子加法操作，将值 `b` 添加到指针 `a` 指向的值上。\r\n\r\n```cpp\r\ninline void write_add(uint64_t *a, uint64_t b) \r\n```\r\n这个函数定义了一个针对 `uint64_t` 类型的原子加法操作，将值 `b` 添加到指针 `a` 指向的值上。\r\n\r\n```cpp\r\ninline void write_add(uint32_t *a, uint32_t b) \r\n```\r\n这个函数定义了一个针对 `uint32_t` 类型的原子加法操作，将值 `b` 添加到指针 `a` 指向的值上。\r\n\r\n```cpp\r\ninline void write_add(int64_t *a, int64_t b) \r\n```\r\n这个函数定义了一个针对 `int64_t` 类型的原子加法操作，将值 `b` 添加到指针 `a` 指向的值上。\r\n\r\n```cpp\r\ninline void write_add(int32_t *a, int32_t b) \r\n```\r\n这个函数定义了一个针对 `int32_t` 类型的原子加法操作，将值 `b` 添加到指针 `a` 指向的值上。\r\n\r\n```cpp\r\ntemplate\r\ninline void write_sub(T *a, T b) \r\n```\r\n这个模板函数定义了一个原子减法操作，将值 `b` 从指针 `a` 指向的值中减去。\r\n\r\n```cpp\r\ninline void write_sub(uint64_t *a, uint64_t b) \r\n```\r\n这个函数定义了一个针对 `uint64_t` 类型的原子减法操作，从指针 `a` 指向的值中减去 `b`。\r\n\r\n```cpp\r\ninline void write_sub(uint32_t *a, uint32_t b) \r\n```\r\n这个函数定义了一个针对 `uint32_t` 类型的原子减法操作，从指针 `a` 指向的值中减去 `b`。\r\n\r\n```cpp\r\ninline void write_sub(int64_t *a, int64_t b) \r\n```\r\n这个函数定义了一个针对 `int64_t` 类型的原子减法操作，从指针 `a` 指向的值中减去 `b`。\n\n该代码段位于文档的“lgraph_atomic”部分，主要介绍了原子操作的实现，具体针对不同数据类型的加法和减法操作。此部分实现了多线程环境下对变量进行安全、原子性的更新，确保数据一致性和避免竞争条件。"
            },
            {
                "content": "```cpp\r\ntemplate\r\ninline void write_sub(T *a, T b) \r\n```\r\n这个模板函数定义了一个原子减法操作，将值 `b` 从指针 `a` 指向的值中减去。\r\n\r\n```cpp\r\ninline void write_sub(uint64_t *a, uint64_t b) \r\n```\r\n这个函数定义了一个针对 `uint64_t` 类型的原子减法操作，从指针 `a` 指向的值中减去 `b`。\r\n\r\n```cpp\r\ninline void write_sub(uint32_t *a, uint32_t b) \r\n```\r\n这个函数定义了一个针对 `uint32_t` 类型的原子减法操作，从指针 `a` 指向的值中减去 `b`。\r\n\r\n```cpp\r\ninline void write_sub(int64_t *a, int64_t b) \r\n```\r\n这个函数定义了一个针对 `int64_t` 类型的原子减法操作，从指针 `a` 指向的值中减去 `b`。\r\n\r\n```cpp\r\ninline void write_sub(int32_t *a, int32_t b) \r\n```\r\n这个函数定义了一个针对 `int32_t` 类型的原子减法操作，从指针 `a` 指向的值中减去 `b`。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_date_time\r\nImplements the DateTime, Date and TimeZone classes. \r\n// 实现了 DateTime，Date 和 TimeZone 类。\r\n\r\n### namespace lgraph_api\r\n// 命名空间 lgraph_api\r\n\r\n### Functions\r\n// 函数\r\n\r\n```cpp\r\nstatic inline constexpr int32_t MinDaysSinceEpochForDate()\r\n```\r\nmin and max values that Date can hold\r\n// Date 可以持有的最小值和最大值\r\n\r\n```cpp\r\nstatic inline constexpr int32_t MaxDaysSinceEpochForDate()\r\n```\r\nMaximum days since epoch for date\n\n该代码块位于文档的“lgraph_atomic”部分，介绍了多个针对不同数据类型的原子减法操作函数。这些操作用于在多线程环境中安全地执行减法，以确保数据一致性和避免竞争条件。"
            },
            {
                "content": "```\r\n这个函数定义了一个针对 `int32_t` 类型的原子减法操作，从指针 `a` 指向的值中减去 `b`。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_date_time\r\nImplements the DateTime, Date and TimeZone classes. \r\n// 实现了 DateTime，Date 和 TimeZone 类。\r\n\r\n### namespace lgraph_api\r\n// 命名空间 lgraph_api\r\n\r\n### Functions\r\n// 函数\r\n\r\n```cpp\r\nstatic inline constexpr int32_t MinDaysSinceEpochForDate()\r\n```\r\nmin and max values that Date can hold\r\n// Date 可以持有的最小值和最大值\r\n\r\n```cpp\r\nstatic inline constexpr int32_t MaxDaysSinceEpochForDate()\r\n```\r\nMaximum days since epoch for date\r\n// Date 的最大纪元天数\r\n\r\n```cpp\r\nstatic inline constexpr int64_t MinMicroSecondsSinceEpochForDateTime()\r\n```\r\nmin and max values that Date can hold\r\n// DateTime 可以持有的最小值和最大值\r\n\r\n```cpp\r\nstatic inline constexpr int64_t MaxMicroSecondsSinceEpochForDateTime()\r\n```\r\nMaximum microseconds since epoch for date time\r\n// DateTime 的最大纪元微秒数\r\n\r\n### class Date\r\n```cpp\r\n#include \r\n```\r\nImplements the Date class. Range of dates is from 0/1/1 to 12/31/9999.\r\n// 实现了 Date 类。日期范围为 0/1/1 到 12/31/9999。\r\n\r\n#### Public Functions\r\n// 公共函数\n\n该文档主要集中在 C++ 开发存储过程接口，其中详细描述了与图数据库交互的各种类和函数。在这段内容中，具体介绍了原子操作的定义，特别是针对 `int32_t` 类型的原子减法操作，以及日期和时间相关的类和函数，包括 `DateTime`、`Date` 和 `TimeZone` 类的实现细节。"
            },
            {
                "content": "```cpp\r\nstatic inline constexpr int64_t MinMicroSecondsSinceEpochForDateTime()\r\n```\r\nmin and max values that Date can hold\r\n// DateTime 可以持有的最小值和最大值\r\n\r\n```cpp\r\nstatic inline constexpr int64_t MaxMicroSecondsSinceEpochForDateTime()\r\n```\r\nMaximum microseconds since epoch for date time\r\n// DateTime 的最大纪元微秒数\r\n\r\n### class Date\r\n```cpp\r\n#include \r\n```\r\nImplements the Date class. Range of dates is from 0/1/1 to 12/31/9999.\r\n// 实现了 Date 类。日期范围为 0/1/1 到 12/31/9999。\r\n\r\n#### Public Functions\r\n// 公共函数\r\n\r\n```cpp\r\nDate()\r\n```\r\nConstruct a new Date object with the date set to 1970/1/1.\r\n// 构造一个新的 Date 对象，日期设置为 1970/1/1。\r\n\r\n```cpp\r\nexplicit Date(const std::chrono::system_clock::time_point &tp)\r\n```\r\nConstruct a new Date object with date set to the specified time. The time point must be in the range of 0/1/1 to 12/31/9999.\r\n// 使用指定的时间构造一个新的 Date 对象。时间点必须在 0/1/1 到 12/31/9999 的范围内。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.\r\n// **抛出** OutOfRange – 如果时间点超出范围则抛出。\r\n\r\n**参数**\n\n该代码块位于文档的“lgraph_date_time”部分，主要介绍了与日期和时间相关的类及其功能，包括“DateTime”类的最小和最大值，以及“Date”类的构造函数和相关抛出异常的描述。"
            },
            {
                "content": "// 公共函数\r\n\r\n```cpp\r\nDate()\r\n```\r\nConstruct a new Date object with the date set to 1970/1/1.\r\n// 构造一个新的 Date 对象，日期设置为 1970/1/1。\r\n\r\n```cpp\r\nexplicit Date(const std::chrono::system_clock::time_point &tp)\r\n```\r\nConstruct a new Date object with date set to the specified time. The time point must be in the range of 0/1/1 to 12/31/9999.\r\n// 使用指定的时间构造一个新的 Date 对象。时间点必须在 0/1/1 到 12/31/9999 的范围内。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.\r\n// **抛出** OutOfRange – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\ntp – Time point to set the date to.\r\n// **参数** tp – 要设置日期的时间点。\r\n\r\n```cpp\r\nexplicit Date(const YearMonthDay &ymd)\r\n```\r\nConstruct a new Date object with date set to the specified date. The date must be in the range of 0/1/1 to 12/31/9999.\r\n// 使用指定的日期构造一个新的 Date 对象。日期必须在 0/1/1 到 12/31/9999 的范围内。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.\r\n// **抛出** OutOfRange – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\nymd – Date in the form of year, month and day.\r\n// **参数** ymd – 以年、月、日形式表示的日期。\r\n\r\n```cpp\n\n该代码块位于文档的 \"lgraph_date_time\" 部分，具体描述了 Date 类的公共构造函数，包括如何创建一个新的 Date 对象以及相应的参数和异常处理。该部分介绍了有关日期对象创建的重要信息，帮助用户了解 Date 类的使用。"
            },
            {
                "content": "tp – Time point to set the date to.\r\n// **参数** tp – 要设置日期的时间点。\r\n\r\n```cpp\r\nexplicit Date(const YearMonthDay &ymd)\r\n```\r\nConstruct a new Date object with date set to the specified date. The date must be in the range of 0/1/1 to 12/31/9999.\r\n// 使用指定的日期构造一个新的 Date 对象。日期必须在 0/1/1 到 12/31/9999 的范围内。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.\r\n// **抛出** OutOfRange – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\nymd – Date in the form of year, month and day.\r\n// **参数** ymd – 以年、月、日形式表示的日期。\r\n\r\n```cpp\r\nexplicit Date(int32_t days_since_epoch)\r\n```\r\nConstruct a new Date object with date set to an offset from epoch, i.e. the date is set to the specified number of days from epoch. The result date must be in the range of 0/1/1 to 12/31/9999.\r\n// 构造一个新的 Date 对象，日期设置为相对于纪元的偏移，即日期设置为距离纪元的指定天数。结果日期必须在 0/1/1 到 12/31/9999 的范围内。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.\r\n// **抛出** OutOfRange – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\ndays_since_epoch – Number of days since epoch.\n\n该块内容位于文档中关于日期时间处理的部分，具体涉及 `Date` 类的构造函数，描述了如何使用不同的输入（如 `YearMonthDay` 和自纪元以来的天数）来创建日期对象。这部分内容强调了日期范围以及可能抛出的异常，适合于理解时间点的设置和日期对象的初始化。"
            },
            {
                "content": "```cpp\r\nexplicit Date(int32_t days_since_epoch)\r\n```\r\nConstruct a new Date object with date set to an offset from epoch, i.e. the date is set to the specified number of days from epoch. The result date must be in the range of 0/1/1 to 12/31/9999.\r\n// 构造一个新的 Date 对象，日期设置为相对于纪元的偏移，即日期设置为距离纪元的指定天数。结果日期必须在 0/1/1 到 12/31/9999 的范围内。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.\r\n// **抛出** OutOfRange – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\ndays_since_epoch – Number of days since epoch.\r\n// **参数** days_since_epoch – 从纪元开始的天数。\r\n\r\n```cpp\r\nexplicit Date(const std::string &str)\r\n```\r\nParse date from a YYYY-MM-DD string.\r\n// 从 YYYY-MM-DD 字符串解析日期。\r\n\r\n**抛出**  \r\nInputError – if the string is not in the correct format.\r\n// **抛出** InputError – 如果字符串不符合正确格式则抛出。\r\n\r\n**参数**  \r\nstr – The string.\r\n// **参数** str – 字符串。\r\n\r\n```cpp\r\nYearMonthDay GetYearMonthDay() const noexcept\r\n```\r\nReturns the current Date in the form of year, month and day.\r\n// 返回当前日期的年、月、日形式。\r\n\r\n**返回**  \r\nThe year month day.\r\n// **返回** 年月日。\r\n\r\n```cpp\n\n该代码块位于文档中关于日期时间处理的部分，具体涉及`Date`类的构造函数及相关方法，包括从纪元天数构造日期对象、从字符串解析日期以及获取当前日期的年、月、日形式。这部分内容为日期时间操作提供了基本的接口和异常处理说明，有助于理解如何在处理图数据库中的时间相关数据时使用日期时间功能。"
            },
            {
                "content": "```cpp\r\nexplicit Date(const std::string &str)\r\n```\r\nParse date from a YYYY-MM-DD string.\r\n// 从 YYYY-MM-DD 字符串解析日期。\r\n\r\n**抛出**  \r\nInputError – if the string is not in the correct format.\r\n// **抛出** InputError – 如果字符串不符合正确格式则抛出。\r\n\r\n**参数**  \r\nstr – The string.\r\n// **参数** str – 字符串。\r\n\r\n```cpp\r\nYearMonthDay GetYearMonthDay() const noexcept\r\n```\r\nReturns the current Date in the form of year, month and day.\r\n// 返回当前日期的年、月、日形式。\r\n\r\n**返回**  \r\nThe year month day.\r\n// **返回** 年月日。\r\n\r\n```cpp\r\nDate operator+(int days) const\r\n```\r\nAdd a number of days to the Date object.\r\n// 向 Date 对象添加一定数量的天数。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.\r\n// **抛出** OutOfRange – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\ndays – Number of days to add.\r\n// **参数** days – 要添加的天数。\r\n\r\n**返回**  \r\nThe resulting Date object.\r\n// **返回** 结果 Date 对象。\r\n\r\n```cpp\r\nDate &operator+=(int days)\r\n```\r\nAdd a number of days to the current Date object. In case of overflow, current object is not modified.\r\n// 向当前 Date 对象添加一定数量的天数。在溢出的情况下，当前对象不进行修改。\n\n该代码块位于有关日期时间类 `Date` 的部分，描述了该类的构造函数以及与日期相关的操作，包括从字符串解析日期、获取年月日、以及向日期添加天数的运算符重载。这部分内容适用于需要处理和表示日期的功能模块。"
            },
            {
                "content": "```\r\nAdd a number of days to the Date object.\r\n// 向 Date 对象添加一定数量的天数。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.\r\n// **抛出** OutOfRange – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\ndays – Number of days to add.\r\n// **参数** days – 要添加的天数。\r\n\r\n**返回**  \r\nThe resulting Date object.\r\n// **返回** 结果 Date 对象。\r\n\r\n```cpp\r\nDate &operator+=(int days)\r\n```\r\nAdd a number of days to the current Date object. In case of overflow, current object is not modified.\r\n// 向当前 Date 对象添加一定数量的天数。在溢出的情况下，当前对象不进行修改。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting date is out of range.\r\n// **抛出** OutOfRange – 如果结果日期超出范围则抛出。\r\n\r\n**参数**  \r\ndays – Number of days to add.\r\n// **参数** days – 要添加的天数。\r\n\r\n**返回**  \r\nReference to the current date.\r\n// **返回** 当前日期的引用。\r\n\r\n```cpp\r\nDate operator-(int days) const\r\n```\r\nSubtract a number of days from the Date object.\r\n// 从 Date 对象中减去一定数量的天数。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting date is out of range.\r\n// **抛出** OutOfRange – 如果结果日期超出范围则抛出。\r\n\r\n**参数**  \r\ndays – Number of days to subtract.\n\n该内容位于文档的日期处理部分，具体涉及 `Date` 类的方法，用于对日期对象进行加减天数操作，包括操作的参数、返回值以及可能抛出的异常。这一部分提供了对日期对象的修改功能的详细说明。"
            },
            {
                "content": "OutOfRange – Thrown if the resulting date is out of range.\r\n// **抛出** OutOfRange – 如果结果日期超出范围则抛出。\r\n\r\n**参数**  \r\ndays – Number of days to add.\r\n// **参数** days – 要添加的天数。\r\n\r\n**返回**  \r\nReference to the current date.\r\n// **返回** 当前日期的引用。\r\n\r\n```cpp\r\nDate operator-(int days) const\r\n```\r\nSubtract a number of days from the Date object.\r\n// 从 Date 对象中减去一定数量的天数。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting date is out of range.\r\n// **抛出** OutOfRange – 如果结果日期超出范围则抛出。\r\n\r\n**参数**  \r\ndays – Number of days to subtract.\r\n// **参数** days – 要减去的天数。\r\n\r\n**返回**  \r\nThe resulting Date object.\r\n// **返回** 结果 Date 对象。\r\n\r\n```cpp\r\nDate &operator-=(int days)\r\n```\r\nSubtract a number of days from the current Date object. In case of overflow, current object is not modified.\r\n// 从当前 Date 对象中减去一定数量的天数。在溢出的情况下，当前对象不进行修改。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting date is out of range.\r\n// **抛出** OutOfRange – 如果结果日期超出范围则抛出。\r\n\r\n**参数**  \r\ndays – Number of days to subtract.\r\n// **参数** days – 要减去的天数。\r\n\r\n**返回**\n\n该块内容位于文档的“lgraph_date_time”部分，具体描述了“Date”类中与日期减法相关的运算符重载，特别是涉及到日期减去天数的操作，处理日期溢出时的异常抛出，以及相关参数和返回值的说明。"
            },
            {
                "content": "// **参数** days – 要减去的天数。\r\n\r\n**返回**  \r\nThe resulting Date object.\r\n// **返回** 结果 Date 对象。\r\n\r\n```cpp\r\nDate &operator-=(int days)\r\n```\r\nSubtract a number of days from the current Date object. In case of overflow, current object is not modified.\r\n// 从当前 Date 对象中减去一定数量的天数。在溢出的情况下，当前对象不进行修改。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting date is out of range.\r\n// **抛出** OutOfRange – 如果结果日期超出范围则抛出。\r\n\r\n**参数**  \r\ndays – Number of days to subtract.\r\n// **参数** days – 要减去的天数。\r\n\r\n**返回**  \r\nReference to the current Date object.\r\n// **返回** 当前 Date 对象的引用。\r\n\r\n```cpp\r\nbool operator<(const Date &rhs) const noexcept\r\n```\r\n```cpp\r\nbool operator<=(const Date &rhs) const noexcept\r\n```\r\n```cpp\r\nbool operator>(const Date &rhs) const noexcept\r\n```\r\n```cpp\r\nbool operator>=(const Date &rhs) const noexcept\r\n```\r\n```cpp\r\nbool operator==(const Date &rhs) const noexcept\r\n```\r\n```cpp\r\nbool operator!=(const Date &rhs) const noexcept\r\n```\r\n```cpp\r\nint32_t DaysSinceEpoch() const noexcept\r\n```\n\n该代码块位于文档中关于`Date`类的部分，具体描述了`operator-=`运算符的重载以及相关的方法，包括从当前`Date`对象中减去天数的功能、溢出处理、抛出的异常以及返回值的说明。这段代码强调了日期操作的边界条件与异常处理，以便于用户理解如何安全地进行日期计算。"
            },
            {
                "content": "**返回**  \r\nReference to the current Date object.\r\n// **返回** 当前 Date 对象的引用。\r\n\r\n```cpp\r\nbool operator<(const Date &rhs) const noexcept\r\n```\r\n```cpp\r\nbool operator<=(const Date &rhs) const noexcept\r\n```\r\n```cpp\r\nbool operator>(const Date &rhs) const noexcept\r\n```\r\n```cpp\r\nbool operator>=(const Date &rhs) const noexcept\r\n```\r\n```cpp\r\nbool operator==(const Date &rhs) const noexcept\r\n```\r\n```cpp\r\nbool operator!=(const Date &rhs) const noexcept\r\n```\r\n```cpp\r\nint32_t DaysSinceEpoch() const noexcept\r\n```\r\nReturns the number of days this date is since epoch.\r\n// 返回该日期距离纪元的天数。\r\n\r\n```cpp\r\nint32_t GetStorage() const noexcept\r\n```\r\nReturns the number of days this date is since epoch.\r\n// 返回该日期距离纪元的天数。\r\n\r\n```cpp\r\nexplicit operator int32_t() const noexcept\r\n```\r\nReturns the number of days this date is since epoch.\r\n// 返回该日期距离纪元的天数。\r\n\r\n```cpp\r\nstd::chrono::system_clock::time_point TimePoint() const noexcept\r\n```\r\nReturns the timepoint corresponding to this date at 00:00 am.\r\n// 返回与该日期对应的时间点（00:00 AM）。\r\n\r\n```cpp\n\n该块内容位于文档中关于`Date`类的部分，主要描述了与日期相关的运算符重载及相关成员函数。这些函数用于比较日期对象，以及获取日期距离纪元的天数和时间点等信息。该类实现了日期的基本操作，方便用户进行日期处理。"
            },
            {
                "content": "Returns the number of days this date is since epoch.\r\n// 返回该日期距离纪元的天数。\r\n\r\n```cpp\r\nint32_t GetStorage() const noexcept\r\n```\r\nReturns the number of days this date is since epoch.\r\n// 返回该日期距离纪元的天数。\r\n\r\n```cpp\r\nexplicit operator int32_t() const noexcept\r\n```\r\nReturns the number of days this date is since epoch.\r\n// 返回该日期距离纪元的天数。\r\n\r\n```cpp\r\nstd::chrono::system_clock::time_point TimePoint() const noexcept\r\n```\r\nReturns the timepoint corresponding to this date at 00:00 am.\r\n// 返回与该日期对应的时间点（00:00 AM）。\r\n\r\n```cpp\r\nstd::string ToString() const noexcept\r\n```\r\nGet the string representation of the date in the format of YYYY-MM-DD.\r\n// 获取日期的字符串表示，格式为 YYYY-MM-DD。\r\n\r\n```cpp\r\nexplicit operator DateTime() const noexcept\r\n```\r\nGet the DateTime object corresponding to 00:00 am on this date.\r\n// 获取与该日期的 00:00 AM 对应的 DateTime 对象。\r\n\r\n#### Public Static Functions\r\n\r\n```cpp\r\nstatic bool Parse(const std::string &str, Date &d) noexcept\r\n```\r\nParse date from YYYY-MM-DD, save value in d.  \r\n从YYYY-MM-DD格式解析日期，并将结果保存到d中。\r\n\r\n**参数**\n\n该代码块属于 `lgraph_date_time` 模块，具体涉及 `Date` 类的公共函数部分，重点描述了如何获取日期的存储、时间点和字符串表示，以及解析日期字符串的方法。这些函数用于操作和处理日期数据，确保支持从纪元起的天数计算和日期格式转换。"
            },
            {
                "content": "std::string ToString() const noexcept\r\n```\r\nGet the string representation of the date in the format of YYYY-MM-DD.\r\n// 获取日期的字符串表示，格式为 YYYY-MM-DD。\r\n\r\n```cpp\r\nexplicit operator DateTime() const noexcept\r\n```\r\nGet the DateTime object corresponding to 00:00 am on this date.\r\n// 获取与该日期的 00:00 AM 对应的 DateTime 对象。\r\n\r\n#### Public Static Functions\r\n\r\n```cpp\r\nstatic bool Parse(const std::string &str, Date &d) noexcept\r\n```\r\nParse date from YYYY-MM-DD, save value in d.  \r\n从YYYY-MM-DD格式解析日期，并将结果保存到d中。\r\n\r\n**参数**  \r\nstr – The string.  \r\nstr – 输入的字符串。\r\n\r\nd – [out] The resulting Date.  \r\nd – [输出] 解析结果的日期对象。\r\n\r\n**返回**  \r\nTrue if success, otherwise false.  \r\n如果成功返回true，否则返回false。\r\n\r\n```cpp\r\nstatic size_t Parse(const char *beg, const char *end, Date &d) noexcept\r\n```\r\nParse date from YYYY-MM-DD, save value in d.  \r\n从YYYY-MM-DD格式解析日期，并将结果保存到d中。\r\n\r\n**参数**  \r\nbeg – The beg.  \r\nbeg – 字符串的起始指针。\r\n\r\nend – The end.  \r\nend – 字符串的结束指针。\r\n\r\nd – [out] The result.  \r\nd – [输出] 解析结果的日期对象。\r\n\r\n**返回**\n\n该代码块属于`lgraph_date_time`模块，其中定义了`Date`类的相关方法和功能，主要用于处理日期的字符串表示、解析日期字符串为`Date`对象等。这些功能对于图数据库中的日期管理和操作非常重要。"
            },
            {
                "content": "**参数**  \r\nstr – The string.  \r\nstr – 输入的字符串。\r\n\r\nd – [out] The resulting Date.  \r\nd – [输出] 解析结果的日期对象。\r\n\r\n**返回**  \r\nTrue if success, otherwise false.  \r\n如果成功返回true，否则返回false。\r\n\r\n```cpp\r\nstatic size_t Parse(const char *beg, const char *end, Date &d) noexcept\r\n```\r\nParse date from YYYY-MM-DD, save value in d.  \r\n从YYYY-MM-DD格式解析日期，并将结果保存到d中。\r\n\r\n**参数**  \r\nbeg – The beg.  \r\nbeg – 字符串的起始指针。\r\n\r\nend – The end.  \r\nend – 字符串的结束指针。\r\n\r\nd – [out] The result.  \r\nd – [输出] 解析结果的日期对象。\r\n\r\n**返回**  \r\nNumber of bytes parsed (must be 10), 0 if failed.  \r\n解析的字节数（必须为10），如果失败则返回0。\r\n\r\n```cpp\r\nstatic Date Now() noexcept\r\n```\r\nReturns the current Date.  \r\n返回当前日期。\r\n\r\n**返回**  \r\nCurrent Date in UTC.  \r\n以UTC格式返回当前日期。\r\n\r\n```cpp\r\nstatic Date LocalNow() noexcept\r\n```\r\nReturns the current Date in local timezone.  \r\n返回本地时区的当前日期。\r\n\r\n**返回**  \r\nCurrent Date in local timezone.  \r\n以本地时区格式返回当前日期。\r\n\r\n#### Private Members\r\n\r\n```cpp\r\nint32_t days_since_epoch_\r\n```\r\nThe days since epoch  \r\n自纪元以来的天数。\r\n\r\n### struct YearMonthDay\r\n```cpp\r\n#include \r\n```\n\n该文本块位于文档的 `lgraph_date_time` 部分，涉及日期相关的功能，包括解析日期字符串、返回当前日期、以及获取本地时区的当前日期等操作。此外，文档还定义了一个结构 `YearMonthDay`，用于表示年、月、日的信息。"
            },
            {
                "content": "解析的字节数（必须为10），如果失败则返回0。\r\n\r\n```cpp\r\nstatic Date Now() noexcept\r\n```\r\nReturns the current Date.  \r\n返回当前日期。\r\n\r\n**返回**  \r\nCurrent Date in UTC.  \r\n以UTC格式返回当前日期。\r\n\r\n```cpp\r\nstatic Date LocalNow() noexcept\r\n```\r\nReturns the current Date in local timezone.  \r\n返回本地时区的当前日期。\r\n\r\n**返回**  \r\nCurrent Date in local timezone.  \r\n以本地时区格式返回当前日期。\r\n\r\n#### Private Members\r\n\r\n```cpp\r\nint32_t days_since_epoch_\r\n```\r\nThe days since epoch  \r\n自纪元以来的天数。\r\n\r\n### struct YearMonthDay\r\n```cpp\r\n#include \r\n```\r\nStructure representing a date in the format of year, month and day.  \r\n用于表示日期的结构，包括年、月、日格式。\r\n\r\n#### Public Members\r\n\r\n```cpp\r\nint year\r\n```\r\nThe year, 0-9999  \r\n年份，范围是0-9999。\r\n\r\n```cpp\r\nunsigned month\r\n```\r\nMonth, 1-12  \r\n月份，范围是1-12。\r\n\r\n```cpp\r\nunsigned day\r\n```\r\nDay, 1-31  \r\n日期，范围是1-31。\r\n\r\n### class DateTime\r\n```cpp\r\n#include \r\n```\r\nImplements a DateTime class that holds DateTime in the range of 0000-01-01 00:00:00.000000 to 9999-12-31 23:59:59.999999.  \r\n实现一个DateTime类，范围从0000-01-01 00:00:00.000000到9999-12-31 23:59:59.999999。\n\n该块内容位于文档的“lgraph_date_time”部分，主要介绍了日期和时间相关的类和函数，包括如何获取当前日期和本地时区的日期以及相关数据结构（如YearMonthDay和DateTime）的定义和成员。"
            },
            {
                "content": "用于表示日期的结构，包括年、月、日格式。\r\n\r\n#### Public Members\r\n\r\n```cpp\r\nint year\r\n```\r\nThe year, 0-9999  \r\n年份，范围是0-9999。\r\n\r\n```cpp\r\nunsigned month\r\n```\r\nMonth, 1-12  \r\n月份，范围是1-12。\r\n\r\n```cpp\r\nunsigned day\r\n```\r\nDay, 1-31  \r\n日期，范围是1-31。\r\n\r\n### class DateTime\r\n```cpp\r\n#include \r\n```\r\nImplements a DateTime class that holds DateTime in the range of 0000-01-01 00:00:00.000000 to 9999-12-31 23:59:59.999999.  \r\n实现一个DateTime类，范围从0000-01-01 00:00:00.000000到9999-12-31 23:59:59.999999。\r\n\r\n#### Public Functions\r\n\r\n```cpp\r\nDateTime()\r\n```\r\nConstruct a new DateTime object with date set to the epoch time, i.e., 1970-1-1 00:00:00.  \r\n构造一个新的DateTime对象，日期设置为纪元时间，即1970-1-1 00:00:00。\r\n\r\n```cpp\r\nexplicit DateTime(const std::chrono::system_clock::time_point &tp)\r\n```\r\nConstruct a new DateTime object with date set to the specified timepoint.  \r\n构造一个新的DateTime对象，日期设置为指定的时间点。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.  \r\n超出范围 – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\ntp – Timepoint to set the DateTime to.  \r\ntp – 设置DateTime的时间点。\n\n该块内容位于文档中关于日期和时间管理的部分，主要介绍了表示日期的 `Date` 结构以及 `DateTime` 类的实现，涵盖其公共成员和构造函数，适用于处理时间数据和日期格式的相关操作。"
            },
            {
                "content": "```\r\nConstruct a new DateTime object with date set to the epoch time, i.e., 1970-1-1 00:00:00.  \r\n构造一个新的DateTime对象，日期设置为纪元时间，即1970-1-1 00:00:00。\r\n\r\n```cpp\r\nexplicit DateTime(const std::chrono::system_clock::time_point &tp)\r\n```\r\nConstruct a new DateTime object with date set to the specified timepoint.  \r\n构造一个新的DateTime对象，日期设置为指定的时间点。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.  \r\n超出范围 – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\ntp – Timepoint to set the DateTime to.  \r\ntp – 设置DateTime的时间点。\r\n\r\n```cpp\r\nexplicit DateTime(const YMDHMSF &ymdhmsf)\r\n```\r\nConstruct a new DateTime object with date set to the specified date and time given in YMDHMSF.  \r\n构造一个新的DateTime对象，日期设置为在YMDHMSF中给定的指定日期和时间。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.  \r\n超出范围 – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\nymdhmsf – Date and time to set the DateTime to.  \r\nymdhmsf – 设置DateTime的日期和时间。\r\n\r\n```cpp\r\nexplicit DateTime(int64_t microseconds_since_epoch)\r\n```\n\n该段落位于文档中的 `lgraph_date_time` 部分，主要介绍 `DateTime` 类的构造函数及其相关功能。文中提到如何使用不同参数（如纪元时间、指定时间点及YMDHMSF格式）构造 `DateTime` 对象，以及可能抛出的异常和参数说明。"
            },
            {
                "content": "tp – 设置DateTime的时间点。\r\n\r\n```cpp\r\nexplicit DateTime(const YMDHMSF &ymdhmsf)\r\n```\r\nConstruct a new DateTime object with date set to the specified date and time given in YMDHMSF.  \r\n构造一个新的DateTime对象，日期设置为在YMDHMSF中给定的指定日期和时间。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.  \r\n超出范围 – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\nymdhmsf – Date and time to set the DateTime to.  \r\nymdhmsf – 设置DateTime的日期和时间。\r\n\r\n```cpp\r\nexplicit DateTime(int64_t microseconds_since_epoch)\r\n```\r\nConstruct a new DateTime object with date set to specified number of microseconds since epoch.  \r\n构造一个新的DateTime对象，日期设置为从纪元以来指定的微秒数。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.  \r\n超出范围 – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\nmicroseconds_since_epoch – Number of microseconds since epoch.  \r\nmicroseconds_since_epoch – 从纪元以来的微秒数。\r\n\r\n```cpp\r\nexplicit DateTime(const std::string &str)\r\n```\r\nConstruct a new DateTime object with date set to the specified date and time given in the form of YYYY-MM-DD HH:MM:SS[.FFFFFF].\n\n该段落位于文档的 `lgraph_date_time` 部分，主要描述了构造 `DateTime` 对象的几种方法，包括根据指定的日期时间、微秒数或字符串格式创建新的 `DateTime` 对象。此部分还涉及异常处理和参数说明，帮助用户理解如何正确使用 `DateTime` 类。"
            },
            {
                "content": "构造一个新的DateTime对象，日期设置为从纪元以来指定的微秒数。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.  \r\n超出范围 – 如果时间点超出范围则抛出。\r\n\r\n**参数**  \r\nmicroseconds_since_epoch – Number of microseconds since epoch.  \r\nmicroseconds_since_epoch – 从纪元以来的微秒数。\r\n\r\n```cpp\r\nexplicit DateTime(const std::string &str)\r\n```\r\nConstruct a new DateTime object with date set to the specified date and time given in the form of YYYY-MM-DD HH:MM:SS[.FFFFFF].  \r\n构造一个新的DateTime对象，日期设置为以YYYY-MM-DD HH:MM:SS[.FFFFFF]形式给定的指定日期和时间。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the time point is out of range.  \r\n超出范围 – 如果时间点超出范围则抛出。\r\n\r\nInputError – Thrown if str has invalid format.  \r\n输入错误 - 如果字符串格式无效则抛出。\r\n\r\n**参数**  \r\nstr – String representation of the date and time in the form of YYYY-MM-DD HH:MM:SS.  \r\nstr – 日期和时间的字符串表示，格式为YYYY-MM-DD HH:MM:SS。\r\n\r\n```cpp\r\nYMDHMSF GetYMDHMSF() const noexcept\r\n```\r\nGet current DateTime in the form of year, month, day, hour, minute, second, fraction.  \r\n以年、月、日、小时、分钟、秒和小数组成的形式获取当前DateTime。\r\n\r\n**返回**  \r\nThe ymdhmsf.\n\n该片段位于文档的 \"lgraph_date_time\" 部分，描述了 `DateTime` 类的构造函数及其相关方法，包括如何从微秒数或特定格式的字符串中构造 `DateTime` 对象，以及可能抛出的异常。这些信息有助于用户理解如何使用 `DateTime` 类来处理时间数据。"
            },
            {
                "content": "OutOfRange – Thrown if the time point is out of range.  \r\n超出范围 – 如果时间点超出范围则抛出。\r\n\r\nInputError – Thrown if str has invalid format.  \r\n输入错误 - 如果字符串格式无效则抛出。\r\n\r\n**参数**  \r\nstr – String representation of the date and time in the form of YYYY-MM-DD HH:MM:SS.  \r\nstr – 日期和时间的字符串表示，格式为YYYY-MM-DD HH:MM:SS。\r\n\r\n```cpp\r\nYMDHMSF GetYMDHMSF() const noexcept\r\n```\r\nGet current DateTime in the form of year, month, day, hour, minute, second, fraction.  \r\n以年、月、日、小时、分钟、秒和小数组成的形式获取当前DateTime。\r\n\r\n**返回**  \r\nThe ymdhmsf.  \r\n返回ymdhmsf格式的数据。\r\n\r\n```cpp\r\nDateTime operator+(int64_t n_microseconds) const\r\n```\r\nAdd a number of microseconds to the DateTime.  \r\n将一定数量的微秒添加到DateTime中。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting DateTime is out of range.  \r\n超出范围 – 如果结果DateTime超出范围则抛出。\r\n\r\n**参数**  \r\nn_microseconds – Number of micorseconds to add.  \r\nn_microseconds – 要添加的微秒数。\r\n\r\n**返回**  \r\nThe resulting DateTime.  \r\n结果DateTime。\r\n\r\n```cpp\r\nDateTime &operator+=(int64_t n_microseconds)\r\n```\n\n此文本块位于C++项目文档中，主要描述了日期时间相关的类和函数，包括如何处理时间点的错误（OutOfRange和InputError），以及获取和操作日期时间的方法，如获取年、月、日、时、分、秒和微秒的函数。这部分内容有助于理解如何在代码中使用日期时间类型及其相关操作。"
            },
            {
                "content": "**返回**  \r\nThe ymdhmsf.  \r\n返回ymdhmsf格式的数据。\r\n\r\n```cpp\r\nDateTime operator+(int64_t n_microseconds) const\r\n```\r\nAdd a number of microseconds to the DateTime.  \r\n将一定数量的微秒添加到DateTime中。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting DateTime is out of range.  \r\n超出范围 – 如果结果DateTime超出范围则抛出。\r\n\r\n**参数**  \r\nn_microseconds – Number of micorseconds to add.  \r\nn_microseconds – 要添加的微秒数。\r\n\r\n**返回**  \r\nThe resulting DateTime.  \r\n结果DateTime。\r\n\r\n```cpp\r\nDateTime &operator+=(int64_t n_microseconds)\r\n```\r\nAdds a number of microseconds to the current DateTime object. In case of overflow, current object is not modified.  \r\n将一定数量的微秒添加到当前DateTime对象。 如果发生溢出，当前对象不会被修改。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting DateTime is out of range.  \r\n超出范围 – 如果结果DateTime超出范围则抛出。\r\n\r\n**参数**  \r\nn_microseconds – Number of microseconds to add.  \r\nn_microseconds – 要添加的微秒数。\r\n\r\n**返回**  \r\nReference to the current DateTime.  \r\n返回对当前DateTime的引用。\r\n\r\n```cpp\r\nDateTime operator-(int64_t n_microseconds) const\r\n```\n\n该内容片段位于文档的 \"lgraph_date_time\" 部分，详细描述了 DateTime 类中与微秒相关的运算符重载，包括加法和减法运算符，以及相应的异常处理和参数说明。这部分内容旨在提供有关如何在 DateTime 对象上执行时间加减操作的具体细节。"
            },
            {
                "content": "```\r\nAdds a number of microseconds to the current DateTime object. In case of overflow, current object is not modified.  \r\n将一定数量的微秒添加到当前DateTime对象。 如果发生溢出，当前对象不会被修改。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting DateTime is out of range.  \r\n超出范围 – 如果结果DateTime超出范围则抛出。\r\n\r\n**参数**  \r\nn_microseconds – Number of microseconds to add.  \r\nn_microseconds – 要添加的微秒数。\r\n\r\n**返回**  \r\nReference to the current DateTime.  \r\n返回对当前DateTime的引用。\r\n\r\n```cpp\r\nDateTime operator-(int64_t n_microseconds) const\r\n```\r\nSubtract a number of microseconds from the DateTime.  \r\n从DateTime中减去一定数量的微秒。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting DateTime is out of range.  \r\n超出范围 – 如果结果DateTime超出范围则抛出。\r\n\r\n**参数**  \r\nn_microseconds – Number of microseconds to subtract.  \r\nn_microseconds – 要减去的微秒数。\r\n\r\n**返回**  \r\nThe resulting DateTime.  \r\n结果DateTime。\r\n\r\n```cpp\r\nDateTime &operator-=(int64_t n_microseconds)\r\n```\r\nSubtract a number of microseconds from the current DateTime object. In case of overflow, current object is not modified.\n\n该代码块位于文档的 `lgraph_date_time` 部分，主要描述了 `DateTime` 类中用于增加和减少微秒数的运算符重载函数，具体包括 `operator+=` 和 `operator-` 的功能、参数、返回值以及可能抛出的异常。这些函数允许对 `DateTime` 对象进行时间上的加减操作，确保日期时间的正确性和有效性。"
            },
            {
                "content": "从DateTime中减去一定数量的微秒。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting DateTime is out of range.  \r\n超出范围 – 如果结果DateTime超出范围则抛出。\r\n\r\n**参数**  \r\nn_microseconds – Number of microseconds to subtract.  \r\nn_microseconds – 要减去的微秒数。\r\n\r\n**返回**  \r\nThe resulting DateTime.  \r\n结果DateTime。\r\n\r\n```cpp\r\nDateTime &operator-=(int64_t n_microseconds)\r\n```\r\nSubtract a number of microseconds from the current DateTime object. In case of overflow, current object is not modified.  \r\n从当前DateTime对象中减去一定数量的微秒。如果发生溢出，当前对象不会被修改。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting DateTime is out of range.  \r\n超出范围 – 如果结果DateTime超出范围则抛出。\r\n\r\n**参数**  \r\nn_microseconds – Number of microseconds to subtract.  \r\nn_microseconds – 要减去的微秒数。\r\n\r\n**返回**  \r\nReference to the current DateTime.  \r\n返回对当前DateTime的引用。\r\n\r\n```cpp\r\nbool operator<(const DateTime &rhs) const noexcept\r\n```\r\n\r\n```cpp\r\nbool operator<=(const DateTime &rhs) const noexcept\r\n```\r\n\r\n```cpp\r\nbool operator>(const DateTime &rhs) const noexcept\r\n```\r\n\r\n```cpp\n\n该代码块位于文档中关于 `DateTime` 类的实现部分，主要描述了从当前 `DateTime` 对象中减去微秒数的操作，包括相关的异常处理、参数说明和返回值。此部分还涉及到运算符重载，用于比较 `DateTime` 对象的各种操作。"
            },
            {
                "content": "**抛出**  \r\nOutOfRange – Thrown if the resulting DateTime is out of range.  \r\n超出范围 – 如果结果DateTime超出范围则抛出。\r\n\r\n**参数**  \r\nn_microseconds – Number of microseconds to subtract.  \r\nn_microseconds – 要减去的微秒数。\r\n\r\n**返回**  \r\nReference to the current DateTime.  \r\n返回对当前DateTime的引用。\r\n\r\n```cpp\r\nbool operator<(const DateTime &rhs) const noexcept\r\n```\r\n\r\n```cpp\r\nbool operator<=(const DateTime &rhs) const noexcept\r\n```\r\n\r\n```cpp\r\nbool operator>(const DateTime &rhs) const noexcept\r\n```\r\n\r\n```cpp\r\nbool operator>=(const DateTime &rhs) const noexcept\r\n```\r\n\r\n```cpp\r\nbool operator==(const DateTime &rhs) const noexcept\r\n```\r\n\r\n```cpp\r\nbool operator!=(const DateTime &rhs) const noexcept\r\n```\r\n\r\n```cpp\r\nint64_t MicroSecondsSinceEpoch() const noexcept\r\n```\r\nReturns the number of microseconds since epoch.  \r\n返回自纪元以来的微秒数。\r\n\r\n```cpp\r\nint64_t GetStorage() const noexcept\r\n```\r\nReturns the number of microseconds since epoch.  \r\n返回自纪元以来的微秒数。\r\n\r\n```cpp\r\nexplicit operator int64_t() const noexcept\r\n```\n\n该代码段来自于 `DateTime` 类的定义部分，描述了类中一些运算符重载（如小于、大于等）的实现，以及与时间相关的函数，特别是关于返回自纪元以来微秒数的相关方法。这部分内容用于处理日期和时间数据，为图形数据库的时间相关分析提供支持。"
            },
            {
                "content": "```cpp\r\nbool operator>=(const DateTime &rhs) const noexcept\r\n```\r\n\r\n```cpp\r\nbool operator==(const DateTime &rhs) const noexcept\r\n```\r\n\r\n```cpp\r\nbool operator!=(const DateTime &rhs) const noexcept\r\n```\r\n\r\n```cpp\r\nint64_t MicroSecondsSinceEpoch() const noexcept\r\n```\r\nReturns the number of microseconds since epoch.  \r\n返回自纪元以来的微秒数。\r\n\r\n```cpp\r\nint64_t GetStorage() const noexcept\r\n```\r\nReturns the number of microseconds since epoch.  \r\n返回自纪元以来的微秒数。\r\n\r\n```cpp\r\nexplicit operator int64_t() const noexcept\r\n```\r\nReturns the number of microseconds since epoch.  \r\n返回自纪元以来的微秒数。\r\n\r\n```cpp\r\nstd::chrono::system_clock::time_point TimePoint() const noexcept\r\n```\r\nReturns the time point corresponding to this DateTime.  \r\n返回与该DateTime对应的时间点。\r\n\r\n```cpp\r\nstd::string ToString() const noexcept\r\n```\r\nGet the string representation of the DateTime in the format of YYYY-MM-DD HH:MM:SS[.FFFFFF].  \r\n获得DateTime的字符串表示，格式为YYYY-MM-DD HH:MM:SS[.FFFFFF]。\r\n\r\n```cpp\r\nstd::string ToDateString() const noexcept\r\n```\n\n该代码块位于文档中关于`DateTime`类的部分，具体定义了用于比较和获取时间信息的运算符及方法，包括操作符重载和获取自纪元以来微秒数的函数。这些函数允许开发人员操作和格式化`DateTime`对象，便于时间相关的操作。"
            },
            {
                "content": "```\r\nReturns the number of microseconds since epoch.  \r\n返回自纪元以来的微秒数。\r\n\r\n```cpp\r\nstd::chrono::system_clock::time_point TimePoint() const noexcept\r\n```\r\nReturns the time point corresponding to this DateTime.  \r\n返回与该DateTime对应的时间点。\r\n\r\n```cpp\r\nstd::string ToString() const noexcept\r\n```\r\nGet the string representation of the DateTime in the format of YYYY-MM-DD HH:MM:SS[.FFFFFF].  \r\n获得DateTime的字符串表示，格式为YYYY-MM-DD HH:MM:SS[.FFFFFF]。\r\n\r\n```cpp\r\nstd::string ToDateString() const noexcept\r\n```\r\nGet the string representation of the date part of DateTime in the format of YYYY-MM-DD.  \r\n获得DateTime日期部分的字符串表示，格式为YYYY-MM-DD。\r\n\r\n```cpp\r\nstd::string ToTimeString() const noexcept\r\n```\r\nGet the string representation of the time part of DateTime in the format of HH:MM:SS[.FFFFFF].  \r\n获得DateTime时间部分的字符串表示，格式为HH:MM:SS[.FFFFFF]。\r\n\r\n#### Public Static Functions\r\n\r\n```cpp\r\nstatic bool Parse(const std::string &str, DateTime &dt) noexcept\r\n```\r\nParse DateTime from string representation, save value in dt.  \r\n从字符串表示中解析DateTime，并将值保存到dt中。\n\n该块内容位于关于`lgraph_date_time`模块的部分，描述了与日期时间相关的类和函数，包括获取当前时间点、字符串表示及解析日期时间字符串的静态函数。这部分内容是对日期时间处理的功能概述，涉及到如何在图数据库操作中处理时间数据。"
            },
            {
                "content": "获得DateTime日期部分的字符串表示，格式为YYYY-MM-DD。\r\n\r\n```cpp\r\nstd::string ToTimeString() const noexcept\r\n```\r\nGet the string representation of the time part of DateTime in the format of HH:MM:SS[.FFFFFF].  \r\n获得DateTime时间部分的字符串表示，格式为HH:MM:SS[.FFFFFF]。\r\n\r\n#### Public Static Functions\r\n\r\n```cpp\r\nstatic bool Parse(const std::string &str, DateTime &dt) noexcept\r\n```\r\nParse DateTime from string representation, save value in dt.  \r\n从字符串表示中解析DateTime，并将值保存到dt中。\r\n\r\n**参数**  \r\nstr – The string.  \r\nstr – 字符串。\r\n\r\ndt – [out] The resulting DateTime.  \r\ndt – [输出] 结果的DateTime。\r\n\r\n**返回**  \r\nTrue if success, otherwise false.  \r\n成功返回true，否则返回false。\r\n\r\n```cpp\r\nstatic size_t Parse(const char *beg, const char *end, DateTime &dt) noexcept\r\n```\r\nParse DateTime from string representation, save value in dt.  \r\n从字符串表示中解析DateTime，并将值保存到dt中。\r\n\r\n**参数**  \r\nbeg – The beg.  \r\nbeg – 开始指针。\r\n\r\nend – The end.  \r\nend – 结束指针。\r\n\r\ndt – [out] The result.  \r\ndt – [输出] 结果。\r\n\r\n**返回**  \r\nNumber of bytes parsed (must be 26), 0 if failed.  \r\n解析的字节数（必须为26），如果失败则返回0。\n\n该代码块位于文档中关于日期和时间处理的部分，具体在`lgraph_date_time`模块中。它描述了`DateTime`类的公共函数，其中包含获取时间字符串表示的函数`ToTimeString()`及解析`DateTime`对象的静态函数，包括从字符串转换为`DateTime`的方法。这些函数是图数据库中时间数据的管理和操作的关键部分。"
            },
            {
                "content": "dt – [输出] 结果的DateTime。\r\n\r\n**返回**  \r\nTrue if success, otherwise false.  \r\n成功返回true，否则返回false。\r\n\r\n```cpp\r\nstatic size_t Parse(const char *beg, const char *end, DateTime &dt) noexcept\r\n```\r\nParse DateTime from string representation, save value in dt.  \r\n从字符串表示中解析DateTime，并将值保存到dt中。\r\n\r\n**参数**  \r\nbeg – The beg.  \r\nbeg – 开始指针。\r\n\r\nend – The end.  \r\nend – 结束指针。\r\n\r\ndt – [out] The result.  \r\ndt – [输出] 结果。\r\n\r\n**返回**  \r\nNumber of bytes parsed (must be 26), 0 if failed.  \r\n解析的字节数（必须为26），如果失败则返回0。\r\n\r\n```cpp\r\nstatic DateTime Now() noexcept\r\n```\r\nReturns the current DateTime.  \r\n返回当前的DateTime。\r\n\r\n**返回**  \r\nCurrent DateTime in UTC.  \r\n以UTC格式返回当前DateTime。\r\n\r\n```cpp\r\nstatic DateTime LocalNow() noexcept\r\n```\r\nReturns the current DateTime in local timezone.  \r\n返回本地时区的当前DateTime。\r\n\r\n**返回**  \r\nCurrent DateTime in local timezone.  \r\n以本地时区格式返回当前DateTime。\r\n\r\n#### Private Members\r\n\r\n```cpp\r\nint64_t microseconds_since_epoch_\r\n```\r\nThe microseconds since epoch.  \r\n自纪元以来的微秒数。\r\n\r\n### struct YMDHMSF\r\n```cpp\r\n#include \r\n```\n\n该文本块位于文档的 `lgraph_date_time` 章节中，介绍了与 `DateTime` 类相关的方法和返回值，包括从字符串解析 `DateTime`、获取当前日期时间以及返回本地时区的当前日期时间。这些函数旨在操作和处理日期时间数据，以支持图数据库中的时间相关功能。"
            },
            {
                "content": "static DateTime Now() noexcept\r\n```\r\nReturns the current DateTime.  \r\n返回当前的DateTime。\r\n\r\n**返回**  \r\nCurrent DateTime in UTC.  \r\n以UTC格式返回当前DateTime。\r\n\r\n```cpp\r\nstatic DateTime LocalNow() noexcept\r\n```\r\nReturns the current DateTime in local timezone.  \r\n返回本地时区的当前DateTime。\r\n\r\n**返回**  \r\nCurrent DateTime in local timezone.  \r\n以本地时区格式返回当前DateTime。\r\n\r\n#### Private Members\r\n\r\n```cpp\r\nint64_t microseconds_since_epoch_\r\n```\r\nThe microseconds since epoch.  \r\n自纪元以来的微秒数。\r\n\r\n### struct YMDHMSF\r\n```cpp\r\n#include \r\n```\r\nStructure representing a DateTime in the format of year, month, day, hour, minute, second and fraction.  \r\n表示日期时间的结构，格式为年、月、日、小时、分钟、秒和分数。\r\n\r\n#### Public Members\r\n\r\n```cpp\r\nint year\r\n```\r\nThe year, 0-9999  \r\n年份，范围是0到9999。\r\n\r\n```cpp\r\nunsigned month\r\n```\r\nMonth, 1-12  \r\n月份，范围是1到12。\r\n\r\n```cpp\r\nunsigned day\r\n```\r\nDay, 1-31  \r\n天，范围是1到31。\r\n\r\n```cpp\r\nunsigned hour\r\n```\r\nHour, 0-23  \r\n小时，范围是0到23。\r\n\r\n```cpp\r\nunsigned minute\r\n```\r\nMinute, 0-59  \r\n分钟，范围是0到59。\r\n\r\n```cpp\r\nunsigned second\r\n```\r\nSecond, 0-59  \r\n秒，范围是0到59。\n\n该片段位于文档的 `lgraph_date_time` 部分，重点介绍 `DateTime` 类及其相关功能，包括获取当前日期时间的方法（`Now` 和 `LocalNow`），以及表示日期时间格式的结构体 `YMDHMSF`。它详细描述了如何处理日期和时间信息，尤其是在不同时间区域中的应用。"
            },
            {
                "content": "表示日期时间的结构，格式为年、月、日、小时、分钟、秒和分数。\r\n\r\n#### Public Members\r\n\r\n```cpp\r\nint year\r\n```\r\nThe year, 0-9999  \r\n年份，范围是0到9999。\r\n\r\n```cpp\r\nunsigned month\r\n```\r\nMonth, 1-12  \r\n月份，范围是1到12。\r\n\r\n```cpp\r\nunsigned day\r\n```\r\nDay, 1-31  \r\n天，范围是1到31。\r\n\r\n```cpp\r\nunsigned hour\r\n```\r\nHour, 0-23  \r\n小时，范围是0到23。\r\n\r\n```cpp\r\nunsigned minute\r\n```\r\nMinute, 0-59  \r\n分钟，范围是0到59。\r\n\r\n```cpp\r\nunsigned second\r\n```\r\nSecond, 0-59  \r\n秒，范围是0到59。\r\n\r\n```cpp\r\nunsigned fraction\r\n```\r\nFraction, 0-999999  \r\n小数部分，范围是0到999999。\r\n\r\n### class TimeZone\r\n```cpp\r\n#include \r\n```\r\nA class that represents a time zone.  \r\n表示时区的类。\r\n\r\n#### Public Functions\r\n\r\n```cpp\r\nexplicit TimeZone(int time_diff_hours = 0)\r\n```\r\nCreate a timezone which has time difference with UTC in hours `time_diff_hours`.  \r\n创建与UTC有时差`time_diff_hours`小时的时区。\r\n\r\n**抛出**  \r\nInvalidParameter – Thrown if `time_diff_hours` is invalid.  \r\nInvalidParameter – 如果`time_diff_hours`无效则抛出。\r\n\r\n**参数**\n\n该片段描述了表示日期时间的结构体，包含年、月、日、时、分、秒和小数部分的字段定义。此外，还介绍了表示时区的类及其构造函数和参数。此内容位于文档的日期和时间处理部分，主要涉及图数据库中时间数据的表示与操作。"
            },
            {
                "content": "```cpp\r\nunsigned fraction\r\n```\r\nFraction, 0-999999  \r\n小数部分，范围是0到999999。\r\n\r\n### class TimeZone\r\n```cpp\r\n#include \r\n```\r\nA class that represents a time zone.  \r\n表示时区的类。\r\n\r\n#### Public Functions\r\n\r\n```cpp\r\nexplicit TimeZone(int time_diff_hours = 0)\r\n```\r\nCreate a timezone which has time difference with UTC in hours `time_diff_hours`.  \r\n创建与UTC有时差`time_diff_hours`小时的时区。\r\n\r\n**抛出**  \r\nInvalidParameter – Thrown if `time_diff_hours` is invalid.  \r\nInvalidParameter – 如果`time_diff_hours`无效则抛出。\r\n\r\n**参数**  \r\ntime_diff_hours – (Optional) Difference between local timezone and UTC. Must be >= -10 && <= 14. Otherwise, the function will throw.  \r\ntime_diff_hours – （可选）本地时区与UTC之间的差异。必须在-10到14之间。否则，该函数将抛出异常。\r\n\r\n```cpp\r\nDateTime FromUTC(const DateTime &dt) const\r\n```\r\nConvert a DateTime from UTC time to this time zone.  \r\n将UTC时间的DateTime转换为此时区。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting value is out of range.  \r\nOutOfRange – 如果结果值超出范围，则抛出。\r\n\r\n**参数**  \r\ndt – DateTime in UTC time.  \r\ndt – UTC时间下的DateTime。\r\n\r\n**返回**\n\n该代码块位于文档关于 `lgraph_date_time` 命名空间的部分，描述了 `TimeZone` 类及其相关功能。`TimeZone` 类用于表示时区，包含创建时区的方法及其参数说明，包括与 UTC 的时差和异常处理。"
            },
            {
                "content": "time_diff_hours – （可选）本地时区与UTC之间的差异。必须在-10到14之间。否则，该函数将抛出异常。\r\n\r\n```cpp\r\nDateTime FromUTC(const DateTime &dt) const\r\n```\r\nConvert a DateTime from UTC time to this time zone.  \r\n将UTC时间的DateTime转换为此时区。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting value is out of range.  \r\nOutOfRange – 如果结果值超出范围，则抛出。\r\n\r\n**参数**  \r\ndt – DateTime in UTC time.  \r\ndt – UTC时间下的DateTime。\r\n\r\n**返回**  \r\nDateTime in local timezone.  \r\n本地时区下的DateTime。\r\n\r\n```cpp\r\nDateTime ToUTC(const DateTime &dt) const\r\n```\r\nConvert a DateTime from this timezone to UTC time.  \r\n将此时区的DateTime转换为UTC时间。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting value is out of range.  \r\nOutOfRange – 如果结果值超出范围，则抛出。\r\n\r\n**参数**  \r\ndt – DateTime in local timezone.  \r\ndt – 本地时区下的DateTime。\r\n\r\n**返回**  \r\nDateTime in UTC.  \r\nUTC时间下的DateTime。\r\n\r\n```cpp\r\nint64_t UTCDiffSeconds() const noexcept\r\n```\r\nReturns diff from UTC in seconds, this is used in Date and DateTime.  \r\n返回与UTC的秒数差，此差值用于日期和时间。\r\n\r\n**返回**  \r\nNumber of seconds local timezone is from UTC.  \r\n本地时区与UTC的秒数差。\n\n此内容位于文档关于时区的部分，主要描述了如何将 UTC 时间转换为本地时区的 DateTime，以及如何从本地时区转换回 UTC 时间，并介绍了 UTC 时间差的相关函数和异常处理。这部分内容涉及到 lgraph_api 命名空间下的 DateTime 和 TimeZone 类的功能。"
            },
            {
                "content": "将此时区的DateTime转换为UTC时间。\r\n\r\n**抛出**  \r\nOutOfRange – Thrown if the resulting value is out of range.  \r\nOutOfRange – 如果结果值超出范围，则抛出。\r\n\r\n**参数**  \r\ndt – DateTime in local timezone.  \r\ndt – 本地时区下的DateTime。\r\n\r\n**返回**  \r\nDateTime in UTC.  \r\nUTC时间下的DateTime。\r\n\r\n```cpp\r\nint64_t UTCDiffSeconds() const noexcept\r\n```\r\nReturns diff from UTC in seconds, this is used in Date and DateTime.  \r\n返回与UTC的秒数差，此差值用于日期和时间。\r\n\r\n**返回**  \r\nNumber of seconds local timezone is from UTC.  \r\n本地时区与UTC的秒数差。\r\n\r\n```cpp\r\nint64_t UTCDiffHours() const noexcept\r\n```\r\nReturns diff from UTC in hours, this is used in Date and DateTime.  \r\n返回与UTC的小时数差，此差值用于日期和时间。\r\n\r\n**返回**  \r\nNumber of hours local timezone is from UTC.  \r\n本地时区与UTC的小时数差。\r\n\r\n#### Public Static Functions\r\n\r\n```cpp\r\nstatic const TimeZone &LocalTimeZone() noexcept\r\n```\r\nGet local timezone.  \r\n获取本地时区。\r\n\r\n**返回**  \r\nA const reference to local timezone.  \r\n对本地时区的常量引用。\r\n\r\n```cpp\r\nstatic void UpdateLocalTimeZone() noexcept\r\n```\n\n该块内容位于文档中有关时区和日期时间处理的部分，主要涉及如何将本地时区的DateTime转换为UTC时间，以及获取本地时区与UTC的时差（秒数和小时数）。相关类和方法的定义在这一部分中详细说明，以便用户能够理解和使用时区相关功能。"
            },
            {
                "content": "本地时区与UTC的秒数差。\r\n\r\n```cpp\r\nint64_t UTCDiffHours() const noexcept\r\n```\r\nReturns diff from UTC in hours, this is used in Date and DateTime.  \r\n返回与UTC的小时数差，此差值用于日期和时间。\r\n\r\n**返回**  \r\nNumber of hours local timezone is from UTC.  \r\n本地时区与UTC的小时数差。\r\n\r\n#### Public Static Functions\r\n\r\n```cpp\r\nstatic const TimeZone &LocalTimeZone() noexcept\r\n```\r\nGet local timezone.  \r\n获取本地时区。\r\n\r\n**返回**  \r\nA const reference to local timezone.  \r\n对本地时区的常量引用。\r\n\r\n```cpp\r\nstatic void UpdateLocalTimeZone() noexcept\r\n```\r\nUpdate local timezone, used only when daylight saving time changes. Daylight saving time may change after `LocalTZ` was initialized, in which case we need to update it. This function will update all references returned by `LocalTimeZone()`.  \r\n更新本地时区，仅在夏令时变化时使用。夏令时可能在`LocalTZ`初始化后发生变化，在这种情况下，我们需要更新它。此函数将更新所有由`LocalTimeZone()`返回的引用。\r\n\r\n#### Private Members\r\n\r\n```cpp\r\nint64_t time_diff_microseconds_\r\n```\r\nThe difference in microseconds from UTC.  \r\n与UTC的微秒差异。\r\n\r\n#### Private Static Functions\r\n\r\n```cpp\n\n该块内容位于文档的“lgraph_date_time”部分，主要介绍了时区相关的功能，包括获取本地时区、更新时区以及计算与UTC的时间差。这些功能对于处理日期和时间的操作至关重要。"
            },
            {
                "content": "```\r\nUpdate local timezone, used only when daylight saving time changes. Daylight saving time may change after `LocalTZ` was initialized, in which case we need to update it. This function will update all references returned by `LocalTimeZone()`.  \r\n更新本地时区，仅在夏令时变化时使用。夏令时可能在`LocalTZ`初始化后发生变化，在这种情况下，我们需要更新它。此函数将更新所有由`LocalTimeZone()`返回的引用。\r\n\r\n#### Private Members\r\n\r\n```cpp\r\nint64_t time_diff_microseconds_\r\n```\r\nThe difference in microseconds from UTC.  \r\n与UTC的微秒差异。\r\n\r\n#### Private Static Functions\r\n\r\n```cpp\r\nstatic TimeZone GetLocalTZ()\r\n```\r\n获取本地时区的私有静态函数。\r\n\r\n```cpp\r\nstatic TimeZone &LocalTZ()\r\n```\r\n获取本地时区的私有静态函数引用。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_db\r\n\r\n### namespace lgraph\r\n### namespace lgraph_api\r\n\r\n### Functions\r\n\r\n#### bool ShouldKillThisTask()\r\nDetermine if we should kill current task.\r\n确定是否应该终止当前任务。\r\n\r\n**返回**  \r\nTrue if a KillTask command was issued for this task, either due to user request or timeout.  \r\n如果对该任务发出了KillTask命令（由于用户请求或超时），则返回True。\r\n\r\n#### ThreadContextPtr GetThreadContext()\n\n这个块位于文档的中间部分，涉及本地时区的更新功能，主要描述了如何在夏令时变化时更新本地时区，以及与UTC的微秒差异的相关成员变量。这部分内容与图数据库的功能、事务管理和时间相关的操作密切相关。"
            },
            {
                "content": "```cpp\r\nstatic TimeZone GetLocalTZ()\r\n```\r\n获取本地时区的私有静态函数。\r\n\r\n```cpp\r\nstatic TimeZone &LocalTZ()\r\n```\r\n获取本地时区的私有静态函数引用。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_db\r\n\r\n### namespace lgraph\r\n### namespace lgraph_api\r\n\r\n### Functions\r\n\r\n#### bool ShouldKillThisTask()\r\nDetermine if we should kill current task.\r\n确定是否应该终止当前任务。\r\n\r\n**返回**  \r\nTrue if a KillTask command was issued for this task, either due to user request or timeout.  \r\n如果对该任务发出了KillTask命令（由于用户请求或超时），则返回True。\r\n\r\n#### ThreadContextPtr GetThreadContext()\r\nGets thread context pointer, which can then be used in ShouldKillThisTask(ctx). Calling ShouldKillThisTask() is equivalent to ShouldKillThisTask(GetThreadContext()). In order to save the cost of GetThreadContext(), you can store the context and use it in ShouldKillThisTask(ctx).\r\n获取线程上下文指针，然后可以在ShouldKillThisTask(ctx)中使用。调用ShouldKillThisTask()等效于调用ShouldKillThisTask(GetThreadContext())。为了节省GetThreadContext()的开销，可以存储上下文并在ShouldKillThisTask(ctx)中使用。\r\n\r\n**Example:** \r\n```c++\n\n该代码片段位于文档的“lgraph_db”部分，主要涉及获取本地时区的静态函数，以及确定是否终止当前任务的函数和获取线程上下文的函数。这些功能是图数据库操作中的关键部分，帮助管理任务执行和时间处理。"
            },
            {
                "content": "Gets thread context pointer, which can then be used in ShouldKillThisTask(ctx). Calling ShouldKillThisTask() is equivalent to ShouldKillThisTask(GetThreadContext()). In order to save the cost of GetThreadContext(), you can store the context and use it in ShouldKillThisTask(ctx).\r\n获取线程上下文指针，然后可以在ShouldKillThisTask(ctx)中使用。调用ShouldKillThisTask()等效于调用ShouldKillThisTask(GetThreadContext())。为了节省GetThreadContext()的开销，可以存储上下文并在ShouldKillThisTask(ctx)中使用。\r\n\r\n**Example:** \r\n```c++\r\nThreadContextPtr ctx = GetThreadContext(); \r\nwhile (HasMoreWorkToDo()) { \r\n    if (ShouldKillThisTask(ctx)) { \r\n        break; \r\n    } \r\n    DoWork(); \r\n}\r\n```\r\n\r\n**返回**  \r\nThe thread context.  \r\n线程上下文。\r\n\r\n#### bool ShouldKillThisTask(ThreadContextPtr ctx)\r\nDetermine if we should kill the task currently running in the thread identified by ctx.\r\n确定是否应该终止在ctx标识的线程中当前运行的任务。\r\n\r\n**参数**  \r\n- ctx – The context, as obtained with GetThreadContext.  \r\n参数ctx – 通过GetThreadContext获得的上下文。\r\n\r\n**返回**\n\n该块内容位于文档的“lgraph_db”部分，主要讨论如何获取线程上下文以在任务执行中判断是否应终止当前线程的任务。它提供了相关函数的定义和示例，说明在多线程环境下如何有效管理任务的终止。"
            },
            {
                "content": "```c++\r\nThreadContextPtr ctx = GetThreadContext(); \r\nwhile (HasMoreWorkToDo()) { \r\n    if (ShouldKillThisTask(ctx)) { \r\n        break; \r\n    } \r\n    DoWork(); \r\n}\r\n```\r\n\r\n**返回**  \r\nThe thread context.  \r\n线程上下文。\r\n\r\n#### bool ShouldKillThisTask(ThreadContextPtr ctx)\r\nDetermine if we should kill the task currently running in the thread identified by ctx.\r\n确定是否应该终止在ctx标识的线程中当前运行的任务。\r\n\r\n**参数**  \r\n- ctx – The context, as obtained with GetThreadContext.  \r\n参数ctx – 通过GetThreadContext获得的上下文。\r\n\r\n**返回**  \r\nTrue if a KillTask command was issued for this task.  \r\n如果对该任务发出了KillTask命令，则返回True。\r\n\r\n### Variables\r\n\r\n#### const typedef void * ThreadContextPtr\r\nDefines an alias representing the thread context pointer.  \r\n定义代表线程上下文指针的别名。\r\n\r\n### class GraphDB\r\n```cpp\r\n#include \r\n```\r\nGraphDB represents a graph instance. In TuGraph, each graph instance has its own schema and access control settings. Accessing a GraphDB without appropriate access rights yields WriteNotAllowed.\n\n该代码块位于文档中关于图数据库（GraphDB）操作的部分，具体描述了如何获取线程上下文和判断是否终止任务的逻辑，涉及多线程操作与任务管理的相关函数与变量定义。"
            },
            {
                "content": "**返回**  \r\nTrue if a KillTask command was issued for this task.  \r\n如果对该任务发出了KillTask命令，则返回True。\r\n\r\n### Variables\r\n\r\n#### const typedef void * ThreadContextPtr\r\nDefines an alias representing the thread context pointer.  \r\n定义代表线程上下文指针的别名。\r\n\r\n### class GraphDB\r\n```cpp\r\n#include \r\n```\r\nGraphDB represents a graph instance. In TuGraph, each graph instance has its own schema and access control settings. Accessing a GraphDB without appropriate access rights yields WriteNotAllowed.  \r\nGraphDB表示一个图实例。在TuGraph中，每个图实例都有自己的模式和访问控制设置。没有适当访问权限访问GraphDB会导致WriteNotAllowed。\r\n\r\nA GraphDB becomes invalid if Close() is called, in which case all transactions and iterators associated with that GraphDB become invalid. Further operation on that GraphDB yields InvalidGraphDB.  \r\n如果调用Close()，则GraphDB变为无效，此时与该GraphDB相关的所有事务和迭代器都会变得无效。对该GraphDB的进一步操作将导致InvalidGraphDB。\r\n\r\n### Public Functions\r\n\r\n#### explicit GraphDB(lgraph::AccessControlledDB *db_with_access_control, bool read_only, bool owns_db = false)\n\n该块内容位于文档中关于 TuGraph 数据库操作的章节，具体涉及任务管理和线程上下文的定义，以及 GraphDB 类的描述。GraphDB 类代表图实例，并包含关于图实例的模式、访问控制设置以及关闭操作对其影响的详细信息。"
            },
            {
                "content": "GraphDB表示一个图实例。在TuGraph中，每个图实例都有自己的模式和访问控制设置。没有适当访问权限访问GraphDB会导致WriteNotAllowed。\r\n\r\nA GraphDB becomes invalid if Close() is called, in which case all transactions and iterators associated with that GraphDB become invalid. Further operation on that GraphDB yields InvalidGraphDB.  \r\n如果调用Close()，则GraphDB变为无效，此时与该GraphDB相关的所有事务和迭代器都会变得无效。对该GraphDB的进一步操作将导致InvalidGraphDB。\r\n\r\n### Public Functions\r\n\r\n#### explicit GraphDB(lgraph::AccessControlledDB *db_with_access_control, bool read_only, bool owns_db = false)\r\nFor internal use only. Users should use Galaxy::OpenGraph() to get GraphDB.  \r\n仅供内部使用。用户应使用Galaxy::OpenGraph()获取GraphDB。\r\n\r\n#### GraphDB(GraphDB&&)\r\n#### GraphDB &operator=(GraphDB&&)\r\n#### ~GraphDB()\r\n#### void Close()\r\nClose the graph. This will close the graph and release all transactions, iterators associated with the graph. After calling Close(), the graph becomes invalid, and cannot be used anymore.  \r\n关闭图。此操作将关闭图并释放与图相关的所有事务和迭代器。调用Close()后，图将变为无效，无法再使用。\r\n\r\n#### Transaction CreateReadTxn()\n\n该块内容位于文档的“lgraph_db”部分，详细描述了GraphDB类及其功能，包括图实例的创建、关闭及其与事务和迭代器的关联性。此部分帮助用户理解如何管理图数据库及其访问控制设置。"
            },
            {
                "content": "For internal use only. Users should use Galaxy::OpenGraph() to get GraphDB.  \r\n仅供内部使用。用户应使用Galaxy::OpenGraph()获取GraphDB。\r\n\r\n#### GraphDB(GraphDB&&)\r\n#### GraphDB &operator=(GraphDB&&)\r\n#### ~GraphDB()\r\n#### void Close()\r\nClose the graph. This will close the graph and release all transactions, iterators associated with the graph. After calling Close(), the graph becomes invalid, and cannot be used anymore.  \r\n关闭图。此操作将关闭图并释放与图相关的所有事务和迭代器。调用Close()后，图将变为无效，无法再使用。\r\n\r\n#### Transaction CreateReadTxn()\r\nCreates a read transaction.  \r\n创建一个读事务。\r\n\r\n**抛出**  \r\nInvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\nInvalidGraphDB – 当当前GraphDB无效时抛出。\r\n\r\n**返回**  \r\nThe new read transaction.  \r\n新的读事务。\r\n\r\n#### Transaction CreateWriteTxn(bool optimistic = false)\n\n该块内容位于文档的\"lgraph_db\"部分，主要介绍GraphDB类的构造函数、移动构造、析构函数及关闭图形的方法，以及如何创建读写事务。它为开发者提供了如何管理图实例及其相关事务的详细信息。"
            },
            {
                "content": "关闭图。此操作将关闭图并释放与图相关的所有事务和迭代器。调用Close()后，图将变为无效，无法再使用。\r\n\r\n#### Transaction CreateReadTxn()\r\nCreates a read transaction.  \r\n创建一个读事务。\r\n\r\n**抛出**  \r\nInvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\nInvalidGraphDB – 当当前GraphDB无效时抛出。\r\n\r\n**返回**  \r\nThe new read transaction.  \r\n新的读事务。\r\n\r\n#### Transaction CreateWriteTxn(bool optimistic = false)\r\nCreates a write transaction. Write operations can only be performed in write transactions, otherwise exceptions will be thrown. A write transaction can be optimistic. Optimistic transactions can run in parallel and any conflict will be detected during commit. If a transaction conflicts with an earlier one, a TxnConflict will be thrown during commit.  \r\n创建一个写事务。写操作仅能在写事务中执行，否则会抛出异常。写事务可以是乐观的。乐观事务可以并行运行，任何冲突将在提交时被检测到。如果事务与先前事务冲突，提交时将抛出TxnConflict。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。\n\n该块内容位于文档中关于“lgraph_db”部分，具体介绍了图数据库（GraphDB）的一些关键功能，包括关闭图、创建读事务和写事务的过程及其相关异常。这些功能是图数据库操作的基础，用于确保数据一致性和事务管理。"
            },
            {
                "content": "创建一个写事务。写操作仅能在写事务中执行，否则会抛出异常。写事务可以是乐观的。乐观事务可以并行运行，任何冲突将在提交时被检测到。如果事务与先前事务冲突，提交时将抛出TxnConflict。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。\r\n\r\n**参数**  \r\n- optimistic – (Optional) True to create an optimistic transaction.  \r\n- optimistic –（可选）True以创建乐观事务。\r\n\r\n**返回**  \r\nThe new write transaction.  \r\n新的写事务。\r\n\r\n#### Transaction ForkTxn(Transaction &txn)\r\nForks a read transaction. The resulting read transaction will share the same view as the forked one, meaning that when reads are performed on the same vertex/edge, the results will always be identical, whether they are performed in the original transaction or the forked one. Only read transactions can be forked. Calling ForkTxn() on a write txn causes an InvalidFork to be thrown.\n\n该段落位于文档的“lgraph_txn”部分，讨论如何创建和管理写事务，包括乐观事务的特性及其异常处理。它强调了读事务和写事务的区别，以及如何派生读事务。"
            },
            {
                "content": "**返回**  \r\nThe new write transaction.  \r\n新的写事务。\r\n\r\n#### Transaction ForkTxn(Transaction &txn)\r\nForks a read transaction. The resulting read transaction will share the same view as the forked one, meaning that when reads are performed on the same vertex/edge, the results will always be identical, whether they are performed in the original transaction or the forked one. Only read transactions can be forked. Calling ForkTxn() on a write txn causes an InvalidFork to be thrown.  \r\n分叉一个读事务。结果读事务将与被分叉的事务共享相同的视图，这意味着当在同一个顶点/边上执行读取时，无论是在原始事务中还是分叉事务中执行，结果总是相同的。只有读事务可以被分叉。在写事务上调用ForkTxn()会导致抛出InvalidFork。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- InvalidFork – Thrown when txn is a write transaction.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- InvalidFork – 当txn是一个写事务时抛出。\r\n\r\n**参数**  \r\n- txn – [in] The read transaction to be forked.  \r\n- txn – [in] 要分叉的读事务。\r\n\r\n**返回**  \r\nA new read Transaction that shares the same view with txn.  \r\n一个新的读事务，与txn共享相同的视图。\r\n\r\n#### void Flush()\n\n该内容位于文档的 **lgraph_db** 部分，讨论了事务的操作及其管理，其中包括创建和分叉事务的具体方法。该部分解释了如何处理事务，确保读写操作的正确性以及有关错误处理的详细信息。"
            },
            {
                "content": "**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- InvalidFork – Thrown when txn is a write transaction.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- InvalidFork – 当txn是一个写事务时抛出。\r\n\r\n**参数**  \r\n- txn – [in] The read transaction to be forked.  \r\n- txn – [in] 要分叉的读事务。\r\n\r\n**返回**  \r\nA new read Transaction that shares the same view with txn.  \r\n一个新的读事务，与txn共享相同的视图。\r\n\r\n#### void Flush()\r\nFlushes buffered data to disk. If there have been some async transactions, there could be data that are written to this graph, but not persisted to disk yet. Calling Flush() will persist the data and prevent data loss in case of system crash.  \r\n将缓冲数据刷新到磁盘。如果存在一些异步事务，可能有数据已写入此图，但尚未持久化到磁盘。调用Flush()将持久化数据，并防止在系统崩溃时丢失数据。\r\n\r\n**抛出**  \r\nInvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\nInvalidGraphDB – 当前GraphDB无效时抛出。\r\n\r\n#### void DropAllData()\r\nDrop all the data in the graph, including labels, indexes and vertexes/edges.  \r\n删除图中的所有数据，包括标签、索引和顶点/边。\r\n\r\n**抛出**\n\n该内容位于文档的 `lgraph_db` 部分，详细描述了 `GraphDB` 类中的一些操作和相关异常处理，包括读事务的分叉、数据刷新及图数据的删除等功能。这些功能涉及图数据库的基本操作，确保数据的有效管理和异常处理。"
            },
            {
                "content": "将缓冲数据刷新到磁盘。如果存在一些异步事务，可能有数据已写入此图，但尚未持久化到磁盘。调用Flush()将持久化数据，并防止在系统崩溃时丢失数据。\r\n\r\n**抛出**  \r\nInvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\nInvalidGraphDB – 当前GraphDB无效时抛出。\r\n\r\n#### void DropAllData()\r\nDrop all the data in the graph, including labels, indexes and vertexes/edges.  \r\n删除图中的所有数据，包括标签、索引和顶点/边。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。\r\n\r\n#### void DropAllVertex()\r\nDrop all vertex and edges but keep the labels and indexes.  \r\n删除所有顶点和边，但保留标签和索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。\r\n\r\n#### size_t EstimateNumVertices()\n\n该块内容位于文档关于图数据库操作的部分，专注于数据持久化和数据清除功能。具体包括“Flush”和“DropAllData”以及“DropAllVertex”方法的描述，涉及如何将数据持久化到磁盘以及如何删除图中的所有数据或顶点。"
            },
            {
                "content": "- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。\r\n\r\n#### void DropAllVertex()\r\nDrop all vertex and edges but keep the labels and indexes.  \r\n删除所有顶点和边，但保留标签和索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。\r\n\r\n#### size_t EstimateNumVertices()\r\nEstimate number of vertices. We don’t maintain the exact number of vertices, but only the next vid. This function actually returns the next vid to be used. So if you have deleted a lot of vertices, the result can be quite different from actual number of vertices.  \r\n估算顶点数量。我们并不维护确切的顶点数量，而只是维护下一个vid。此函数实际上返回即将使用的下一个vid。因此，如果您删除了很多顶点，则结果可能与实际顶点数量差异很大。\r\n\r\n**抛出**  \r\nInvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\nInvalidGraphDB – 当前GraphDB无效时抛出。\r\n\r\n**返回**  \r\nEstimated number of vertices.  \r\n估计的顶点数量。\n\n该段落位于文档的\"lgraph_db\"部分，主要介绍了图数据库的操作，包括删除所有顶点和边的函数`DropAllVertex()`及其抛出异常的条件，以及估算顶点数量的函数`EstimateNumVertices()`及其异常处理。此部分的内容帮助用户理解在操作数据库时可能遇到的情况和返回的结果。"
            },
            {
                "content": "估算顶点数量。我们并不维护确切的顶点数量，而只是维护下一个vid。此函数实际上返回即将使用的下一个vid。因此，如果您删除了很多顶点，则结果可能与实际顶点数量差异很大。\r\n\r\n**抛出**  \r\nInvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\nInvalidGraphDB – 当前GraphDB无效时抛出。\r\n\r\n**返回**  \r\nEstimated number of vertices.  \r\n估计的顶点数量。\r\n\r\n#### bool AddVertexLabel(const std::string &label, const std::vector &fds, const VertexOptions &options)\r\nAdds a vertex label.  \r\n添加一个顶点标签。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.  \r\n- InputError – Thrown if the schema is illegal.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果模式不合法，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.  \r\n- fds – The field specifications.  \r\n- primary_field – The primary field.  \r\n- label – 标签名称。  \r\n- fds – 字段规范。  \r\n- primary_field – 主字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label already exists.  \r\n如果成功则返回True，如果标签已存在则返回false。\n\n该块内容位于文档的“lgraph_db”部分，主要描述了图数据库中的顶点管理函数，包括估算顶点数量的函数和添加顶点标签的函数。此部分详细说明了相应函数的功能、参数、返回值及可能抛出的异常，以帮助开发者理解如何操作图数据库中的顶点数据。"
            },
            {
                "content": "- InputError – Thrown if the schema is illegal.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果模式不合法，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.  \r\n- fds – The field specifications.  \r\n- primary_field – The primary field.  \r\n- label – 标签名称。  \r\n- fds – 字段规范。  \r\n- primary_field – 主字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label already exists.  \r\n如果成功则返回True，如果标签已存在则返回false。\r\n\r\n#### bool DeleteVertexLabel(const std::string &label, size_t *n_modified = nullptr)\r\nDeletes a vertex label and all the vertices with this label.  \r\n删除一个顶点标签及其所有顶点。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。\r\n\r\n**参数**  \r\n- label – The label name.  \r\n- n_modified – [out] (Optional) If non-null, return the number of deleted vertices.  \r\n- label – 标签名称。\n\n该段落位于文档中的 \"lgraph\"模块，具体涉及顶点标签的管理，包括添加和删除顶点标签的函数定义。它详细描述了函数的参数、返回值以及可能抛出的异常类型。"
            },
            {
                "content": "Deletes a vertex label and all the vertices with this label.  \r\n删除一个顶点标签及其所有顶点。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。\r\n\r\n**参数**  \r\n- label – The label name.  \r\n- n_modified – [out] (Optional) If non-null, return the number of deleted vertices.  \r\n- label – 标签名称。  \r\n- n_modified – [out]（可选）如果不为null，返回删除的顶点数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.  \r\n如果成功则返回True，如果标签不存在则返回false。\r\n\r\n#### bool AlterVertexLabelDelFields(const std::string &label, const std::vector &del_fields, size_t *n_modified = nullptr)\r\nDeletes fields in a vertex label. This function also updates the vertex data and indices accordingly to make sure the database remains in a consistent state.  \r\n删除顶点标签中的字段。此函数还会相应地更新顶点数据和索引，以确保数据库保持一致的状态。\r\n\r\n**抛出**\n\n该内容位于文档的“lgraph_db”模块中，具体描述了如何删除一个顶点标签及其所有相关顶点的操作，同时也说明了在删除过程中可能抛出的异常和相关参数。这部分内容是关于图数据库操作的核心部分，涉及图数据管理和维护的一项重要功能。"
            },
            {
                "content": "- label – 标签名称。  \r\n- n_modified – [out]（可选）如果不为null，返回删除的顶点数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.  \r\n如果成功则返回True，如果标签不存在则返回false。\r\n\r\n#### bool AlterVertexLabelDelFields(const std::string &label, const std::vector &del_fields, size_t *n_modified = nullptr)\r\nDeletes fields in a vertex label. This function also updates the vertex data and indices accordingly to make sure the database remains in a consistent state.  \r\n删除顶点标签中的字段。此函数还会相应地更新顶点数据和索引，以确保数据库保持一致的状态。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.  \r\n- InputError – Thrown if field not found, or some fields cannot be deleted.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果未找到字段，或者某些字段无法删除，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.  \r\n- del_fields – Labels of the fields to be deleted.\n\n该块位于文档中关于图数据库（GraphDB）标签管理的部分，具体涉及顶点标签的删除字段操作及其相关条件、异常处理和参数定义。"
            },
            {
                "content": "删除顶点标签中的字段。此函数还会相应地更新顶点数据和索引，以确保数据库保持一致的状态。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.  \r\n- InputError – Thrown if field not found, or some fields cannot be deleted.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果未找到字段，或者某些字段无法删除，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.  \r\n- del_fields – Labels of the fields to be deleted.  \r\n- n_modified – [out] (Optional) If non-null, return the number of modified vertices.  \r\n- label – 标签名称。  \r\n- del_fields – 要删除字段的标签。  \r\n- n_modified – [out]（可选）如果不为null，返回修改后的顶点数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.  \r\n如果成功则返回True，如果标签不存在则返回false。\r\n\r\n#### bool AlterVertexLabelAddFields(const std::string &label, const std::vector &add_fields, const std::vector &default_values, size_t *n_modified = nullptr)\n\n该块内容位于文档的“lgraph_db”部分，其中描述了有关删除顶点标签中字段的函数，包括函数的抛出异常、参数和返回值。该部分主要关注图数据库的操作和管理函数，特别是在修改顶点标签时的相关细节。"
            },
            {
                "content": "- del_fields – Labels of the fields to be deleted.  \r\n- n_modified – [out] (Optional) If non-null, return the number of modified vertices.  \r\n- label – 标签名称。  \r\n- del_fields – 要删除字段的标签。  \r\n- n_modified – [out]（可选）如果不为null，返回修改后的顶点数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.  \r\n如果成功则返回True，如果标签不存在则返回false。\r\n\r\n#### bool AlterVertexLabelAddFields(const std::string &label, const std::vector &add_fields, const std::vector &default_values, size_t *n_modified = nullptr)\r\nAdd fields to a vertex label. The new fields in existing vertices will be filled with default values.  \r\n向顶点标签添加字段。现有顶点中的新字段将填充默认值。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.  \r\n- InputError – Thrown if field already exists.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果字段已存在，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.\n\n该块内容位于整体文档的“lgraph_db”部分，具体在描述如何操作顶点标签的函数中。其中包括对顶点标签的字段删除和添加操作的详细信息，以及相应的异常处理和返回值。"
            },
            {
                "content": "Add fields to a vertex label. The new fields in existing vertices will be filled with default values.  \r\n向顶点标签添加字段。现有顶点中的新字段将填充默认值。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.  \r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.  \r\n- InputError – Thrown if field already exists.  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在具有只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果字段已存在，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.  \r\n- add_fields – The add fields.  \r\n- default_values – The default values of the newly added fields.  \r\n- n_modified – [out] (Optional) If non-null, return the number of modified vertices.  \r\n- label – 标签名称。  \r\n- add_fields – 添加的字段。  \r\n- default_values – 新添加字段的默认值。  \r\n- n_modified – [out]（可选）如果不为null，返回修改后的顶点数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.  \r\n如果成功则返回True，如果标签不存在则返回false。\n\n该块内容位于文档的 \"lgraph_db\" 部分，主要描述了如何向顶点标签添加字段。这部分涵盖了添加字段的参数、可能抛出的异常以及函数的返回值，主要用于图数据库操作的功能实现。"
            },
            {
                "content": "- InputError – 如果字段已存在，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.  \r\n- add_fields – The add fields.  \r\n- default_values – The default values of the newly added fields.  \r\n- n_modified – [out] (Optional) If non-null, return the number of modified vertices.  \r\n- label – 标签名称。  \r\n- add_fields – 添加的字段。  \r\n- default_values – 新添加字段的默认值。  \r\n- n_modified – [out]（可选）如果不为null，返回修改后的顶点数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.  \r\n如果成功则返回True，如果标签不存在则返回false。\r\n\r\n#### bool AlterVertexLabelModFields(const std::string &label, const std::vector &mod_fields, size_t *n_modified = nullptr)\r\nModify fields in a vertex label, either change the data type or optional, or both.\r\n// 修改顶点标签中的字段，可以改变数据类型、选项，或两者均可。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if field not found, or is of incompatible data type.\n\n该块内容位于文档的 lgraph_db 部分，其中详细描述了与图数据库操作相关的各种函数，包括添加和修改顶点标签字段的功能。这些函数允许用户对数据库中的顶点标签进行操作，如添加、删除和修改字段，并提供了相应的异常处理机制。"
            },
            {
                "content": "Modify fields in a vertex label, either change the data type or optional, or both.\r\n// 修改顶点标签中的字段，可以改变数据类型、选项，或两者均可。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if field not found, or is of incompatible data type.\r\n// 如果找不到字段或者字段的数据类型不兼容，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- mod_fields – The new specification of the modified fields.\r\n// 修改字段的新规格。\r\n- n_modified – [out] (Optional) If non-null, return the number of modified vertices.\r\n// [输出]（可选）如果非空，返回修改的顶点数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.\r\n// 如果成功返回真，如果标签不存在则返回假。\r\n\r\n#### bool AddEdgeLabel(const std::string &label, const std::vector &fds, const EdgeOptions &options)\n\n该段落位于文档中关于图数据库（GraphDB）标签和字段管理的部分，具体描述了如何修改顶点标签中的字段，包括字段的数据类型、选项和相关参数。该内容概述了在进行字段修改时可能抛出的异常，以及函数的参数和返回值，适用于开发人员在实现图形数据库操作时参考。"
            },
            {
                "content": "// 如果找不到字段或者字段的数据类型不兼容，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- mod_fields – The new specification of the modified fields.\r\n// 修改字段的新规格。\r\n- n_modified – [out] (Optional) If non-null, return the number of modified vertices.\r\n// [输出]（可选）如果非空，返回修改的顶点数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.\r\n// 如果成功返回真，如果标签不存在则返回假。\r\n\r\n#### bool AddEdgeLabel(const std::string &label, const std::vector &fds, const EdgeOptions &options)\r\nAdd an edge label, specifying its schema. It is allowed to specify edge constraints, too. An edge can be bound to several (source_label, destination_label) pairs, which makes sure this type of edges will only be added between these types of vertices. By default, the constraint is empty, meaning that the edge is not restricted.\r\n// 添加边标签，指定其模式。也允许指定边约束。一个边可以绑定到多个 (source_label, destination_label) 对，这确保这种类型的边只会在这些类型的顶点之间添加。默认情况下，约束为空，意味着边没有限制。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\n\n在文档中，该块内容位于描述图数据库标签和边标签管理的部分，具体涉及到修改边标签字段的函数定义及其参数、返回值和异常抛出情况。这部分主要讨论如何添加和修改边标签的相关功能，确保图形结构的完整性和可操作性。"
            },
            {
                "content": "// 添加边标签，指定其模式。也允许指定边约束。一个边可以绑定到多个 (source_label, destination_label) 对，这确保这种类型的边只会在这些类型的顶点之间添加。默认情况下，约束为空，意味着边没有限制。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – if invalid schema (invalid specification, re-definition of the same field, etc.).\r\n// 如果模式无效（规格无效、重新定义相同字段等）则抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- fds – The field specifications.\r\n// 字段规格。\r\n- options – The edge options.\r\n// 边选项。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label already exists.\r\n// 如果成功返回真，如果标签已经存在则返回假。\r\n\r\n#### bool DeleteEdgeLabel(const std::string &label, size_t *n_modified = nullptr)\r\nDeletes an edge label and all the edges with this label.\r\n// 删除边标签及其所有相关的边。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\n\n该文本块位于文档中关于边标签和边操作的部分，详细描述了如何添加边标签及其约束、异常处理及相关参数，主要用于支持图数据库中的边操作与管理。"
            },
            {
                "content": "**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- fds – The field specifications.\r\n// 字段规格。\r\n- options – The edge options.\r\n// 边选项。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label already exists.\r\n// 如果成功返回真，如果标签已经存在则返回假。\r\n\r\n#### bool DeleteEdgeLabel(const std::string &label, size_t *n_modified = nullptr)\r\nDeletes an edge label and all the edges with this label.\r\n// 删除边标签及其所有相关的边。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- n_modified – [out] (Optional) If non-null, return the number of deleted edges.\r\n// [输出]（可选）如果非空，返回已删除边的数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.\r\n// 如果成功返回真，如果标签不存在则返回假。\r\n\r\n#### bool AlterEdgeLabelDelFields(const std::string &label, const std::vector &del_fields, size_t *n_modified = nullptr)\n\n该代码块位于文档中关于图数据库操作的部分，主要涉及边标签的添加和删除功能。其中包括添加边标签所需的参数和返回值说明，以及删除边标签的异常处理和参数定义。这部分内容提供了用户在进行图数据库操作时的具体接口说明，便于理解如何管理图中的边标签。"
            },
            {
                "content": "// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- n_modified – [out] (Optional) If non-null, return the number of deleted edges.\r\n// [输出]（可选）如果非空，返回已删除边的数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.\r\n// 如果成功返回真，如果标签不存在则返回假。\r\n\r\n#### bool AlterEdgeLabelDelFields(const std::string &label, const std::vector &del_fields, size_t *n_modified = nullptr)\r\nDeletes fields in an edge label. This function also updates the edge data and indices accordingly to make sure the database remains in a consistent state.\r\n// 删除边标签中的字段。此函数还会相应地更新边数据和索引，以确保数据库保持一致的状态。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if field not found, or some fields cannot be deleted.\n\n该块内容位于文档中关于 `GraphDB` 类与其相关函数的描述部分，具体涉及删除边标签字段的操作及其异常处理机制，包括在无效数据库或只读访问级别下抛出的异常，以及删除字段后的数据更新要求。这部分强调了边标签的管理方法和相关性保证。"
            },
            {
                "content": "Deletes fields in an edge label. This function also updates the edge data and indices accordingly to make sure the database remains in a consistent state.\r\n// 删除边标签中的字段。此函数还会相应地更新边数据和索引，以确保数据库保持一致的状态。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if field not found, or some fields cannot be deleted.\r\n// 如果找不到字段，或者某些字段无法被删除，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- del_fields – Labels of the fields to be deleted.\r\n// 要删除的字段标签。\r\n- n_modified – [out] (Optional) If non-null, return the number of modified edges.\r\n// [输出]（可选）如果非空，返回修改的边数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.\r\n// 如果成功返回真，如果标签不存在则返回假。\r\n\r\n#### bool AlterEdgeLabelAddFields(const std::string &label, const std::vector &add_fields, const std::vector &default_values, size_t *n_modified = nullptr)\n\n该块内容位于文档的“lgraph_db”部分，涉及定义和操作图数据库中的边标签。具体描述了删除边标签字段的函数，包括异常抛出条件、输入参数和返回值。这是图数据库管理和数据一致性维护的重要功能。"
            },
            {
                "content": "// 如果找不到字段，或者某些字段无法被删除，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- del_fields – Labels of the fields to be deleted.\r\n// 要删除的字段标签。\r\n- n_modified – [out] (Optional) If non-null, return the number of modified edges.\r\n// [输出]（可选）如果非空，返回修改的边数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.\r\n// 如果成功返回真，如果标签不存在则返回假。\r\n\r\n#### bool AlterEdgeLabelAddFields(const std::string &label, const std::vector &add_fields, const std::vector &default_values, size_t *n_modified = nullptr)\r\nAdd fields to an edge label. The new fields in existing edges will be filled with default values.\r\n// 向边标签添加字段。现有边中的新字段将填充默认值。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if field already exists.\r\n// 如果字段已经存在则抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- add_fields – The add fields.\r\n// 添加的字段。\n\n该块内容位于文档中关于图数据库操作的部分，具体涉及边标签的修改和字段处理，包括删除字段和添加字段的功能描述。"
            },
            {
                "content": "Add fields to an edge label. The new fields in existing edges will be filled with default values.\r\n// 向边标签添加字段。现有边中的新字段将填充默认值。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if field already exists.\r\n// 如果字段已经存在则抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- add_fields – The add fields.\r\n// 添加的字段。\r\n- default_values – The default values of the newly added fields.\r\n// 新添加字段的默认值。\r\n- n_modified – [out] (Optional) If non-null, return the number of modified edges.\r\n// [输出]（可选）如果非空，返回修改的边数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.\r\n// 如果成功返回真，如果标签不存在则返回假。\r\n\r\n#### bool AlterEdgeLabelModFields(const std::string &label, const std::vector &mod_fields, size_t *n_modified = nullptr)\r\nModify fields in an edge label, either change the data type or optional, or both.\r\n// 修改边标签中的字段，可以改变数据类型、选项，或两者均可。\n\n该段落位于文档中有关图数据库操作的部分，描述了如何向边标签添加字段以及修改边标签中的字段。它详细说明了抛出的异常、参数和返回值，适用于边的操作和修改过程的上下文。"
            },
            {
                "content": "// 新添加字段的默认值。\r\n- n_modified – [out] (Optional) If non-null, return the number of modified edges.\r\n// [输出]（可选）如果非空，返回修改的边数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.\r\n// 如果成功返回真，如果标签不存在则返回假。\r\n\r\n#### bool AlterEdgeLabelModFields(const std::string &label, const std::vector &mod_fields, size_t *n_modified = nullptr)\r\nModify fields in an edge label, either change the data type or optional, or both.\r\n// 修改边标签中的字段，可以改变数据类型、选项，或两者均可。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if field not found, or is of incompatible data type.\r\n// 如果找不到字段或者字段的数据类型不兼容，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- mod_fields – The new specification of the modified fields.\r\n// 修改字段的新规格。\r\n- n_modified – [out] (Optional) If non-null, return the number of modified edges.\r\n// [输出]（可选）如果非空，返回修改的边数量。\r\n\r\n**返回**\n\n该块内容位于文档中描述对边标签进行修改的函数部分。具体说明了如何修改边标签字段，包括可选参数、异常处理、输入参数和返回值的描述，强调了在进行操作时对GraphDB有效性和字段兼容性的检查。"
            },
            {
                "content": "// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if field not found, or is of incompatible data type.\r\n// 如果找不到字段或者字段的数据类型不兼容，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- mod_fields – The new specification of the modified fields.\r\n// 修改字段的新规格。\r\n- n_modified – [out] (Optional) If non-null, return the number of modified edges.\r\n// [输出]（可选）如果非空，返回修改的边数量。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the label does not exist.\r\n// 如果成功返回真，如果标签不存在则返回假。\r\n\r\n\r\n#### bool AddVertexIndex(const std::string &label, const std::string &field, IndexType type)\r\nAdds an index to ‘label:field’. This function blocks until the index is fully created.\r\n// 为 'label:field' 添加索引。此函数阻止执行直到索引完全创建。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\n\n该块内容位于文档中涉及到对GraphDB的操作和异常处理部分，具体说明了在对GraphDB进行修改或添加索引时可能产生的异常，包括无效的GraphDB、只读访问级别的限制以及字段不匹配等情况，主要涉及到如何处理在图数据库操作中的错误情况。"
            },
            {
                "content": "// 如果成功返回真，如果标签不存在则返回假。\r\n\r\n\r\n#### bool AddVertexIndex(const std::string &label, const std::string &field, IndexType type)\r\nAdds an index to ‘label:field’. This function blocks until the index is fully created.\r\n// 为 'label:field' 添加索引。此函数阻止执行直到索引完全创建。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if label:field does not exist, or not indexable.\r\n// 如果 label:field 不存在或者不可索引，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- field – The field name.\r\n// 字段名称。\r\n- is_unique – True if it's a unique index, false if not.\r\n// 如果是唯一索引则为真，不是则为假。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the index already exists.\r\n// 如果成功返回真，如果索引已经存在则返回假。\r\n\r\n---\r\n\r\n#### bool AddEdgeIndex(const std::string &label, const std::string &field, IndexType type)\r\nAdds an index to ‘label:field’. This function blocks until the index is fully created.\n\n该块内容位于文档中关于图数据库（GraphDB）操作的部分，主要讨论如何为顶点和边添加索引，包括相关的参数、返回值和可能抛出的异常。这部分详细描述了添加索引的功能及其使用的注意事项，为用户提供了关于图数据库优化查询性能的指导。"
            },
            {
                "content": "// 如果 label:field 不存在或者不可索引，则抛出。\r\n\r\n**参数**  \r\n- label – The label name.\r\n// 标签名称。\r\n- field – The field name.\r\n// 字段名称。\r\n- is_unique – True if it's a unique index, false if not.\r\n// 如果是唯一索引则为真，不是则为假。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the index already exists.\r\n// 如果成功返回真，如果索引已经存在则返回假。\r\n\r\n---\r\n\r\n#### bool AddEdgeIndex(const std::string &label, const std::string &field, IndexType type)\r\nAdds an index to ‘label:field’. This function blocks until the index is fully created.\r\n// 为 'label:field' 添加索引。此函数阻止执行直到索引完全创建。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if label:field does not exist, or not indexable.\r\n// 如果 label:field 不存在或者不可索引，则抛出。\r\n\r\n**参数**  \r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\r\n- is_unique – True if the field content is unique for each vertex.\r\n// 如果字段内容对每个顶点都是唯一的，则为真。\r\n\r\n**返回**\n\n该块内容位于文档关于图数据库操作的部分，具体描述了如何为图的边标签添加索引，其中包括添加索引的异常情况、参数说明以及返回值的含义，是对索引管理功能的具体实现和使用说明。"
            },
            {
                "content": "**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if label:field does not exist, or not indexable.\r\n// 如果 label:field 不存在或者不可索引，则抛出。\r\n\r\n**参数**  \r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\r\n- is_unique – True if the field content is unique for each vertex.\r\n// 如果字段内容对每个顶点都是唯一的，则为真。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the index already exists.\r\n// 如果成功返回真，如果索引已经存在则返回假。\r\n\r\n---\r\n\r\n#### bool AddVertexCompositeIndex(const std::string &label, const std::vector &fields, CompositeIndexType type)\r\n\r\n#### bool AddVectorIndex(bool is_vertex, const std::string &label, const std::string &field, const std::string &index_type, int vec_dimension, const std::string &distance_type, std::vector &index_spec)\r\nAdds a vector index to ‘label:field’. This function blocks until the index is fully created.\n\n该文本块位于文档中关于图数据库操作的部分，详细描述了在特定条件下抛出的异常（如 InvalidGraphDB、WriteNotAllowed 和 InputError），以及在添加索引时的参数和返回值。这部分内容主要涉及图数据库的索引管理，定义了如何通过标签和字段创建唯一索引或复合索引，特别是在执行这些操作时可能遇到的错误处理和返回结果的逻辑。"
            },
            {
                "content": "True if it succeeds, false if the index already exists.\r\n// 如果成功返回真，如果索引已经存在则返回假。\r\n\r\n---\r\n\r\n#### bool AddVertexCompositeIndex(const std::string &label, const std::vector &fields, CompositeIndexType type)\r\n\r\n#### bool AddVectorIndex(bool is_vertex, const std::string &label, const std::string &field, const std::string &index_type, int vec_dimension, const std::string &distance_type, std::vector &index_spec)\r\nAdds a vector index to ‘label:field’. This function blocks until the index is fully created.\r\n// 为 'label:field' 添加向量索引。此函数阻止执行直到索引完全创建。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if label:field does not exist, or not indexable.\r\n// 如果 label:field 不存在或者不可索引，则抛出。\r\n\r\n**参数**  \r\n- is_vertex – Vertex or edge.\r\n// 顶点或边。\r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\n\n该块内容位于文档的 \"lgraph_types\" 部分，具体涉及图数据库的索引操作，包括添加复合索引和向量索引的功能，以及相关的异常处理和参数说明。这部分内容主要为用户提供关于如何在 TuGraph 数据库中创建索引的具体方法和注意事项。"
            },
            {
                "content": "// 为 'label:field' 添加向量索引。此函数阻止执行直到索引完全创建。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if label:field does not exist, or not indexable.\r\n// 如果 label:field 不存在或者不可索引，则抛出。\r\n\r\n**参数**  \r\n- is_vertex – Vertex or edge.\r\n// 顶点或边。\r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\r\n- is_unique – True if the field content is unique for each vertex.\r\n// 如果字段内容对每个顶点都是唯一的，则为真。\r\n- index_type – Type of the index.\r\n// 索引类型。\r\n- vec_dimension – Dimension of the vector.\r\n// 向量的维度。\r\n- distance_type – Type of the distance.\r\n// 距离的类型。\r\n- index_spec – Specification of the index.\r\n// 索引的规格。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the index already exists.\r\n// 如果成功返回真，如果索引已经存在则返回假。\r\n\r\n---\r\n\r\n#### bool IsVertexIndexed(const std::string &label, const std::string &field)\r\nCheck if this vertex_label:field is indexed.\n\n该段落位于文档的“lgraph_types”部分，描述了在图数据库中为特定标签和字段添加向量索引的功能，包括异常处理、参数说明和返回值。此功能是 TuGraph 中图查询与数据操作的一个重要组成部分，有助于优化图结构的数据访问与查询效率。"
            },
            {
                "content": "// 如果字段内容对每个顶点都是唯一的，则为真。\r\n- index_type – Type of the index.\r\n// 索引类型。\r\n- vec_dimension – Dimension of the vector.\r\n// 向量的维度。\r\n- distance_type – Type of the distance.\r\n// 距离的类型。\r\n- index_spec – Specification of the index.\r\n// 索引的规格。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the index already exists.\r\n// 如果成功返回真，如果索引已经存在则返回假。\r\n\r\n---\r\n\r\n#### bool IsVertexIndexed(const std::string &label, const std::string &field)\r\nCheck if this vertex_label:field is indexed.\r\n// 检查这个 vertex_label:field 是否被索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- InputError – Thrown if label:field does not exist.\r\n// 如果 label:field 不存在则抛出。\r\n\r\n**参数**  \r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\r\n\r\n**返回**  \r\nTrue if index exists, false if label:field exists but not indexed.\r\n// 如果索引存在则返回真，如果 label:field 存在但没有被索引则返回假。\r\n\r\n---\r\n\r\n#### bool IsEdgeIndexed(const std::string &label, const std::string &field)\r\nCheck if this edge_label:field is indexed.\n\n该块内容位于文档的“lgraph_types”部分，主要讨论图数据模型中关于索引的定义和使用情况，包括对顶点和边的索引检查及其参数。具体而言，它描述了如何检查特定标签和字段的索引状态，以及相关的异常处理和返回值。"
            },
            {
                "content": "**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- InputError – Thrown if label:field does not exist.\r\n// 如果 label:field 不存在则抛出。\r\n\r\n**参数**  \r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\r\n\r\n**返回**  \r\nTrue if index exists, false if label:field exists but not indexed.\r\n// 如果索引存在则返回真，如果 label:field 存在但没有被索引则返回假。\r\n\r\n---\r\n\r\n#### bool IsEdgeIndexed(const std::string &label, const std::string &field)\r\nCheck if this edge_label:field is indexed.\r\n// 检查这个 edge_label:field 是否被索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- InputError – Thrown if label:field does not exist.\r\n// 如果 label:field 不存在则抛出。\r\n\r\n**参数**  \r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\r\n\r\n**返回**  \r\nTrue if index exists, false if label:field exists but not indexed.\r\n// 如果索引存在则返回真，如果 label:field 存在但没有被索引则返回假。\r\n\r\n---\r\n\r\n#### bool IsVertexCompositeIndexed(const std::string &label, const std::vector &field)\n\n该代码块位于文档的 \"lgraph_types\" 部分，专门讨论如何检查边标签和顶点标签是否被索引，包括对相关参数、异常情况和返回值的描述。这部分内容帮助用户理解如何在 TuGraph 数据库中处理标签索引的相关操作。"
            },
            {
                "content": "// 检查这个 edge_label:field 是否被索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- InputError – Thrown if label:field does not exist.\r\n// 如果 label:field 不存在则抛出。\r\n\r\n**参数**  \r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\r\n\r\n**返回**  \r\nTrue if index exists, false if label:field exists but not indexed.\r\n// 如果索引存在则返回真，如果 label:field 存在但没有被索引则返回假。\r\n\r\n---\r\n\r\n#### bool IsVertexCompositeIndexed(const std::string &label, const std::vector &field)\r\n\r\n#### bool DeleteVertexIndex(const std::string &label, const std::string &field)\r\nDeletes the index to ‘vertex_label:field’.\r\n// 删除对 'vertex_label:field' 的索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if label or field does not exist.\r\n// 如果标签或字段不存在，则抛出。\r\n\r\n**参数**  \r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\n\n该内容位于文档的“lgraph_types”部分，主要讨论图数据库中与标签和字段相关的索引功能，包括判断索引是否存在的函数以及删除特定标签和字段的索引的函数。这部分内容为用户在图数据库中进行索引管理提供了具体的接口和异常处理机制。"
            },
            {
                "content": "Deletes the index to ‘vertex_label:field’.\r\n// 删除对 'vertex_label:field' 的索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if label or field does not exist.\r\n// 如果标签或字段不存在，则抛出。\r\n\r\n**参数**  \r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the index does not exist.\r\n// 如果成功返回真，如果索引不存在则返回假。\r\n\r\n---\r\n\r\n#### bool DeleteVertexCompositeIndex(const std::string &label, const std::vector &fields)\r\n\r\n#### bool DeleteEdgeIndex(const std::string &label, const std::string &field)\r\nDeletes the index to ‘edge_label:field’.\r\n// 删除对 'edge_label:field' 的索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\n\n该块内容位于文档的“lgraph_types”部分，主要介绍了如何删除图数据库中的索引，包括对顶点标签和边标签的索引操作的描述、抛出的异常类型、参数说明以及成功与否的返回值。"
            },
            {
                "content": "// 如果成功返回真，如果索引不存在则返回假。\r\n\r\n---\r\n\r\n#### bool DeleteVertexCompositeIndex(const std::string &label, const std::vector &fields)\r\n\r\n#### bool DeleteEdgeIndex(const std::string &label, const std::string &field)\r\nDeletes the index to ‘edge_label:field’.\r\n// 删除对 'edge_label:field' 的索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if label or field does not exist.\r\n// 如果标签或字段不存在，则抛出。\r\n\r\n**参数**  \r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the index does not exist.\r\n// 如果成功返回真，如果索引不存在则返回假。\r\n\r\n---\r\n\r\n#### bool DeleteVectorIndex(bool is_vertex, const std::string &label, const std::string &field)\r\nDeletes the vector index to ‘vertex_label:field’.\r\n// 删除对 'vertex_label:field' 的向量索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\n\n该段落位于文档中关于图数据库操作的部分，具体描述了删除索引的函数，包括删除顶点复合索引、边索引和向量索引的相关抛出异常和参数说明。这部分内容有助于用户理解如何管理和操作图数据库中的索引，以确保有效的数据管理与检索。"
            },
            {
                "content": "// 如果标签或字段不存在，则抛出。\r\n\r\n**参数**  \r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the index does not exist.\r\n// 如果成功返回真，如果索引不存在则返回假。\r\n\r\n---\r\n\r\n#### bool DeleteVectorIndex(bool is_vertex, const std::string &label, const std::string &field)\r\nDeletes the vector index to ‘vertex_label:field’.\r\n// 删除对 'vertex_label:field' 的向量索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n// 当当前 GraphDB 无效时抛出。\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if label or field does not exist.\r\n// 如果标签或字段不存在，则抛出。\r\n\r\n**参数**  \r\n- is_vertex – Vertex or edge.\r\n// 顶点或边。\r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the index does not exist.\r\n// 如果成功返回真，如果索引不存在则返回假。\r\n\r\n---\r\n\r\n#### std::string GetDescription() const\r\nGet graph description.\r\n获取图形描述。\r\n\r\n**抛出**\n\n该片段位于文档的“lgraph_types”部分，具体涉及与索引相关的函数定义，包括删除向量索引的操作和返回图形描述的函数。这些功能有助于管理和查询图数据库中的标签和字段。"
            },
            {
                "content": "- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n// 当在只读访问级别的 GraphDB 上调用时抛出。\r\n- InputError – Thrown if label or field does not exist.\r\n// 如果标签或字段不存在，则抛出。\r\n\r\n**参数**  \r\n- is_vertex – Vertex or edge.\r\n// 顶点或边。\r\n- label – The label.\r\n// 标签。\r\n- field – The field.\r\n// 字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the index does not exist.\r\n// 如果成功返回真，如果索引不存在则返回假。\r\n\r\n---\r\n\r\n#### std::string GetDescription() const\r\nGet graph description.\r\n获取图形描述。\r\n\r\n**抛出**  \r\nInvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n抛出异常：InvalidGraphDB – 当前GraphDB无效时抛出。\r\n\r\n**返回**  \r\nThe description.\r\n返回图形描述。\r\n\r\n---\r\n\r\n#### size_t GetMaxSize() const\r\nGet maximum graph size.\r\n获取最大图形大小。\r\n\r\n**抛出**  \r\nInvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n抛出异常：InvalidGraphDB – 当前GraphDB无效时抛出。\r\n\r\n**返回**  \r\nThe maximum size.\r\n返回最大大小。\r\n\r\n---\r\n\r\n#### bool AddVertexFullTextIndex(const std::string &vertex_label, const std::string &field)\r\nAdd fulltext index to ‘vertex_label:field’.\n\n该块内容位于文档的“lgraph_db”部分，主要描述了在只读访问级别的GraphDB上进行操作时可能抛出的异常，包括“WriteNotAllowed”和“InputError”。此外，还介绍了与图形描述和最大图形大小相关的获取函数，最后提到添加全文索引的函数，用于在图中为特定字段添加索引。这部分内容涉及图数据库的操作限制和元数据管理。"
            },
            {
                "content": "抛出异常：InvalidGraphDB – 当前GraphDB无效时抛出。\r\n\r\n**返回**  \r\nThe description.\r\n返回图形描述。\r\n\r\n---\r\n\r\n#### size_t GetMaxSize() const\r\nGet maximum graph size.\r\n获取最大图形大小。\r\n\r\n**抛出**  \r\nInvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n抛出异常：InvalidGraphDB – 当前GraphDB无效时抛出。\r\n\r\n**返回**  \r\nThe maximum size.\r\n返回最大大小。\r\n\r\n---\r\n\r\n#### bool AddVertexFullTextIndex(const std::string &vertex_label, const std::string &field)\r\nAdd fulltext index to ‘vertex_label:field’.\r\n将全文索引添加到‘vertex_label:field’。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n- InputError – Thrown if vertex label or field does not exist.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果顶点标签或字段不存在，则抛出。  \r\n\r\n**参数**  \r\n- vertex_label – The vertex label.\r\n顶点标签。\r\n\r\n- field – The field.\r\n字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the fulltext index already exists.\n\n该段落位于文档中与 `lgraph_db` 类相关的部分，具体介绍了 `GetMaxSize()` 和 `AddVertexFullTextIndex()` 方法的异常抛出情况和返回值。这些方法是图数据库操作的一部分，用于获取最大图形大小以及为顶点添加全文索引。"
            },
            {
                "content": "**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n- InputError – Thrown if vertex label or field does not exist.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果顶点标签或字段不存在，则抛出。  \r\n\r\n**参数**  \r\n- vertex_label – The vertex label.\r\n顶点标签。\r\n\r\n- field – The field.\r\n字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the fulltext index already exists.\r\n如果成功返回true，如果全文索引已存在则返回false。\r\n\r\n---\r\n\r\n#### bool AddEdgeFullTextIndex(const std::string &edge_label, const std::string &field)\r\nAdd fulltext index to ‘edge_label:field’.\r\n将全文索引添加到‘edge_label:field’。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n- InputError – Thrown if edge label or field does not exist.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。\n\n该段落位于文档中的 `lgraph_db` 部分，主要描述与图数据库操作相关的异常抛出情况。具体来说，它说明了在执行 `AddVertexFullTextIndex` 和 `AddEdgeFullTextIndex` 函数时可能遇到的异常，包括无效的图数据库状态、只读访问级别的限制以及标签或字段不存在的错误。"
            },
            {
                "content": "如果成功返回true，如果全文索引已存在则返回false。\r\n\r\n---\r\n\r\n#### bool AddEdgeFullTextIndex(const std::string &edge_label, const std::string &field)\r\nAdd fulltext index to ‘edge_label:field’.\r\n将全文索引添加到‘edge_label:field’。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n- InputError – Thrown if edge label or field does not exist.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果边标签或字段不存在，则抛出。  \r\n\r\n**参数**  \r\n- edge_label – The edge label.\r\n边标签。\r\n\r\n- field – The field.\r\n字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the fulltext index already exists.\r\n如果成功返回true，如果全文索引已存在则返回false。\r\n\r\n---\r\n\r\n#### bool DeleteVertexFullTextIndex(const std::string &vertex_label, const std::string &field)\r\nDelete the fulltext index of ‘vertex_label:field’.\r\n删除‘vertex_label:field’的全文索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\n\n该块内容位于文档的“lgraph_db”部分，具体讨论了如何在图数据库中为边标签添加全文索引和删除全文索引的功能，包括相应的异常处理和参数说明。这部分内容为用户提供了操作全文索引的接口和方法。"
            },
            {
                "content": "- InputError – 如果边标签或字段不存在，则抛出。  \r\n\r\n**参数**  \r\n- edge_label – The edge label.\r\n边标签。\r\n\r\n- field – The field.\r\n字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the fulltext index already exists.\r\n如果成功返回true，如果全文索引已存在则返回false。\r\n\r\n---\r\n\r\n#### bool DeleteVertexFullTextIndex(const std::string &vertex_label, const std::string &field)\r\nDelete the fulltext index of ‘vertex_label:field’.\r\n删除‘vertex_label:field’的全文索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n- InputError – Thrown if vertex label or field does not exist.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果顶点标签或字段不存在，则抛出。  \r\n\r\n**参数**  \r\n- vertex_label – The vertex label.\r\n顶点标签。\r\n\r\n- field – The field.\r\n字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the fulltext index does not exist.\r\n如果成功返回true，如果全文索引不存在则返回false。\r\n\r\n---\n\n该块内容位于文档中关于图数据库的操作和方法部分，具体涉及到与图数据库中边和顶点标签的全文索引相关的操作，包括添加和删除全文索引的功能，以及相应的异常处理和参数说明。这部分内容的目标是为了提供用户对边和顶点标签的全文索引创建和管理的具体指引。"
            },
            {
                "content": "- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n- InputError – Thrown if vertex label or field does not exist.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果顶点标签或字段不存在，则抛出。  \r\n\r\n**参数**  \r\n- vertex_label – The vertex label.\r\n顶点标签。\r\n\r\n- field – The field.\r\n字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the fulltext index does not exist.\r\n如果成功返回true，如果全文索引不存在则返回false。\r\n\r\n---\r\n\r\n#### bool DeleteEdgeFullTextIndex(const std::string &edge_label, const std::string &field)\r\nDelete the fulltext index of ‘edge_label:field’.\r\n删除‘edge_label:field’的全文索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n- InputError – Thrown if edge label or field does not exist.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果边标签或字段不存在，则抛出。  \r\n\r\n**参数**\n\n该块内容位于文档的“lgraph_db”部分，具体涉及对图数据库（GraphDB）操作时抛出的异常，包括在只读模式下调用方法时的限制和错误处理，主要针对创建和删除边或顶点的全文索引过程中的潜在错误。"
            },
            {
                "content": "Delete the fulltext index of ‘edge_label:field’.\r\n删除‘edge_label:field’的全文索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n- InputError – Thrown if edge label or field does not exist.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在只读访问级别的GraphDB上调用时抛出。  \r\n- InputError – 如果边标签或字段不存在，则抛出。  \r\n\r\n**参数**  \r\n- edge_label – The edge label.\r\n边标签。\r\n\r\n- field – The field.\r\n字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the fulltext index does not exist.\r\n如果成功返回true，如果全文索引不存在则返回false。\r\n\r\n---\r\n\r\n#### void RebuildFullTextIndex(const std::set &vertex_labels, const std::set &edge_labels)\r\nRebuild the fulltext index of vertex_labels and edge_labels.\r\n重建顶点标签和边标签的全文索引。\r\n\r\n**参数**  \r\n- vertex_labels – The vertex labels whose fulltext index need to be rebuilt.\r\n需要重建全文索引的顶点标签。\r\n\r\n- edge_labels – The edge labels whose fulltext index need to be rebuilt.\r\n需要重建全文索引的边标签。\r\n\r\n---\n\n该段落位于文档的“lgraph_db”部分，具体描述了删除边标签的全文索引及重建全文索引的函数。这部分内容主要讲解如何管理与图数据库中的边和顶点相关的全文索引，包括异常抛出条件、参数说明以及返回值的含义。这些函数对于张量分析和图数据库的检索功能至关重要。"
            },
            {
                "content": "字段。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if the fulltext index does not exist.\r\n如果成功返回true，如果全文索引不存在则返回false。\r\n\r\n---\r\n\r\n#### void RebuildFullTextIndex(const std::set &vertex_labels, const std::set &edge_labels)\r\nRebuild the fulltext index of vertex_labels and edge_labels.\r\n重建顶点标签和边标签的全文索引。\r\n\r\n**参数**  \r\n- vertex_labels – The vertex labels whose fulltext index need to be rebuilt.\r\n需要重建全文索引的顶点标签。\r\n\r\n- edge_labels – The edge labels whose fulltext index need to be rebuilt.\r\n需要重建全文索引的边标签。\r\n\r\n---\r\n\r\n#### std::vector> ListFullTextIndexes()\r\nList fulltext indexes of vertex and edge.\r\n列出顶点和边的全文索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在只读访问级别的GraphDB上调用时抛出。  \r\n\r\n**返回**  \r\nFormat of returned data: (is_vertex, label_name, property_name).\r\n返回数据格式：(is_vertex, label_name, property_name)。\r\n\r\n---\n\n该块内容位于文档的“lgraph_db”部分，主要讨论了正文相关的操作和函数，包括重建全文索引和列出边和顶点的全文索引。这部分提供了对全文索引的操作细节以及方法的异常处理说明。"
            },
            {
                "content": "需要重建全文索引的边标签。\r\n\r\n---\r\n\r\n#### std::vector> ListFullTextIndexes()\r\nList fulltext indexes of vertex and edge.\r\n列出顶点和边的全文索引。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在只读访问级别的GraphDB上调用时抛出。  \r\n\r\n**返回**  \r\nFormat of returned data: (is_vertex, label_name, property_name).\r\n返回数据格式：(is_vertex, label_name, property_name)。\r\n\r\n---\r\n\r\n#### std::vector> QueryVertexByFullTextIndex(const std::string &label, const std::string &query, int top_n)\r\nQuery vertex by fulltext index.\r\n通过全文索引查询顶点。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- InputError – Thrown if label does not exist.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- InputError – 如果标签不存在，则抛出。  \r\n\r\n**参数**  \r\n- label – The vertex label.\r\n标签 – 顶点标签。\r\n\r\n- query – Lucene query language.\r\n查询 – Lucene查询语言。\r\n\r\n- top_n – Return top n data.\r\ntop_n – 返回前n条数据。\n\n该片段位于文档的“lgraph_db”部分，专注于数据库的全文索引功能，包括列出索引和通过全文索引查询顶点的相关函数和异常处理，旨在优化图数据库的查询性能和管理索引。"
            },
            {
                "content": "Query vertex by fulltext index.\r\n通过全文索引查询顶点。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- InputError – Thrown if label does not exist.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- InputError – 如果标签不存在，则抛出。  \r\n\r\n**参数**  \r\n- label – The vertex label.\r\n标签 – 顶点标签。\r\n\r\n- query – Lucene query language.\r\n查询 – Lucene查询语言。\r\n\r\n- top_n – Return top n data.\r\ntop_n – 返回前n条数据。\r\n\r\n**返回**  \r\nVertex vids and score. Throws exception on error.\r\n返回顶点的vid和分数。发生错误时抛出异常。\r\n\r\n---\r\n\r\n#### std::vector> QueryEdgeByFullTextIndex(const std::string &label, const std::string &query, int top_n)\r\nQuery edge by fulltext index.\r\n通过全文索引查询边。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- InputError – Thrown if label does not exist.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- InputError – 如果标签不存在，则抛出。  \r\n\r\n**参数**  \r\n- label – The edge label.\r\n标签 – 边标签。\r\n\r\n- query – Lucene query language.\r\n查询 – Lucene查询语言。\r\n\r\n- top_n – Return top n data.\r\ntop_n – 返回前n条数据。\r\n\r\n**返回**\n\n该段落位于文档的“lgraph_rpc_client”部分，主要介绍了通过全文索引查询顶点和边的功能，包括异常处理、参数说明和返回值。这部分内容提供了如何在TuGraph数据库中进行高效数据检索的接口定义。"
            },
            {
                "content": "Query edge by fulltext index.\r\n通过全文索引查询边。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- InputError – Thrown if label does not exist.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- InputError – 如果标签不存在，则抛出。  \r\n\r\n**参数**  \r\n- label – The edge label.\r\n标签 – 边标签。\r\n\r\n- query – Lucene query language.\r\n查询 – Lucene查询语言。\r\n\r\n- top_n – Return top n data.\r\ntop_n – 返回前n条数据。\r\n\r\n**返回**  \r\nEdge uids and score. Throws exception on error.\r\n返回边的uids和分数。发生错误时抛出异常。\r\n\r\n---\r\n\r\n#### void RefreshCount()\r\nRecount the total number of vertex and edge, stop writing during the count.\r\n重新计算顶点和边的总数，在计数期间停止写入。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在只读访问级别的GraphDB上调用时抛出。  \r\n\r\n---\r\n\r\n### Private Functions\r\n\r\n#### GraphDB(const GraphDB&) = delete\r\nCopying is disabled.\r\n复制功能被禁止。\n\n该块内容位于文档的“lgraph_db”部分，具体涉及通过全文索引查询边的功能和相关异常处理。此外，还包含了重新计算图中顶点和边数量的函数说明及其异常处理。这些内容为图数据库的查询和管理提供了重要的接口和操作说明。"
            },
            {
                "content": "---\r\n\r\n#### void RefreshCount()\r\nRecount the total number of vertex and edge, stop writing during the count.\r\n重新计算顶点和边的总数，在计数期间停止写入。\r\n\r\n**抛出**  \r\n- InvalidGraphDB – Thrown when currently GraphDB is invalid.\r\n- WriteNotAllowed – Thrown when called on a GraphDB with read-only access level.\r\n\r\n抛出异常：  \r\n- InvalidGraphDB – 当前GraphDB无效时抛出。  \r\n- WriteNotAllowed – 在只读访问级别的GraphDB上调用时抛出。  \r\n\r\n---\r\n\r\n### Private Functions\r\n\r\n#### GraphDB(const GraphDB&) = delete\r\nCopying is disabled.\r\n复制功能被禁止。\r\n\r\n#### GraphDB &operator=(const GraphDB&) = delete\r\n赋值操作被禁止。\r\n\r\n### Private Members\r\n\r\n#### lgraph::AccessControlledDB *db_\r\n数据库指针。\r\n\r\n#### bool should_delete_db_ = false\r\n是否应该删除数据库的标志，默认值为false。\r\n\r\n#### bool read_only_ = false\r\n是否只读的标志，默认值为false。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_edge_index_iterator\r\n\r\n```cpp\r\nnamespace lgraph {\r\nnamespace lgraph_api {\r\nclass EdgeIndexIterator {\r\n#include \r\n```\n\n该块内容位于文档的 **lgraph_db** 部分，详细描述了 `RefreshCount()` 函数的功能和异常抛出情况，主要用于重新计算图数据库中顶点和边的数量，以及与 `GraphDB` 类的复制和赋值操作的禁用相关的私有函数和成员。"
            },
            {
                "content": "---\r\n\r\n### Private Functions\r\n\r\n#### GraphDB(const GraphDB&) = delete\r\nCopying is disabled.\r\n复制功能被禁止。\r\n\r\n#### GraphDB &operator=(const GraphDB&) = delete\r\n赋值操作被禁止。\r\n\r\n### Private Members\r\n\r\n#### lgraph::AccessControlledDB *db_\r\n数据库指针。\r\n\r\n#### bool should_delete_db_ = false\r\n是否应该删除数据库的标志，默认值为false。\r\n\r\n#### bool read_only_ = false\r\n是否只读的标志，默认值为false。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_edge_index_iterator\r\n\r\n```cpp\r\nnamespace lgraph {\r\nnamespace lgraph_api {\r\nclass EdgeIndexIterator {\r\n#include \r\n```\r\n\r\n`EdgeIndexIterator` can be used to access a set of edges that has the same indexed value. 如果索引是唯一的（即每条边具有唯一的索引值），那么每个 `EdgeIndexIterator` 只会有一个边的唯一 ID，并且在调用 `Next()` 后将变得无效。\r\n\r\nAn `EdgeIndexIterator` is valid iff it points to a valid `(index_value, euid)` pair; otherwise, it is invalid. `EdgeIndexIterator` 在指向有效的 `(index_value, euid)` 对时有效；否则，它是无效的。调用无效 `EdgeIndexIterator` 的成员函数会抛出异常，唯一不抛出异常的函数是 `IsValid()`。\r\n\r\n### Public Functions\r\n\r\n- **EdgeIndexIterator(EdgeIndexIterator &&rhs)**\n\n该块内容位于文档中关于`GraphDB`类的部分，描述了`GraphDB`的私有构造函数和成员变量，以及防止复制和赋值操作的设定，随后引入了`EdgeIndexIterator`类，进一步详细说明了迭代器的用法和有效性检查。"
            },
            {
                "content": "#include \r\n```\r\n\r\n`EdgeIndexIterator` can be used to access a set of edges that has the same indexed value. 如果索引是唯一的（即每条边具有唯一的索引值），那么每个 `EdgeIndexIterator` 只会有一个边的唯一 ID，并且在调用 `Next()` 后将变得无效。\r\n\r\nAn `EdgeIndexIterator` is valid iff it points to a valid `(index_value, euid)` pair; otherwise, it is invalid. `EdgeIndexIterator` 在指向有效的 `(index_value, euid)` 对时有效；否则，它是无效的。调用无效 `EdgeIndexIterator` 的成员函数会抛出异常，唯一不抛出异常的函数是 `IsValid()`。\r\n\r\n### Public Functions\r\n\r\n- **EdgeIndexIterator(EdgeIndexIterator &&rhs)**\r\n\r\n- **EdgeIndexIterator &operator=(EdgeIndexIterator&&)**\r\n\r\n- **~EdgeIndexIterator()**\r\n\r\n- **void Close()**\r\n  - Closes this iterator.\r\n  - 关闭此迭代器。\r\n\r\n- **bool IsValid() const**\r\n  - Query if this iterator is valid, i.e., the Key and Vid can be queried.\r\n  - 查询此迭代器是否有效，即 Key 和 Vid 是否可以查询。\r\n  \r\n  **返回**\r\n  - True if valid, false if not.\r\n  - 如果有效返回 True，如果无效返回 false。\r\n\r\n- **bool Next()**\n\n该块内容位于文档的“lgraph_vertex_index_iterator”章节，描述了`EdgeIndexIterator`类的功能和使用方法，主要用于访问具有相同索引值的边集合。该部分介绍了类的构造函数、公共函数以及如何判断迭代器的有效性等细节。"
            },
            {
                "content": "### Public Functions\r\n\r\n- **EdgeIndexIterator(EdgeIndexIterator &&rhs)**\r\n\r\n- **EdgeIndexIterator &operator=(EdgeIndexIterator&&)**\r\n\r\n- **~EdgeIndexIterator()**\r\n\r\n- **void Close()**\r\n  - Closes this iterator.\r\n  - 关闭此迭代器。\r\n\r\n- **bool IsValid() const**\r\n  - Query if this iterator is valid, i.e., the Key and Vid can be queried.\r\n  - 查询此迭代器是否有效，即 Key 和 Vid 是否可以查询。\r\n  \r\n  **返回**\r\n  - True if valid, false if not.\r\n  - 如果有效返回 True，如果无效返回 false。\r\n\r\n- **bool Next()**\r\n  - Move to the next edge unique id in the list, which consists of all the valid edge unique ids of the iterator and is sorted from small to large. If we hit the end of the list, the iterator will become invalid and false is returned.\r\n  - 移动到列表中的下一个边的唯一 ID，该列表由迭代器的所有有效边的唯一 ID 组成，并按从小到大的顺序排序。如果到达列表的末尾，则迭代器将变为无效并返回 false。\r\n  \r\n  **返回**\r\n  - True if it succeeds, otherwise false.\r\n  - 如果成功返回 True，否则返回 false。\r\n\r\n- **FieldData GetIndexValue() const**\n\n该块内容位于文档的“lgraph_vertex_index_iterator”部分，介绍了`VertexIndexIterator`类的公共函数，包括构造函数、析构函数、关闭迭代器、验证迭代器有效性、移动到下一个边唯一ID以及获取当前索引值的功能。这些功能帮助用户在图数据库中处理边索引迭代器的操作。"
            },
            {
                "content": "- 如果有效返回 True，如果无效返回 false。\r\n\r\n- **bool Next()**\r\n  - Move to the next edge unique id in the list, which consists of all the valid edge unique ids of the iterator and is sorted from small to large. If we hit the end of the list, the iterator will become invalid and false is returned.\r\n  - 移动到列表中的下一个边的唯一 ID，该列表由迭代器的所有有效边的唯一 ID 组成，并按从小到大的顺序排序。如果到达列表的末尾，则迭代器将变为无效并返回 false。\r\n  \r\n  **返回**\r\n  - True if it succeeds, otherwise false.\r\n  - 如果成功返回 True，否则返回 false。\r\n\r\n- **FieldData GetIndexValue() const**\r\n  - Gets the current index value. The euids are sorted in `(EdgeIndexValue, euid)` order. When `Next()` is called, the iterator moves from one euid to the next, possibly moving from one `EdgeIndexValue` to another. This function tells the `EdgeIndexValue` currently pointed to.\r\n  - 获取当前的索引值。euids 按 `(EdgeIndexValue, euid)` 顺序排序。当调用 `Next()` 时，迭代器从一个 euid 移动到下一个，可能会从一个 `EdgeIndexValue` 移动到另一个。此函数返回当前指向的 `EdgeIndexValue`。\r\n  \r\n  **返回**\r\n  - The key.\r\n  - 返回键值。\r\n\r\n- **EdgeUid GetUid() const**\n\n该块内容位于 `lgraph_edge_index_iterator` 类的定义部分，描述了 `EdgeIndexIterator` 的主要功能，包括如何移动到下一个有效的边唯一 ID、获取当前索引值以及访问边的唯一 ID。这些功能是图数据库操作中重要的迭代器方法，用于处理与边相关的遍历和索引。"
            },
            {
                "content": "- Gets the current index value. The euids are sorted in `(EdgeIndexValue, euid)` order. When `Next()` is called, the iterator moves from one euid to the next, possibly moving from one `EdgeIndexValue` to another. This function tells the `EdgeIndexValue` currently pointed to.\r\n  - 获取当前的索引值。euids 按 `(EdgeIndexValue, euid)` 顺序排序。当调用 `Next()` 时，迭代器从一个 euid 移动到下一个，可能会从一个 `EdgeIndexValue` 移动到另一个。此函数返回当前指向的 `EdgeIndexValue`。\r\n  \r\n  **返回**\r\n  - The key.\r\n  - 返回键值。\r\n\r\n- **EdgeUid GetUid() const**\r\n  - Gets the Edge Unique Id.\r\n  - 获取边的唯一 ID。\r\n  \r\n  **返回**\r\n  - The UID.\r\n  - 返回 UID。\r\n\r\n- **int64_t GetSrc() const**\r\n  - Gets the source vertex id.\r\n  - 获取源顶点 ID。\r\n  \r\n  **返回**\r\n  - The source vertex id.\r\n  - 返回源顶点 ID。\r\n\r\n- **int64_t GetDst() const**\r\n  - Gets the destination of the edge.\r\n  - 获取边的目的地。\r\n  \r\n  **返回**\r\n  - The destination vertex id.\r\n  - 返回目的顶点 ID。\r\n\r\n- **size_t GetLabelId() const**\r\n  - Gets label id of this edge.\r\n  - 获取此边的标签 ID。\r\n  \r\n  **返回**\r\n  - The label identifier.\r\n  - 返回标签标识符。\n\n该内容来自于文档中的 `EdgeIndexIterator` 类部分，主要描述了与边索引迭代器相关的公共函数，包括获取当前索引值、边的唯一 ID、源顶点 ID、目标顶点 ID 和边的标签 ID 等功能。"
            },
            {
                "content": "- Gets the Edge Unique Id.\r\n  - 获取边的唯一 ID。\r\n  \r\n  **返回**\r\n  - The UID.\r\n  - 返回 UID。\r\n\r\n- **int64_t GetSrc() const**\r\n  - Gets the source vertex id.\r\n  - 获取源顶点 ID。\r\n  \r\n  **返回**\r\n  - The source vertex id.\r\n  - 返回源顶点 ID。\r\n\r\n- **int64_t GetDst() const**\r\n  - Gets the destination of the edge.\r\n  - 获取边的目的地。\r\n  \r\n  **返回**\r\n  - The destination vertex id.\r\n  - 返回目的顶点 ID。\r\n\r\n- **size_t GetLabelId() const**\r\n  - Gets label id of this edge.\r\n  - 获取此边的标签 ID。\r\n  \r\n  **返回**\r\n  - The label identifier.\r\n  - 返回标签标识符。\r\n\r\n- **int64_t GetEdgeId() const**\r\n  - Gets edge id.\r\n  - 获取边的 ID。\r\n  \r\n  **返回**\r\n  - The edge identifier.\r\n  - 返回边标识符。\r\n\r\n### Private Functions\r\n\r\n- **EdgeIndexIterator(lgraph::EdgeIndexIterator &⁢, const std::shared_ptr &txn)**\r\n\r\n- **EdgeIndexIterator(const EdgeIndexIterator&) = delete**\r\n\r\n- **EdgeIndexIterator &operator=(const EdgeIndexIterator&) = delete**\r\n\r\n### Private Members\r\n\r\n- **std::unique_ptr it_**\r\n\r\n- **std::shared_ptr txn_**\r\n\r\n### Friends\r\n\r\n- **friend class Transaction**\n\n该块内容位于文档的 `lgraph_edge_iterator` 类部分，描述了如何获取边的唯一 ID、源顶点 ID、目的顶点 ID、标签 ID 和边 ID 的公共函数。这些函数是图数据库操作的一部分，用于处理和访问边的相关属性。"
            },
            {
                "content": "- Gets edge id.\r\n  - 获取边的 ID。\r\n  \r\n  **返回**\r\n  - The edge identifier.\r\n  - 返回边标识符。\r\n\r\n### Private Functions\r\n\r\n- **EdgeIndexIterator(lgraph::EdgeIndexIterator &⁢, const std::shared_ptr &txn)**\r\n\r\n- **EdgeIndexIterator(const EdgeIndexIterator&) = delete**\r\n\r\n- **EdgeIndexIterator &operator=(const EdgeIndexIterator&) = delete**\r\n\r\n### Private Members\r\n\r\n- **std::unique_ptr it_**\r\n\r\n- **std::shared_ptr txn_**\r\n\r\n### Friends\r\n\r\n- **friend class Transaction**\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_edge_iterator\r\n\r\n### namespace lgraph\r\n### namespace graph\r\n### namespace lgraph_api\r\n\r\n### Functions\r\n\r\n```cpp\r\nbool operator==(const OutEdgeIterator &lhs, const OutEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator==(const OutEdgeIterator &lhs, const InEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator==(const InEdgeIterator &lhs, const OutEdgeIterator &rhs)\r\n```\n\n该段落位于文档的“lgraph_edge_index_iterator”部分，主要描述了`EdgeIndexIterator`类的功能及其相关的私有函数和成员。此外，还涉及`lgraph_edge_iterator`类的定义，包含了用于比较出边迭代器和入边迭代器是否指向同一条边的重载运算符函数。简而言之，这是关于图形数据库中边迭代器的实现细节。"
            },
            {
                "content": "### namespace lgraph\r\n### namespace graph\r\n### namespace lgraph_api\r\n\r\n### Functions\r\n\r\n```cpp\r\nbool operator==(const OutEdgeIterator &lhs, const OutEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator==(const OutEdgeIterator &lhs, const InEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator==(const InEdgeIterator &lhs, const OutEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator==(const InEdgeIterator &lhs, const InEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator!=(const OutEdgeIterator &lhs, const OutEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator!=(const OutEdgeIterator &lhs, const InEdgeIterator &rhs)\r\n```\n\n该片段位于文档中关于 TuGraph 的 `lgraph_api` 命名空间下，具体涉及边迭代器（`OutEdgeIterator` 和 `InEdgeIterator`）的比较操作符的定义。这些函数用于检查两个边迭代器是否指向同一条边，从而在图形遍历和边操作中提供功能支持。"
            },
            {
                "content": "```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator==(const InEdgeIterator &lhs, const InEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator!=(const OutEdgeIterator &lhs, const OutEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator!=(const OutEdgeIterator &lhs, const InEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator!=(const InEdgeIterator &lhs, const OutEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator!=(const InEdgeIterator &lhs, const InEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n### class InEdgeIterator\r\n```cpp\r\n#include \r\n```\n\n该代码块位于文档的“lgraph_edge_iterator”部分，特别是涉及边迭代器的比较运算符重载。在此部分中，定义了如何检查不同类型的边迭代器（如入边和出边迭代器）是否指向相同的边。这些运算符包括相等（`==`）和不等（`!=`）的重载，旨在支持在图遍历和图数据处理中的边比较操作。"
            },
            {
                "content": "```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator!=(const InEdgeIterator &lhs, const OutEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n```cpp\r\nbool operator!=(const InEdgeIterator &lhs, const InEdgeIterator &rhs)\r\n```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n### class InEdgeIterator\r\n```cpp\r\n#include \r\n```\r\nAn InEdgeIterator can be used to iterate through the in-coming edges of a vertex. Edges are sorted in (lid, tid, src, eid) order, and each (dst, lid, tid, src, eid) tuple is guaranteed to uniquely identify an edge.  // InEdgeIterator 可用于遍历一个顶点的入边。边按 (lid, tid, src, eid) 的顺序排序，每个 (dst, lid, tid, src, eid) 元组保证唯一标识一条边。\n\n该块内容位于文档的 `lgraph_edge_iterator` 类部分，具体讨论了如何比较边缘迭代器（`InEdgeIterator` 和 `OutEdgeIterator`）是否指向同一条边。此段落包括重载的相等和不等运算符函数，并介绍了 `InEdgeIterator` 的基本功能和用法，用于遍历顶点的入边。"
            },
            {
                "content": "```\r\nCheck whether lhs and rhs points to the same edge.  // 检查 lhs 和 rhs 是否指向同一条边。\r\n\r\n### class InEdgeIterator\r\n```cpp\r\n#include \r\n```\r\nAn InEdgeIterator can be used to iterate through the in-coming edges of a vertex. Edges are sorted in (lid, tid, src, eid) order, and each (dst, lid, tid, src, eid) tuple is guaranteed to uniquely identify an edge.  // InEdgeIterator 可用于遍历一个顶点的入边。边按 (lid, tid, src, eid) 的顺序排序，每个 (dst, lid, tid, src, eid) 元组保证唯一标识一条边。\r\n\r\nAn InEdgeIterator is valid iff it points to a valid in-coming edge; otherwise, it is invalid. Calling member function on an invalid InEdgeIterator throws an exception, except for the IsValid() and Goto() functions.  // 当 InEdgeIterator 指向一个有效的入边时，它是有效的；否则，它是无效的。在无效的 InEdgeIterator 上调用成员函数会抛出异常，除了 IsValid() 和 Goto() 函数。\r\n\r\nThe following operations invalidate an InEdgeIterator:  // 以下操作会使 InEdgeIterator 无效：\r\n\r\n- Constructing an InEdgeIterator for non-existing edge.  // 为不存在的边构造 InEdgeIterator。\n\n该块内容位于关于`lgraph_edge_iterator`和`lgraph_vertex_iterator`的章节中，具体讨论了`InEdgeIterator`类，侧重于其功能和有效性。`InEdgeIterator`用于遍历顶点的入边，确保对边的唯一识别，并定义了其有效性与指向有效入边的条件。"
            },
            {
                "content": "An InEdgeIterator is valid iff it points to a valid in-coming edge; otherwise, it is invalid. Calling member function on an invalid InEdgeIterator throws an exception, except for the IsValid() and Goto() functions.  // 当 InEdgeIterator 指向一个有效的入边时，它是有效的；否则，它是无效的。在无效的 InEdgeIterator 上调用成员函数会抛出异常，除了 IsValid() 和 Goto() 函数。\r\n\r\nThe following operations invalidate an InEdgeIterator:  // 以下操作会使 InEdgeIterator 无效：\r\n\r\n- Constructing an InEdgeIterator for non-existing edge.  // 为不存在的边构造 InEdgeIterator。\r\n- Calling Goto() with the id of a non-existing edge.  // 使用不存在的边的 ID 调用 Goto()。\r\n- Calling Next() on the last in-coming edge.  // 在最后一个入边上调用 Next()。\r\n- Calling Delete() on the last in-coming edge.  // 在最后一个入边上调用 Delete()。\r\n- Calling Close() on the iterator.  // 在迭代器上调用 Close()。\n\n该段落位于文档中关于 `InEdgeIterator` 类的部分，描述了 `InEdgeIterator` 的有效性及其无效化的操作。它提供了有效的遍历入边的功能，并说明了在无效状态下调用成员函数时的错误处理，适用于图数据库的遍历操作相关内容。"
            },
            {
                "content": "The following operations invalidate an InEdgeIterator:  // 以下操作会使 InEdgeIterator 无效：\r\n\r\n- Constructing an InEdgeIterator for non-existing edge.  // 为不存在的边构造 InEdgeIterator。\r\n- Calling Goto() with the id of a non-existing edge.  // 使用不存在的边的 ID 调用 Goto()。\r\n- Calling Next() on the last in-coming edge.  // 在最后一个入边上调用 Next()。\r\n- Calling Delete() on the last in-coming edge.  // 在最后一个入边上调用 Delete()。\r\n- Calling Close() on the iterator.  // 在迭代器上调用 Close()。\r\n\r\nIn TuGraph, every iterator belongs to a transaction, and can only be used when the transaction is valid. Calling member functions on an iterator inside an invalid transaction yields InvalidTxn, except for Invalid().  // 在 TuGraph 中，每个迭代器属于一个事务，只能在事务有效时使用。在无效事务中的迭代器上调用成员函数会返回 InvalidTxn，Invalid() 除外。\r\n\r\n#### Public Functions\r\n\r\n```cpp\r\nInEdgeIterator(InEdgeIterator &&rhs)\r\n```\r\n\r\n```cpp\r\nInEdgeIterator &operator=(InEdgeIterator&&)\r\n```\r\n\r\n```cpp\r\n~InEdgeIterator()\r\n```\r\n\r\n```cpp\r\nvoid Close() noexcept\r\n```\n\n该段落位于文档中关于 `InEdgeIterator` 类的部分，主要描述了无效化 `InEdgeIterator` 的各种操作，包括构造无效边、调用非法 ID、迭代器的下一步移动、删除操作和关闭操作。同时指出，所有迭代器在 TuGraph 中都属于特定的事务，并且只能在有效的事务中使用。"
            },
            {
                "content": "In TuGraph, every iterator belongs to a transaction, and can only be used when the transaction is valid. Calling member functions on an iterator inside an invalid transaction yields InvalidTxn, except for Invalid().  // 在 TuGraph 中，每个迭代器属于一个事务，只能在事务有效时使用。在无效事务中的迭代器上调用成员函数会返回 InvalidTxn，Invalid() 除外。\r\n\r\n#### Public Functions\r\n\r\n```cpp\r\nInEdgeIterator(InEdgeIterator &&rhs)\r\n```\r\n\r\n```cpp\r\nInEdgeIterator &operator=(InEdgeIterator&&)\r\n```\r\n\r\n```cpp\r\n~InEdgeIterator()\r\n```\r\n\r\n```cpp\r\nvoid Close() noexcept\r\n```\r\nCloses this iterator. The iterator turns invalid after being closed.  // 关闭此迭代器。关闭后，迭代器变为无效。\r\n\r\n```cpp\r\nbool Next()\r\n```\r\nMove to the next incoming edge to current destination vertex. If there is no more edge, the iterator becomes invalid and false is returned.  // 移动到当前目标顶点的下一个入边。如果没有更多边，迭代器变为无效并返回 false。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\n\n该段内容位于文档中关于“lgraph_vertex_iterator”和“lgraph_edge_iterator”类的部分，详细描述了在TuGraph中迭代器与事务的关系，特别是如何在有效的事务环境中使用`InEdgeIterator`类进行入边遍历操作，包括相关函数的声明和使用说明。"
            },
            {
                "content": "```\r\nCloses this iterator. The iterator turns invalid after being closed.  // 关闭此迭代器。关闭后，迭代器变为无效。\r\n\r\n```cpp\r\nbool Next()\r\n```\r\nMove to the next incoming edge to current destination vertex. If there is no more edge, the iterator becomes invalid and false is returned.  // 移动到当前目标顶点的下一个入边。如果没有更多边，迭代器变为无效并返回 false。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nTrue if it succeeds, false if it fails.  // 如果成功则返回 true，失败则返回 false。\r\n\r\n```cpp\r\nbool Goto(EdgeUid euid, bool nearest = false)\r\n```\r\nGo to the edge specified by euid. If the specified edge cannot be found and nearest==true, then try to get the next in-coming edge to the vertex euid.dst, sorted by (label, tid, src, eid). If there is no such edge, iterator is invalidated and false is returned.  // 转到由 euid 指定的边。如果无法找到指定的边且 nearest==true，则尝试获取到顶点 euid.dst 的下一个入边，按 (label, tid, src, eid) 排序。如果没有这样的边，迭代器变为无效并返回 false。\n\n该片段位于关于 `InEdgeIterator` 类的文档中，该类用于遍历图中的入边。片段详细描述了关闭迭代器和移动到下一个入边的操作，包括异常抛出情况和函数返回值的说明。"
            },
            {
                "content": "```cpp\r\nbool Goto(EdgeUid euid, bool nearest = false)\r\n```\r\nGo to the edge specified by euid. If the specified edge cannot be found and nearest==true, then try to get the next in-coming edge to the vertex euid.dst, sorted by (label, tid, src, eid). If there is no such edge, iterator is invalidated and false is returned.  // 转到由 euid 指定的边。如果无法找到指定的边且 nearest==true，则尝试获取到顶点 euid.dst 的下一个入边，按 (label, tid, src, eid) 排序。如果没有这样的边，迭代器变为无效并返回 false。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**参数**\r\n- euid – Edge Unique Id.  // 边的唯一 ID。\r\n- nearest – (Optional) True to get the nearest edge if the specified one cannot be found.  // （可选）如果未找到指定的边，则为真以获取最近的边。\r\n\r\n**返回**\r\nTrue if it succeeds, false if it fails.  // 如果成功则返回 true，失败则返回 false。\r\n\r\n```cpp\r\nEdgeUid GetUid() const\r\n```\r\nGets the Edge Unique Id.  // 获取边的唯一 ID。\r\n\r\n**抛出**\n\n该代码块位于文档中关于 `InEdgeIterator` 和 `OutEdgeIterator` 类的部分，这些类用于迭代图数据库中的入边和出边。具体来说，这块代码描述了 `Goto` 方法，该方法用于在图中定位指定的边，并介绍了其参数、返回值及可能抛出的异常。这些信息对于理解如何通过迭代器访问和操作图中的边非常重要。"
            },
            {
                "content": "InvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**参数**\r\n- euid – Edge Unique Id.  // 边的唯一 ID。\r\n- nearest – (Optional) True to get the nearest edge if the specified one cannot be found.  // （可选）如果未找到指定的边，则为真以获取最近的边。\r\n\r\n**返回**\r\nTrue if it succeeds, false if it fails.  // 如果成功则返回 true，失败则返回 false。\r\n\r\n```cpp\r\nEdgeUid GetUid() const\r\n```\r\nGets the Edge Unique Id.  // 获取边的唯一 ID。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe UID.  // 返回 UID。\r\n\r\n```cpp\r\nint64_t GetSrc() const\r\n```\r\nGets the source vertex id.  // 获取源顶点 ID。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe source vertex id.  // 返回源顶点 ID。\n\n该块内容位于文档的“lgraph_txn”类部分，详细描述了事务和迭代器的状态检查，包括抛出异常的条件以及获取边唯一 ID 和源顶点 ID 的方法。这些函数确保在事务操作中保持有效性和一致性，从而保证图数据库的稳定运行。"
            },
            {
                "content": "InvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe UID.  // 返回 UID。\r\n\r\n```cpp\r\nint64_t GetSrc() const\r\n```\r\nGets the source vertex id.  // 获取源顶点 ID。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe source vertex id.  // 返回源顶点 ID。\r\n\r\n```cpp\r\nint64_t GetDst() const\r\n```\r\nGets destination vertex id.  // 获取目标顶点 ID。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe destination vertex id.  // 返回目标顶点 ID。\r\n\r\n```cpp\r\nint64_t GetEdgeId() const\r\n```\r\nGets edge id.  // 获取边 ID。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\n\n该块内容位于文档中与`lgraph_txn`（事务）相关的部分，描述了事务的相关错误处理和返回值。具体内容涵盖了当事务或迭代器无效时抛出的异常类型以及如何获取源和目标顶点的ID等操作的方法。这些细节帮助用户了解如何在操作图形数据库时处理常见的错误情况。"
            },
            {
                "content": "The source vertex id.  // 返回源顶点 ID。\r\n\r\n```cpp\r\nint64_t GetDst() const\r\n```\r\nGets destination vertex id.  // 获取目标顶点 ID。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe destination vertex id.  // 返回目标顶点 ID。\r\n\r\n```cpp\r\nint64_t GetEdgeId() const\r\n```\r\nGets edge id.  // 获取边 ID。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe edge id.  // 返回边 ID。\r\n\r\n```cpp\r\nint64_t GetTemporalId() const\r\n```\r\nGets temporal id.  // 获取时间 ID。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe temporal id.  // 返回时间 ID。\r\n\r\n```cpp\r\nbool IsValid() const\r\n```\r\nQuery if this iterator is valid.  // 查询此迭代器是否有效。\n\n该内容片段位于文档的“lgraph_vertex_iterator”部分，描述了与图数据库中的顶点和边相关的操作，包括获取源顶点ID、目标顶点ID、边ID和时间ID的函数。它还提到在事务无效或迭代器无效时可能抛出的异常，以及这些函数的返回值。"
            },
            {
                "content": "InvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe edge id.  // 返回边 ID。\r\n\r\n```cpp\r\nint64_t GetTemporalId() const\r\n```\r\nGets temporal id.  // 获取时间 ID。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe temporal id.  // 返回时间 ID。\r\n\r\n```cpp\r\nbool IsValid() const\r\n```\r\nQuery if this iterator is valid.  // 查询此迭代器是否有效。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nTrue if valid, false if not.  // 如果有效则返回 true，如果无效则返回 false。\r\n\r\n```cpp\r\nconst std::string &GetLabel() const\r\n```\r\nGets the label of this edge.  // 获取该边的标签。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\n\n该块内容位于文档中的 `VertexIterator` 类部分，描述了与迭代器操作相关的异常处理和返回值，包括无效迭代器抛出的异常、获取边的时间 ID 和查询迭代器有效性的方法。这些信息对于理解图形数据库中如何使用迭代器进行遍历和数据访问至关重要。"
            },
            {
                "content": "```\r\nQuery if this iterator is valid.  // 查询此迭代器是否有效。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nTrue if valid, false if not.  // 如果有效则返回 true，如果无效则返回 false。\r\n\r\n```cpp\r\nconst std::string &GetLabel() const\r\n```\r\nGets the label of this edge.  // 获取该边的标签。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe label.  // 返回标签。\r\n\r\n```cpp\r\nint16_t GetLabelId() const\r\n```\r\nGets label id of this edge.  // 获取该边的标签 ID。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe label identifier.  // 返回标签标识符。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_names) const\r\n```\n\n该代码块位于文档的“lgraph_vertex_iterator”类部分，描述了VertexIterator类中的函数，包括查询迭代器有效性、获取边标签及其标签ID的相关操作和异常处理。这一部分主要关注如何利用VertexIterator访问和处理图中边的属性。"
            },
            {
                "content": "InvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe label.  // 返回标签。\r\n\r\n```cpp\r\nint16_t GetLabelId() const\r\n```\r\nGets label id of this edge.  // 获取该边的标签 ID。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\n**返回**\r\nThe label identifier.  // 返回标签标识符。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_names) const\r\n```\r\nGets the fields specified.  // 获取指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if any field does not exist.  // 如果任何字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_names – List of names of the fields.  // 字段名称的列表。\r\n\r\n**返回**\r\nThe fields.  // 返回字段。\r\n\r\n```cpp\r\nFieldData GetField(const std::string &field_name) const\r\n```\r\nGets the field specified.  // 获取指定的字段。\n\n该片段位于文档中关于`VertexIterator`类的部分，描述了该类的成员函数，包括获取边的标签ID、检查迭代器有效性及获取指定字段等功能。此类用于遍历图数据库中的顶点，通过这些函数，用户可以控制和访问顶点的相关属性和信息。"
            },
            {
                "content": "**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if any field does not exist.  // 如果任何字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_names – List of names of the fields.  // 字段名称的列表。\r\n\r\n**返回**\r\nThe fields.  // 返回字段。\r\n\r\n```cpp\r\nFieldData GetField(const std::string &field_name) const\r\n```\r\nGets the field specified.  // 获取指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if field does not exist.  // 如果字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_name – Field name.  // 字段名称。\r\n\r\n**返回**\r\nField value.  // 返回字段值。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_ids) const\r\n```\r\nGets the fields specified.  // 获取指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\n\n该块内容位于文档中的 `lgraph_vertex_iterator` 类部分，详细描述了迭代器在事务无效和当前迭代器无效时可能抛出的异常，以及获取字段的相关方法，包括参数和返回值的说明。这有助于读者理解如何在迭代器操作中正确处理异常以及如何访问特定字段。"
            },
            {
                "content": "InvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if field does not exist.  // 如果字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_name – Field name.  // 字段名称。\r\n\r\n**返回**\r\nField value.  // 返回字段值。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_ids) const\r\n```\r\nGets the fields specified.  // 获取指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if any field does not exist.  // 如果任何字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_ids – List of ids for the fields.  // 字段 ID 的列表。\r\n\r\n**返回**\r\nThe fields.  // 返回字段。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_ids) const\r\n```\r\nGets the fields specified.  // 获取指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\n\n该块内容位于文档中 `lgraph_vertex_iterator` 类的描述部分，重点讲述了在使用迭代器时可能引发的异常及其参数和返回值的相关信息，具体涉及 `GetField` 和 `GetFields` 方法的异常处理、参数定义和返回结果。"
            },
            {
                "content": "InputError – Thrown if any field does not exist.  // 如果任何字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_ids – List of ids for the fields.  // 字段 ID 的列表。\r\n\r\n**返回**\r\nThe fields.  // 返回字段。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_ids) const\r\n```\r\nGets the fields specified.  // 获取指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if any field does not exist.  // 如果任何字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_ids – List of ids for the fields.  // 字段 ID 的列表。\r\n\r\n**返回**\r\nThe fields.  // 返回字段。\r\n\r\n```cpp\r\nFieldData GetField(size_t field_id) const\r\n```\r\nGets the field specified.  // 获取指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if field does not exist.  // 如果字段不存在，则抛出 InputError。\r\n\r\n**参数**\n\n该块内容位于文档的`lgraph_types`部分，主要描述了`FieldData`类的相关函数及其异常处理，包括如何获取指定字段、错误抛出情况以及相应的参数和返回值。此部分与图数据库中的字段操作和数据处理密切相关。"
            },
            {
                "content": "**参数**\r\nfield_ids – List of ids for the fields.  // 字段 ID 的列表。\r\n\r\n**返回**\r\nThe fields.  // 返回字段。\r\n\r\n```cpp\r\nFieldData GetField(size_t field_id) const\r\n```\r\nGets the field specified.  // 获取指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if field does not exist.  // 如果字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_id – Field ID.  // 字段 ID。\r\n\r\n**返回**\r\nField value.  // 返回字段值。\r\n\r\n```cpp\r\ninline FieldData operator[](const std::string &field_name) const\r\n```\r\nGet field identified by field_name.  // 获取由字段名标识的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if field does not exist.  // 如果字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_name – Filename of the file.  // 文件名。\r\n\r\n**返回**\r\nThe indexed value.  // 返回索引值。\r\n\r\n```cpp\n\n该块内容位于文档中关于\"Lgraph Vertex Iterator\"的部分，描述了如何获取指定字段的方法及其相关参数、返回值和可能抛出的异常。它是对图形数据库中顶点字段访问的详细说明。"
            },
            {
                "content": "```cpp\r\ninline FieldData operator[](const std::string &field_name) const\r\n```\r\nGet field identified by field_name.  // 获取由字段名标识的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if field does not exist.  // 如果字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_name – Filename of the file.  // 文件名。\r\n\r\n**返回**\r\nThe indexed value.  // 返回索引值。\r\n\r\n```cpp\r\ninline FieldData operator[](size_t fid) const\r\n```\r\nGet field identified by field id.  // 获取由字段 ID 标识的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if field does not exist.  // 如果字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfid – The field id.  // 字段 ID。\r\n\r\n**返回**\r\nThe indexed value.  // 返回索引值。\r\n\r\n```cpp\r\nstd::map GetAllFields() const\r\n```\n\n该代码块位于文档中的 `FieldData` 结构部分，主要描述了通过字段名和字段 ID 获取相应字段值的操作，以及相关的异常处理。此部分属于 `lgraph_types` 命名空间，涉及类型定义和操作，通常用于图数据库的字段处理。"
            },
            {
                "content": "```cpp\r\ninline FieldData operator[](size_t fid) const\r\n```\r\nGet field identified by field id.  // 获取由字段 ID 标识的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if field does not exist.  // 如果字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfid – The field id.  // 字段 ID。\r\n\r\n**返回**\r\nThe indexed value.  // 返回索引值。\r\n\r\n```cpp\r\nstd::map GetAllFields() const\r\n```\r\nGets all fields of current vertex.  // 获取当前顶点的所有字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if any field does not exist.  // 如果任何字段不存在，则抛出 InputError。\r\n\r\n**返回**\r\nAll field names and values stored as a {(field_name, field_value),…} map.  // 返回以 {(字段名, 字段值), …} 存储的所有字段名和值的映射。\r\n\r\n```cpp\r\nvoid SetField(const std::string &field_name, const FieldData &field_value)\n\n该代码块位于文档的`lgraph_types`部分，主要描述了`FieldData`类的操作，包括通过字段 ID 获取字段的索引值、获取当前顶点的所有字段以及设置字段的功能。这些函数涉及到图数据库操作时的事务管理和字段数据处理。"
            },
            {
                "content": "**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nInputError – Thrown if any field does not exist.  // 如果任何字段不存在，则抛出 InputError。\r\n\r\n**返回**\r\nAll field names and values stored as a {(field_name, field_value),…} map.  // 返回以 {(字段名, 字段值), …} 存储的所有字段名和值的映射。\r\n\r\n```cpp\r\nvoid SetField(const std::string &field_name, const FieldData &field_value)\r\n```\r\nSets the specified field.  // 设置指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nWriteNotAllowed – Thrown if called inside a read-only transaction.  // 如果在只读事务中调用，则抛出 WriteNotAllowed。\r\n\r\nInputError – Thrown if any field does not exist.  // 如果任何字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_name – Field name.  // 字段名。\r\n\r\nfield_value – Field value.  // 字段值。\r\n\r\n```cpp\n\n该区块位于文档中的 `lgraph_vertex_iterator` 类部分，描述了用于迭代数据库中顶点的函数及其相关的异常处理和返回值。这些函数包括设置顶点字段的方法，并列出了可能抛出的异常情况。"
            },
            {
                "content": "```\r\nSets the specified field.  // 设置指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nWriteNotAllowed – Thrown if called inside a read-only transaction.  // 如果在只读事务中调用，则抛出 WriteNotAllowed。\r\n\r\nInputError – Thrown if any field does not exist.  // 如果任何字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_name – Field name.  // 字段名。\r\n\r\nfield_value – Field value.  // 字段值。\r\n\r\n```cpp\r\nvoid SetField(size_t field_id, const FieldData &field_value)\r\n```\r\nSets the specified field.  // 设置指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nWriteNotAllowed – Thrown if called inside a read-only transaction.  // 如果在只读事务中调用，则抛出 WriteNotAllowed。\r\n\r\nInputError – Thrown if field does not exist.  // 如果字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_id – Field id.  // 字段 ID。\n\n该块内容出现在文档中关于使用 `Transaction` 类的部分，主要介绍了如何设置指定字段的方法 `SetField`，包括函数的声明、参数说明以及可能抛出的异常。这段内容帮助用户了解在进行图数据库操作时，如何正确地设置字段值并处理相关错误。"
            },
            {
                "content": "void SetField(size_t field_id, const FieldData &field_value)\r\n```\r\nSets the specified field.  // 设置指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nWriteNotAllowed – Thrown if called inside a read-only transaction.  // 如果在只读事务中调用，则抛出 WriteNotAllowed。\r\n\r\nInputError – Thrown if field does not exist.  // 如果字段不存在，则抛出 InputError。\r\n\r\n**参数**\r\nfield_id – Field id.  // 字段 ID。\r\n\r\nfield_value – Field value.  // 字段值。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_names, const std::vector &field_value_strings)\r\n```\r\nSets the fields specified.  // 设置指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nWriteNotAllowed – Thrown if called inside a read-only transaction.  // 如果在只读事务中调用，则抛出 WriteNotAllowed。\n\n该代码段位于lgraph库的lgraph_txn模块中，主要描述了如何设置字段的值。包括两个函数：`SetField`用于设置指定字段的值，以及`SetFields`用于同时设置多个字段的值。在函数说明中，详细列出了可能抛出的异常和参数说明，以帮助用户理解在进行图事务操作时如何正确使用这些函数。"
            },
            {
                "content": "**参数**\r\nfield_id – Field id.  // 字段 ID。\r\n\r\nfield_value – Field value.  // 字段值。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_names, const std::vector &field_value_strings)\r\n```\r\nSets the fields specified.  // 设置指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nWriteNotAllowed – Thrown if called inside a read-only transaction.  // 如果在只读事务中调用，则抛出 WriteNotAllowed。\r\n\r\nInputError – Thrown if any field does not exist or field value type is incorrect.  // 如果任何字段不存在或字段值类型不正确，则抛出 InputError。\r\n\r\n**参数**\r\nfield_names – List of names of the fields.  // 字段名称的列表。\r\n\r\nfield_value_strings – The field value strings.  // 字段值字符串。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_names, const std::vector &field_values)\r\n```\r\nSets the fields specified.  // 设置指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\n\n该块内容位于文档的“lgraph_types”部分，具体描述了如何设置字段及其相关的异常处理和参数说明，适用于在事务和迭代器上下文中操作字段数据的函数。"
            },
            {
                "content": "InputError – Thrown if any field does not exist or field value type is incorrect.  // 如果任何字段不存在或字段值类型不正确，则抛出 InputError。\r\n\r\n**参数**\r\nfield_names – List of names of the fields.  // 字段名称的列表。\r\n\r\nfield_value_strings – The field value strings.  // 字段值字符串。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_names, const std::vector &field_values)\r\n```\r\nSets the fields specified.  // 设置指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nWriteNotAllowed – Thrown if called inside a read-only transaction.  // 如果在只读事务中调用，则抛出 WriteNotAllowed。\r\n\r\nInputError – Thrown if any field does not exist or field value type is incorrect.  // 如果任何字段不存在或字段值类型不正确，则抛出 InputError。\r\n\r\n**参数**\r\nfield_names – List of names of the fields.  // 字段名称的列表。\r\n\r\nfield_values – The field values.  // 字段值。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_ids, const std::vector &field_values)\r\n```\n\n该块内容位于文档中关于 `lgraph_types` 命名空间的部分，具体描述了字段设置相关的函数 `SetFields` 的参数和异常抛出信息。此部分重点在于如何设置字段及其相关的错误处理，适合用于图数据库中对字段类型和存在性进行验证的场景。"
            },
            {
                "content": "WriteNotAllowed – Thrown if called inside a read-only transaction.  // 如果在只读事务中调用，则抛出 WriteNotAllowed。\r\n\r\nInputError – Thrown if any field does not exist or field value type is incorrect.  // 如果任何字段不存在或字段值类型不正确，则抛出 InputError。\r\n\r\n**参数**\r\nfield_names – List of names of the fields.  // 字段名称的列表。\r\n\r\nfield_values – The field values.  // 字段值。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_ids, const std::vector &field_values)\r\n```\r\nSets the fields specified.  // 设置指定的字段。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nWriteNotAllowed – Thrown if called inside a read-only transaction.  // 如果在只读事务中调用，则抛出 WriteNotAllowed。\r\n\r\nInputError – Thrown if any field does not exist or field value type is incorrect.  // 如果任何字段不存在或字段值类型不正确，则抛出 InputError。\r\n\r\n**参数**\r\nfield_ids – List of identifiers for the fields.  // 字段的标识符列表。\r\n\r\nfield_values – The field values.  // 字段值。\r\n\r\n```cpp\n\n该块内容位于文档中的 `lgraph_txn` 部分，描述了事务中字段设置的方法 `SetFields`，包括参数说明和异常情况处理。该方法用于在事务中设置指定字段的值，确保在读写操作中对字段的有效性和类型进行检查。"
            },
            {
                "content": "InvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nWriteNotAllowed – Thrown if called inside a read-only transaction.  // 如果在只读事务中调用，则抛出 WriteNotAllowed。\r\n\r\nInputError – Thrown if any field does not exist or field value type is incorrect.  // 如果任何字段不存在或字段值类型不正确，则抛出 InputError。\r\n\r\n**参数**\r\nfield_ids – List of identifiers for the fields.  // 字段的标识符列表。\r\n\r\nfield_values – The field values.  // 字段值。\r\n\r\n```cpp\r\nvoid Delete()\r\n```\r\nDeletes this edge. The iterator will point to the next incoming edge sorted by (lid, tid, src, eid) if there is any. If no in-coming edge is left for this vertex, the iterator becomes invalid.  // 删除这条边。如果有任何边，这个迭代器将指向下一个按 (lid, tid, src, eid) 排序的入边。如果此顶点没有剩余的入边，迭代器将变为无效。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\n\n该代码块位于文档中有关 `VertexIterator` 类的章节中，描述了在操作无效迭代器和只读事务中的异常抛出情况，并详细说明了 `Delete()` 方法的功能和异常处理。这部分主要涵盖了迭代器的状态检查及其在图数据库操作中的有效性管理。"
            },
            {
                "content": "```cpp\r\nvoid Delete()\r\n```\r\nDeletes this edge. The iterator will point to the next incoming edge sorted by (lid, tid, src, eid) if there is any. If no in-coming edge is left for this vertex, the iterator becomes invalid.  // 删除这条边。如果有任何边，这个迭代器将指向下一个按 (lid, tid, src, eid) 排序的入边。如果此顶点没有剩余的入边，迭代器将变为无效。\r\n\r\n**抛出**\r\nInvalidTxn – Thrown if the transaction is invalid.  // 如果事务无效，则抛出 InvalidTxn。\r\n\r\nInvalidIterator – Thrown if the iterator is invalid.  // 如果迭代器无效，则抛出 InvalidIterator。\r\n\r\nWriteNotAllowed – Thrown if called inside a read-only transaction.  // 如果在只读事务中调用，则抛出 WriteNotAllowed。\r\n\r\n```cpp\r\nstd::string ToString() const\r\n```\r\nGet string representation of the edge.  // 获取边的字符串表示。\r\n\r\n### Private Functions\r\n\r\n```cpp\r\nInEdgeIterator(lgraph::graph::InEdgeIterator&&, const std::shared_ptr&)\r\n```\r\nConstructors are private; use `Transaction::GetInEdgeIterator()` or `VertexIterator::GetInEdgeIterator()` instead.  \r\n构造函数是私有的；请使用 `Transaction::GetInEdgeIterator()` 或 `VertexIterator::GetInEdgeIterator()` 代替。\r\n\r\n```cpp\n\n该块内容位于文档中涉及图形数据库操作的部分，特别是关于遍历图的边和顶点的迭代器功能。主要描述了如何删除一条边及相关的异常处理机制，同时提供获取边的字符串表示的方法。这些操作属于`InEdgeIterator`和`OutEdgeIterator`类的成员函数，因此在图分析和操作中具有重要意义。"
            },
            {
                "content": "```cpp\r\nstd::string ToString() const\r\n```\r\nGet string representation of the edge.  // 获取边的字符串表示。\r\n\r\n### Private Functions\r\n\r\n```cpp\r\nInEdgeIterator(lgraph::graph::InEdgeIterator&&, const std::shared_ptr&)\r\n```\r\nConstructors are private; use `Transaction::GetInEdgeIterator()` or `VertexIterator::GetInEdgeIterator()` instead.  \r\n构造函数是私有的；请使用 `Transaction::GetInEdgeIterator()` 或 `VertexIterator::GetInEdgeIterator()` 代替。\r\n\r\n```cpp\r\nInEdgeIterator(const InEdgeIterator&) = delete\r\n```\r\nDeleted copy constructor.  \r\n删除拷贝构造函数。\r\n\r\n```cpp\r\nInEdgeIterator &operator=(const InEdgeIterator&) = delete\r\n```\r\nDeleted copy assignment operator.  \r\n删除拷贝赋值运算符。\r\n\r\n#### Private Members\r\n\r\n```cpp\r\nstd::unique_ptr it_\r\n```\r\nUnique pointer to an InEdgeIterator.  \r\n指向 InEdgeIterator 的唯一指针。\r\n\r\n```cpp\r\nstd::shared_ptr txn_\r\n```\r\nShared pointer to a Transaction.  \r\n指向 Transaction 的共享指针。\r\n\r\n#### Friends\r\n\r\n```cpp\r\nfriend class Transaction\r\n```\r\nFriend class declaration for Transaction.  \r\nTransaction 的友元类声明。\r\n\r\n```cpp\n\n该代码块涉及`InEdgeIterator`类，该类用于遍历图中的入边。文档中包含了该类的公共和私有函数，以及与其相关的构造函数、拷贝构造函数及赋值运算符的声明。同时还提到该类的私有成员和友元类声明，适用于与图数据库事务交互的场景。"
            },
            {
                "content": "删除拷贝构造函数。\r\n\r\n```cpp\r\nInEdgeIterator &operator=(const InEdgeIterator&) = delete\r\n```\r\nDeleted copy assignment operator.  \r\n删除拷贝赋值运算符。\r\n\r\n#### Private Members\r\n\r\n```cpp\r\nstd::unique_ptr it_\r\n```\r\nUnique pointer to an InEdgeIterator.  \r\n指向 InEdgeIterator 的唯一指针。\r\n\r\n```cpp\r\nstd::shared_ptr txn_\r\n```\r\nShared pointer to a Transaction.  \r\n指向 Transaction 的共享指针。\r\n\r\n#### Friends\r\n\r\n```cpp\r\nfriend class Transaction\r\n```\r\nFriend class declaration for Transaction.  \r\nTransaction 的友元类声明。\r\n\r\n```cpp\r\nfriend class VertexIterator\r\n```\r\nFriend class declaration for VertexIterator.  \r\nVertexIterator 的友元类声明。\r\n\r\n### Class OutEdgeIterator\r\n\r\n```cpp\r\n#include \r\n```\r\n\r\nAn `OutEdgeIterator` can be used to iterate through the outgoing edges of a vertex. Edges are sorted in the order of (lid, dst, eid), and each (src, lid, tid, dst, eid) tuple uniquely identifies an edge.  \r\n`OutEdgeIterator` 可以用于遍历一个顶点的出边。边按 (lid, dst, eid) 的顺序排序，每个 (src, lid, tid, dst, eid) 元组唯一标识一条边。\n\n该块内容摘录自文档的 \"lgraph_vertex_iterator\" 部分，具体描述了 `InEdgeIterator` 类的构造函数和成员函数，以及该类的私有成员和友元类声明。随后，它引入了 `OutEdgeIterator` 类，阐述了如何使用该类遍历一个顶点的出边。"
            },
            {
                "content": "Transaction 的友元类声明。\r\n\r\n```cpp\r\nfriend class VertexIterator\r\n```\r\nFriend class declaration for VertexIterator.  \r\nVertexIterator 的友元类声明。\r\n\r\n### Class OutEdgeIterator\r\n\r\n```cpp\r\n#include \r\n```\r\n\r\nAn `OutEdgeIterator` can be used to iterate through the outgoing edges of a vertex. Edges are sorted in the order of (lid, dst, eid), and each (src, lid, tid, dst, eid) tuple uniquely identifies an edge.  \r\n`OutEdgeIterator` 可以用于遍历一个顶点的出边。边按 (lid, dst, eid) 的顺序排序，每个 (src, lid, tid, dst, eid) 元组唯一标识一条边。\r\n\r\nAn `OutEdgeIterator` is valid if it points to a valid outgoing edge; otherwise, it is invalid. Calling member functions on an invalid `OutEdgeIterator` throws an `InvalidIterator`, except for the `IsValid()` and `Goto()` functions.  \r\n如果 `OutEdgeIterator` 指向有效的出边，则它是有效的；否则，它是无效的。在无效的 `OutEdgeIterator` 上调用成员函数会抛出 `InvalidIterator`， `IsValid()` 和 `Goto()` 函数除外。\r\n\r\nThe following operations invalidate an `OutEdgeIterator`:\r\n- Constructing an `OutEdgeIterator` for a non-existing edge.  \r\n- 为不存在的边构造 `OutEdgeIterator`。\n\n在整个文档中，该块位于介绍`Transaction`类的背景下，具体讨论了`Transaction`类的友元类声明，特别是与`VertexIterator`和`OutEdgeIterator`类相关的功能和行为。该块阐述了`OutEdgeIterator`的用途以及在遍历顶点的出边时的有效性和无效性处理。"
            },
            {
                "content": "如果 `OutEdgeIterator` 指向有效的出边，则它是有效的；否则，它是无效的。在无效的 `OutEdgeIterator` 上调用成员函数会抛出 `InvalidIterator`， `IsValid()` 和 `Goto()` 函数除外。\r\n\r\nThe following operations invalidate an `OutEdgeIterator`:\r\n- Constructing an `OutEdgeIterator` for a non-existing edge.  \r\n- 为不存在的边构造 `OutEdgeIterator`。\r\n- Calling `Goto()` with the id of a non-existing edge.  \r\n- 使用不存在边的 ID 调用 `Goto()`。\r\n- Calling `Next()` on the last outgoing edge.  \r\n- 在最后一条出边上调用 `Next()`。\r\n- Calling `Delete()` on the last outgoing edge.  \r\n- 在最后一条出边上调用 `Delete()`。\r\n- Calling `Close()` on the iterator.  \r\n- 在迭代器上调用 `Close()`。\r\n\r\nIn TuGraph, every iterator belongs to a transaction and can only be used when the transaction is valid. Calling member functions on an iterator inside an invalid transaction yields `InvalidTxn`, except for `Invalid()`.  \r\n在 TuGraph 中，每个迭代器属于一个事务，并且只能在事务有效时使用。在无效事务中的迭代器上调用成员函数会导致 `InvalidTxn`， `Invalid()` 除外。\r\n\r\n#### Public Functions\r\n\r\n```cpp\r\nOutEdgeIterator(OutEdgeIterator &&rhs)\r\n```\r\nMove constructor.  \r\n移动构造函数。\r\n\r\n```cpp\n\n该段落位于文档的 \"lgraph_vertex_iterator\" 类部分，详细描述了 `OutEdgeIterator` 的有效性规则及其失效操作，强调了与事务的关系以及在无效状态下调用成员函数所引发的异常。这有助于理解图遍历过程中出边迭代器的正确使用方式。"
            },
            {
                "content": "- Calling `Close()` on the iterator.  \r\n- 在迭代器上调用 `Close()`。\r\n\r\nIn TuGraph, every iterator belongs to a transaction and can only be used when the transaction is valid. Calling member functions on an iterator inside an invalid transaction yields `InvalidTxn`, except for `Invalid()`.  \r\n在 TuGraph 中，每个迭代器属于一个事务，并且只能在事务有效时使用。在无效事务中的迭代器上调用成员函数会导致 `InvalidTxn`， `Invalid()` 除外。\r\n\r\n#### Public Functions\r\n\r\n```cpp\r\nOutEdgeIterator(OutEdgeIterator &&rhs)\r\n```\r\nMove constructor.  \r\n移动构造函数。\r\n\r\n```cpp\r\nOutEdgeIterator &operator=(OutEdgeIterator &&rhs)\r\n```\r\nMove assignment operator.  \r\n移动赋值运算符。\r\n\r\n```cpp\r\n~OutEdgeIterator()\r\n```\r\nDestructor.  \r\n析构函数。\r\n\r\n```cpp\r\nvoid Close() noexcept\r\n```\r\nCloses this iterator. The iterator turns invalid after being closed.  \r\n关闭此迭代器。迭代器在关闭后变为无效。\r\n\r\n```cpp\r\nbool Goto(EdgeUid euid, bool nearest = false)\r\n```\n\n此块内容位于文档中的 `lgraph_vertex_iterator` 类部分，主要描述了在迭代器上调用 `Close()` 方法以及事务有效性对迭代器操作的影响。它包括 `OutEdgeIterator` 的公共函数定义，尤其强调了移动构造函数、移动赋值运算符和关闭迭代器时的行为。"
            },
            {
                "content": "#### Public Functions\r\n\r\n```cpp\r\nOutEdgeIterator(OutEdgeIterator &&rhs)\r\n```\r\nMove constructor.  \r\n移动构造函数。\r\n\r\n```cpp\r\nOutEdgeIterator &operator=(OutEdgeIterator &&rhs)\r\n```\r\nMove assignment operator.  \r\n移动赋值运算符。\r\n\r\n```cpp\r\n~OutEdgeIterator()\r\n```\r\nDestructor.  \r\n析构函数。\r\n\r\n```cpp\r\nvoid Close() noexcept\r\n```\r\nCloses this iterator. The iterator turns invalid after being closed.  \r\n关闭此迭代器。迭代器在关闭后变为无效。\r\n\r\n```cpp\r\nbool Goto(EdgeUid euid, bool nearest = false)\r\n```\r\nGo to the edge specified by `euid`. If `nearest == true` and the exact edge was not found, the iterator tries to get the next edge that sorts after the specified edge. The edges are sorted in (label, tid, dst, eid) order. The iterator becomes invalid if there is no outgoing edge from `euid.src` that sorts after `euid`.  \r\n转到由 `euid` 指定的边。如果 `nearest == true` 并且未找到确切的边，则迭代器尝试获取在指定边后排序的下一条边。边按 (label, tid, dst, eid) 顺序排序。如果从 `euid.src` 没有排在 `euid` 后面的出边，则迭代器变为无效。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.\n\n该代码片段位于文档中 `lgraph_edge_iterator` 类的部分，描述了该类中与出边迭代器相关的公共函数，包括构造函数、析构函数、移动赋值运算符以及关闭和跳转到指定边的功能。文档整体涉及TuGraph数据库的各种操作和图分析功能，其中 `lgraph_edge_iterator` 用于遍历图中的边，允许对边的操作进行高效的迭代。"
            },
            {
                "content": "转到由 `euid` 指定的边。如果 `nearest == true` 并且未找到确切的边，则迭代器尝试获取在指定边后排序的下一条边。边按 (label, tid, dst, eid) 顺序排序。如果从 `euid.src` 没有排在 `euid` 后面的出边，则迭代器变为无效。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。\r\n\r\n**参数**  \r\n- `euid` – Edge Unique ID.  \r\n  边的唯一 ID。\r\n- `nearest` – (Optional) True to get the nearest edge if the specified one cannot be found.  \r\n  （可选）如果找不到指定的边，则为 true 以获取最近的边。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if there is no such edge.  \r\n成功则返回 true，如果没有这样的边则返回 false。\r\n\r\n```cpp\r\nbool IsValid() const noexcept\r\n```\r\nQuery if this iterator is valid.  \r\n查询此迭代器是否有效。\r\n\r\n**返回**  \r\nTrue if valid, false if not.  \r\n有效则返回 true，无效则返回 false。\r\n\r\n```cpp\r\nbool Next()\r\n```\r\nMove to the next edge. Invalidates iterator if there are no more outgoing edges from the current source vertex.  \r\n移动到下一条边。如果当前源顶点没有更多的出边，则使迭代器无效。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.\n\n该块内容位于文档的 `lgraph_vertex_iterator` 类部分，具体描述了如何通过 `VertexIterator` 类访问和操作边的信息。内容涉及边的迭代器有效性检查、迭代到指定边的操作以及获取当前边信息的相关函数。"
            },
            {
                "content": "```cpp\r\nbool IsValid() const noexcept\r\n```\r\nQuery if this iterator is valid.  \r\n查询此迭代器是否有效。\r\n\r\n**返回**  \r\nTrue if valid, false if not.  \r\n有效则返回 true，无效则返回 false。\r\n\r\n```cpp\r\nbool Next()\r\n```\r\nMove to the next edge. Invalidates iterator if there are no more outgoing edges from the current source vertex.  \r\n移动到下一条边。如果当前源顶点没有更多的出边，则使迭代器无效。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nTrue if it succeeds, false if it fails (no more out edges from current source).  \r\n成功则返回 true，如果失败（当前源没有更多出边）则返回 false。\r\n\r\n```cpp\r\nEdgeUid GetUid() const\r\n```\r\nGets the Edge Unique Id.  \r\n获取边的唯一 ID。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe UID.  \r\n唯一 ID。\r\n\r\n```cpp\r\nint64_t GetDst() const\r\n```\r\nGets the destination of the edge.  \r\n获取边的目的地。\n\n该代码块位于文档中关于`VertexIterator`类的部分，主要描述如何查询当前迭代器的有效性、移动到下一条边、获取边的唯一ID，以及获取边的目的顶点。它提供了对边迭代器操作的细节，包括可能抛出的异常和返回值说明，适用于图数据库的遍历和操作。"
            },
            {
                "content": "**返回**  \r\nTrue if it succeeds, false if it fails (no more out edges from current source).  \r\n成功则返回 true，如果失败（当前源没有更多出边）则返回 false。\r\n\r\n```cpp\r\nEdgeUid GetUid() const\r\n```\r\nGets the Edge Unique Id.  \r\n获取边的唯一 ID。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe UID.  \r\n唯一 ID。\r\n\r\n```cpp\r\nint64_t GetDst() const\r\n```\r\nGets the destination of the edge.  \r\n获取边的目的地。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe destination vertex id.  \r\n目的地顶点 ID。\r\n\r\n```cpp\r\nint64_t GetEdgeId() const\r\n```\r\nGets the edge id.  \r\n获取边的 ID。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe edge identifier.\n\n该代码块位于描述边迭代器（`OutEdgeIterator`）的部分，包含获取边的唯一 ID、目的地顶点 ID 和边 ID 的函数，以及相关的异常处理和返回值说明。这部分内容用于帮助开发者理解如何操作边及其属性。"
            },
            {
                "content": "**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe destination vertex id.  \r\n目的地顶点 ID。\r\n\r\n```cpp\r\nint64_t GetEdgeId() const\r\n```\r\nGets the edge id.  \r\n获取边的 ID。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe edge identifier.  \r\n边的标识符。\r\n\r\n```cpp\r\nint64_t GetTemporalId() const\r\n```\r\nGets the primary id.  \r\n获取主 ID。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe primary id of the edge.  \r\n边的主 ID。\r\n\r\n```cpp\r\nint64_t GetSrc() const\r\n```\r\nGets the source vertex id.  \r\n获取源顶点 ID。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。\n\n该块内容位于文档中关于`VertexIterator`类的部分，详细描述了该类中用于获取边信息的公有函数，包括获取边ID、主ID以及源顶点ID等，涉及到需要抛出的异常和返回值，适用于图数据库操作中的边遍历和分析。"
            },
            {
                "content": "边的标识符。\r\n\r\n```cpp\r\nint64_t GetTemporalId() const\r\n```\r\nGets the primary id.  \r\n获取主 ID。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe primary id of the edge.  \r\n边的主 ID。\r\n\r\n```cpp\r\nint64_t GetSrc() const\r\n```\r\nGets the source vertex id.  \r\n获取源顶点 ID。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe source vertex id.  \r\n源顶点 ID。\r\n\r\n```cpp\r\nconst std::string &GetLabel() const\r\n```\r\nGets the label of this edge.  \r\n获取该边的标签。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe label.  \r\n标签。\r\n\r\n```cpp\r\nint16_t GetLabelId() const\r\n```\r\nGets the label id of this edge.  \r\n获取该边的标签 ID。\r\n\r\n**抛出**\n\n该代码块位于文档中关于操作边（Edge）对象的部分，具体描述了如何获取边的主 ID、源顶点 ID、边的标签和标签 ID。这些函数抛出异常以处理事务无效或迭代器无效的情况，为用户提供有关边的详细信息和操作方式。这一部分紧密关联于边的操作和管理，适合于需要处理图形结构中边的数据的开发者或用户。"
            },
            {
                "content": "当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe source vertex id.  \r\n源顶点 ID。\r\n\r\n```cpp\r\nconst std::string &GetLabel() const\r\n```\r\nGets the label of this edge.  \r\n获取该边的标签。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe label.  \r\n标签。\r\n\r\n```cpp\r\nint16_t GetLabelId() const\r\n```\r\nGets the label id of this edge.  \r\n获取该边的标签 ID。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe label identifier.  \r\n标签标识符。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_names) const\r\n```\r\nGets the fields specified.  \r\n获取指定的字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\n\n该块内容位于文档的 `lgraph_vertex_iterator` 类部分，主要描述了该类中的公共函数，具体操作与获取边的标签及标签ID，涉及异常处理和返回值。这部分是关于遍历图中边的相关信息，帮助用户理解如何通过迭代器访问边的属性。"
            },
            {
                "content": "**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nThe label identifier.  \r\n标签标识符。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_names) const\r\n```\r\nGets the fields specified.  \r\n获取指定的字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n**参数**  \r\n- `field_names` – List of names of the fields.  \r\n  字段名称列表。\r\n\r\n**返回**  \r\nThe fields.  \r\n字段。\r\n\r\n```cpp\r\nFieldData GetField(const std::string &field_name) const\r\n```\r\nGets the field specified.  \r\n获取指定的字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。\n\n该段落位于文档中描述 `VertexIterator` 类的部分，具体说明了该类中一些公共函数的异常抛出和返回值。包含有关获取指定字段和标签标识符的详细信息，以及在无效事务或迭代器情况下的异常处理。"
            },
            {
                "content": "当当前迭代器无效时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n**参数**  \r\n- `field_names` – List of names of the fields.  \r\n  字段名称列表。\r\n\r\n**返回**  \r\nThe fields.  \r\n字段。\r\n\r\n```cpp\r\nFieldData GetField(const std::string &field_name) const\r\n```\r\nGets the field specified.  \r\n获取指定的字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n**参数**  \r\n- `field_name` – Field name.  \r\n  字段名称。\r\n\r\n**返回**  \r\nField value.  \r\n字段值。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_ids) const\r\n```\r\nGets the fields specified.  // 获取指定的字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。\n\n该段落位于描述`VertexIterator`类的部分，主要介绍了其方法`GetFields`和`GetField`，强调了在无效事务或无效迭代器中调用这些方法时会抛出的异常以及相关参数。这些信息对于理解在图数据库操作中如何安全地访问和操作顶点字段数据至关重要。"
            },
            {
                "content": "当当前迭代器无效时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n**参数**  \r\n- `field_name` – Field name.  \r\n  字段名称。\r\n\r\n**返回**  \r\nField value.  \r\n字段值。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_ids) const\r\n```\r\nGets the fields specified.  // 获取指定的字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_ids` – List of ids for the fields. // 字段的ID列表。\r\n\r\n**返回**  \r\nThe fields. // 字段。\r\n\r\n```cpp\r\nFieldData GetField(size_t field_id) const\r\n```\r\nGets the field specified. // 获取指定字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。\n\n该片段位于文档的“lgraph_vertex_iterator”类部分，主要描述在无效事务或迭代器的情况下，获取指定字段的值时可能抛出的异常及其参数。这部分内容涉及对图数据库中顶点的字段访问和处理，说明了字段操作的异常处理机制。"
            },
            {
                "content": "InputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_ids` – List of ids for the fields. // 字段的ID列表。\r\n\r\n**返回**  \r\nThe fields. // 字段。\r\n\r\n```cpp\r\nFieldData GetField(size_t field_id) const\r\n```\r\nGets the field specified. // 获取指定字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_id` – Field ID. // 字段ID。\r\n\r\n**返回**  \r\nField value. // 字段值。\r\n\r\n```cpp\r\ninline FieldData operator[](const std::string &field_name) const\r\n```\r\nGet field identified by field_name. // 获取由 field_name 标识的字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。\n\n该块内容位于文档中关于操作数据库中的字段数据的部分，具体在描述如何获取指定字段及其相关错误处理时，主要涉及到 `GetField` 函数及其异常处理，确保用户在访问字段时能够理解潜在的错误情况和参数要求。"
            },
            {
                "content": "InputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_id` – Field ID. // 字段ID。\r\n\r\n**返回**  \r\nField value. // 字段值。\r\n\r\n```cpp\r\ninline FieldData operator[](const std::string &field_name) const\r\n```\r\nGet field identified by field_name. // 获取由 field_name 标识的字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_name` – The name of the field to get. // 要获取的字段名称。\r\n\r\n**返回**  \r\nField value. // 字段值。\r\n\r\n```cpp\r\ninline FieldData operator[](size_t fid) const\r\n```\r\nGet field identified by field id. FieldId can be obtained with `txn.GetEdgeFieldId()`. // 获取由字段ID标识的字段。FieldId 可以通过 `txn.GetEdgeFieldId()` 获取。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。\n\n该片段属于 `lgraph_types` 命名空间下的 `FieldData` 结构，主要描述了如何获取、设置和处理字段数据，包括获取字段值的方法以及对应的异常处理。这部分内容为用户在操作字段数据时提供了必要的接口和错误管理策略。"
            },
            {
                "content": "InputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_name` – The name of the field to get. // 要获取的字段名称。\r\n\r\n**返回**  \r\nField value. // 字段值。\r\n\r\n```cpp\r\ninline FieldData operator[](size_t fid) const\r\n```\r\nGet field identified by field id. FieldId can be obtained with `txn.GetEdgeFieldId()`. // 获取由字段ID标识的字段。FieldId 可以通过 `txn.GetEdgeFieldId()` 获取。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `fid` – Field id. // 字段ID。\r\n\r\n**返回**  \r\nField value. // 字段值。\r\n\r\n```cpp\r\nstd::map GetAllFields() const\r\n```\r\nGets all fields of the current vertex. // 获取当前顶点的所有字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。\n\n该段落位于文档中的 `lgraph_types` 部分，具体描述了 `FieldData` 类的函数和异常处理，包括如何获取字段值、处理无效事务时抛出的异常，以及如何获取当前顶点的所有字段。这部分内容旨在提供对数据字段操作的详细说明，以便用户在进行图数据库操作时能够正确处理各种情况。"
            },
            {
                "content": "InputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `fid` – Field id. // 字段ID。\r\n\r\n**返回**  \r\nField value. // 字段值。\r\n\r\n```cpp\r\nstd::map GetAllFields() const\r\n```\r\nGets all fields of the current vertex. // 获取当前顶点的所有字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nAll fields in a dictionary of {(field_name, field_value),…}. // 返回一个字典，其中包含所有字段 {(字段名称, 字段值),…}。\r\n\r\n```cpp\r\nvoid SetField(const std::string &field_name, const FieldData &field_value)\r\n```\r\nSets the specified field. // 设置指定字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nWriteNotAllowed – Thrown when called in a read-only transaction. // 在只读事务中调用时抛出。\n\n该块内容源于关于TuGraph的字段操作和事务处理的描述部分，主要涉及自定义异常`InputError`、获取当前顶点所有字段的方法、以及设置指定字段的功能。这部分信息是文档中有关图形数据库操作和异常处理的重要组成部分，帮助用户理解如何有效地管理顶点的数据和处理错误。"
            },
            {
                "content": "**返回**  \r\nAll fields in a dictionary of {(field_name, field_value),…}. // 返回一个字典，其中包含所有字段 {(字段名称, 字段值),…}。\r\n\r\n```cpp\r\nvoid SetField(const std::string &field_name, const FieldData &field_value)\r\n```\r\nSets the specified field. // 设置指定字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nWriteNotAllowed – Thrown when called in a read-only transaction. // 在只读事务中调用时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_name` – Field name. // 字段名称。\r\n- `field_value` – Field value. // 字段值。\r\n\r\n```cpp\r\nvoid SetField(size_t field_id, const FieldData &field_value)\r\n```\r\nSets the specified field. // 设置指定字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。\n\n该块内容位于文档中的 `lgraph_result` 部分，具体描述了 `Record` 类的公共函数和其功能，包括如何设置字段及其相关的异常处理情况。这一部分是图数据库操作结果和返回值处理的重要组成，帮助用户理解如何处理图分析过程中的数据。"
            },
            {
                "content": "InputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_name` – Field name. // 字段名称。\r\n- `field_value` – Field value. // 字段值。\r\n\r\n```cpp\r\nvoid SetField(size_t field_id, const FieldData &field_value)\r\n```\r\nSets the specified field. // 设置指定字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nWriteNotAllowed – Thrown when called in a read-only transaction. // 在只读事务中调用时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_id` – Field id. // 字段ID。\r\n- `field_value` – Field value. // 字段值。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_names, const std::vector &field_value_strings)\r\n```\r\nSets the fields specified. // 设置指定字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。\n\n该块内容位于文档中的“lgraph_types”部分，具体涉及到如何设置字段的函数及其相关的异常处理和参数说明，包括对字段值和字段名称的设置操作。这些内容主要针对在使用图数据库进行数据插入和更新时所需的参数和错误处理机制。"
            },
            {
                "content": "WriteNotAllowed – Thrown when called in a read-only transaction. // 在只读事务中调用时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_id` – Field id. // 字段ID。\r\n- `field_value` – Field value. // 字段值。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_names, const std::vector &field_value_strings)\r\n```\r\nSets the fields specified. // 设置指定字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nWriteNotAllowed – Thrown when called in a read-only transaction. // 在只读事务中调用时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_names` – List of names of the fields. // 字段名称列表。\r\n- `field_value_strings` – The field values in string representation. // 字段值的字符串表示。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_names, const std::vector &field_values)\r\n```\n\n该块内容位于文档中有关设置字段的方法部分，特别是针对无法在只读事务中调用的异常处理和输入错误的说明。它详细说明了在不同情况下可能抛出的异常，并提供了用于设置字段的函数签名，以及相关的参数描述。这部分内容主要强调在处理图数据库事务时字段的更新和错误处理机制。"
            },
            {
                "content": "InvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nWriteNotAllowed – Thrown when called in a read-only transaction. // 在只读事务中调用时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_names` – List of names of the fields. // 字段名称列表。\r\n- `field_value_strings` – The field values in string representation. // 字段值的字符串表示。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_names, const std::vector &field_values)\r\n```\r\nSets the fields specified. // 设置指定字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nWriteNotAllowed – Thrown when called in a read-only transaction. // 在只读事务中调用时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_names` – List of names of the fields. // 字段名称列表。\r\n- `field_values` – The field values. // 字段值。\r\n\r\n```cpp\n\n该块内容位于关于图数据库中顶点和边的遍历接口部分，主要描述了在使用迭代器时可能抛出的异常（如无效迭代器、只读事务中的写操作不允许、输入错误）及其相关参数。它涉及到设置字段值的方法及其异常处理，是对 GraphDB 操作的细节补充。"
            },
            {
                "content": "**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nWriteNotAllowed – Thrown when called in a read-only transaction. // 在只读事务中调用时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_names` – List of names of the fields. // 字段名称列表。\r\n- `field_values` – The field values. // 字段值。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_ids, const std::vector &field_values)\r\n```\r\nSets the fields specified. // 设置指定字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nWriteNotAllowed – Thrown when called in a read-only transaction. // 在只读事务中调用时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**\n\n该段落位于文档中关于`VertexIterator`类的函数定义部分，具体描述了函数`SetFields`的异常抛出和参数说明。在此之前，文档讨论了`VertexIterator`在无效事务和只读事务中的行为，以及与之相关的输入错误处理。"
            },
            {
                "content": "```cpp\r\nvoid SetFields(const std::vector &field_ids, const std::vector &field_values)\r\n```\r\nSets the fields specified. // 设置指定字段。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nWriteNotAllowed – Thrown when called in a read-only transaction. // 在只读事务中调用时抛出。  \r\nInputError – Thrown on other input errors (field not exist, etc.). // 在其他输入错误时抛出（字段不存在等）。\r\n\r\n**参数**  \r\n- `field_ids` – List of identifiers for the fields. // 字段的标识符列表。\r\n- `field_values` – The field values. // 字段值。\r\n\r\n```cpp\r\nvoid Delete()\r\n```\r\nDeletes this edge. The iterator will point to the next outgoing edge sorted by (label, tid, dst, eid) if there is any. If there are no more outgoing edges for this source vertex, the iterator becomes invalid. // 删除该边。如果有，迭代器将指向下一个按 (label, tid, dst, eid) 排序的出边。如果该源顶点没有更多出边，迭代器将变得无效。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。\n\n该代码片段位于 TuGraph 的 `lgraph_types` 模块中，具体是在描述操作类（如 `VertexIterator` 和 `EdgeIterator`）时，定义了设置和删除字段的函数。这些函数涉及到在图形数据库中对边的操作，包括设置字段值和删除边的功能，相关的异常情况也被详细列出。"
            },
            {
                "content": "- `field_values` – The field values. // 字段值。\r\n\r\n```cpp\r\nvoid Delete()\r\n```\r\nDeletes this edge. The iterator will point to the next outgoing edge sorted by (label, tid, dst, eid) if there is any. If there are no more outgoing edges for this source vertex, the iterator becomes invalid. // 删除该边。如果有，迭代器将指向下一个按 (label, tid, dst, eid) 排序的出边。如果该源顶点没有更多出边，迭代器将变得无效。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。  \r\nWriteNotAllowed – Thrown when called in a read-only transaction. // 在只读事务中调用时抛出。\r\n\r\n```cpp\r\nstd::string ToString() const\r\n```\r\nGet string representation of the edge. // 获取边的字符串表示。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nA `std::string` that represents this object. // 一个表示该对象的 `std::string`。\r\n\r\n### Private Functions\r\n\r\n```cpp\n\n该片段位于文档的`lgraph_vertex_iterator`类部分中，主要描述了与边操作相关的函数，包括删除边和获取边的字符串表示。这些函数涉及如何删除图中的边以及处理边的数据结构，适用于在TuGraph中进行图形遍历和操作的上下文。"
            },
            {
                "content": "WriteNotAllowed – Thrown when called in a read-only transaction. // 在只读事务中调用时抛出。\r\n\r\n```cpp\r\nstd::string ToString() const\r\n```\r\nGet string representation of the edge. // 获取边的字符串表示。\r\n\r\n**抛出**  \r\nInvalidTxn – Thrown when called inside an invalid transaction. // 当在无效事务中调用时抛出。  \r\nInvalidIterator – Thrown when the current iterator is invalid. // 当前迭代器无效时抛出。\r\n\r\n**返回**  \r\nA `std::string` that represents this object. // 一个表示该对象的 `std::string`。\r\n\r\n### Private Functions\r\n\r\n```cpp\r\nOutEdgeIterator(lgraph::graph::OutEdgeIterator&&, const std::shared_ptr&)\r\n```\r\nConstructors are private; use `Transaction::GetOutEdgeIterator()` or `VertexIterator::GetOutEdgeIterator()` instead. // 构造函数是私有的；请使用 `Transaction::GetOutEdgeIterator()` 或 `VertexIterator::GetOutEdgeIterator()`。\r\n\r\n```cpp\r\nOutEdgeIterator(const OutEdgeIterator&) = delete\r\n```\r\nThis copy constructor is deleted to prevent copying. // 该复制构造函数被删除以防止复制。\r\n\r\n```cpp\r\nOutEdgeIterator &operator=(const OutEdgeIterator&) = delete\r\n```\n\n该区块位于文档中关于TuGraph的`OutEdgeIterator`类的描述部分，主要介绍了该类的构造函数、公共函数及相关异常抛出情况，尤其是在只读事务中调用时的限制和边的字符串表示获取方法。此内容包含有关事务有效性和迭代器状态的异常处理信息。"
            },
            {
                "content": "OutEdgeIterator(lgraph::graph::OutEdgeIterator&&, const std::shared_ptr&)\r\n```\r\nConstructors are private; use `Transaction::GetOutEdgeIterator()` or `VertexIterator::GetOutEdgeIterator()` instead. // 构造函数是私有的；请使用 `Transaction::GetOutEdgeIterator()` 或 `VertexIterator::GetOutEdgeIterator()`。\r\n\r\n```cpp\r\nOutEdgeIterator(const OutEdgeIterator&) = delete\r\n```\r\nThis copy constructor is deleted to prevent copying. // 该复制构造函数被删除以防止复制。\r\n\r\n```cpp\r\nOutEdgeIterator &operator=(const OutEdgeIterator&) = delete\r\n```\r\nThis assignment operator is deleted to prevent assignment. // 该赋值运算符被删除以防止赋值。\r\n\r\n#### Private Members\r\n\r\n```cpp\r\nstd::unique_ptr it_\r\n```\r\nUnique pointer to the out-edge iterator. // 指向出边迭代器的唯一指针。\r\n\r\n```cpp\r\nstd::shared_ptr txn_\r\n```\r\nShared pointer to the transaction. // 指向事务的共享指针。\r\n\r\n#### Friends\r\n\r\n```cpp\r\nfriend class Transaction\r\n```\r\nTransaction class is a friend. // Transaction 类是友元类。\r\n\r\n```cpp\r\nfriend class VertexIterator\r\n```\r\nVertexIterator class is a friend. // VertexIterator 类是友元类。\n\n该代码块属于文档中的 `lgraph_vertex_iterator` 类，具体描述了 `OutEdgeIterator` 的构造函数、拷贝构造函数和赋值运算符的私有处理，以及与该迭代器相关的私有成员和友元类声明。这部分主要涉及图数据库中出边迭代器的实现，旨在避免不当的复制和赋值操作，以确保迭代器的正确使用。"
            },
            {
                "content": "#### Private Members\r\n\r\n```cpp\r\nstd::unique_ptr it_\r\n```\r\nUnique pointer to the out-edge iterator. // 指向出边迭代器的唯一指针。\r\n\r\n```cpp\r\nstd::shared_ptr txn_\r\n```\r\nShared pointer to the transaction. // 指向事务的共享指针。\r\n\r\n#### Friends\r\n\r\n```cpp\r\nfriend class Transaction\r\n```\r\nTransaction class is a friend. // Transaction 类是友元类。\r\n\r\n```cpp\r\nfriend class VertexIterator\r\n```\r\nVertexIterator class is a friend. // VertexIterator 类是友元类。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_exceptions\r\n\r\n### Defines\r\n\r\n- **ERROR_CODES**  // 定义了错误代码\r\n- **X(code, msg)**  // 定义了一个宏，接受错误代码和消息\r\n- **THROW_CODE(code, ...)**  // 定义了一个宏，用于抛出指定的错误代码\r\n\r\n### namespace lgraph_api  // 命名空间 lgraph_api\r\n\r\n### Enums\r\n\r\n- **enum class ErrorCode**  // 错误代码的枚举类\r\n  - Values:  // 枚举值\r\n    - enumerator X  // 枚举值 X\r\n    - enumerator ERROR_CODES  // 枚举值 ERROR_CODES\r\n\r\n### Functions\r\n\r\n```cpp\r\nconst char *ErrorCodeToString(ErrorCode code)  // 将错误代码转换为字符串\r\n```\r\n\r\n```cpp\r\nconst char *ErrorCodeDesc(ErrorCode code)  // 获取错误代码的描述\r\n```\n\n该文档主要介绍了 TuGraph 数据库的各种接口和功能，包括图的存储、遍历、异常处理、图分析引擎等。在私有成员部分，文档详细描述了 `VertexIterator` 类中的成员变量与友元类，用于管理图中顶点的遍历操作。接下来的内容则涉及到异常处理相关的定义与函数，提供了错误处理的机制和异常类型的信息。"
            },
            {
                "content": "- **ERROR_CODES**  // 定义了错误代码\r\n- **X(code, msg)**  // 定义了一个宏，接受错误代码和消息\r\n- **THROW_CODE(code, ...)**  // 定义了一个宏，用于抛出指定的错误代码\r\n\r\n### namespace lgraph_api  // 命名空间 lgraph_api\r\n\r\n### Enums\r\n\r\n- **enum class ErrorCode**  // 错误代码的枚举类\r\n  - Values:  // 枚举值\r\n    - enumerator X  // 枚举值 X\r\n    - enumerator ERROR_CODES  // 枚举值 ERROR_CODES\r\n\r\n### Functions\r\n\r\n```cpp\r\nconst char *ErrorCodeToString(ErrorCode code)  // 将错误代码转换为字符串\r\n```\r\n\r\n```cpp\r\nconst char *ErrorCodeDesc(ErrorCode code)  // 获取错误代码的描述\r\n```\r\n\r\n### class LgraphException : public exception  // LgraphException 类，继承自标准异常类\r\n\r\n```cpp\r\n#include   // 引入 lgraph_exceptions 头文件\r\n```\r\n\r\n#### Public Functions\r\n\r\n```cpp\r\nexplicit LgraphException(ErrorCode code)  // 构造函数，接受一个错误代码\r\n```\r\n\r\n```cpp\r\nexplicit LgraphException(ErrorCode code, const std::string &msg)  // 构造函数，接受错误代码和消息字符串\r\n```\r\n\r\n```cpp\r\nexplicit LgraphException(ErrorCode code, const char *msg)  // 构造函数，接受错误代码和消息 C 字符串\r\n```\r\n\r\n```cpp\r\ntemplate\n\n该代码块位于文档的异常处理部分，主要描述了错误代码定义、枚举类 `ErrorCode` 的值，以及用于抛出和处理错误的 `LgraphException` 类的构造函数和相关函数。这部分功能是用于支持和管理异常，以提高图数据库操作中的错误处理能力。"
            },
            {
                "content": "```\r\n\r\n### class LgraphException : public exception  // LgraphException 类，继承自标准异常类\r\n\r\n```cpp\r\n#include   // 引入 lgraph_exceptions 头文件\r\n```\r\n\r\n#### Public Functions\r\n\r\n```cpp\r\nexplicit LgraphException(ErrorCode code)  // 构造函数，接受一个错误代码\r\n```\r\n\r\n```cpp\r\nexplicit LgraphException(ErrorCode code, const std::string &msg)  // 构造函数，接受错误代码和消息字符串\r\n```\r\n\r\n```cpp\r\nexplicit LgraphException(ErrorCode code, const char *msg)  // 构造函数，接受错误代码和消息 C 字符串\r\n```\r\n\r\n```cpp\r\ntemplate\r\ninline explicit LgraphException(ErrorCode code, const char *format, const Ts&... ds)  // 模板构造函数，支持格式化消息\r\n```\r\n\r\n```cpp\r\ninline ErrorCode code() const  // 返回错误代码\r\n```\r\n\r\n```cpp\r\ninline const std::string &msg() const  // 返回错误消息字符串\r\n```\r\n\r\n```cpp\r\ninline const char *what() const noexcept override  // 重写 what() 函数，返回异常的描述\r\n```\r\n\r\n#### Private Members\r\n\r\n- **ErrorCode code_**  // 存储错误代码的私有成员\r\n- **std::string msg_**  // 存储错误消息的私有成员\r\n- **std::string what_**  // 存储异常描述的私有成员\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_galaxy\r\n\r\n### namespace lgraph\n\n该块内容位于文档中关于 `lgraph_exceptions` 和 `lgraph_galaxy` 的部分，主要介绍了 `LgraphException` 类，该类用于处理图数据库中的异常，包括构造函数、返回错误代码和消息的方法，以及存储错误信息的私有成员。这部分为用户理解图数据库异常处理机制提供了重要信息。"
            },
            {
                "content": "```\r\n\r\n```cpp\r\ninline ErrorCode code() const  // 返回错误代码\r\n```\r\n\r\n```cpp\r\ninline const std::string &msg() const  // 返回错误消息字符串\r\n```\r\n\r\n```cpp\r\ninline const char *what() const noexcept override  // 重写 what() 函数，返回异常的描述\r\n```\r\n\r\n#### Private Members\r\n\r\n- **ErrorCode code_**  // 存储错误代码的私有成员\r\n- **std::string msg_**  // 存储错误消息的私有成员\r\n- **std::string what_**  // 存储异常描述的私有成员\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_galaxy\r\n\r\n### namespace lgraph\r\n### namespace lgraph_api\r\n\r\n### class Galaxy\r\n\r\n```cpp\r\n#include \r\n```\r\n\r\nA galaxy is the storage engine for one TuGraph instance. It manages a set of User/Role/GraphDBs.\r\n  \r\n一个 galaxy 是一个 TuGraph 实例的存储引擎。它管理一组用户/角色/图数据库。\r\n\r\nA galaxy can be opened in async mode, in which case ALL write transactions will be treated as async, whether they declare async or not. This can come in handy if we are performing a lot of writing, but can cause data loss for online processing.\r\n\r\n一个 galaxy 可以在异步模式下打开，在这种情况下，所有写事务都将被视为异步，无论它们是否声明为异步。这在进行大量写入时可能会很有用，但可能会导致在线处理中的数据丢失。\n\n这段代码属于 lgraph_exceptions 章节，专门描述了 LgraphException 类的相关成员函数和私有成员，用于处理在图数据库操作中的异常情况。在后续内容中，介绍了 lgraph_galaxy 章节，讨论 galaxy 作为 TuGraph 实例的存储引擎的功能。"
            },
            {
                "content": "#include \r\n```\r\n\r\nA galaxy is the storage engine for one TuGraph instance. It manages a set of User/Role/GraphDBs.\r\n  \r\n一个 galaxy 是一个 TuGraph 实例的存储引擎。它管理一组用户/角色/图数据库。\r\n\r\nA galaxy can be opened in async mode, in which case ALL write transactions will be treated as async, whether they declare async or not. This can come in handy if we are performing a lot of writing, but can cause data loss for online processing.\r\n\r\n一个 galaxy 可以在异步模式下打开，在这种情况下，所有写事务都将被视为异步，无论它们是否声明为异步。这在进行大量写入时可能会很有用，但可能会导致在线处理中的数据丢失。\r\n\r\n#### Public Functions\r\n\r\n```cpp\r\nexplicit Galaxy(const std::string &dir, bool durable = false, bool create_if_not_exist = true)\r\n```\r\nConstructor.\r\n\r\n构造函数。\r\n\r\n抛出  \r\nDBNotExist – Thrown if DB does not exist and create_if_not_exist is false.\r\n\r\n此异常在数据库不存在且 create_if_not_exist 为 false 时抛出。\r\n\r\nIOError – Thrown if DB does not exist, but we failed to create the DB due to IO error.\r\n\r\n此异常在数据库不存在，但由于 IO 错误无法创建数据库时抛出。\n\n该文档主要介绍了TuGraph数据库的各种功能与接口，包括存储过程、图遍历、异常处理、时间处理等模块。所提供的代码片段描述了galaxy的概念，它是TuGraph实例的存储引擎，管理用户、角色和图数据库，并支持异步模式的事务处理。此部分有助于理解如何在TuGraph中管理数据存储和处理。"
            },
            {
                "content": "一个 galaxy 可以在异步模式下打开，在这种情况下，所有写事务都将被视为异步，无论它们是否声明为异步。这在进行大量写入时可能会很有用，但可能会导致在线处理中的数据丢失。\r\n\r\n#### Public Functions\r\n\r\n```cpp\r\nexplicit Galaxy(const std::string &dir, bool durable = false, bool create_if_not_exist = true)\r\n```\r\nConstructor.\r\n\r\n构造函数。\r\n\r\n抛出  \r\nDBNotExist – Thrown if DB does not exist and create_if_not_exist is false.\r\n\r\n此异常在数据库不存在且 create_if_not_exist 为 false 时抛出。\r\n\r\nIOError – Thrown if DB does not exist, but we failed to create the DB due to IO error.\r\n\r\n此异常在数据库不存在，但由于 IO 错误无法创建数据库时抛出。\r\n\r\nInputError – Thrown if there are other input errors. e.g., dir is actually a plain file, or DB is corruptted.\r\n\r\n此异常在存在其他输入错误时抛出。例如，dir 实际上是一个普通文件，或数据库已损坏。\r\n\r\n参数  \r\ndir – The TuGraph dir.\r\n\r\ndir – TuGraph 的目录。\r\n\r\ndurable – (Optional) True to open in durable mode. If set to false, ALL write transactions are async, whether they declare async or not.\r\n\r\ndurable – （可选）设置为 true 以在持久模式下打开。如果设置为 false，所有写事务都是异步的，无论它们是否声明为异步。\n\n该块内容位于文档中的“lgraph_galaxy”部分，讨论了如何以异步模式打开一个galaxy以及相关构造函数的异常处理。这一部分主要涉及TuGraph数据库中Galaxy的初始化和配置，特别是在执行大量写入操作时的性能优化和潜在的数据丢失风险。"
            },
            {
                "content": "此异常在数据库不存在，但由于 IO 错误无法创建数据库时抛出。\r\n\r\nInputError – Thrown if there are other input errors. e.g., dir is actually a plain file, or DB is corruptted.\r\n\r\n此异常在存在其他输入错误时抛出。例如，dir 实际上是一个普通文件，或数据库已损坏。\r\n\r\n参数  \r\ndir – The TuGraph dir.\r\n\r\ndir – TuGraph 的目录。\r\n\r\ndurable – (Optional) True to open in durable mode. If set to false, ALL write transactions are async, whether they declare async or not.\r\n\r\ndurable – （可选）设置为 true 以在持久模式下打开。如果设置为 false，所有写事务都是异步的，无论它们是否声明为异步。\r\n\r\ncreate_if_not_exist – (Optional) If true, the TuGraph DB will be created if dir does not exist; otherwise, an exception is thrown.\r\n\r\ncreate_if_not_exist – （可选）如果为 true，且 dir 不存在，则将创建 TuGraph 数据库；否则将抛出异常。\r\n\r\n```cpp\r\nGalaxy(const std::string &dir, const std::string &user, const std::string &password, bool durable, bool create_if_not_exist)\r\n```\r\nConstructor. Open the Galaxy and try to login with specified user and password.\r\n\r\n构造函数。打开 Galaxy 并尝试使用指定的用户和密码登录。\r\n\r\n抛出  \r\nDBNotExist – Thrown if DB does not exist and create_if_not_exist is false.\n\n此块内容位于文档的\"lgraph_galaxy\"部分，具体描述了在创建Galaxy实例时可能出现的异常情况及其参数设置，包括数据库不存在时的处理、持久模式的选择，以及只读打开模式等。这些信息对于理解TuGraph实例的初始化和错误处理非常重要。"
            },
            {
                "content": "create_if_not_exist – （可选）如果为 true，且 dir 不存在，则将创建 TuGraph 数据库；否则将抛出异常。\r\n\r\n```cpp\r\nGalaxy(const std::string &dir, const std::string &user, const std::string &password, bool durable, bool create_if_not_exist)\r\n```\r\nConstructor. Open the Galaxy and try to login with specified user and password.\r\n\r\n构造函数。打开 Galaxy 并尝试使用指定的用户和密码登录。\r\n\r\n抛出  \r\nDBNotExist – Thrown if DB does not exist and create_if_not_exist is false.\r\n\r\n此异常在数据库不存在且 create_if_not_exist 为 false 时抛出。\r\n\r\nIOError – Thrown if DB does not exist, but we failed to create the DB due to IO error.\r\n\r\n此异常在数据库不存在，但由于 IO 错误无法创建数据库时抛出。\r\n\r\nInputError – Thrown if there are other input errors. e.g., dir is actually a plain file, or DB is corruptted.\r\n\r\n此异常在存在其他输入错误时抛出。例如，dir 实际上是一个普通文件，或数据库已损坏。\r\n\r\nUnauthorized – Thrown if user/password is not correct.\r\n\r\n当用户/密码不正确时抛出此异常。\r\n\r\n参数  \r\ndir – The dir.\r\n\r\ndir – 目录。\r\n\r\nuser – The user.\r\n\r\nuser – 用户。\r\n\r\npassword – The password.\r\n\r\npassword – 密码。\r\n\r\ndurable – True to open the Galaxy in durable mode.\n\n该代码块位于文档的 \"lgraph_galaxy\" 部分，描述了 Galaxy 类的构造函数及其基本功能。它涵盖了如何打开 Galaxy 实例、用户登录以及在特定情况下会抛出的异常。这部分内容对于理解如何初始化和管理图数据库的连接至关重要。"
            },
            {
                "content": "此异常在数据库不存在，但由于 IO 错误无法创建数据库时抛出。\r\n\r\nInputError – Thrown if there are other input errors. e.g., dir is actually a plain file, or DB is corruptted.\r\n\r\n此异常在存在其他输入错误时抛出。例如，dir 实际上是一个普通文件，或数据库已损坏。\r\n\r\nUnauthorized – Thrown if user/password is not correct.\r\n\r\n当用户/密码不正确时抛出此异常。\r\n\r\n参数  \r\ndir – The dir.\r\n\r\ndir – 目录。\r\n\r\nuser – The user.\r\n\r\nuser – 用户。\r\n\r\npassword – The password.\r\n\r\npassword – 密码。\r\n\r\ndurable – True to open the Galaxy in durable mode.\r\n\r\ndurable – 设置为 true 以在持久模式下打开 Galaxy。\r\n\r\ncreate_if_not_exist – True to create if DB does not exist.\r\n\r\ncreate_if_not_exist – 如果数据库不存在，则为 true，以创建数据库。\r\n\r\n```cpp\r\nGalaxy(Galaxy&&)\r\n```\r\n\r\n```cpp\r\nGalaxy &operator=(Galaxy&&)\r\n```\r\n\r\n```cpp\r\n~Galaxy()\r\n```\r\n\r\n```cpp\r\nvoid SetCurrentUser(const std::string &user, const std::string &password)\r\n```\r\nValidate and set current user\r\n\r\n验证并设置当前用户。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user/password is incorrect.\r\n\r\n当用户/密码不正确时抛出此异常。\r\n\r\n参数  \r\nuser – The user.\n\n该块内容位于文档的“lgraph_galaxy”部分，描述了在打开或创建银河实例时可能抛出的异常，包括数据库不存在、IO错误、输入错误以及用户验证失败的情况。此部分提供了参数说明，以及相应的构造函数和方法。"
            },
            {
                "content": "create_if_not_exist – 如果数据库不存在，则为 true，以创建数据库。\r\n\r\n```cpp\r\nGalaxy(Galaxy&&)\r\n```\r\n\r\n```cpp\r\nGalaxy &operator=(Galaxy&&)\r\n```\r\n\r\n```cpp\r\n~Galaxy()\r\n```\r\n\r\n```cpp\r\nvoid SetCurrentUser(const std::string &user, const std::string &password)\r\n```\r\nValidate and set current user\r\n\r\n验证并设置当前用户。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user/password is incorrect.\r\n\r\n当用户/密码不正确时抛出此异常。\r\n\r\n参数  \r\nuser – The user.\r\n\r\nuser – 用户。\r\n\r\npassword – The password.\r\n\r\npassword – 密码。\r\n\r\n```cpp\r\nvoid SetUser(const std::string &user)\r\n```\r\nSet current user\r\n\r\n设置当前用户。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if token is incorrect.\r\n\r\n当令牌不正确时抛出此异常。\r\n\r\n参数  \r\nuser – The current user.\r\n\r\nuser – 当前用户。\r\n\r\n```cpp\r\nbool CreateGraph(const std::string &graph_name, const std::string &description = \"\", size_t max_size = (size_t)1 << 40)\r\n```\r\nValidate token and set current user\r\n\r\n验证令牌并设置当前用户。\r\n\r\n抛出\n\n该片段位于文档的 \"lgraph_galaxy\" 部分，主要描述了 `Galaxy` 类的构造函数、移动构造函数、赋值运算符以及用户设置相关方法的实现细节，包括参数、异常抛出以及功能描述。这一部分旨在提供关于图数据库用户管理和图创建操作的详细信息。"
            },
            {
                "content": "password – 密码。\r\n\r\n```cpp\r\nvoid SetUser(const std::string &user)\r\n```\r\nSet current user\r\n\r\n设置当前用户。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if token is incorrect.\r\n\r\n当令牌不正确时抛出此异常。\r\n\r\n参数  \r\nuser – The current user.\r\n\r\nuser – 当前用户。\r\n\r\n```cpp\r\nbool CreateGraph(const std::string &graph_name, const std::string &description = \"\", size_t max_size = (size_t)1 << 40)\r\n```\r\nValidate token and set current user\r\n\r\n验证令牌并设置当前用户。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission to create graph.\r\n\r\n当用户没有创建图表的权限时抛出此异常。\r\n\r\nInputError – Other input errors such as invalid graph name, size, etc.\r\n\r\n输入错误 – 其他输入错误，例如无效的图表名称、大小等。\r\n\r\n参数  \r\ngraph_name – Name of the graph to create.  \r\ndescription (Optional) – Description of the graph.  \r\nmax_size (Optional) – Maximum size of the graph.\r\n\r\n返回  \r\nTrue if it succeeds, false if graph already exists.\n\n该块内容位于文档的 \"lgraph_galaxy\" 部分，涉及用户管理与图形创建的函数，包括设置当前用户和创建图形的方法及相关异常处理。这部分内容描述了在 TuGraph 实例中如何验证用户凭证和管理图形的基本操作。"
            },
            {
                "content": "抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission to create graph.\r\n\r\n当用户没有创建图表的权限时抛出此异常。\r\n\r\nInputError – Other input errors such as invalid graph name, size, etc.\r\n\r\n输入错误 – 其他输入错误，例如无效的图表名称、大小等。\r\n\r\n参数  \r\ngraph_name – Name of the graph to create.  \r\ndescription (Optional) – Description of the graph.  \r\nmax_size (Optional) – Maximum size of the graph.\r\n\r\n返回  \r\nTrue if it succeeds, false if graph already exists.\r\n\r\n如果成功返回 true，如果图形已经存在则返回 false。\r\n\r\n```cpp\r\nbool DeleteGraph(const std::string &graph_name)\r\n```\r\nDelete a graph\r\n\r\n删除一张图。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission to delete graph.\r\n\r\n当用户没有删除图表的权限时抛出此异常。\r\n\r\n参数  \r\ngraph_name – Name of the graph.\r\n\r\ngraph_name – 图形名称。\r\n\r\n返回  \r\nTrue if it succeeds, false if the graph does not exist.\r\n\r\n如果成功返回 true，如果图形不存在则返回 false。\r\n\r\n```cpp\n\n该代码块位于文档的\"lgraph_galaxy\"部分，具体描述了与图形数据库操作相关的异常处理机制和参数说明，包括创建和删除图形的功能。这部分内容有助于理解如何在使用TuGraph时处理图形的创建和删除操作，以及相应的权限检查和错误处理。"
            },
            {
                "content": "如果成功返回 true，如果图形已经存在则返回 false。\r\n\r\n```cpp\r\nbool DeleteGraph(const std::string &graph_name)\r\n```\r\nDelete a graph\r\n\r\n删除一张图。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission to delete graph.\r\n\r\n当用户没有删除图表的权限时抛出此异常。\r\n\r\n参数  \r\ngraph_name – Name of the graph.\r\n\r\ngraph_name – 图形名称。\r\n\r\n返回  \r\nTrue if it succeeds, false if the graph does not exist.\r\n\r\n如果成功返回 true，如果图形不存在则返回 false。\r\n\r\n```cpp\r\nbool ModGraph(const std::string &graph_name, bool mod_desc, const std::string &desc, bool mod_size, size_t new_max_size)\r\n```\r\nModify graph info\r\n\r\n修改图信息。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission to modify graph.\r\n\r\n当用户没有修改图表的权限时抛出此异常。\r\n\r\n参数  \r\ngraph_name – Name of the graph.  \r\nmod_desc – True to modify description.  \r\ndesc – The new description.  \r\nmod_size – True to modify size.  \r\nnew_max_size – New maximum size.\r\n\r\n返回\n\n此块内容位于文档的 \"lgraph_galaxy\" 部分，主要描述了与图形数据库的图形管理相关的功能，包括删除和修改图形的信息，以及相应的异常处理和返回值说明。"
            },
            {
                "content": "```\r\nModify graph info\r\n\r\n修改图信息。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission to modify graph.\r\n\r\n当用户没有修改图表的权限时抛出此异常。\r\n\r\n参数  \r\ngraph_name – Name of the graph.  \r\nmod_desc – True to modify description.  \r\ndesc – The new description.  \r\nmod_size – True to modify size.  \r\nnew_max_size – New maximum size.\r\n\r\n返回  \r\nTrue if it succeeds, false if it fails.\r\n\r\n如果成功返回 true，如果失败返回 false。\r\n\r\n```cpp\r\nstd::map> ListGraphs() const\r\n```\r\nList graphs\r\n\r\n列出图表。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission to list graphs.\r\n\r\n当用户没有列出图表的权限时抛出此异常。\r\n\r\n返回  \r\nA dictionary of {graph_name: (description, max_size)}\r\n\r\n返回一个字典，格式为 {graph_name: (description, max_size)}。\r\n\r\n```cpp\r\nbool CreateUser(const std::string &user, const std::string &password, const std::string &desc = \"\")\r\n```\r\nCreates a user\r\n\r\n创建用户。\r\n\r\n抛出\n\n该代码块位于文档关于TuGraph图数据库的描述部分，主要涉及图的管理和用户权限控制，包括修改图信息和列出图的功能，以及创建用户的过程。这些函数描述的异常处理和参数设置帮助开发者理解如何操作图数据库及其安全性。"
            },
            {
                "content": "std::map> ListGraphs() const\r\n```\r\nList graphs\r\n\r\n列出图表。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission to list graphs.\r\n\r\n当用户没有列出图表的权限时抛出此异常。\r\n\r\n返回  \r\nA dictionary of {graph_name: (description, max_size)}\r\n\r\n返回一个字典，格式为 {graph_name: (description, max_size)}。\r\n\r\n```cpp\r\nbool CreateUser(const std::string &user, const std::string &password, const std::string &desc = \"\")\r\n```\r\nCreates a user\r\n\r\n创建用户。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission.\r\n\r\n当用户没有权限时抛出此异常。\r\n\r\nInputError – Thrown if other input errors, such as illegal user name, password, etc.\r\n\r\n输入错误 – 如果存在其他输入错误，例如非法的用户名、密码等，抛出此异常。\r\n\r\n参数  \r\nuser – The user.  \r\npassword – The password.  \r\ndesc – (Optional) The description.\r\n\r\n返回  \r\nTrue if it succeeds, false if user already exists.\r\n\r\n如果成功返回 true，如果用户已经存在则返回 false。\r\n\r\n```cpp\n\n该代码片段位于文档的 \"lgraph_galaxy\" 部分，主要描述了与图形数据库相关的操作，包括列出所有图形的函数 `ListGraphs()` 和创建用户的函数 `CreateUser()`。这两部分功能涉及图形数据库的管理与用户权限控制。"
            },
            {
                "content": "创建用户。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission.\r\n\r\n当用户没有权限时抛出此异常。\r\n\r\nInputError – Thrown if other input errors, such as illegal user name, password, etc.\r\n\r\n输入错误 – 如果存在其他输入错误，例如非法的用户名、密码等，抛出此异常。\r\n\r\n参数  \r\nuser – The user.  \r\npassword – The password.  \r\ndesc – (Optional) The description.\r\n\r\n返回  \r\nTrue if it succeeds, false if user already exists.\r\n\r\n如果成功返回 true，如果用户已经存在则返回 false。\r\n\r\n```cpp\r\nbool DeleteUser(const std::string &user)\r\n```\r\nDeletes the user.\r\n\r\n删除用户。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission.\r\n\r\n当用户没有权限时抛出此异常。\r\n\r\n参数  \r\nuser – The user.\r\n\r\nuser – 用户。\r\n\r\n返回  \r\nTrue if it succeeds, false if user does not exist.\r\n\r\n如果成功返回 true，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nbool SetPassword(const std::string &user, const std::string &old_password, const std::string &new_password)\r\n```\n\n该块内容位于文档的 lgraph_galaxy 部分，具体涉及用户管理功能，包括创建用户、删除用户和设置用户密码的相关定义和异常处理。这些功能是 TuGraph 图数据库管理的一部分，涉及用户权限和访问控制。"
            },
            {
                "content": "```cpp\r\nbool DeleteUser(const std::string &user)\r\n```\r\nDeletes the user.\r\n\r\n删除用户。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission.\r\n\r\n当用户没有权限时抛出此异常。\r\n\r\n参数  \r\nuser – The user.\r\n\r\nuser – 用户。\r\n\r\n返回  \r\nTrue if it succeeds, false if user does not exist.\r\n\r\n如果成功返回 true，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nbool SetPassword(const std::string &user, const std::string &old_password, const std::string &new_password)\r\n```\r\nSet the password of the specified user.\r\n\r\n设置指定用户的密码。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission, or curr_user==user, but old_password is incorrect.\r\n\r\n当用户没有权限时抛出此异常，或当前用户 == 用户，但是旧密码不正确。\r\n\r\nInputError – Thrown if new_password is illegal.\r\n\r\n输入错误 – 当 new_password 不合法时抛出此异常。\r\n\r\n参数  \r\nuser – The user to modify.  \r\nold_password – The old password, required if curr_user==user.  \r\nnew_password – The new password.\n\n该代码块位于文档的 \"lgraph_galaxy\" 部分，具体涉及用户管理功能，包括删除用户和设置用户密码的方法。这些方法说明了在图数据库中如何管理用户权限和安全性，并描述了相关异常处理和参数要求。"
            },
            {
                "content": "设置指定用户的密码。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission, or curr_user==user, but old_password is incorrect.\r\n\r\n当用户没有权限时抛出此异常，或当前用户 == 用户，但是旧密码不正确。\r\n\r\nInputError – Thrown if new_password is illegal.\r\n\r\n输入错误 – 当 new_password 不合法时抛出此异常。\r\n\r\n参数  \r\nuser – The user to modify.  \r\nold_password – The old password, required if curr_user==user.  \r\nnew_password – The new password.\r\n\r\n返回  \r\nTrue if it succeeds, false if user does not exist.\r\n\r\n如果成功返回 true，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nbool SetUserDesc(const std::string &user, const std::string &desc)\r\n```\r\nSets user description.\r\n\r\n设置用户描述。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission.\r\n\r\n当用户没有权限时抛出此异常。\r\n\r\nInputError – Thrown if desc is illegal.\r\n\r\n输入错误 – 当 desc 不合法时抛出此异常。\r\n\r\n参数  \r\nuser – The user.  \r\ndesc – The new description.\r\n\r\n返回\n\n此段落位于文档中有关用户管理和权限控制的部分，特别是描述如何设置用户密码和用户描述的相关功能。它详细说明了每个操作可能抛出的异常和操作的参数，适用于开发者在实施用户管理时的参考。"
            },
            {
                "content": "返回  \r\nTrue if it succeeds, false if user does not exist.\r\n\r\n如果成功返回 true，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nbool SetUserDesc(const std::string &user, const std::string &desc)\r\n```\r\nSets user description.\r\n\r\n设置用户描述。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission.\r\n\r\n当用户没有权限时抛出此异常。\r\n\r\nInputError – Thrown if desc is illegal.\r\n\r\n输入错误 – 当 desc 不合法时抛出此异常。\r\n\r\n参数  \r\nuser – The user.  \r\ndesc – The new description.\r\n\r\n返回  \r\nTrue if it succeeds, false if user does not exist.\r\n\r\n如果成功返回 true，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nbool SetUserRoles(const std::string &user, const std::vector &roles)\r\n```\r\nSet the roles of the specified user. If you need to add or delete a role, you will need to use GetUserInfo to get the roles first.\r\n\r\n设置指定用户的角色。如果需要添加或删除角色，则首先需要使用 GetUserInfo 获取角色。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission.\n\n该块内容位于文档的 \"lgraph_types\" 部分，具体讨论了用户角色管理功能，包含设置用户描述和角色的相关函数及其文档说明，涵盖了函数参数、异常抛出情况和返回值说明。"
            },
            {
                "content": "返回  \r\nTrue if it succeeds, false if user does not exist.\r\n\r\n如果成功返回 true，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nbool SetUserRoles(const std::string &user, const std::vector &roles)\r\n```\r\nSet the roles of the specified user. If you need to add or delete a role, you will need to use GetUserInfo to get the roles first.\r\n\r\n设置指定用户的角色。如果需要添加或删除角色，则首先需要使用 GetUserInfo 获取角色。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission.\r\n\r\n当用户没有权限时抛出此异常。\r\n\r\nInputError – Thrown if any role does not exist.\r\n\r\n输入错误 – 如果任何角色不存在则抛出此异常。\r\n\r\n参数  \r\nuser – The user.  \r\nroles – A list of roles.\r\n\r\n返回  \r\nTrue if it succeeds, false if user does not exist.\r\n\r\n如果成功返回 true，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nbool SetUserGraphAccess(const std::string &user, const std::string &graph, const AccessLevel &access)\r\n```\r\nSets user access rights on a graph.\r\n\r\n设置用户对图表的访问权限。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\n\n该块内容位于文档的 lgraph_galaxy 部分，描述了如何设置指定用户的角色和对图形的访问权限，包括抛出的异常及其参数与返回值，用于用户管理和权限控制的相关操作。"
            },
            {
                "content": "当用户没有权限时抛出此异常。\r\n\r\nInputError – Thrown if any role does not exist.\r\n\r\n输入错误 – 如果任何角色不存在则抛出此异常。\r\n\r\n参数  \r\nuser – The user.  \r\nroles – A list of roles.\r\n\r\n返回  \r\nTrue if it succeeds, false if user does not exist.\r\n\r\n如果成功返回 true，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nbool SetUserGraphAccess(const std::string &user, const std::string &graph, const AccessLevel &access)\r\n```\r\nSets user access rights on a graph.\r\n\r\n设置用户对图表的访问权限。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission.\r\n\r\n当用户没有权限时抛出此异常。\r\n\r\nInputError – Thrown if graph does not exist.\r\n\r\n输入错误 – 如果图形不存在则抛出此异常。\r\n\r\n参数  \r\nuser – The user.  \r\ngraph – The graph.  \r\naccess – The access level.\r\n\r\n返回  \r\nTrue if it succeeds, false if user does not exist.\r\n\r\n如果成功返回 true，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nbool DisableUser(const std::string &user)\r\n```\r\nDisable a user. A disabled user is not able to login or perform any operation. A user cannot disable itself.\n\n该片段位于文档的权限管理部分，涉及设置用户对图形的访问权限以及禁用用户的功能，描述了相关异常的抛出条件和参数说明，有助于理解如何控制用户在图数据库中的权限和操作。"
            },
            {
                "content": "Unauthorized – Thrown if user does not have permission.\r\n\r\n当用户没有权限时抛出此异常。\r\n\r\nInputError – Thrown if graph does not exist.\r\n\r\n输入错误 – 如果图形不存在则抛出此异常。\r\n\r\n参数  \r\nuser – The user.  \r\ngraph – The graph.  \r\naccess – The access level.\r\n\r\n返回  \r\nTrue if it succeeds, false if user does not exist.\r\n\r\n如果成功返回 true，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nbool DisableUser(const std::string &user)\r\n```\r\nDisable a user. A disabled user is not able to login or perform any operation. A user cannot disable itself.\r\n\r\n禁用用户。被禁用的用户无法登录或执行任何操作。用户无法禁用自己。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission.\r\n\r\n当用户没有权限时抛出此异常。\r\n\r\nInputError – Thrown if user name is illegal.\r\n\r\n输入错误 – 当用户名非法时抛出此异常。\r\n\r\n参数  \r\nuser – The user to disable.\r\n\r\nuser – 要禁用的用户。\r\n\r\n返回  \r\nTrue if it succeeds, false if user does not exist.\r\n\r\n如果成功返回 true，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nbool EnableUser(const std::string &user)\r\n```\r\nEnables the user. // 启用用户。\r\n\r\n抛出\n\n该片段位于文档的“lgraph_galaxy”部分，具体讨论了用户权限管理，包括禁用和启用用户的相关函数及其异常处理。此部分提供了有关如何处理用户权限和错误情况的详细信息，确保只有授权用户才能进行特定操作。"
            },
            {
                "content": "禁用用户。被禁用的用户无法登录或执行任何操作。用户无法禁用自己。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid.\r\n\r\n当当前 galaxy 无效时抛出此异常。\r\n\r\nUnauthorized – Thrown if user does not have permission.\r\n\r\n当用户没有权限时抛出此异常。\r\n\r\nInputError – Thrown if user name is illegal.\r\n\r\n输入错误 – 当用户名非法时抛出此异常。\r\n\r\n参数  \r\nuser – The user to disable.\r\n\r\nuser – 要禁用的用户。\r\n\r\n返回  \r\nTrue if it succeeds, false if user does not exist.\r\n\r\n如果成功返回 true，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nbool EnableUser(const std::string &user)\r\n```\r\nEnables the user. // 启用用户。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if user name is illegal. // 如果用户名不合法，则抛出 InputError。\r\n\r\n参数  \r\nuser – The user. // user – 用户名。\r\n\r\n返回  \r\nTrue if it succeeds, false if user does not exist. // 成功返回 True，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nstd::map ListUsers() const\r\n```\r\nList all users // 列出所有用户\r\n\r\n抛出\n\n该块内容位于文档的用户权限管理部分，主要描述了禁用和启用用户的操作及其相应的异常处理机制，适用于TuGraph系统中用户管理的相关细节。"
            },
            {
                "content": "```\r\nEnables the user. // 启用用户。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if user name is illegal. // 如果用户名不合法，则抛出 InputError。\r\n\r\n参数  \r\nuser – The user. // user – 用户名。\r\n\r\n返回  \r\nTrue if it succeeds, false if user does not exist. // 成功返回 True，如果用户不存在则返回 false。\r\n\r\n```cpp\r\nstd::map ListUsers() const\r\n```\r\nList all users // 列出所有用户\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\n返回  \r\nA dictionary of {user_name:user_info} // 返回一个字典，格式为 {用户名:用户信息}\r\n\r\n```cpp\r\nUserInfo GetUserInfo(const std::string &user) const\r\n```\r\nGets user information // 获取用户信息\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\n\n此段落位于文档的\"lgraph_galaxy\"部分，主要介绍了与用户管理相关的功能，包括启用用户、列出所有用户和获取用户信息的操作。它详细描述了每个函数的参数、返回值以及可能抛出的异常，有助于用户理解如何在TuGraph数据库中进行用户权限的管理。"
            },
            {
                "content": "```\r\nList all users // 列出所有用户\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\n返回  \r\nA dictionary of {user_name:user_info} // 返回一个字典，格式为 {用户名:用户信息}\r\n\r\n```cpp\r\nUserInfo GetUserInfo(const std::string &user) const\r\n```\r\nGets user information // 获取用户信息\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\n参数  \r\nuser – The user. // user – 用户名。\r\n\r\n返回  \r\nThe user information. // 返回用户信息。\r\n\r\n```cpp\r\nbool CreateRole(const std::string &role, const std::string &desc)\r\n```\r\nCreate a role. A role has different access levels to different graphs. Every user must be assigned some role to get access to graphs. // 创建一个角色。角色对不同图形具有不同的访问级别。每个用户必须被分配某个角色才能访问图形。\r\n\r\n抛出\n\n该片段位于文档中的 `lgraph_galaxy` 类相关部分，具体描述了与用户管理和角色创建相关的操作，包括列出所有用户、获取用户信息和创建角色的函数及其异常处理机制。这些内容为TuGraph的用户权限管理提供了基础。"
            },
            {
                "content": "Unauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\n参数  \r\nuser – The user. // user – 用户名。\r\n\r\n返回  \r\nThe user information. // 返回用户信息。\r\n\r\n```cpp\r\nbool CreateRole(const std::string &role, const std::string &desc)\r\n```\r\nCreate a role. A role has different access levels to different graphs. Every user must be assigned some role to get access to graphs. // 创建一个角色。角色对不同图形具有不同的访问级别。每个用户必须被分配某个角色才能访问图形。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name or desc is illegal. // 如果角色名称或描述不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。  \r\ndesc – The description. // desc – 描述。\r\n\r\n返回  \r\nTrue if it succeeds, false if role already exists. // 成功返回 True，如果角色已存在则返回 false。\r\n\r\n```cpp\r\nbool DeleteRole(const std::string &role)\r\n```\r\nDeletes the role described by role // 删除由角色描述的角色\r\n\r\n抛出\n\n在文档中，该块内容位于`lgraph_api`命名空间下，涉及用户和角色管理的函数，具体包括创建角色和删除角色的操作，以及相应的异常处理和参数说明。这部分内容对于理解如何管理图数据库内的用户权限和角色非常重要。"
            },
            {
                "content": "Unauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name or desc is illegal. // 如果角色名称或描述不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。  \r\ndesc – The description. // desc – 描述。\r\n\r\n返回  \r\nTrue if it succeeds, false if role already exists. // 成功返回 True，如果角色已存在则返回 false。\r\n\r\n```cpp\r\nbool DeleteRole(const std::string &role)\r\n```\r\nDeletes the role described by role // 删除由角色描述的角色\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name is illegal. // 如果角色名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。\r\n\r\n返回  \r\nTrue if it succeeds, false if role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\r\nbool DisableRole(const std::string &role)\r\n```\n\n该块内容位于文档的 \"lgraph_types\" 部分，主要涉及用户和角色的访问权限管理，包括对角色的创建、删除、禁用等操作的异常处理和返回值说明。这些操作涉及权限检查和角色描述的合法性。"
            },
            {
                "content": "```\r\nDeletes the role described by role // 删除由角色描述的角色\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name is illegal. // 如果角色名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。\r\n\r\n返回  \r\nTrue if it succeeds, false if role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\r\nbool DisableRole(const std::string &role)\r\n```\r\nDisable a role. A disabled role still has the data, but is not effective. i.e., users will not have access rights to graphs that are obtained by having this role. // 禁用一个角色。禁用的角色仍然有数据，但无效。即，用户将无法访问通过拥有该角色获得的图形。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name is illegal. // 如果角色名称不合法，则抛出 InputError。\r\n\r\n参数\n\n该块内容位于文档关于TuGraph图数据库的OLAP接口部分，描述如何删除角色及其对应的权限管理。在这一部分，定义了相关的异常情况、输入参数和返回值，说明角色的禁用状态如何影响用户对图形的访问。"
            },
            {
                "content": "```\r\nDisable a role. A disabled role still has the data, but is not effective. i.e., users will not have access rights to graphs that are obtained by having this role. // 禁用一个角色。禁用的角色仍然有数据，但无效。即，用户将无法访问通过拥有该角色获得的图形。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name is illegal. // 如果角色名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。\r\n\r\n返回  \r\nTrue if it succeeds, false if the role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\r\nbool EnableRole(const std::string &role)\r\n```\r\nEnables the role. // 启用角色。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name is illegal. // 如果角色名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。\r\n\r\n返回\n\n该段落位于文档的“lgraph_types”部分，具体讨论了在TuGraph中禁用和启用角色的功能，以及相应的异常处理和返回值，涉及用户权限管理的详细细节。"
            },
            {
                "content": "返回  \r\nTrue if it succeeds, false if the role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\r\nbool EnableRole(const std::string &role)\r\n```\r\nEnables the role. // 启用角色。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name is illegal. // 如果角色名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。\r\n\r\n返回  \r\nTrue if it succeeds, false if role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\r\nbool SetRoleDesc(const std::string &role, const std::string &desc)\r\n```\r\nSet the description of the specified role // 设置指定角色的描述\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name or desc is illegal. // 如果角色名称或描述不合法，则抛出 InputError。\r\n\r\n参数\n\n该块内容位于文档中与`lgraph`相关的权限管理功能部分，特别是涉及角色的启用、描述设置以及错误处理机制的函数定义和参数说明。这部分提供了用户在设置角色权限时所需的操作方法和注意事项。"
            },
            {
                "content": "True if it succeeds, false if role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\r\nbool SetRoleDesc(const std::string &role, const std::string &desc)\r\n```\r\nSet the description of the specified role // 设置指定角色的描述\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name or desc is illegal. // 如果角色名称或描述不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。  \r\ndesc – The description. // desc – 描述。\r\n\r\n返回  \r\nTrue if it succeeds, false if role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\r\nbool SetRoleAccessRights(const std::string &role, const std::map &graph_access)\r\n```\r\nSet access of the role to graphs. If you need to add or remove access to part of the graphs, you need to get full graph_access map by using GetRoleInfo first. // 设置角色对图形的访问权限。如果需要添加或删除对部分图形的访问权限，必须先通过 GetRoleInfo 获取完整的 graph_access 映射。\r\n\r\n抛出\n\n该块内容位于文档的 lgraph_types 章节中，具体涉及角色管理的功能，包括设置角色描述和访问权限的方法。这些方法定义了如何在 TuGraph 中操作用户角色的访问权，并确保用户在执行这些操作时遵循相应的权限和限制。"
            },
            {
                "content": "role – The role. // role – 角色名称。  \r\ndesc – The description. // desc – 描述。\r\n\r\n返回  \r\nTrue if it succeeds, false if role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\r\nbool SetRoleAccessRights(const std::string &role, const std::map &graph_access)\r\n```\r\nSet access of the role to graphs. If you need to add or remove access to part of the graphs, you need to get full graph_access map by using GetRoleInfo first. // 设置角色对图形的访问权限。如果需要添加或删除对部分图形的访问权限，必须先通过 GetRoleInfo 获取完整的 graph_access 映射。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name or any of the graph name is illegal. // 如果角色名称或任何图形名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。  \r\ngraph_access – The graph access. // graph_access – 图形访问权限。\r\n\r\n返回  \r\nTrue if it succeeds, false if role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\n\n该代码块位于文档的“lgraph_types”部分，介绍了角色管理相关的函数，例如设置角色的访问权限及其参数和返回值。此外，它还描述了在执行这些操作时可能抛出的异常和错误处理。"
            },
            {
                "content": "抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name or any of the graph name is illegal. // 如果角色名称或任何图形名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。  \r\ngraph_access – The graph access. // graph_access – 图形访问权限。\r\n\r\n返回  \r\nTrue if it succeeds, false if role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\r\nbool SetRoleAccessRightsIncremental(const std::string &role, const std::map &graph_access)\r\n```\n\n该代码块位于文档的“lgraph_galaxy”部分，具体在描述“Galaxy”类的成员函数`SetRoleAccessRightsIncremental`时，用于设置指定角色对图形的访问权限。代码块中详细说明了抛出的异常类型、参数及返回值，旨在帮助用户理解函数的用法和可能遇到的错误。"
            },
            {
                "content": "Unauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name or any of the graph name is illegal. // 如果角色名称或任何图形名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。  \r\ngraph_access – The graph access. // graph_access – 图形访问权限。\r\n\r\n返回  \r\nTrue if it succeeds, false if role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\r\nbool SetRoleAccessRightsIncremental(const std::string &role, const std::map &graph_access)\r\n```\r\nIncrementally modify the access right of the specified role. For example, for a role that has access right {graph1:READ, graph2:WRITE}, calling this function with graph_access={graph2:READ, graph3:FULL} will set the access right of this role to {graph1:READ, graph2:READ, graph3:FULL} // 逐步修改指定角色的访问权限。例如，对于一个访问权限为 {graph1:READ, graph2:WRITE} 的角色，调用此函数并传入 graph_access={graph2:READ, graph3:FULL} 将把该角色的访问权限设置为 {graph1:READ, graph2:READ, graph3:FULL}。\r\n\r\n抛出\n\n该片段位于文档中的 `lgraph_galaxy` 部分，具体是在描述如何设置角色访问权限的函数 `SetRoleAccessRightsIncremental` 的上下文中。这里解释了当用户没有权限时抛出的 `Unauthorized` 异常以及当角色名称或图形名称不合法时抛出的 `InputError` 异常，同时详细描述了相关参数和返回值的含义。"
            },
            {
                "content": "```\r\nIncrementally modify the access right of the specified role. For example, for a role that has access right {graph1:READ, graph2:WRITE}, calling this function with graph_access={graph2:READ, graph3:FULL} will set the access right of this role to {graph1:READ, graph2:READ, graph3:FULL} // 逐步修改指定角色的访问权限。例如，对于一个访问权限为 {graph1:READ, graph2:WRITE} 的角色，调用此函数并传入 graph_access={graph2:READ, graph3:FULL} 将把该角色的访问权限设置为 {graph1:READ, graph2:READ, graph3:FULL}。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name or any of the graph name is illegal. // 如果角色名称或任何图形名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。  \r\ngraph_access – The graph access. // graph_access – 图形访问权限。\r\n\r\n返回  \r\nTrue if it succeeds, false if role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\r\nRoleInfo GetRoleInfo(const std::string &role) const\r\n```\n\n该内容位于文档中关于权限管理的部分，特别是描述如何逐步修改特定角色在图数据库中的访问权限，并提到了与图形访问相关的异常处理和参数设置。"
            },
            {
                "content": "Unauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name or any of the graph name is illegal. // 如果角色名称或任何图形名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。  \r\ngraph_access – The graph access. // graph_access – 图形访问权限。\r\n\r\n返回  \r\nTrue if it succeeds, false if role does not exist. // 成功返回 True，如果角色不存在则返回 false。\r\n\r\n```cpp\r\nRoleInfo GetRoleInfo(const std::string &role) const\r\n```\r\nGets role information // 获取角色信息\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name is illegal. // 如果角色名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。\r\n\r\n返回  \r\nThe role information. // 返回角色信息。\r\n\r\n```cpp\r\nstd::map ListRoles() const\r\n```\r\nList all the roles // 列出所有角色\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\n\n该区块位于文档中关于用户和角色管理的部分，特别是涉及图数据库的权限控制和角色信息检索的内容。它描述了在进行角色操作时可能抛出的异常，包括未授权访问和输入错误，并提供了获取角色信息和列出所有角色的函数定义。"
            },
            {
                "content": "Unauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if role name is illegal. // 如果角色名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nrole – The role. // role – 角色名称。\r\n\r\n返回  \r\nThe role information. // 返回角色信息。\r\n\r\n```cpp\r\nstd::map ListRoles() const\r\n```\r\nList all the roles // 列出所有角色\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\n返回  \r\nA dictionary of {role_name:RoleInfo} // 返回一个字典，格式为 {角色名称:角色信息}\r\n\r\n```cpp\r\nAccessLevel GetAccessLevel(const std::string &user, const std::string &graph) const\r\n```\r\nGet the access level that the specified user have to the graph // 获取指定用户对图形的访问级别\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\n\n该代码块位于 TuGraph 文档中的用户与角色权限管理部分，描述了在进行角色管理操作（如列出角色和获取用户访问级别）时可能抛出的异常，包括用户无权限和角色名称不合法的情况。这些内容帮助开发者理解在权限检查和角色管理中可能遇到的错误及其处理方式。"
            },
            {
                "content": "返回  \r\nA dictionary of {role_name:RoleInfo} // 返回一个字典，格式为 {角色名称:角色信息}\r\n\r\n```cpp\r\nAccessLevel GetAccessLevel(const std::string &user, const std::string &graph) const\r\n```\r\nGet the access level that the specified user have to the graph // 获取指定用户对图形的访问级别\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if user name or graph name is illegal. // 如果用户名或图形名称不合法，则抛出 InputError。\r\n\r\n参数  \r\nuser – The user. // user – 用户名。  \r\ngraph – The graph. // graph – 图形名称。\r\n\r\n返回  \r\nThe access level. // 返回访问级别。\r\n\r\n```cpp\r\nGraphDB OpenGraph(const std::string &graph, bool read_only = false) const\r\n```\r\nOpens a graph. // 打开一个图形。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\n\n该段落位于文档的权限管理部分，描述了如何获取用户对图形的访问级别，包括相关的异常处理和参数说明，涉及到用户和图形的权限控制。"
            },
            {
                "content": "参数  \r\nuser – The user. // user – 用户名。  \r\ngraph – The graph. // graph – 图形名称。\r\n\r\n返回  \r\nThe access level. // 返回访问级别。\r\n\r\n```cpp\r\nGraphDB OpenGraph(const std::string &graph, bool read_only = false) const\r\n```\r\nOpens a graph. // 打开一个图形。\r\n\r\n抛出  \r\nInvalidGalaxy – Thrown if current galaxy is invalid. // 如果当前的 galaxy 无效，则抛出 InvalidGalaxy。\r\n\r\nUnauthorized – Thrown if user does not have permission. // 如果用户没有权限，则抛出 Unauthorized。\r\n\r\nInputError – Thrown if graph name is illegal. // 如果图形名称不合法，则抛出 InputError。\r\n\r\n参数  \r\ngraph – The graph. // graph – 图形名称。  \r\nread_only – (Optional) True to open in read-only mode. A read-only GraphDB cannot be written to. // read_only – （可选）若为 True，则以只读模式打开。只读的 GraphDB 不能被写入。\r\n\r\n返回  \r\nA GraphDB. // 返回一个 GraphDB。\r\n\r\n```cpp\r\nvoid Close()\r\n```\r\nCloses this Galaxy, turning it into an invalid state. // 关闭这个 Galaxy，将其变为无效状态。\r\n\r\n#### Private Functions\r\n\r\n```cpp\r\nexplicit Galaxy(lgraph::Galaxy *db)\r\n```\r\n\r\n```cpp\r\ninline Galaxy(const Galaxy&)\r\n```\r\n\r\n```cpp\r\ninline Galaxy &operator=(const Galaxy&)\n\n该块内容位于文档的`lgraph_types`部分，涉及处理图形数据库的权限和用户管理，包括打开图形和关闭银河的相关函数以及可能抛出的异常。这些函数定义了如何通过用户权限在图形数据库中操作和管理图形。"
            },
            {
                "content": "graph – The graph. // graph – 图形名称。  \r\nread_only – (Optional) True to open in read-only mode. A read-only GraphDB cannot be written to. // read_only – （可选）若为 True，则以只读模式打开。只读的 GraphDB 不能被写入。\r\n\r\n返回  \r\nA GraphDB. // 返回一个 GraphDB。\r\n\r\n```cpp\r\nvoid Close()\r\n```\r\nCloses this Galaxy, turning it into an invalid state. // 关闭这个 Galaxy，将其变为无效状态。\r\n\r\n#### Private Functions\r\n\r\n```cpp\r\nexplicit Galaxy(lgraph::Galaxy *db)\r\n```\r\n\r\n```cpp\r\ninline Galaxy(const Galaxy&)\r\n```\r\n\r\n```cpp\r\ninline Galaxy &operator=(const Galaxy&)\r\n```\r\n\r\n#### Private Members\r\n\r\n```cpp\r\nstd::string user_\r\n```\r\n\r\n```cpp\r\nlgraph::Galaxy *db_\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_result\r\n\r\nResult interface for plugins and built-in procedures. The result of a plugin should be provided in this format in order for the Cypher engine and the graph visualizer to understand.  \r\n结果接口用于插件和内置过程。插件的结果应以这种格式提供，以便 Cypher 引擎和图形可视化工具能够理解。\r\n\r\n### Namespace\r\n- `namespace lgraph`  \r\n- `namespace cypher`  \r\n- `namespace lgraph_api`  \r\n\r\n### Typedefs\r\n```cpp\n\n该代码块位于文档中的“lgraph_galaxy”部分，介绍了用于在只读模式下打开图形数据库（GraphDB）的构造函数及其在关闭时使对象变为无效状态的功能。上下文包含了与图数据库接口和事务管理相关的内容。"
            },
            {
                "content": "```\r\n\r\n#### Private Members\r\n\r\n```cpp\r\nstd::string user_\r\n```\r\n\r\n```cpp\r\nlgraph::Galaxy *db_\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_result\r\n\r\nResult interface for plugins and built-in procedures. The result of a plugin should be provided in this format in order for the Cypher engine and the graph visualizer to understand.  \r\n结果接口用于插件和内置过程。插件的结果应以这种格式提供，以便 Cypher 引擎和图形可视化工具能够理解。\r\n\r\n### Namespace\r\n- `namespace lgraph`  \r\n- `namespace cypher`  \r\n- `namespace lgraph_api`  \r\n\r\n### Typedefs\r\n```cpp\r\ntypedef std::unordered_map> NODEMAP\r\n```\r\n```cpp\r\ntypedef std::unordered_map, EdgeUid::Hash> RELPMAP\r\n```\r\n\r\n### Class Record\r\n```cpp\r\n#include \r\n```\r\nYou only initialize the class by Result instance. Record provides some insert methods to insert data into the record, e.g., Insert, InsertVertexByID, InsertEdgeByID.  \r\n您只能通过 Result 实例初始化类。Record 提供了一些插入方法将数据插入记录，例如：Insert、InsertVertexByID、InsertEdgeByID。\r\n\r\n#### Public Functions\r\n```cpp\r\nRecord(const Record&)\r\n```\r\n```cpp\r\nRecord(Record&&)\r\n```\r\n```cpp\n\n该代码块位于文档的“lgraph_rpc_client”部分后，描述了“lgraph_result”类及其相关的接口和方法，主要用于插件和内置过程的结果处理，并包括记录插入和处理的相关细节。同时，文档中涉及到“用户”和“数据库”相关的私有成员变量定义。"
            },
            {
                "content": "typedef std::unordered_map> NODEMAP\r\n```\r\n```cpp\r\ntypedef std::unordered_map, EdgeUid::Hash> RELPMAP\r\n```\r\n\r\n### Class Record\r\n```cpp\r\n#include \r\n```\r\nYou only initialize the class by Result instance. Record provides some insert methods to insert data into the record, e.g., Insert, InsertVertexByID, InsertEdgeByID.  \r\n您只能通过 Result 实例初始化类。Record 提供了一些插入方法将数据插入记录，例如：Insert、InsertVertexByID、InsertEdgeByID。\r\n\r\n#### Public Functions\r\n```cpp\r\nRecord(const Record&)\r\n```\r\n```cpp\r\nRecord(Record&&)\r\n```\r\n```cpp\r\nRecord &operator=(const Record&)\r\n```\r\n```cpp\r\nRecord &operator=(Record&&)\r\n```\r\n```cpp\r\nvoid Insert(const std::string &fname, const FieldData &fv)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – Field name you defined earlier.  // fname - 您之前定义的字段名  \r\nfv – Field value.  // fv - 字段值\r\n\r\n```cpp\n\n该块内容位于文档的 `lgraph_result` 部分，主要介绍了表示结果的 `Record` 类及其公共函数和方法。它描述了如何通过 `Result` 实例初始化 `Record` 类，并提供了一些用于插入数据的方法，如插入字段值和操作记录的函数。"
            },
            {
                "content": "```\r\n```cpp\r\nRecord(Record&&)\r\n```\r\n```cpp\r\nRecord &operator=(const Record&)\r\n```\r\n```cpp\r\nRecord &operator=(Record&&)\r\n```\r\n```cpp\r\nvoid Insert(const std::string &fname, const FieldData &fv)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – Field name you defined earlier.  // fname - 您之前定义的字段名  \r\nfv – Field value.  // fv - 字段值\r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, const int64_t vid, lgraph_api::Transaction *txn)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier. You can get properties and labels from the interface; this is different from InsertVertexByID.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。您可以通过接口获取属性和标签，这与 InsertVertexByID 不同。\r\n\r\n参数  \r\nfname – Title name you defined earlier.  // fname - 您之前定义的标题名称  \r\nvid – VertexId  // vid - 顶点 ID\n\n该代码块位于文档中关于 `Result` 类的部分，描述了 `Record` 类的构造函数和赋值运算符，以及插入值到结果表的方法。此部分提供了如何操作结果表和记录的数据结构的详细信息。"
            },
            {
                "content": "```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier. You can get properties and labels from the interface; this is different from InsertVertexByID.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。您可以通过接口获取属性和标签，这与 InsertVertexByID 不同。\r\n\r\n参数  \r\nfname – Title name you defined earlier.  // fname - 您之前定义的标题名称  \r\nvid – VertexId  // vid - 顶点 ID  \r\ntxn – Transaction  // txn - 事务  \r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, EdgeUid &euid, lgraph_api::Transaction *txn)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier. You can get properties and labels from the interface; this is different from InsertEdgeByID.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。您可以通过接口获取属性和标签，这与 InsertEdgeByID 不同。\r\n\r\n参数  \r\nfname – Title name you defined earlier.  // fname - 您之前定义的标题名称  \r\neuid – EdgeUid  // euid - 边 UID\n\n此段落位于文档中关于 lgraph_result 类的部分，具体描述了如何将值插入结果表，并提供了相关的插入函数示例。通过这些函数，用户可以将顶点或边的信息添加到结果集中，同时提及了属性和标签的获取方式，以供用户进行更复杂的操作和查询。"
            },
            {
                "content": "```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier. You can get properties and labels from the interface; this is different from InsertEdgeByID.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。您可以通过接口获取属性和标签，这与 InsertEdgeByID 不同。\r\n\r\n参数  \r\nfname – Title name you defined earlier.  // fname - 您之前定义的标题名称  \r\neuid – EdgeUid  // euid - 边 UID  \r\ntxn – Transaction  // txn - 事务  \r\n\r\n```cpp\r\nvoid InsertVertexByID(const std::string &fname, int64_t vid)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – Field name you defined earlier.  // fname - 您之前定义的字段名  \r\nvid – VertexId.  // vid - 顶点 ID\r\n\r\n```cpp\r\nvoid InsertEdgeByID(const std::string &fname, const EdgeUid &uid)\r\n```\n\n该块内容位于文档中关于结果接口和记录处理的部分，具体描述了如何将值插入结果表，包括插入顶点和边的操作。它详细列出了插入函数的参数，包括字段名称和边的唯一标识符 (EdgeUid)，并强调了与插入顶点和边的不同点。"
            },
            {
                "content": "txn – Transaction  // txn - 事务  \r\n\r\n```cpp\r\nvoid InsertVertexByID(const std::string &fname, int64_t vid)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – Field name you defined earlier.  // fname - 您之前定义的字段名  \r\nvid – VertexId.  // vid - 顶点 ID\r\n\r\n```cpp\r\nvoid InsertEdgeByID(const std::string &fname, const EdgeUid &uid)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – Title name you defined earlier.  // fname - 您之前定义的标题名称  \r\nuid – EdgeUid.  // uid - 边 UID\r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, const lgraph_api::VertexIterator &vit)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.\n\n该块内容位于文档的`lgraph_txn`部分，主要描述了与事务相关的功能，包括如何在结果表中插入顶点和边的相关方法。具体包括`InsertVertexByID`和`InsertEdgeByID`函数，以及参数说明，方便用户了解如何进行操作和调用。"
            },
            {
                "content": "将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – Title name you defined earlier.  // fname - 您之前定义的标题名称  \r\nuid – EdgeUid.  // uid - 边 UID\r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, const lgraph_api::VertexIterator &vit)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – One of the title names you defined earlier.  // fname - 您之前定义的标题名称之一  \r\nvit – VertexIterator.  // vit - 顶点迭代器\r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, const lgraph_api::InEdgeIterator &ieit)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – One of the title names you defined earlier.  // fname - 您之前定义的标题名称之一  \r\nieit – InEdgeIterator.  // ieit - 入边迭代器\r\n\r\n```cpp\n\n这个chunk位于文档的结果接口部分，具体描述了如何在结果表中插入值，包括对不同类型迭代器（如VertexIterator和InEdgeIterator）的操作说明。"
            },
            {
                "content": "vit – VertexIterator.  // vit - 顶点迭代器\r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, const lgraph_api::InEdgeIterator &ieit)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – One of the title names you defined earlier.  // fname - 您之前定义的标题名称之一  \r\nieit – InEdgeIterator.  // ieit - 入边迭代器\r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, const lgraph_api::OutEdgeIterator &oeit)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – One of the title names you defined earlier.  // fname - 您之前定义的标题名称之一  \r\noeit – OutEdgeIterator.  // oeit - 出边迭代器\r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, const std::vector &list)\r\n```\n\n该文本块位于文档的“lgraph_result”部分，主要描述了`Record`类的插入方法，包括如何使用`InEdgeIterator`和`OutEdgeIterator`将边数据插入结果表中。这些方法为图形数据库中的边缘处理提供了具体的实现示例，能够帮助用户在图的分析与操作中有效地管理顶点和边信息。"
            },
            {
                "content": "```cpp\r\nvoid Insert(const std::string &fname, const lgraph_api::OutEdgeIterator &oeit)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – One of the title names you defined earlier.  // fname - 您之前定义的标题名称之一  \r\noeit – OutEdgeIterator.  // oeit - 出边迭代器\r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, const std::vector &list)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – One of the title names you defined earlier.  // fname - 您之前定义的标题名称之一  \r\nlist – List of FieldData.  // list - FieldData 的列表\r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, const std::map ↦)\r\n```\n\n该代码块位于文档中 `lgraph_result` 类的部分，具体描述了结果表的插入方法，包括向结果表插入出边迭代器和字段数据列表的方法。这些函数允许用户在图数据库的结果处理中灵活地添加数据，使其能够更好地与插入的元数据匹配。"
            },
            {
                "content": "```cpp\r\nvoid Insert(const std::string &fname, const std::vector &list)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – One of the title names you defined earlier.  // fname - 您之前定义的标题名称之一  \r\nlist – List of FieldData.  // list - FieldData 的列表\r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, const std::map ↦)\r\n```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – One of the title names you defined earlier.  // fname - 您之前定义的标题名称之一  \r\nmap – Map of   // map -  的映射\r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, const traversal::Path &path, lgraph_api::Transaction *txn, NODEMAP &node_map, RELPMAP &relp_map)\r\n```\n\n该代码块位于文档中关于`Result`类的部分，`Result`类提供了一系列插入数据到结果表的方法。代码块中的方法定义了如何插入不同类型的数据（如字符串和映射）到结果表，并说明了每个方法的参数和功能。这些方法用于处理图分析结果，以便在后续操作中使用。"
            },
            {
                "content": "```\r\nInsert a value to the result table. You can insert a value by the insert function, and the value type must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过插入函数插入一个值，且值的类型必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – One of the title names you defined earlier.  // fname - 您之前定义的标题名称之一  \r\nmap – Map of   // map -  的映射\r\n\r\n```cpp\r\nvoid Insert(const std::string &fname, const traversal::Path &path, lgraph_api::Transaction *txn, NODEMAP &node_map, RELPMAP &relp_map)\r\n```\r\nInsert value into the result table. You can insert a value by the function, and the value must be the same as you defined earlier.  \r\n将值插入结果表。您可以通过该函数插入值，且该值必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – One of the title names you defined earlier.  // fname - 您之前定义的标题名称之一  \r\npath – Path of traverse API.  // path - 遍历 API 的路径  \r\ntxn – Transaction  // txn - 事务  \r\n\r\n```cpp\r\ninline int64_t Size() const\r\n```\r\nGet the size of the record. If the record is empty, return 0; max size is not beyond the length of your defined param list.  \r\n获取记录的大小。如果记录为空，则返回 0；最大大小不超过您定义的参数列表的长度。\n\n该块位于文档中关于记录和结果表的部分，具体描述了如何将值插入结果表的方法以及相关参数，尤其涉及到使用路径（Path）和事务（Transaction）对象插入数据的函数定义和说明。通过此块，可以理解在TuGraph图分析中如何有效地处理结果数据。"
            },
            {
                "content": "将值插入结果表。您可以通过该函数插入值，且该值必须与您之前定义的相同。\r\n\r\n参数  \r\nfname – One of the title names you defined earlier.  // fname - 您之前定义的标题名称之一  \r\npath – Path of traverse API.  // path - 遍历 API 的路径  \r\ntxn – Transaction  // txn - 事务  \r\n\r\n```cpp\r\ninline int64_t Size() const\r\n```\r\nGet the size of the record. If the record is empty, return 0; max size is not beyond the length of your defined param list.  \r\n获取记录的大小。如果记录为空，则返回 0；最大大小不超过您定义的参数列表的长度。\r\n\r\n返回  \r\nSize of record.  // 返回：记录的大小\r\n\r\n```cpp\r\ninline bool HasKey(const std::string &key) const\r\n```\r\nCheck if a key exists or not. The key is one of the titles you defined earlier.  \r\n检查某个键是否存在。该键是您之前定义的标题之一。\r\n\r\n参数  \r\nkey – The key.  // key - 键\r\n\r\n返回  \r\nTrue if exists, otherwise false.  // 如果存在则返回真，否则返回假。\r\n\r\n#### Private Functions\r\n```cpp\r\nexplicit Record(const std::vector>&)\r\n```\r\n\r\n#### Private Members\r\n```cpp\r\nstd::unordered_map> record\r\n```\r\n```cpp\r\nstd::unordered_map header\r\n```\r\n```cpp\r\nint64_t length_\r\n```\r\n\r\n#### Friends\r\nfriend class Result\r\n\r\n### Class Result\r\n```cpp\r\n#include\n\n该代码块位于文档中关于 `Result` 类和 `Record` 类的部分，主要描述如何将值插入结果表，获取记录的大小，以及检查键是否存在的相关方法。它提供了对结果表操作的详细描述，适用于插件和内置过程的返回结果。"
            },
            {
                "content": "```\r\nCheck if a key exists or not. The key is one of the titles you defined earlier.  \r\n检查某个键是否存在。该键是您之前定义的标题之一。\r\n\r\n参数  \r\nkey – The key.  // key - 键\r\n\r\n返回  \r\nTrue if exists, otherwise false.  // 如果存在则返回真，否则返回假。\r\n\r\n#### Private Functions\r\n```cpp\r\nexplicit Record(const std::vector>&)\r\n```\r\n\r\n#### Private Members\r\n```cpp\r\nstd::unordered_map> record\r\n```\r\n```cpp\r\nstd::unordered_map header\r\n```\r\n```cpp\r\nint64_t length_\r\n```\r\n\r\n#### Friends\r\nfriend class Result\r\n\r\n### Class Result\r\n```cpp\r\n#include \r\n```\r\nResult table, result instance provides [MutableRecord], [ResetHeader], [Dump], and [Load] methods. The table also provides some methods to view the content of the table. For example, [Header] and [Recordview].  \r\n结果表，结果实例提供 [MutableRecord]、[ResetHeader]、[Dump] 和 [Load] 方法。该表还提供一些方法以查看表的内容。例如， [Header] 和 [Recordview]。\n\n该块内容位于文档中关于 `lgraph_types` 和 `lgraph_result` 的部分，描述了如何检查键是否存在的函数及其参数和返回值。此外，还涉及了 `Record` 类的私有函数、私有成员和与之相关的 `Result` 类的介绍，为用户提供了结果表的操作接口和相关功能。"
            },
            {
                "content": "std::unordered_map> record\r\n```\r\n```cpp\r\nstd::unordered_map header\r\n```\r\n```cpp\r\nint64_t length_\r\n```\r\n\r\n#### Friends\r\nfriend class Result\r\n\r\n### Class Result\r\n```cpp\r\n#include \r\n```\r\nResult table, result instance provides [MutableRecord], [ResetHeader], [Dump], and [Load] methods. The table also provides some methods to view the content of the table. For example, [Header] and [Recordview].  \r\n结果表，结果实例提供 [MutableRecord]、[ResetHeader]、[Dump] 和 [Load] 方法。该表还提供一些方法以查看表的内容。例如， [Header] 和 [Recordview]。\r\n\r\nIt’s worth noting that you are best to define your header before using the result table. e.g., `auto result = Result({title, LGraphType}…)` If you do not define the header and initialize by Result(), you will get an empty table without a header; you just use the table after using [ResetHeader] method to set your header.  \r\n值得注意的是，您最好在使用结果表之前定义您的头部。例如， `auto result = Result({title, LGraphType}…)` 如果您没有定义头部并通过 Result() 初始化，您将得到一个没有头部的空表；您只能在使用 [ResetHeader] 方法设置头部后使用该表。\r\n\r\n#### Public Functions\r\n```cpp\r\nResult()\n\n该代码块位于文档的“lgraph_result”部分，描述了“Result”类的相关实现和功能，包括结果表的定义、公共函数以及如何初始化和使用结果表。同时提到了在使用结果表之前定义头部的重要性，以确保结果表的正确结构。"
            },
            {
                "content": "值得注意的是，您最好在使用结果表之前定义您的头部。例如， `auto result = Result({title, LGraphType}…)` 如果您没有定义头部并通过 Result() 初始化，您将得到一个没有头部的空表；您只能在使用 [ResetHeader] 方法设置头部后使用该表。\r\n\r\n#### Public Functions\r\n```cpp\r\nResult()\r\n```\r\n构造函数，初始化一个结果对象。\r\n\r\n```cpp\r\nResult(const std::initializer_list>&)\r\n```\r\n使用初始化列表构造结果对象。\r\n\r\n```cpp\r\nexplicit Result(const std::vector>&)\r\n```\r\n使用向量构造结果对象，参数为一对字符串和LGraphType的向量。\r\n\r\n```cpp\r\nLGraphType GetType(std::string title)\r\n```\r\nGet the type of the title.  \r\n获取标题的类型。\r\n\r\n参数  \r\ntitle – One of the titles in the table.  \r\n标题 - 表格中的一个标题。\r\n\r\n返回  \r\nLGraphType.  \r\n返回LGraphType。\r\n\r\n```cpp\r\nvoid ResetHeader(const std::vector> &header)\r\n```\r\nReset your header; the operation will clear the original data and header. Please use the function carefully.  \r\n重置你的表头；该操作将清除原始数据和表头。请小心使用该函数。\r\n\r\n参数  \r\nheader – List of   \r\n表头 – <标题, LGraphType> 的列表。\r\n\r\n```cpp\r\nvoid ResetHeader(const std::initializer_list> &header)\r\n```\r\nReset your header; the operation will clear the original data and header. Please use the function carefully.\n\n该段落位于文档的 `lgraph_result` 部分，主要讨论了如何使用结果表的构造函数、重置头部以及获取标题类型等公共函数。这些函数对于在 TuGraph 中实现插件或图分析的重要性明显，并提供了关于如何正确使用结果对象的指导。"
            },
            {
                "content": "标题 - 表格中的一个标题。\r\n\r\n返回  \r\nLGraphType.  \r\n返回LGraphType。\r\n\r\n```cpp\r\nvoid ResetHeader(const std::vector> &header)\r\n```\r\nReset your header; the operation will clear the original data and header. Please use the function carefully.  \r\n重置你的表头；该操作将清除原始数据和表头。请小心使用该函数。\r\n\r\n参数  \r\nheader – List of   \r\n表头 – <标题, LGraphType> 的列表。\r\n\r\n```cpp\r\nvoid ResetHeader(const std::initializer_list> &header)\r\n```\r\nReset your header; the operation will clear the original data and header. Please use the function carefully.  \r\n重置你的表头；该操作将清除原始数据和表头。请小心使用该函数。\r\n\r\n参数  \r\nheader – List of   \r\n表头 – <标题, LGraphType> 的列表。\r\n\r\n```cpp\r\nRecord *MutableRecord()\r\n```\r\nCreate a new record in the table and return the record. The record is a reference of the record in the table; if you want to modify the record, you must assign the return value to a reference variable.  \r\n在表中创建新记录并返回该记录。该记录是表中记录的引用；如果要修改该记录，必须将返回值分配给引用变量。\r\n\r\n返回  \r\nThe reference of the record.  \r\n记录的引用。\r\n\r\n```cpp\r\nvoid Reserve(size_t n)\r\n```\n\n该块内容位于文档的lgraph_types部分，主要涉及FieldSpec和Result类的定义。它介绍了如何重置表头，以及如何创建和修改记录。这些函数在图数据库操作中用于管理和访问记录数据。"
            },
            {
                "content": "重置你的表头；该操作将清除原始数据和表头。请小心使用该函数。\r\n\r\n参数  \r\nheader – List of   \r\n表头 – <标题, LGraphType> 的列表。\r\n\r\n```cpp\r\nRecord *MutableRecord()\r\n```\r\nCreate a new record in the table and return the record. The record is a reference of the record in the table; if you want to modify the record, you must assign the return value to a reference variable.  \r\n在表中创建新记录并返回该记录。该记录是表中记录的引用；如果要修改该记录，必须将返回值分配给引用变量。\r\n\r\n返回  \r\nThe reference of the record.  \r\n记录的引用。\r\n\r\n```cpp\r\nvoid Reserve(size_t n)\r\n```\r\nThis function attempts to reserve enough memory for the result vector to hold the specified number of elements.  \r\n该函数尝试为结果向量预留足够的内存以容纳指定数量的元素。\r\n\r\n```cpp\r\nvoid Resize(size_t n)\r\n```\r\nThis function will resize the vector to the specified number of elements.  \r\n该函数将向量调整为指定数量的元素。\r\n\r\n```cpp\r\nRecord *At(size_t n)\r\n```\r\nProvides access to the data contained in the vector.  \r\n提供对向量中包含的数据的访问。\r\n\r\n```cpp\r\nconst std::vector> &Header() const\r\n```\r\nReturn the header of the table.  \r\n返回表头。\r\n\r\n返回  \r\nHeader.  \r\n表头。\r\n\r\n```cpp\r\nint64_t Size() const\r\n```\n\n该片段位于文档中的“lgraph_result”部分，涉及结果表的管理和操作方法，包括重置表头、创建新记录、内存预留、调整大小和访问记录等功能。这些功能是TuGraph在执行查询和操作时管理结果数据的重要组成部分。"
            },
            {
                "content": "该函数尝试为结果向量预留足够的内存以容纳指定数量的元素。\r\n\r\n```cpp\r\nvoid Resize(size_t n)\r\n```\r\nThis function will resize the vector to the specified number of elements.  \r\n该函数将向量调整为指定数量的元素。\r\n\r\n```cpp\r\nRecord *At(size_t n)\r\n```\r\nProvides access to the data contained in the vector.  \r\n提供对向量中包含的数据的访问。\r\n\r\n```cpp\r\nconst std::vector> &Header() const\r\n```\r\nReturn the header of the table.  \r\n返回表头。\r\n\r\n返回  \r\nHeader.  \r\n表头。\r\n\r\n```cpp\r\nint64_t Size() const\r\n```\r\nReturn size of the table.  \r\n返回表的大小。\r\n\r\n返回  \r\nTable size.  \r\n表的大小。\r\n\r\n```cpp\r\nstd::string Dump(bool is_standard = true)\r\n```\r\nSerialize the table.  \r\n序列化表。\r\n\r\n参数  \r\nis_standard – (Optional) If true, the result will serialize to a standard result; the standard result can be visualized in the web. If false, the result will serialize a JSON object — SDK result.  \r\nis_standard – （可选）如果为true，结果将序列化为标准结果；标准结果可以在网页上可视化。如果为false，结果将序列化为JSON对象 - SDK结果。\r\n\r\n返回  \r\nSerialize result.  \r\n序列化结果。\r\n\r\n```cpp\r\nvoid Load(const std::string &json)\r\n```\n\n该代码块位于TuGraph OLAP接口的文档部分，主要描述了结果表的操作，包括调整大小、访问数据、获取表头和大小，以及序列化和加载功能。这些功能用于实现图分析算法并管理数据的存储和访问。"
            },
            {
                "content": "返回表的大小。\r\n\r\n返回  \r\nTable size.  \r\n表的大小。\r\n\r\n```cpp\r\nstd::string Dump(bool is_standard = true)\r\n```\r\nSerialize the table.  \r\n序列化表。\r\n\r\n参数  \r\nis_standard – (Optional) If true, the result will serialize to a standard result; the standard result can be visualized in the web. If false, the result will serialize a JSON object — SDK result.  \r\nis_standard – （可选）如果为true，结果将序列化为标准结果；标准结果可以在网页上可视化。如果为false，结果将序列化为JSON对象 - SDK结果。\r\n\r\n返回  \r\nSerialize result.  \r\n序列化结果。\r\n\r\n```cpp\r\nvoid Load(const std::string &json)\r\n```\r\nDeserialize data to the result table. This will clear the original data and header; please use this function carefully.  \r\n将数据反序列化到结果表。 这将清除原始数据和表头；请小心使用此函数。\r\n\r\n参数  \r\njson – JSON string to be deserialized.  \r\njson – 要反序列化的JSON字符串。\r\n\r\n```cpp\r\nvoid ClearRecords()\r\n```\r\nClear all the records; Size() will be 0.  \r\n清除所有记录；Size()将为0。\r\n\r\n```cpp\r\nstd::vector BoltHeader()\r\n```\r\n```cpp\r\nstd::vector> BoltRecords()\r\n```\r\n```cpp\r\ninline void MarkPythonDriver(bool is_python_driver)\r\n```\n\n该块内容位于 lgraph_result 类中，主要描述了该类的功能，包括序列化和反序列化结果表、获取表大小以及清除记录等操作。这些功能可以帮助用户处理和管理图数据库中查询的结果数据。"
            },
            {
                "content": "```\r\nDeserialize data to the result table. This will clear the original data and header; please use this function carefully.  \r\n将数据反序列化到结果表。 这将清除原始数据和表头；请小心使用此函数。\r\n\r\n参数  \r\njson – JSON string to be deserialized.  \r\njson – 要反序列化的JSON字符串。\r\n\r\n```cpp\r\nvoid ClearRecords()\r\n```\r\nClear all the records; Size() will be 0.  \r\n清除所有记录；Size()将为0。\r\n\r\n```cpp\r\nstd::vector BoltHeader()\r\n```\r\n```cpp\r\nstd::vector> BoltRecords()\r\n```\r\n```cpp\r\ninline void MarkPythonDriver(bool is_python_driver)\r\n```\r\nMark that the result is returned to the Python driver. The Python driver is special, use the virtual edge id instead of the real edge id.  \r\n标记结果已返回给Python驱动程序。Python驱动程序是特殊的，使用虚拟边缘ID而不是实际边缘ID。\r\n\r\n#### Private Functions\r\n```cpp\r\nconst std::unordered_map> &RecordView(int64_t row_num)\r\n```\r\nGet record of the table; if row number is more significant than the max length of the table, throw an exception.  \r\n获取表的记录；如果行号大于表的最大长度，抛出异常。\r\n\r\n参数  \r\nrow_num – Row number of the table.  \r\nrow_num – 表的行号。\r\n\r\n返回  \r\nOne Record.  \r\n一个记录。\n\n该内容位于文档的 `lgraph_result` 部分，主要描述了结果表的操作，包括如何将数据反序列化到结果表、清除所有记录以及用于Python驱动程序的标记。这部分内容针对图数据库操作的结果处理和记录管理提供了详细的函数定义和参数解释。"
            },
            {
                "content": "标记结果已返回给Python驱动程序。Python驱动程序是特殊的，使用虚拟边缘ID而不是实际边缘ID。\r\n\r\n#### Private Functions\r\n```cpp\r\nconst std::unordered_map> &RecordView(int64_t row_num)\r\n```\r\nGet record of the table; if row number is more significant than the max length of the table, throw an exception.  \r\n获取表的记录；如果行号大于表的最大长度，抛出异常。\r\n\r\n参数  \r\nrow_num – Row number of the table.  \r\nrow_num – 表的行号。\r\n\r\n返回  \r\nOne Record.  \r\n一个记录。\r\n\r\n#### Private Members\r\n```cpp\r\nstd::vector result\r\n```\r\n记录结果的向量。\r\n\r\n```cpp\r\nstd::vector> header\r\n```\r\n表头，存储标题与LGraphType的配对。\r\n\r\n```cpp\r\nint64_t row_count_\r\n```\r\n记录行数。\r\n\r\n```cpp\r\nbool is_python_driver_ = false\r\n```\r\n指示是否为Python驱动程序的标志，默认为false。\r\n\r\n```cpp\r\nint64_t v_eid_ = 0\r\n```\r\n虚拟边缘ID，默认为0。\r\n\r\n#### Friends\r\nfriend class lgraph::StateMachine  \r\nfriend class cypher::PluginAdapter  \r\nnamespace lgraph_result  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_rpc_client\r\n\r\n```cpp\r\nnamespace fma_common\r\nnamespace lgraph_rpc\r\nnamespace lgraph\r\n```\r\n\r\n### Enums\r\n\r\n- **enum class GraphQueryType**\r\n  \r\n  **Values:**\n\n该块内容涵盖了 `lgraph_result` 类中的私有函数和成员的定义，主要关注记录结果的存储、访问和记录管理，尤其是针对Python驱动程序的特定实现。同时，后续内容介绍了 `lgraph_rpc_client` 的命名空间和图查询类型的枚举，显示了与图数据库的查询和通信相关的功能。"
            },
            {
                "content": "```\r\n表头，存储标题与LGraphType的配对。\r\n\r\n```cpp\r\nint64_t row_count_\r\n```\r\n记录行数。\r\n\r\n```cpp\r\nbool is_python_driver_ = false\r\n```\r\n指示是否为Python驱动程序的标志，默认为false。\r\n\r\n```cpp\r\nint64_t v_eid_ = 0\r\n```\r\n虚拟边缘ID，默认为0。\r\n\r\n#### Friends\r\nfriend class lgraph::StateMachine  \r\nfriend class cypher::PluginAdapter  \r\nnamespace lgraph_result  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_rpc_client\r\n\r\n```cpp\r\nnamespace fma_common\r\nnamespace lgraph_rpc\r\nnamespace lgraph\r\n```\r\n\r\n### Enums\r\n\r\n- **enum class GraphQueryType**\r\n  \r\n  **Values:**\r\n  - enumerator CYPHER  // 数据查询语言的枚举值，表示 Cypher 查询语言。\r\n  - enumerator GQL     // 数据查询语言的枚举值，表示 GQL 查询语言。\r\n\r\n- **enum ClientType**\r\n\r\n  **Values:**\r\n  - enumerator DIRECT_HA_CONNECTION      // 客户端类型，表示直接高可用性连接。\r\n  - enumerator INDIRECT_HA_CONNECTION     // 客户端类型，表示间接高可用性连接。\r\n  - enumerator SINGLE_CONNECTION           // 客户端类型，表示单一连接。\r\n\r\n### class RpcClient\r\n\r\n```cpp\r\n#include \r\n```\r\n\r\n### Public Functions\r\n\r\n- **explicit RpcClient(const std::string &url, const std::string &user, const std::string &password)**\n\n该片段位于文档的后半部分，涉及到 `Python` 驱动程序的标志、行数记录，以及关于 `lgraph_rpc_client` 类的定义和功能。此部分主要描述了图查询类型的枚举、客户端类型的枚举，以及 `RpcClient` 类及其公共函数的实现，为用户使用 TuGraph 提供了接口和配置选项。"
            },
            {
                "content": "- enumerator GQL     // 数据查询语言的枚举值，表示 GQL 查询语言。\r\n\r\n- **enum ClientType**\r\n\r\n  **Values:**\r\n  - enumerator DIRECT_HA_CONNECTION      // 客户端类型，表示直接高可用性连接。\r\n  - enumerator INDIRECT_HA_CONNECTION     // 客户端类型，表示间接高可用性连接。\r\n  - enumerator SINGLE_CONNECTION           // 客户端类型，表示单一连接。\r\n\r\n### class RpcClient\r\n\r\n```cpp\r\n#include \r\n```\r\n\r\n### Public Functions\r\n\r\n- **explicit RpcClient(const std::string &url, const std::string &user, const std::string &password)**  \r\n  RpcClient Login.  // 构造函数，用于登录。\r\n\r\n  **参数**\r\n  - url – Login address.  // 登录地址。\r\n  - user – The username.  // 用户名。\r\n  - password – The password.  // 密码。\r\n\r\n- **explicit RpcClient(std::vector &urls, std::string user, std::string password)**  \r\n  RpcClient Login.  // 构造函数，用于登录。\r\n\r\n  **参数**\r\n  - urls – Login address.  // 登录地址。\r\n  - user – The username.  // 用户名。\r\n  - password – The password.  // 密码。\r\n\r\n- **~RpcClient()**  // 析构函数。\n\n该块内容位于文档中有关lgraph库的RPC客户端部分，具体描述了客户端类型的枚举以及RpcClient类的构造函数和公共方法。这部分内容主要涉及与图数据库的交互和查询相关的功能。"
            },
            {
                "content": "RpcClient Login.  // 构造函数，用于登录。\r\n\r\n  **参数**\r\n  - url – Login address.  // 登录地址。\r\n  - user – The username.  // 用户名。\r\n  - password – The password.  // 密码。\r\n\r\n- **explicit RpcClient(std::vector &urls, std::string user, std::string password)**  \r\n  RpcClient Login.  // 构造函数，用于登录。\r\n\r\n  **参数**\r\n  - urls – Login address.  // 登录地址。\r\n  - user – The username.  // 用户名。\r\n  - password – The password.  // 密码。\r\n\r\n- **~RpcClient()**  // 析构函数。\r\n\r\n- **bool CallCypher(std::string &result, const std::string &cypher, const std::string &graph = \"default\", bool json_format = true, double timeout = 0, const std::string &url = \"\")**  \r\n  Execute a cypher query.  // 执行 Cypher 查询。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - cypher – [in] inquire statement.  // 输入查询语句。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 可选，返回格式，true 表示 JSON，否则为二进制格式。\n\n该块内容位于文档中关于TuGraph图数据库的RPC客户端接口部分，主要描述了`RpcClient`类的构造函数、登录机制以及执行Cypher查询的相关方法和参数。这些功能是连接和操作图数据库的基础，适合于用户在进行数据库交互时参考。"
            },
            {
                "content": "Execute a cypher query.  // 执行 Cypher 查询。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - cypher – [in] inquire statement.  // 输入查询语句。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 可选，返回格式，true 表示 JSON，否则为二进制格式。\r\n  - timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 可选，最大执行时间，超时将中断。\r\n  - url – [in] (Optional) Node address of calling cypher.  // 可选，调用 Cypher 的节点地址。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\r\n\r\n- **bool CallCypherToLeader(std::string &result, const std::string &cypher, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Execute a cypher query to leader.  // 执行 Cypher 查询到领导者。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - cypher – [in] inquire statement.  // 输入查询语句。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\n\n该片段位于文档中的 `lgraph_rpc_client` 类部分，主要描述如何执行 Cypher 查询以及相关参数设置。这一部分提供了与图数据库交互的接口，允许用户通过RPC调用执行图查询操作。"
            },
            {
                "content": "**返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\r\n\r\n- **bool CallCypherToLeader(std::string &result, const std::string &cypher, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Execute a cypher query to leader.  // 执行 Cypher 查询到领导者。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - cypher – [in] inquire statement.  // 输入查询语句。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 可选，返回格式，true 表示 JSON，否则为二进制格式。\r\n  - timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 可选，最大执行时间，超时将中断。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\r\n\r\n- **bool CallGql(std::string &result, const std::string &gql, const std::string &graph = \"default\", bool json_format = true, double timeout = 0, const std::string &url = \"\")**  \r\n  Execute a gql query.  // 执行 GQL 查询。\r\n\r\n  **参数**\n\n该片段位于文档的“lgraph_rpc_client”部分，涉及RPC客户端的功能，特别是执行Cypher和GQL查询的相关函数以及其参数和返回值的说明。这部分主要描述了如何通过RPC客户端与图数据库进行交互，包括发送查询、处理响应以及查询的格式选项。"
            },
            {
                "content": "- timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 可选，最大执行时间，超时将中断。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\r\n\r\n- **bool CallGql(std::string &result, const std::string &gql, const std::string &graph = \"default\", bool json_format = true, double timeout = 0, const std::string &url = \"\")**  \r\n  Execute a gql query.  // 执行 GQL 查询。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - gql – [in] inquire statement.  // 输入查询语句。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 可选，返回格式，true 表示 JSON，否则为二进制格式。\r\n  - timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 可选，最大执行时间，超时将中断。\r\n  - url – [in] (Optional) Node address of calling cypher.  // 可选，调用 GQL 的节点地址。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\n\n该块内容位于文档的“lgraph_rpc_client”部分，主要介绍了 GQL 查询的执行函数 `CallGql` 及其参数，包括结果、查询语句、图的指定、输出格式和超时等配置。这一部分适用于用户定义的过程和数据库的操作，帮助用户进行图形查询。"
            },
            {
                "content": "- gql – [in] inquire statement.  // 输入查询语句。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 可选，返回格式，true 表示 JSON，否则为二进制格式。\r\n  - timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 可选，最大执行时间，超时将中断。\r\n  - url – [in] (Optional) Node address of calling cypher.  // 可选，调用 GQL 的节点地址。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\r\n\r\n- **bool CallGqlToLeader(std::string &result, const std::string &gql, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Execute a gql query to leader.  // 执行 GQL 查询到领导者。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - gql – [in] inquire statement.  // 输入查询语句。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 可选，返回格式，true 表示 JSON，否则为二进制格式。\n\n该块内容位于文档中关于 TuGraph 的 RPC 客户端的部分，主要涵盖了执行 GQL 查询的相关函数及其参数，包括查询语句、图的选择、返回格式以及执行超时设置。这些函数用于与 TuGraph 数据库进行交互，以便进行图数据的查询和操作。"
            },
            {
                "content": "- **bool CallGqlToLeader(std::string &result, const std::string &gql, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Execute a gql query to leader.  // 执行 GQL 查询到领导者。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - gql – [in] inquire statement.  // 输入查询语句。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 可选，返回格式，true 表示 JSON，否则为二进制格式。\r\n  - timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 可选，最大执行时间，超时将中断。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\r\n\r\n- **bool CallProcedure(std::string &result, const std::string &procedure_type, const std::string &procedure_name, const std::string &param, double procedure_time_out = 0.0, bool in_process = false, const std::string &graph = \"default\", bool json_format = true, const std::string &url = \"\")**\n\n该块内容位于文档的lgraph_rpc_client部分，描述了在TuGraph中执行GQL查询和用户自定义过程的相关函数，包括执行GQL查询以获取结果、查询参数以及返回值的解释。这些函数提供了与图数据库交互的接口，支持异步和可选的图参数设置。"
            },
            {
                "content": "- timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 可选，最大执行时间，超时将中断。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\r\n\r\n- **bool CallProcedure(std::string &result, const std::string &procedure_type, const std::string &procedure_name, const std::string &param, double procedure_time_out = 0.0, bool in_process = false, const std::string &graph = \"default\", bool json_format = true, const std::string &url = \"\")**  \r\n  Execute a user-defined procedure.  // 执行用户自定义的过程。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - procedure_type – [in] the procedure type, currently supported CPP and PY.  // 输入过程类型，目前支持 CPP 和 PY。\r\n  - procedure_name – [in] procedure name.  // 输入过程名称。\r\n  - param – [in] the execution parameters.  // 输入执行参数。\r\n  - procedure_time_out – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 可选，最大执行时间，超时将中断。\r\n  - in_process – [in] (Optional) support in future.  // 可选，未来支持。\n\n该块内容位于文档中关于 RPC 客户端的部分，具体讨论了如何调用用户自定义过程的函数 `CallProcedure`，包括参数说明和返回值。这部分涵盖了使用 TuGraph 图数据库进行图分析时的事务管理和调用过程的相关细节。"
            },
            {
                "content": "Execute a user-defined procedure.  // 执行用户自定义的过程。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - procedure_type – [in] the procedure type, currently supported CPP and PY.  // 输入过程类型，目前支持 CPP 和 PY。\r\n  - procedure_name – [in] procedure name.  // 输入过程名称。\r\n  - param – [in] the execution parameters.  // 输入执行参数。\r\n  - procedure_time_out – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 可选，最大执行时间，超时将中断。\r\n  - in_process – [in] (Optional) support in future.  // 可选，未来支持。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 可选，返回格式，true 表示 JSON，否则为二进制格式。\r\n  - url – [in] (Optional) Node address of calling procedure.  // 可选，调用过程的节点地址。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\n\n该段落位于文档的 `lgraph_rpc_client` 类中，描述了如何执行用户定义的过程，提供了调用该过程所需的参数及返回值的说明，适用于图数据库的操作和插件开发。"
            },
            {
                "content": "- in_process – [in] (Optional) support in future.  // 可选，未来支持。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 可选，返回格式，true 表示 JSON，否则为二进制格式。\r\n  - url – [in] (Optional) Node address of calling procedure.  // 可选，调用过程的节点地址。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\r\n\r\n- **bool CallProcedureToLeader(std::string &result, const std::string &procedure_type, const std::string &procedure_name, const std::string &param, double procedure_time_out = 0.0, bool in_process = false, const std::string &graph = \"default\", bool json_format = true)**  \r\n  Execute a user-defined procedure to leader.  // 执行用户自定义的过程到领导者。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - procedure_type – [in] the procedure type, currently supported CPP and PY.  // 输入过程类型，目前支持 CPP 和 PY。\r\n  - procedure_name – [in] procedure name.  // 输入过程名称。\n\n该块内容位于文档的“lgraph_galaxy”部分，主要描述了执行用户自定义过程的函数和参数，包括调用过程时的选项、返回值以及处理的细节，提供了对TuGraph图数据库的图分析和操作的相关信息。"
            },
            {
                "content": "Execute a user-defined procedure to leader.  // 执行用户自定义的过程到领导者。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - procedure_type – [in] the procedure type, currently supported CPP and PY.  // 输入过程类型，目前支持 CPP 和 PY。\r\n  - procedure_name – [in] procedure name.  // 输入过程名称。\r\n  - param – [in] the execution parameters.  // 输入执行参数。\r\n  - procedure_time_out – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 可选，最大执行时间，超时将中断。\r\n  - in_process – [in] (Optional) support in future.  // 可选，未来支持。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 可选，返回格式，true 表示 JSON，否则为二进制格式。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\n\n该代码块位于文档的 \"lgraph_rpc_client\" 部分，描述了如何在 TuGraph 中执行用户自定义过程到领导者，包括相关参数及其类型、可选性和预期返回值，为用户提供了操作过程的具体细节与指导。"
            },
            {
                "content": "- param – [in] the execution parameters.  // 输入执行参数。\r\n  - procedure_time_out – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 可选，最大执行时间，超时将中断。\r\n  - in_process – [in] (Optional) support in future.  // 可选，未来支持。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 可选，返回格式，true 表示 JSON，否则为二进制格式。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\r\n\r\n- **bool LoadProcedure(std::string &result, const std::string &source_file, const std::string &procedure_type, const std::string &procedure_name, const std::string &code_type, const std::string &procedure_description, bool read_only, const std::string &version = \"v1\", const std::string &graph = \"default\")**  \r\n  Load a built-in procedure.  // 加载内置过程。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - source_file – [in] the source_file contain procedure code.  // 输入包含过程代码的源文件。\n\n该块内容位于文档的函数部分，具体用于描述在TuGraph中加载内置过程的操作及其参数。其重点在于如何使用加载过程的函数，包括输入参数、可选参数以及函数返回值，帮助用户理解在图数据库中处理图分析时的使用方法和注意事项。"
            },
            {
                "content": "- **bool LoadProcedure(std::string &result, const std::string &source_file, const std::string &procedure_type, const std::string &procedure_name, const std::string &code_type, const std::string &procedure_description, bool read_only, const std::string &version = \"v1\", const std::string &graph = \"default\")**  \r\n  Load a built-in procedure.  // 加载内置过程。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出结果。\r\n  - source_file – [in] the source_file contain procedure code.  // 输入包含过程代码的源文件。\r\n  - procedure_type – [in] the procedure type, currently supported CPP and PY.  // 输入过程类型，目前支持 CPP 和 PY。\r\n  - procedure_name – [in] procedure name.  // 输入过程名称。\r\n  - code_type – [in] code type, currently supported PY, SO, CPP, ZIP.  // 输入代码类型，目前支持 PY、SO、CPP、ZIP。\r\n  - procedure_description – [in] procedure description.  // 输入过程描述。\r\n  - read_only – [in] procedure is read only or not.  // 输入过程是否为只读。\r\n  - version – [in] (Optional) the version of procedure.  // 可选，过程版本。\n\n该段落位于文档的“lgraph_rpc_client”部分，描述了加载内置过程的功能及其参数。这一功能是图数据库操作的关键部分，为用户提供了扩展图数据库功能的接口。"
            },
            {
                "content": "- procedure_type – [in] the procedure type, currently supported CPP and PY.  // 输入过程类型，目前支持 CPP 和 PY。\r\n  - procedure_name – [in] procedure name.  // 输入过程名称。\r\n  - code_type – [in] code type, currently supported PY, SO, CPP, ZIP.  // 输入代码类型，目前支持 PY、SO、CPP、ZIP。\r\n  - procedure_description – [in] procedure description.  // 输入过程描述。\r\n  - read_only – [in] procedure is read only or not.  // 输入过程是否为只读。\r\n  - version – [in] (Optional) the version of procedure.  // 可选，过程版本。\r\n  - graph – [in] (Optional) the graph to query.  // 可选，指定要查询的图。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\r\n\r\n- **bool LoadProcedure(std::string &result, const std::vector &source_files, const std::string &procedure_type, const std::string &procedure_name, const std::string &code_type, const std::string &procedure_description, bool read_only, const std::string &version = \"v1\", const std::string &graph = \"default\")**  \r\n  Load a built-in procedure.  \r\n  加载一个内置过程。\r\n\r\n  **参数**\n\n该块内容位于有关TuGraph的RPC客户端部分，具体描述了与用户自定义过程相关的参数，包括过程类型、名称、代码类型、描述、只读状态、版本和图的查询选择。它补充了如何加载内置过程的相关信息。"
            },
            {
                "content": "**返回**  \r\n  True if it succeeds, false if it fails.  // 如果成功返回真，失败返回假。\r\n\r\n- **bool LoadProcedure(std::string &result, const std::vector &source_files, const std::string &procedure_type, const std::string &procedure_name, const std::string &code_type, const std::string &procedure_description, bool read_only, const std::string &version = \"v1\", const std::string &graph = \"default\")**  \r\n  Load a built-in procedure.  \r\n  加载一个内置过程。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\r\n  - source_files – [in] the source_file list contain procedure code(only for code_type cpp).  // 输入参数，包含过程代码的源文件列表（仅适用于代码类型为cpp）。\r\n  - procedure_type – [in] the procedure type, currently supported CPP and PY.  // 输入参数，过程类型，目前支持CPP和PY。\r\n  - procedure_name – [in] procedure name.  // 输入参数，过程名称。\r\n  - code_type – [in] code type, currently supported PY, SO, CPP, ZIP.  // 输入参数，代码类型，目前支持PY、SO、CPP、ZIP。\r\n  - procedure_description – [in] procedure description.  // 输入参数，过程描述。\n\n该块内容位于文档中与TuGraph的RPC客户端相关的部分，主要描述了如何加载内置过程的函数声明及其参数说明。这部分内容对理解如何使用TuGraph的图数据库操作和自定义过程具有重要意义。"
            },
            {
                "content": "- source_files – [in] the source_file list contain procedure code(only for code_type cpp).  // 输入参数，包含过程代码的源文件列表（仅适用于代码类型为cpp）。\r\n  - procedure_type – [in] the procedure type, currently supported CPP and PY.  // 输入参数，过程类型，目前支持CPP和PY。\r\n  - procedure_name – [in] procedure name.  // 输入参数，过程名称。\r\n  - code_type – [in] code type, currently supported PY, SO, CPP, ZIP.  // 输入参数，代码类型，目前支持PY、SO、CPP、ZIP。\r\n  - procedure_description – [in] procedure description.  // 输入参数，过程描述。\r\n  - read_only – [in] procedure is read only or not.  // 输入参数，过程是否为只读。\r\n  - version – [in] (Optional) the version of procedure.  // 输入参数（可选），过程的版本。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **bool ListProcedures(std::string &result, const std::string &procedure_type, const std::string &version = \"any\", const std::string &graph = \"default\", const std::string &url = \"\")**  \r\n  List user-defined procedures.  \r\n  列出用户定义的过程。\r\n\r\n  **参数**\n\n该块内容位于文档的“lgraph_rpc_client”部分，详细描述了如何加载用户定义的过程和列出过程的功能，包括相应的参数及返回值，适用于图数据库操作。"
            },
            {
                "content": "- version – [in] (Optional) the version of procedure.  // 输入参数（可选），过程的版本。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **bool ListProcedures(std::string &result, const std::string &procedure_type, const std::string &version = \"any\", const std::string &graph = \"default\", const std::string &url = \"\")**  \r\n  List user-defined procedures.  \r\n  列出用户定义的过程。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\r\n  - procedure_type – [in] (Optional) the procedure type, “” for all procedures, CPP and PY for special type.  // 输入参数（可选），过程类型，\"\"表示所有过程，CPP和PY表示特定类型。\r\n  - version – [in] (Optional) the version of procedure.  // 输入参数（可选），过程的版本。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n  - url – [in] Node address of calling procedure.  // 输入参数，调用过程的节点地址。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\n\n该块内容位于文档的 \"lgraph_rpc_client\" 部分，具体描述了如何列出用户定义的过程，包括相关参数和返回值说明。在此部分，用户可以了解如何通过 RPC 客户端与 TuGraph 数据库交互，以获取关于用户定义过程的详细信息。"
            },
            {
                "content": "**参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\r\n  - procedure_type – [in] (Optional) the procedure type, “” for all procedures, CPP and PY for special type.  // 输入参数（可选），过程类型，\"\"表示所有过程，CPP和PY表示特定类型。\r\n  - version – [in] (Optional) the version of procedure.  // 输入参数（可选），过程的版本。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n  - url – [in] Node address of calling procedure.  // 输入参数，调用过程的节点地址。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **bool DeleteProcedure(std::string &result, const std::string &procedure_type, const std::string &procedure_name, const std::string &graph = \"default\")**  \r\n  Execute a user-defined procedure.  \r\n  执行用户定义的程序。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\r\n  - procedure_type – [in] the procedure type, currently supported CPP and PY.  // 输入参数，过程类型，目前支持CPP和PY。\r\n  - procedure_name – [in] procedure name.  // 输入参数，过程名称。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\n\n该块内容位于文档的 **lgraph_rpc_client** 部分，主要描述了用于执行用户定义过程的函数接口，包括其参数和返回值的详细说明。这些函数允许用户通过RPC调用进行图数据库的操作，支撑对图形的动态查询和管理。"
            },
            {
                "content": "- **bool DeleteProcedure(std::string &result, const std::string &procedure_type, const std::string &procedure_name, const std::string &graph = \"default\")**  \r\n  Execute a user-defined procedure.  \r\n  执行用户定义的程序。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\r\n  - procedure_type – [in] the procedure type, currently supported CPP and PY.  // 输入参数，过程类型，目前支持CPP和PY。\r\n  - procedure_name – [in] procedure name.  // 输入参数，过程名称。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **bool ImportSchemaFromContent(std::string &result, const std::string &schema, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge schema from content string.  \r\n  从内容字符串中导入顶点或边的模式。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\r\n  - schema – [in] the schema to be imported.  // 输入参数，要导入的模式。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\n\n该内容块位于文档的OLAP接口部分，具体涉及到用户定义的过程的执行和从内容字符串导入顶点或边模式的函数定义。这些函数提供了在TuGraph中进行图数据操作的能力，并支持对过程和模式的灵活管理。"
            },
            {
                "content": "True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **bool ImportSchemaFromContent(std::string &result, const std::string &schema, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge schema from content string.  \r\n  从内容字符串中导入顶点或边的模式。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\r\n  - schema – [in] the schema to be imported.  // 输入参数，要导入的模式。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 输入参数（可选），返回格式，true表示json，否则为二进制格式。\r\n  - timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 输入参数（可选），最大执行时间，超时将被中断。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\n\n该内容片段位于文档中描述 TuGraph 数据库操作的部分，具体涉及从内容字符串导入顶点或边的模式，包含相关的函数定义、参数说明及返回值信息。"
            },
            {
                "content": "- result – [out] The result.  // 输出参数，返回结果。\r\n  - schema – [in] the schema to be imported.  // 输入参数，要导入的模式。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 输入参数（可选），返回格式，true表示json，否则为二进制格式。\r\n  - timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 输入参数（可选），最大执行时间，超时将被中断。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **bool ImportDataFromContent(std::string &result, const std::string &desc, const std::string &data, const std::string &delimiter, bool continue_on_error = false, int thread_nums = 8, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge data from content string.  \r\n  从内容字符串中导入顶点或边的数据。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\r\n  - desc – [in] data format description.  // 输入参数，数据格式描述。\n\n该块内容位于文档的 lgraph_rpc_client 部分，详细描述了一些函数的参数和返回值，用于从内容字符串导入图形的顶点或边数据。在这里，用户可以了解到如何使用相关函数，以实现数据导入以及处理异常情况。"
            },
            {
                "content": "- **bool ImportDataFromContent(std::string &result, const std::string &desc, const std::string &data, const std::string &delimiter, bool continue_on_error = false, int thread_nums = 8, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge data from content string.  \r\n  从内容字符串中导入顶点或边的数据。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\r\n  - desc – [in] data format description.  // 输入参数，数据格式描述。\r\n  - data – [in] the data to be imported.  // 输入参数，要导入的数据。\r\n  - delimiter – [in] data separator.  // 输入参数，数据分隔符。\r\n  - continue_on_error – [in] (Optional) whether to continue when importing data fails.  // 输入参数（可选），导入数据失败时是否继续。\r\n  - thread_nums – [in] (Optional) maximum number of threads.  // 输入参数（可选），最大线程数。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 输入参数（可选），返回格式，true表示json，否则为二进制格式。\n\n该段落位于文档的“lgraph_rpc_client”部分，详细描述了如何使用从内容字符串导入顶点或边数据的函数`ImportDataFromContent`，包括输入参数、输出结果及其功能，适用于在TuGraph图数据库中处理数据导入。"
            },
            {
                "content": "- data – [in] the data to be imported.  // 输入参数，要导入的数据。\r\n  - delimiter – [in] data separator.  // 输入参数，数据分隔符。\r\n  - continue_on_error – [in] (Optional) whether to continue when importing data fails.  // 输入参数（可选），导入数据失败时是否继续。\r\n  - thread_nums – [in] (Optional) maximum number of threads.  // 输入参数（可选），最大线程数。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 输入参数（可选），返回格式，true表示json，否则为二进制格式。\r\n  - timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 输入参数（可选），最大执行时间，超时将被中断。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **bool ImportSchemaFromFile(std::string &result, const std::string &schema_file, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge schema from file.  \r\n  从文件导入顶点或边的模式。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\n\n该块内容位于文档中的 `lgraph_rpc_client` 部分，主要描述了从文件导入图形数据和模式的函数及其参数，强调了导入过程中的选项、参数和返回值。这部分内容对于了解如何在TuGraph中处理数据的输入和管理具有重要意义。"
            },
            {
                "content": "- timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 输入参数（可选），最大执行时间，超时将被中断。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **bool ImportSchemaFromFile(std::string &result, const std::string &schema_file, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge schema from file.  \r\n  从文件导入顶点或边的模式。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\r\n  - schema_file – [in] the schema_file contain schema.  // 输入参数，包含模式的schema文件。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 输入参数（可选），返回格式，true表示json，否则为二进制格式。\r\n  - timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 输入参数（可选），最大执行时间，超时将被中断。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\n\n该块内容位于文档的 \"lgraph_rpc_client\" 部分，主要描述了如何导入顶点或边的模式文件，包括函数参数和返回值的信息。这部分内容强调了调用此函数时的超时限制和成功与否的返回结果。"
            },
            {
                "content": "- schema_file – [in] the schema_file contain schema.  // 输入参数，包含模式的schema文件。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 输入参数（可选），返回格式，true表示json，否则为二进制格式。\r\n  - timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 输入参数（可选），最大执行时间，超时将被中断。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **bool ImportDataFromFile(std::string &result, const std::string &conf_file, const std::string &delimiter, bool continue_on_error = false, int thread_nums = 8, int skip_packages = 0, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge data from file.  \r\n  从文件导入顶点或边的数据。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\r\n  - conf_file – [in] data file contain format description and data.  // 输入参数，包含格式描述和数据的数据文件。\r\n  - delimiter – [in] data separator.  // 输入参数，数据分隔符。\n\n该段落位于文档中的 \"lgraph_rpc_client\" 部分，描述了如何从文件导入图的顶点或边数据以及相关的参数和返回值。此部分主要涉及图数据库操作的实现细节和使用方法。"
            },
            {
                "content": "Import vertex or edge data from file.  \r\n  从文件导入顶点或边的数据。\r\n\r\n  **参数**\r\n  - result – [out] The result.  // 输出参数，返回结果。\r\n  - conf_file – [in] data file contain format description and data.  // 输入参数，包含格式描述和数据的数据文件。\r\n  - delimiter – [in] data separator.  // 输入参数，数据分隔符。\r\n  - continue_on_error – [in] (Optional) whether to continue when importing data fails.  // 输入参数（可选），导入数据失败时是否继续。\r\n  - thread_nums – [in] (Optional) maximum number of threads.  // 输入参数（可选），最大线程数。\r\n  - skip_packages – [in] (Optional) skip packages number.  // 输入参数（可选），跳过的包数量。\r\n  - graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 输入参数（可选），返回格式，true表示json，否则为二进制格式。\r\n  - timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 输入参数（可选），最大执行时间，超时将被中断。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **int64_t Restore(const std::vector &requests)**\r\n\r\n- **void Logout()**\n\n该文档详细介绍了TuGraph的图数据库接口，包含了各种功能和类的定义。其中，关于从文件导入顶点或边数据的功能被描述在`ImportDataFromFile`函数的部分，涵盖了参数说明及返回值，适用于使用TuGraph进行图数据管理和分析的场景。"
            },
            {
                "content": "- graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。\r\n  - json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  // 输入参数（可选），返回格式，true表示json，否则为二进制格式。\r\n  - timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  // 输入参数（可选），最大执行时间，超时将被中断。\r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **int64_t Restore(const std::vector &requests)**\r\n\r\n- **void Logout()**  \r\n  Client log out.  \r\n  客户端登出。\r\n\r\n### Private Functions\r\n\r\n- **bool IsReadQuery(lgraph::GraphQueryType type, const std::string &query, const std::string &graph)**  \r\n  Determine whether it is a read-only query.  \r\n  确定是否为只读查询。\r\n\r\n  **参数**  \r\n  type – [in] inquire query type.  // 输入参数，查询类型。  \r\n  query – [in] inquire statement.  // 输入参数，查询语句。  \r\n  graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\n\n该代码块位于关于 TuGraph 数据库中图查询的 RPC 客户端部分，描述了执行查询时的参数设置，包括指定图形、返回格式和最大执行时间等。它同时包括了查询是否为只读的判断函数。"
            },
            {
                "content": "Client log out.  \r\n  客户端登出。\r\n\r\n### Private Functions\r\n\r\n- **bool IsReadQuery(lgraph::GraphQueryType type, const std::string &query, const std::string &graph)**  \r\n  Determine whether it is a read-only query.  \r\n  确定是否为只读查询。\r\n\r\n  **参数**  \r\n  type – [in] inquire query type.  // 输入参数，查询类型。  \r\n  query – [in] inquire statement.  // 输入参数，查询语句。  \r\n  graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **std::shared_ptr GetClient(lgraph::GraphQueryType type, const std::string &cypher, const std::string &graph)**  \r\n  Return rpc client based on whether it is a read-only query.  \r\n  根据是否为只读查询返回rpc客户端。\r\n\r\n  **参数**  \r\n  type – [in] inquire query type.  // 输入参数，查询类型。  \r\n  query – [in] inquire statement.  // 输入参数，查询语句。  \r\n  graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。  \r\n\r\n  **返回**\n\n该块内容位于文档的 **lgraph_rpc_client** 部分，其中描述了 RPC 客户端的功能和方法，包括如何处理查询和获取客户端连接。此部分专注于客户端的登录、查询执行、查询处理和注销等操作。"
            },
            {
                "content": "**返回**  \r\n  True if it succeeds, false if it fails.  // 成功返回true，失败返回false。\r\n\r\n- **std::shared_ptr GetClient(lgraph::GraphQueryType type, const std::string &cypher, const std::string &graph)**  \r\n  Return rpc client based on whether it is a read-only query.  \r\n  根据是否为只读查询返回rpc客户端。\r\n\r\n  **参数**  \r\n  type – [in] inquire query type.  // 输入参数，查询类型。  \r\n  query – [in] inquire statement.  // 输入参数，查询语句。  \r\n  graph – [in] (Optional) the graph to query.  // 输入参数（可选），要查询的图。  \r\n\r\n  **返回**  \r\n  Master rpc client if cypher is not read-only, slaver rpc client if cypher is read-only.  // 如果cypher不是只读，返回主rpc客户端；如果cypher是只读，返回从rpc客户端。\r\n\r\n- **std::shared_ptr GetClient(bool isReadQuery)**  \r\n  Return rpc client based on whether it is a read-only query.  \r\n  根据是否为只读查询返回rpc客户端。\r\n\r\n  **参数**  \r\n  isReadQuery – [in] read query or not.  // 输入参数，是否为只读查询。  \r\n\r\n  **返回**  \r\n  Master rpc client if cypher is not read-only, slaver rpc client if cypher is read-only.  // 如果cypher不是只读，返回主rpc客户端；如果cypher是只读，返回从rpc客户端。\n\n该块内容位于文档的 \"lgraph_rpc_client\" 部分，主要描述了如何获取 RPC 客户端的相关函数，包括根据查询类型返回主或从客户端的行为，以及处理只读查询的相关参数和返回值。这些函数是 TuGraph 的 RPC 接口的一部分，用于支持图数据库的操作和查询。"
            },
            {
                "content": "- **std::shared_ptr GetClient(bool isReadQuery)**  \r\n  Return rpc client based on whether it is a read-only query.  \r\n  根据是否为只读查询返回rpc客户端。\r\n\r\n  **参数**  \r\n  isReadQuery – [in] read query or not.  // 输入参数，是否为只读查询。  \r\n\r\n  **返回**  \r\n  Master rpc client if cypher is not read-only, slaver rpc client if cypher is read-only.  // 如果cypher不是只读，返回主rpc客户端；如果cypher是只读，返回从rpc客户端。\r\n\r\n- **std::shared_ptr GetClientByNode(const std::string &url)**  \r\n  Get the client according to the node url.  \r\n  根据节点url获取客户端。\r\n\r\n  **参数**  \r\n  url – [in] Node address of client connection.  // 输入参数，客户端连接的节点地址。  \r\n\r\n  **返回**  \r\n  Rpc client connecting to url.  // 连接到url的Rpc客户端。\r\n\r\n- **void RefreshUserDefinedProcedure()**  \r\n  Refresh User-defined Procedure.  \r\n  刷新用户定义的过程。\r\n\r\n- **void RefreshBuiltInProcedure()**  \r\n  Refresh Built-in Procedure.  \r\n  刷新内置过程。\r\n\r\n- **void RefreshClientPool()**  \r\n  Refresh the client connection pool according to the cluster status.  \r\n  根据集群状态刷新客户端连接池。\r\n\r\n- **void LoadBalanceClientPool()**\n\n该块内容位于文档的RPC客户端部分，主要涉及RpcClient类中的一些公共函数，具体功能包括根据查询类型获取RPC客户端、通过节点URL获取客户端，以及刷新用户定义和内置过程的操作等。这些功能有助于管理与TuGraph数据库的连接和交互。"
            },
            {
                "content": "**参数**  \r\n  url – [in] Node address of client connection.  // 输入参数，客户端连接的节点地址。  \r\n\r\n  **返回**  \r\n  Rpc client connecting to url.  // 连接到url的Rpc客户端。\r\n\r\n- **void RefreshUserDefinedProcedure()**  \r\n  Refresh User-defined Procedure.  \r\n  刷新用户定义的过程。\r\n\r\n- **void RefreshBuiltInProcedure()**  \r\n  Refresh Built-in Procedure.  \r\n  刷新内置过程。\r\n\r\n- **void RefreshClientPool()**  \r\n  Refresh the client connection pool according to the cluster status.  \r\n  根据集群状态刷新客户端连接池。\r\n\r\n- **void LoadBalanceClientPool()**  \r\n  Load balance the client pool.  \r\n  负载均衡客户端池。\r\n\r\n- **void RefreshConnection()**  \r\n  Refresh client pool, procedure info.  \r\n  刷新客户端池和过程信息。\r\n\r\n- **template bool DoubleCheckQuery(F const &f)**  \r\n  If an exception is thrown in the query, refresh the connection and re-execute.  \r\n  如果查询中抛出异常，刷新连接并重新执行。\r\n\r\n### Private Members\r\n\r\n- **ClientType client_type**  \r\n- **std::string user**  \r\n- **std::string password**  \r\n- **std::shared_ptr base_client**  \r\n- **std::vector urls**  \r\n- **std::shared_ptr leader_client**\n\n该块内容位于文档中关于 `lgraph_rpc_client` 类的部分，具体处理了 RPC 客户端的各种功能，包括登录、执行查询、刷新用户定义过程、刷新内置过程及客户端连接池等操作，以及如何管理和维护与 TuGraph 数据库的连接。"
            },
            {
                "content": "负载均衡客户端池。\r\n\r\n- **void RefreshConnection()**  \r\n  Refresh client pool, procedure info.  \r\n  刷新客户端池和过程信息。\r\n\r\n- **template bool DoubleCheckQuery(F const &f)**  \r\n  If an exception is thrown in the query, refresh the connection and re-execute.  \r\n  如果查询中抛出异常，刷新连接并重新执行。\r\n\r\n### Private Members\r\n\r\n- **ClientType client_type**  \r\n- **std::string user**  \r\n- **std::string password**  \r\n- **std::shared_ptr base_client**  \r\n- **std::vector urls**  \r\n- **std::shared_ptr leader_client**  \r\n- **std::deque> client_pool**  \r\n- **nlohmann::json built_in_procedures = {}**  \r\n- **nlohmann::json user_defined_procedures = {}**  \r\n- **std::vector cypher_write_constant**  \r\n- **std::vector gql_write_constant**  \r\n\r\n### class RpcSingleClient\r\n\r\n#### Public Functions\r\n\r\n- **RpcSingleClient(const std::string &url, const std::string &user, const std::string &password)**  \r\n  RpcSingleClient Login.  \r\n  RpcSingleClient 登录。\r\n\r\n  **参数**  \r\n  url – Login address.  \r\n  url – 登录地址。  \r\n  user – The username.  \r\n  user – 用户名。\n\n此块内容位于文档中与TuGraph图数据库的客户端交互相关的部分，主要讨论有关负载均衡和客户端连接管理的功能。它具体描述了`RefreshConnection()`和`DoubleCheckQuery()`方法，并介绍了`RpcClient`和`RpcSingleClient`类的构造函数及其参数，用于实现图数据库的操作和查询。"
            },
            {
                "content": "- **nlohmann::json built_in_procedures = {}**  \r\n- **nlohmann::json user_defined_procedures = {}**  \r\n- **std::vector cypher_write_constant**  \r\n- **std::vector gql_write_constant**  \r\n\r\n### class RpcSingleClient\r\n\r\n#### Public Functions\r\n\r\n- **RpcSingleClient(const std::string &url, const std::string &user, const std::string &password)**  \r\n  RpcSingleClient Login.  \r\n  RpcSingleClient 登录。\r\n\r\n  **参数**  \r\n  url – Login address.  \r\n  url – 登录地址。  \r\n  user – The username.  \r\n  user – 用户名。  \r\n  password – The password.  \r\n  password – 密码。  \r\n\r\n- **~RpcSingleClient()**\r\n\r\n- **int64_t Restore(const std::vector &requests)**\r\n\r\n- **bool LoadProcedure(std::string &result, const std::vector &source_files, const std::string &procedure_type, const std::string &procedure_name, const std::string &code_type, const std::string &procedure_description, bool read_only, const std::string &version = \"v1\", const std::string &graph = \"default\")**  \r\n  Load a user-defined procedure.  \r\n  加载用户定义的过程。\r\n\r\n  **参数**\n\n该块内容位于文档中关于TuGraph图数据库的RPC客户端部分，特别是`RpcClient`类的实现，其中包含用户定义过程的加载、保存和请求功能。此部分介绍了`RpcSingleClient`类的构造函数和公共方法，专注于如何通过RPC与TuGraph进行交互。"
            },
            {
                "content": "password – The password.  \r\n  password – 密码。  \r\n\r\n- **~RpcSingleClient()**\r\n\r\n- **int64_t Restore(const std::vector &requests)**\r\n\r\n- **bool LoadProcedure(std::string &result, const std::vector &source_files, const std::string &procedure_type, const std::string &procedure_name, const std::string &code_type, const std::string &procedure_description, bool read_only, const std::string &version = \"v1\", const std::string &graph = \"default\")**  \r\n  Load a user-defined procedure.  \r\n  加载用户定义的过程。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  source_files – [in] the source_file list contain procedure code(only for code_type cpp).  \r\n  source_files – [输入] 包含过程代码的源文件列表（仅适用于代码类型 cpp）。  \r\n  procedure_type – [in] the procedure type, currently supported CPP and PY.  \r\n  procedure_type – [输入] 过程类型，目前支持 CPP 和 PY。  \r\n  procedure_name – [in] procedure name.  \r\n  procedure_name – [输入] 过程名称。  \r\n  code_type – [in] code type, currently supported PY, SO, CPP, ZIP.\n\n该块内容位于文档的“lgraph_rpc_client”部分，重点介绍如何通过 `RpcSingleClient` 类进行用户登录以及如何加载用户定义的过程。它详细列出了构造函数、析构函数，以及处理请求的方法，包括加载过程的相关参数和返回结果。"
            },
            {
                "content": "加载用户定义的过程。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  source_files – [in] the source_file list contain procedure code(only for code_type cpp).  \r\n  source_files – [输入] 包含过程代码的源文件列表（仅适用于代码类型 cpp）。  \r\n  procedure_type – [in] the procedure type, currently supported CPP and PY.  \r\n  procedure_type – [输入] 过程类型，目前支持 CPP 和 PY。  \r\n  procedure_name – [in] procedure name.  \r\n  procedure_name – [输入] 过程名称。  \r\n  code_type – [in] code type, currently supported PY, SO, CPP, ZIP.  \r\n  code_type – [输入] 代码类型，目前支持 PY、SO、CPP、ZIP。  \r\n  procedure_description – [in] procedure description.  \r\n  procedure_description – [输入] 过程描述。  \r\n  read_only – [in] procedure is read only or not.  \r\n  read_only – [输入] 过程是否为只读。  \r\n  version – [in] (Optional) the version of procedure.  \r\n  version – [输入] （可选）过程的版本。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\n\n该段落位于文档的 \"lgraph_rpc_client\" 部分，具体描述了如何加载用户定义的过程，包括相关参数的说明和返回值的定义。这部分内容是关于在 TuGraph 中执行用户自定义过程的接口细节，帮助用户理解如何通过 RPC 客户端加载和管理自定义过程。"
            },
            {
                "content": "code_type – [输入] 代码类型，目前支持 PY、SO、CPP、ZIP。  \r\n  procedure_description – [in] procedure description.  \r\n  procedure_description – [输入] 过程描述。  \r\n  read_only – [in] procedure is read only or not.  \r\n  read_only – [输入] 过程是否为只读。  \r\n  version – [in] (Optional) the version of procedure.  \r\n  version – [输入] （可选）过程的版本。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **bool CallProcedure(std::string &result, const std::string &procedure_type, const std::string &procedure_name, const std::string &param, double procedure_time_out = 0.0, bool in_process = false, const std::string &graph = \"default\", bool json_format = true)**  \r\n  Execute a user-defined procedure.  \r\n  执行用户定义的过程。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  procedure_type – [in] the procedure type, currently supported CPP and PY.  \r\n  procedure_type – [输入] 过程类型，目前支持 CPP 和 PY。\n\n该代码块位于文档的“lgraph_rpc_client”部分，详细描述了执行用户定义过程的函数，包括参数及其作用。其中涉及的参数包括代码类型、过程描述、只读属性、版本和图的查询信息，同时还说明了函数的返回值及其含义。"
            },
            {
                "content": "Execute a user-defined procedure.  \r\n  执行用户定义的过程。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  procedure_type – [in] the procedure type, currently supported CPP and PY.  \r\n  procedure_type – [输入] 过程类型，目前支持 CPP 和 PY。  \r\n  procedure_name – [in] procedure name.  \r\n  procedure_name – [输入] 过程名称。  \r\n  param – [in] the execution parameters.  \r\n  param – [输入] 执行参数。  \r\n  procedure_time_out – [in] (Optional) Maximum execution time, overruns will be interrupted.  \r\n  procedure_time_out – [输入] （可选）最大执行时间，超时将被中断。  \r\n  in_process – [in] (Optional) support in future.  \r\n  in_process – [输入] （可选）未来支持。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n  json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\n\n该片段位于文档的 \"lgraph_rpc_client\" 部分，描述了如何执行用户定义的过程，包含输入参数和返回值的信息。这一部分提供了与 TuGraph 的 RPC 客户端相关的功能和方法，用于进行图数据库查询和操作。"
            },
            {
                "content": "procedure_time_out – [输入] （可选）最大执行时间，超时将被中断。  \r\n  in_process – [in] (Optional) support in future.  \r\n  in_process – [输入] （可选）未来支持。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n  json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **bool ListProcedures(std::string &result, const std::string &procedure_type, const std::string &version = \"any\", const std::string &graph = \"default\")**  \r\n  List user-defined procedures.  \r\n  列出用户定义的过程。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  procedure_type – [in] (Optional) the procedure type, “” for all procedures, CPP and PY for special type.  \r\n  procedure_type – [输入] （可选）过程类型，“”表示所有过程，CPP 和 PY 表示特定类型。  \r\n  version – [in] (Optional) the version of procedure.  \r\n  version – [输入] （可选）过程的版本。\n\n该文本块位于文档中关于TuGraph图数据库中RPC客户端接口的部分，具体描述了调用用户定义过程时的参数，包括最大执行时间、处理模式以及查询图的信息等内容。它还提到了如何列出用户定义的过程及相关参数。"
            },
            {
                "content": "List user-defined procedures.  \r\n  列出用户定义的过程。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  procedure_type – [in] (Optional) the procedure type, “” for all procedures, CPP and PY for special type.  \r\n  procedure_type – [输入] （可选）过程类型，“”表示所有过程，CPP 和 PY 表示特定类型。  \r\n  version – [in] (Optional) the version of procedure.  \r\n  version – [输入] （可选）过程的版本。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **bool DeleteProcedure(std::string &result, const std::string &procedure_type, const std::string &procedure_name, const std::string &graph = \"default\")**  \r\n  Execute a user-defined procedure.  \r\n  删除用户定义的程序。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  procedure_type – [in] the procedure type, currently supported CPP and PY.  \r\n  procedure_type – [输入] 过程类型，目前支持 CPP 和 PY。  \r\n  procedure_name – [in] procedure name.  \r\n  procedure_name – [输入] 过程名称。\n\n在文档的“lgraph_galaxy”部分，介绍了与图数据库交互的各种功能，其中包括列出用户定义的过程和删除用户定义的过程的相关函数。这些函数的参数和返回值详细说明了如何有效使用图数据库中的用户定义过程，为用户提供了清晰的操作指南。"
            },
            {
                "content": "如果成功则返回真，失败则返回假。\r\n\r\n- **bool DeleteProcedure(std::string &result, const std::string &procedure_type, const std::string &procedure_name, const std::string &graph = \"default\")**  \r\n  Execute a user-defined procedure.  \r\n  删除用户定义的程序。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  procedure_type – [in] the procedure type, currently supported CPP and PY.  \r\n  procedure_type – [输入] 过程类型，目前支持 CPP 和 PY。  \r\n  procedure_name – [in] procedure name.  \r\n  procedure_name – [输入] 过程名称。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **bool ImportSchemaFromFile(std::string &result, const std::string &schema_file, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge schema from file.  \r\n  从文件导入顶点或边的模式。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  schema_file – [in] the schema_file contain schema.\n\n该块内容属于文档的“lgraph_rpc_client”部分，描述了执行用户定义过程和从文件导入顶点或边模式的函数及其参数和返回值。这部分功能主要用于处理图数据库中的自定义操作和数据结构的定义，旨在帮助用户有效地管理和操作图数据库中的数据。"
            },
            {
                "content": "graph – [输入] （可选）要查询的图。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **bool ImportSchemaFromFile(std::string &result, const std::string &schema_file, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge schema from file.  \r\n  从文件导入顶点或边的模式。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  schema_file – [in] the schema_file contain schema.  \r\n  schema_file – [输入] 包含模式的模式文件。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n  json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n  timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  \r\n  timeout – [输入] （可选）最大执行时间，超时将被中断。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\n\n该段落位于文档中关于TuGraph图数据库的OLAP接口部分，具体介绍了导入顶点或边模式的方法及其参数设置。它描述了如何通过文件将模式导入到数据库中，并提供了对应的返回值指示导入是否成功。"
            },
            {
                "content": "schema_file – [输入] 包含模式的模式文件。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n  json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n  timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  \r\n  timeout – [输入] （可选）最大执行时间，超时将被中断。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **bool ImportDataFromFile(std::string &result, const std::string &conf_file, const std::string &delimiter, bool continue_on_error = false, int thread_nums = 8, int skip_packages = 0, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge data from file.  \r\n  从文件导入顶点或边的数据。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  conf_file – [in] data file contain format description and data.  \r\n  conf_file – [输入] 数据文件包含格式描述和数据。  \r\n  delimiter – [in] data separator.\n\n该块内容位于文档中关于TuGraph OLAP接口的部分，具体讲述了如何导入模式文件和数据文件的函数定义，其中包括参数说明和返回值描述。它属于对数据库操作和图分析算法实现的详细说明，帮助用户理解如何通过API进行数据导入。"
            },
            {
                "content": "Import vertex or edge data from file.  \r\n  从文件导入顶点或边的数据。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  conf_file – [in] data file contain format description and data.  \r\n  conf_file – [输入] 数据文件包含格式描述和数据。  \r\n  delimiter – [in] data separator.  \r\n  delimiter – [输入] 数据分隔符。  \r\n  continue_on_error – [in] (Optional) whether to continue when importing data fails.  \r\n  continue_on_error – [输入] （可选）导入数据失败时是否继续。  \r\n  thread_nums – [in] (Optional) maximum number of threads.  \r\n  thread_nums – [输入] （可选）最大线程数。  \r\n  skip_packages – [in] (Optional) skip packages number.  \r\n  skip_packages – [输入] （可选）跳过的包数。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n  json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n  timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  \r\n  timeout – [输入] （可选）最大执行时间，超时将被中断。  \r\n\r\n  **返回**\n\n该文档是关于 C++ 开发存储过程接口的全面描述，涵盖了与图数据库（GraphDB）相关的多个重要功能，包括 Base64 编码、图数据库操作、日期和时间处理、异常处理以及并行处理等。其中的“从文件导入顶点或边的数据”部分详细描述了如何使用特定参数加载数据，以便于在图数据库中进行操作。"
            },
            {
                "content": "thread_nums – [输入] （可选）最大线程数。  \r\n  skip_packages – [in] (Optional) skip packages number.  \r\n  skip_packages – [输入] （可选）跳过的包数。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n  json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n  timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  \r\n  timeout – [输入] （可选）最大执行时间，超时将被中断。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **bool ImportSchemaFromContent(std::string &result, const std::string &schema, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge schema from content string.  \r\n  从内容字符串导入顶点或边的模式。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  schema – [in] the schema to be imported.  \r\n  schema – [输入] 要导入的模式。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。\n\n该代码块位于文档的 `lgraph_utils` 部分，具体是在描述图数据库操作时的导入函数，其中包括导入模式和数据从内容字符串的函数。此部分详细讲述了如何设置参数，如最大线程数和跳过的包数，以及返回值的处理，旨在提供关于如何有效进行图数据导入的指导。"
            },
            {
                "content": "如果成功则返回真，失败则返回假。\r\n\r\n- **bool ImportSchemaFromContent(std::string &result, const std::string &schema, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge schema from content string.  \r\n  从内容字符串导入顶点或边的模式。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  schema – [in] the schema to be imported.  \r\n  schema – [输入] 要导入的模式。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n  json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n  timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  \r\n  timeout – [输入] （可选）最大执行时间，超时将被中断。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\n\n该段落位于关于TuGraph的OLAP接口部分，具体描述了从内容字符串导入顶点或边模式的函数`ImportSchemaFromContent`，包括其参数、返回值以及可能的错误处理。这有助于用户理解如何通过API进行图数据的模式导入操作。"
            },
            {
                "content": "schema – [in] the schema to be imported.  \r\n  schema – [输入] 要导入的模式。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n  json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n  timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  \r\n  timeout – [输入] （可选）最大执行时间，超时将被中断。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **bool ImportDataFromContent(std::string &result, const std::string &desc, const std::string &data, const std::string &delimiter, bool continue_on_error = false, int thread_nums = 8, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge data from content string.  \r\n  从内容字符串导入顶点或边的数据。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  desc – [in] data format description.  \r\n  desc – [输入] 数据格式描述。\n\n该片段位于文档中有关 TuGraph 数据库的导入功能章节，特别是关于从内容字符串导入模式和数据的函数定义。该部分包括导入模式和数据的参数说明及返回值，旨在为使用者提供操作指南。"
            },
            {
                "content": "如果成功则返回真，失败则返回假。\r\n\r\n- **bool ImportDataFromContent(std::string &result, const std::string &desc, const std::string &data, const std::string &delimiter, bool continue_on_error = false, int thread_nums = 8, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Import vertex or edge data from content string.  \r\n  从内容字符串导入顶点或边的数据。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  desc – [in] data format description.  \r\n  desc – [输入] 数据格式描述。  \r\n  data – [in] the data to be imported.  \r\n  data – [输入] 要导入的数据。  \r\n  delimiter – [in] data separator.  \r\n  delimiter – [输入] 数据分隔符。  \r\n  continue_on_error – [in] (Optional) whether to continue when importing data fails.  \r\n  continue_on_error – [输入] （可选）导入数据失败时是否继续。  \r\n  thread_nums – [in] (Optional) maximum number of threads.  \r\n  thread_nums – [输入] （可选）最大线程数。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。\n\n该片段位于文档中的“lgraph_rpc_client”部分，具体讨论了从内容字符串导入顶点或边数据的函数 `ImportDataFromContent`。此函数的描述包括参数详解及其使用场景，旨在指导用户如何有效地在 TuGraph 中处理数据导入操作。"
            },
            {
                "content": "desc – [in] data format description.  \r\n  desc – [输入] 数据格式描述。  \r\n  data – [in] the data to be imported.  \r\n  data – [输入] 要导入的数据。  \r\n  delimiter – [in] data separator.  \r\n  delimiter – [输入] 数据分隔符。  \r\n  continue_on_error – [in] (Optional) whether to continue when importing data fails.  \r\n  continue_on_error – [输入] （可选）导入数据失败时是否继续。  \r\n  thread_nums – [in] (Optional) maximum number of threads.  \r\n  thread_nums – [输入] （可选）最大线程数。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n  json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n  timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  \r\n  timeout – [输入] （可选）最大执行时间，超时将被中断。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **bool CallCypher(std::string &result, const std::string &cypher, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**\n\n该段落位于文档中关于如何导入数据到图数据库的内容部分，具体描述了导入数据时需要的参数和选项，包括数据格式描述、分隔符、线程数等。它强调了在导入过程中可能会发生的错误处理，并说明了函数返回的结果。"
            },
            {
                "content": "json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n  timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  \r\n  timeout – [输入] （可选）最大执行时间，超时将被中断。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **bool CallCypher(std::string &result, const std::string &cypher, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Execute a cypher query.  \r\n  执行一个 cypher 查询。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  cypher – [in] inquire statement.  \r\n  cypher – [输入] 查询语句。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n  json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n  timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.\n\n该内容位于文档中有关执行 Cypher 查询的部分，具体描述了在调用 Cypher 查询时传入的参数，包括结果输出、查询语句、图的名称、返回格式以及最大执行时间等信息。这些参数有助于用户理解如何正确使用 CallCypher 函数。"
            },
            {
                "content": "Execute a cypher query.  \r\n  执行一个 cypher 查询。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  cypher – [in] inquire statement.  \r\n  cypher – [输入] 查询语句。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n  json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n  timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  \r\n  timeout – [输入] （可选）最大执行时间，超时将被中断。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **bool CallGql(std::string &result, const std::string &gql, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Execute a gql query.  \r\n  执行一个 gql 查询。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  gql – [in] inquire statement.  \r\n  gql – [输入] 查询语句。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。\n\n该段落位于文档中的“lgraph_rpc_client”类部分，主要描述如何执行Cypher和GQL查询的相关函数及其参数。此部分阐明了如何通过RPC客户端与图数据库交互，并提供关于执行查询的详细信息和返回结果的说明。"
            },
            {
                "content": "**返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **bool CallGql(std::string &result, const std::string &gql, const std::string &graph = \"default\", bool json_format = true, double timeout = 0)**  \r\n  Execute a gql query.  \r\n  执行一个 gql 查询。\r\n\r\n  **参数**  \r\n  result – [out] The result.  \r\n  result – [输出] 结果。  \r\n  gql – [in] inquire statement.  \r\n  gql – [输入] 查询语句。  \r\n  graph – [in] (Optional) the graph to query.  \r\n  graph – [输入] （可选）要查询的图。  \r\n  json_format – [in] (Optional) Returns the format， true is json，Otherwise, binary format.  \r\n  json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n  timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  \r\n  timeout – [输入] （可选）最大执行时间，超时将被中断。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **std::string GetUrl()**  \r\n  Get the url of single client.  \r\n  获取单个客户端的 URL。\r\n\r\n  **返回**  \r\n  the url of single client.  \r\n  单个客户端的 URL。\r\n\r\n- **void Logout()**  \r\n  Client log out.\n\n该块内容位于文档的lgraph_rpc_client部分，主要描述了执行GQL查询的功能，包括参数说明和返回值的解释，同时也介绍了获取单个客户端URL和客户端登出的操作。此部分提供了与图数据库交互的接口方法，有助于理解如何进行数据库查询和用户管理。"
            },
            {
                "content": "json_format – [输入] （可选）返回格式，真为 json，其他为二进制格式。  \r\n  timeout – [in] (Optional) Maximum execution time, overruns will be interrupted.  \r\n  timeout – [输入] （可选）最大执行时间，超时将被中断。  \r\n\r\n  **返回**  \r\n  True if it succeeds, false if it fails.  \r\n  如果成功则返回真，失败则返回假。\r\n\r\n- **std::string GetUrl()**  \r\n  Get the url of single client.  \r\n  获取单个客户端的 URL。\r\n\r\n  **返回**  \r\n  the url of single client.  \r\n  单个客户端的 URL。\r\n\r\n- **void Logout()**  \r\n  Client log out.  \r\n  客户端登出。\r\n\r\n### Private Functions\r\n\r\n- **LGraphResponse HandleRequest(LGraphRequest *req)**  \r\n- **bool HandleGraphQueryRequest(lgraph::GraphQueryType type, LGraphResponse *res, const std::string &query, const std::string &graph, bool json_format, double timeout)**  \r\n- **std::string GraphQueryResponseExtractor(const GraphQueryResponse &cypher)**  \r\n\r\n### Private Members\r\n\r\n- **std::string url**  \r\n- **std::string user**  \r\n- **std::string password**  \r\n- **std::string token**  \r\n- **int64_t server_version**  \r\n- **std::shared_ptr channel**  \r\n- **std::shared_ptr cntl**\n\n此块内容位于文档关于 `lgraph_rpc_client` 类的描述中，详细介绍了该类的方法，包括执行 Cypher 查询、GQL 查询以及获取客户端 URL 和登出功能。此部分还涉及到输入参数的定义和返回值的说明，有助于理解该类在图数据库操作中的应用。"
            },
            {
                "content": "- **bool HandleGraphQueryRequest(lgraph::GraphQueryType type, LGraphResponse *res, const std::string &query, const std::string &graph, bool json_format, double timeout)**  \r\n- **std::string GraphQueryResponseExtractor(const GraphQueryResponse &cypher)**  \r\n\r\n### Private Members\r\n\r\n- **std::string url**  \r\n- **std::string user**  \r\n- **std::string password**  \r\n- **std::string token**  \r\n- **int64_t server_version**  \r\n- **std::shared_ptr channel**  \r\n- **std::shared_ptr cntl**  \r\n- **std::shared_ptr options**\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_traversal\r\n\r\n```cpp\r\nnamespace lgraph_api\r\nnamespace traversal\r\n```\r\n\r\n### Functions\r\n\r\n- **ParallelVector FindVertices(GraphDB &db, Transaction &txn, std::function filter, bool parallel = false)**  \r\n  Retrieve all vertices passing the specified filter. Note that if the transaction is not read-only, parallel will be ignored (i.e. parallelism will not be available).  \r\n  // 检索所有满足指定过滤条件的顶点。请注意，如果事务不是只读，则并行将被忽略（即无法使用并行）。\r\n\r\n  **参数**\n\n该块内容位于文档关于图查询请求处理的部分，主要描述了`HandleGraphQueryRequest`函数和`GraphQueryResponseExtractor`函数的定义，以及与其相关的私有成员变量，如`url`、`user`、`password`等，属于`RpcClient`类的实现细节。同时，文档还涉及图遍历功能的定义和如何通过过滤器检索顶点。"
            },
            {
                "content": "- **std::shared_ptr options**\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_traversal\r\n\r\n```cpp\r\nnamespace lgraph_api\r\nnamespace traversal\r\n```\r\n\r\n### Functions\r\n\r\n- **ParallelVector FindVertices(GraphDB &db, Transaction &txn, std::function filter, bool parallel = false)**  \r\n  Retrieve all vertices passing the specified filter. Note that if the transaction is not read-only, parallel will be ignored (i.e. parallelism will not be available).  \r\n  // 检索所有满足指定过滤条件的顶点。请注意，如果事务不是只读，则并行将被忽略（即无法使用并行）。\r\n\r\n  **参数**  \r\n  db – [inout] The GraphDB instance.  \r\n  // db – [输入输出] GraphDB 实例。  \r\n  txn – [inout] The transaction.  \r\n  // txn – [输入输出] 事务。  \r\n  filter – [inout] The user-defined filter function.  \r\n  // filter – [输入输出] 用户定义的过滤函数。  \r\n  parallel – (Optional) Enable parallelism or not.  \r\n  // parallel – （可选）是否启用并行。\r\n\r\n  **返回**  \r\n  The corresponding list of vertices.  \r\n  // 返回相应的顶点列表。\n\n该块内容位于文档中的“lgraph_traversal”部分，描述了图形数据库中使用的遍历函数，特别是 `FindVertices` 函数，该函数用于根据指定过滤条件检索顶点。这一部分涵盖了图分析操作的核心功能，帮助用户理解如何有效地进行顶点查询和筛选。"
            },
            {
                "content": "// 检索所有满足指定过滤条件的顶点。请注意，如果事务不是只读，则并行将被忽略（即无法使用并行）。\r\n\r\n  **参数**  \r\n  db – [inout] The GraphDB instance.  \r\n  // db – [输入输出] GraphDB 实例。  \r\n  txn – [inout] The transaction.  \r\n  // txn – [输入输出] 事务。  \r\n  filter – [inout] The user-defined filter function.  \r\n  // filter – [输入输出] 用户定义的过滤函数。  \r\n  parallel – (Optional) Enable parallelism or not.  \r\n  // parallel – （可选）是否启用并行。\r\n\r\n  **返回**  \r\n  The corresponding list of vertices.  \r\n  // 返回相应的顶点列表。\r\n\r\n- **template static ParallelVector ExtractVertexData(GraphDB &db, Transaction &txn, ParallelVector &frontier, std::function extract, bool parallel = false)**  \r\n  Extract data from specified vertices. Note that if the transaction is not read-only, parallel will be ignored (i.e. parallelism will not be available).  \r\n  // 从指定的顶点中提取数据。请注意，如果事务不是只读，则并行将被忽略（即无法使用并行）。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  \r\n  // std::runtime_error – 当发生运行时错误条件时引发。\r\n\r\n  **模板参数**  \r\n  VertexData – Type of the vertex data.\n\n该片段位于文档关于图数据库操作的部分，具体涉及使用过滤条件检索顶点以及从指定顶点提取数据的函数定义。该部分描述了如何在事务中处理顶点数据，强调了并行计算的可选性和相关参数。"
            },
            {
                "content": "Extract data from specified vertices. Note that if the transaction is not read-only, parallel will be ignored (i.e. parallelism will not be available).  \r\n  // 从指定的顶点中提取数据。请注意，如果事务不是只读，则并行将被忽略（即无法使用并行）。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  \r\n  // std::runtime_error – 当发生运行时错误条件时引发。\r\n\r\n  **模板参数**  \r\n  VertexData – Type of the vertex data.  \r\n  // VertexData – 顶点数据的类型。\r\n\r\n  **参数**  \r\n  db – [inout] The database.  \r\n  // db – [输入输出] 数据库。  \r\n  txn – [inout] The transaction.  \r\n  // txn – [输入输出] 事务。  \r\n  frontier – [inout] The vertices to extract data from.  \r\n  // frontier – [输入输出] 要提取数据的顶点。  \r\n  extract – [inout] The user-defined extract function.  \r\n  // extract – [输入输出] 用户定义的提取函数。  \r\n  parallel – (Optional) Enable parallelism or not.  \r\n  // parallel – （可选）是否启用并行。\r\n\r\n  **返回**  \r\n  The corresponding extracted data.  \r\n  // 返回相应的提取数据。\r\n\r\n- **template bool DefaultFilter(IT ⁢)**  \r\n  The default filter you may use.  \r\n  // 您可以使用的默认过滤器。\r\n\r\n  **模板参数**\n\n该块内容位于文档中的 lgraph_traversal 部分，主要涉及图遍历的功能，特别是从指定顶点提取数据的方法、相关参数和处理异常的说明。这些功能允许用户在对图数据库进行读操作时实现并行处理。"
            },
            {
                "content": "// txn – [输入输出] 事务。  \r\n  frontier – [inout] The vertices to extract data from.  \r\n  // frontier – [输入输出] 要提取数据的顶点。  \r\n  extract – [inout] The user-defined extract function.  \r\n  // extract – [输入输出] 用户定义的提取函数。  \r\n  parallel – (Optional) Enable parallelism or not.  \r\n  // parallel – （可选）是否启用并行。\r\n\r\n  **返回**  \r\n  The corresponding extracted data.  \r\n  // 返回相应的提取数据。\r\n\r\n- **template bool DefaultFilter(IT ⁢)**  \r\n  The default filter you may use.  \r\n  // 您可以使用的默认过滤器。\r\n\r\n  **模板参数**  \r\n  IT – Type of the iterator.  \r\n  // IT – 迭代器的类型。\r\n\r\n  **参数**  \r\n  it – [inout] An iterator class.  \r\n  // it – [输入输出] 一个迭代器类。\r\n\r\n  **返回**  \r\n  Always true.  \r\n  // 总是返回 true。\r\n\r\n- **template std::function LabelEquals(const std::string &label)**  \r\n  Function closure filtering by label.  \r\n  // 根据标签进行过滤的函数闭包。\r\n\r\n  **模板参数**  \r\n  IT – Type of the iterator.  \r\n  // IT – 迭代器的类型。\r\n\r\n  **参数**  \r\n  label – An iterator class.  \r\n  // label – 一个迭代器类。\r\n\r\n  **返回**  \r\n  The filter function.  \r\n  // 返回过滤函数。\n\n该内容位于文档的 **lgraph_traversal** 部分，具体讨论了图遍历操作中的过滤和提取函数。它提供了一些关于如何通过用户定义的过滤器和提取函数来处理顶点的示例，同时还定义了默认过滤器和标签过滤闭包的功能。这些内容对于实现图遍历算法和操作非常重要。"
            },
            {
                "content": "IT – Type of the iterator.  \r\n  // IT – 迭代器的类型。\r\n\r\n  **参数**  \r\n  it – [inout] An iterator class.  \r\n  // it – [输入输出] 一个迭代器类。\r\n\r\n  **返回**  \r\n  Always true.  \r\n  // 总是返回 true。\r\n\r\n- **template std::function LabelEquals(const std::string &label)**  \r\n  Function closure filtering by label.  \r\n  // 根据标签进行过滤的函数闭包。\r\n\r\n  **模板参数**  \r\n  IT – Type of the iterator.  \r\n  // IT – 迭代器的类型。\r\n\r\n  **参数**  \r\n  label – An iterator class.  \r\n  // label – 一个迭代器类。\r\n\r\n  **返回**  \r\n  The filter function.  \r\n  // 返回过滤函数。\r\n\r\n- **template std::function LabelEquals(size_t label_id)**  \r\n  Function closure filtering by label id.  \r\n  // 根据标签 ID 进行过滤的函数闭包。\r\n\r\n  **模板参数**  \r\n  IT – Type of the iterator.  \r\n  // IT – 迭代器的类型。\r\n\r\n  **参数**  \r\n  label_id – An iterator class.  \r\n  // label_id – 一个迭代器类。\r\n\r\n  **返回**  \r\n  The filter function.  \r\n  // 返回过滤函数。\r\n\r\n- **bool operator==(const Vertex &lhs, const Vertex &rhs)**  \r\n  // 重载运算符 ==，比较两个 Vertex 对象是否相等。\r\n\r\n- **bool operator!=(const Vertex &lhs, const Vertex &rhs)**\n\n该文本块位于文档的图遍历部分，主要讨论用于图遍历的迭代器类型及其相等性运算符的重载，同时提供有关标签过滤的函数闭包。这部分内容为理解在图数据库中如何通过标签进行遍历和操作提供了基础知识。"
            },
            {
                "content": "// 返回过滤函数。\r\n\r\n- **template std::function LabelEquals(size_t label_id)**  \r\n  Function closure filtering by label id.  \r\n  // 根据标签 ID 进行过滤的函数闭包。\r\n\r\n  **模板参数**  \r\n  IT – Type of the iterator.  \r\n  // IT – 迭代器的类型。\r\n\r\n  **参数**  \r\n  label_id – An iterator class.  \r\n  // label_id – 一个迭代器类。\r\n\r\n  **返回**  \r\n  The filter function.  \r\n  // 返回过滤函数。\r\n\r\n- **bool operator==(const Vertex &lhs, const Vertex &rhs)**  \r\n  // 重载运算符 ==，比较两个 Vertex 对象是否相等。\r\n\r\n- **bool operator!=(const Vertex &lhs, const Vertex &rhs)**  \r\n  // 重载运算符 !=，比较两个 Vertex 对象是否不相等。\r\n\r\n- **bool operator==(const Edge &lhs, const Edge &rhs)**  \r\n  // 重载运算符 ==，比较两个 Edge 对象是否相等。\r\n\r\n- **bool operator!=(const Edge &lhs, const Edge &rhs)**  \r\n  // 重载运算符 !=，比较两个 Edge 对象是否不相等。\r\n\r\n### Variables\r\n\r\n- `static constexpr size_t MAX_RESULT_SIZE = 1ul << 36`  \r\n  // 最大结果大小的静态常量。\r\n\r\n- `static constexpr size_t TRAVERSAL_PARALLEL = 1ul << 0`  \r\n  // 并行遍历的静态常量。\r\n\r\n- `static constexpr size_t TRAVERSAL_ALLOW_REVISITS = 1ul << 1`  \r\n  // 允许重新访问的静态常量。\r\n\r\n### class Edge\n\n该块内容属于文档中关于图遍历和图元素比较的部分，具体涉及到标签过滤函数、图的顶点和边的相等性操作符重载。该部分描述了如何通过标签 ID 进行过滤以及对顶点和边对象进行比较的运算符定义，后面还包括对最大结果大小和并行遍历的静态常量定义。这为后续的图遍历实现提供了基本的功能和相关参数设置。"
            },
            {
                "content": "// 重载运算符 !=，比较两个 Vertex 对象是否不相等。\r\n\r\n- **bool operator==(const Edge &lhs, const Edge &rhs)**  \r\n  // 重载运算符 ==，比较两个 Edge 对象是否相等。\r\n\r\n- **bool operator!=(const Edge &lhs, const Edge &rhs)**  \r\n  // 重载运算符 !=，比较两个 Edge 对象是否不相等。\r\n\r\n### Variables\r\n\r\n- `static constexpr size_t MAX_RESULT_SIZE = 1ul << 36`  \r\n  // 最大结果大小的静态常量。\r\n\r\n- `static constexpr size_t TRAVERSAL_PARALLEL = 1ul << 0`  \r\n  // 并行遍历的静态常量。\r\n\r\n- `static constexpr size_t TRAVERSAL_ALLOW_REVISITS = 1ul << 1`  \r\n  // 允许重新访问的静态常量。\r\n\r\n### class Edge\r\n\r\n```cpp\r\n#include \r\n```\r\nRepresent an edge.  \r\n// 表示一条边。\r\n\r\n**Public Functions**\r\n\r\n- **Edge(size_t start, uint16_t lid, uint64_t tid, size_t end, size_t eid, bool forward)**  \r\n  Constructor  \r\n  // 构造函数\r\n\r\n  **参数**  \r\n  start – The start.  \r\n  // start – 起始位置。  \r\n  lid – The lid.  \r\n  // lid – 标签 ID。  \r\n  tid – The tid.  \r\n  // tid – 时间 ID。  \r\n  end – The end.  \r\n  // end – 结束位置。  \r\n  eid – The eid.  \r\n  // eid – 边 ID。  \r\n  forward – True to forward.  \r\n  // forward – 如果为 true，则表示为正向。\n\n该块内容位于文档的“lgraph_traversal”部分，具体涉及到图的边（Edge）和顶点（Vertex）对象的重载运算符以及相关变量的定义。这些定义和函数用于图分析引擎中，对于实现图遍历和操作至关重要。"
            },
            {
                "content": "### class Edge\r\n\r\n```cpp\r\n#include \r\n```\r\nRepresent an edge.  \r\n// 表示一条边。\r\n\r\n**Public Functions**\r\n\r\n- **Edge(size_t start, uint16_t lid, uint64_t tid, size_t end, size_t eid, bool forward)**  \r\n  Constructor  \r\n  // 构造函数\r\n\r\n  **参数**  \r\n  start – The start.  \r\n  // start – 起始位置。  \r\n  lid – The lid.  \r\n  // lid – 标签 ID。  \r\n  tid – The tid.  \r\n  // tid – 时间 ID。  \r\n  end – The end.  \r\n  // end – 结束位置。  \r\n  eid – The eid.  \r\n  // eid – 边 ID。  \r\n  forward – True to forward.  \r\n  // forward – 如果为 true，则表示为正向。\r\n\r\n- **Edge(const Edge &rhs) = default**  \r\n  Copy constructor  \r\n  // 拷贝构造函数\r\n\r\n  **参数**  \r\n  rhs – The right hand side.  \r\n  // rhs – 右侧对象。\r\n\r\n- **Vertex GetStartVertex() const**  \r\n  Get the start vertex of this edge.  \r\n  // 获取此边的起始顶点。\r\n\r\n  **返回**  \r\n  The start vertex.  \r\n  // 返回起始顶点。\r\n\r\n- **Vertex GetEndVertex() const**  \r\n  Get the end vertex of this edge.  \r\n  // 获取此边的结束顶点。\r\n\r\n  **返回**  \r\n  The end vertex.  \r\n  // 返回结束顶点。\r\n\r\n- **uint16_t GetLabelId() const**  \r\n  Get the label ID.  \r\n  // 获取标签 ID。\n\n该代码块属于文档中有关图数据库（TuGraph）相关的数据结构定义部分，具体描述了表示边的 `Edge` 类及其构造函数、成员函数和属性，包括边的起始和结束顶点、标签ID等。这一部分为理解如何在图数据库中处理边及其属性提供了基础。"
            },
            {
                "content": "- **Edge(const Edge &rhs) = default**  \r\n  Copy constructor  \r\n  // 拷贝构造函数\r\n\r\n  **参数**  \r\n  rhs – The right hand side.  \r\n  // rhs – 右侧对象。\r\n\r\n- **Vertex GetStartVertex() const**  \r\n  Get the start vertex of this edge.  \r\n  // 获取此边的起始顶点。\r\n\r\n  **返回**  \r\n  The start vertex.  \r\n  // 返回起始顶点。\r\n\r\n- **Vertex GetEndVertex() const**  \r\n  Get the end vertex of this edge.  \r\n  // 获取此边的结束顶点。\r\n\r\n  **返回**  \r\n  The end vertex.  \r\n  // 返回结束顶点。\r\n\r\n- **uint16_t GetLabelId() const**  \r\n  Get the label ID.  \r\n  // 获取标签 ID。\r\n\r\n  **返回**  \r\n  The label ID.  \r\n  // 返回标签 ID。\r\n\r\n- **uint64_t GetTemporalId() const**  \r\n  Get the Temporal ID.  \r\n  // 获取时间 ID。\r\n\r\n  **返回**  \r\n  The temporal ID.  \r\n  // 返回时间 ID。\r\n\r\n- **size_t GetEdgeId() const**  \r\n  Get the edge ID.  \r\n  // 获取边 ID。\r\n\r\n  **返回**  \r\n  The edge ID.  \r\n  // 返回边 ID。\r\n\r\n- **bool IsForward() const**  \r\n  Get the direction of this edge.  \r\n  // 获取此边的方向。\r\n\r\n  **返回**  \r\n  true : forward; false: backward.  \r\n  // 返回 true 表示正向，false 表示反向。\r\n\r\n- **Vertex GetSrcVertex() const**\n\n该文档主要介绍了C++开发中的图数据库接口，包括存储过程、图形数据库、事务处理和图遍历等功能。在其中，关于边的构造函数和访问方法的部分，尤其是copy构造函数、获取开始和结束顶点、获取标签ID、时间ID和边ID的方法，描绘了如何操作边对象及其相关属性。这些内容对于实现基于图的算法和分析至关重要。"
            },
            {
                "content": "**返回**  \r\n  The label ID.  \r\n  // 返回标签 ID。\r\n\r\n- **uint64_t GetTemporalId() const**  \r\n  Get the Temporal ID.  \r\n  // 获取时间 ID。\r\n\r\n  **返回**  \r\n  The temporal ID.  \r\n  // 返回时间 ID。\r\n\r\n- **size_t GetEdgeId() const**  \r\n  Get the edge ID.  \r\n  // 获取边 ID。\r\n\r\n  **返回**  \r\n  The edge ID.  \r\n  // 返回边 ID。\r\n\r\n- **bool IsForward() const**  \r\n  Get the direction of this edge.  \r\n  // 获取此边的方向。\r\n\r\n  **返回**  \r\n  true : forward; false: backward.  \r\n  // 返回 true 表示正向，false 表示反向。\r\n\r\n- **Vertex GetSrcVertex() const**  \r\n  Get the source vertex of this edge.  \r\n  // 获取此边的源顶点。\r\n\r\n  **返回**  \r\n  The source vertex.  \r\n  // 返回源顶点。\r\n\r\n- **Vertex GetDstVertex() const**  \r\n  Get the destination vertex of this edge.  \r\n  // 获取此边的目标顶点。\r\n\r\n  **返回**  \r\n  The destination vertex.  \r\n  // 返回目标顶点。\r\n\r\n**Private Members**\r\n\r\n- size_t start_  \r\n  // 起始位置。\r\n\r\n- size_t end_  \r\n  // 结束位置。\r\n\r\n- size_t eid_  \r\n  // 边 ID。\r\n\r\n- uint16_t lid_  \r\n  // 标签 ID。\r\n\r\n- int64_t tid_  \r\n  // 时间 ID。\r\n\r\n- bool forward_  \r\n  // 方向标志。\r\n\r\n**Friends**\n\n该段落位于文档关于图数据库 API 的 `Edge` 类的描述中，具体介绍了与边相关的功能和属性，包括获取边的 ID、方向、源顶点和目标顶点等信息，以及相关的私有成员变量。这些内容在图分析和操作过程中至关重要。"
            },
            {
                "content": "Get the source vertex of this edge.  \r\n  // 获取此边的源顶点。\r\n\r\n  **返回**  \r\n  The source vertex.  \r\n  // 返回源顶点。\r\n\r\n- **Vertex GetDstVertex() const**  \r\n  Get the destination vertex of this edge.  \r\n  // 获取此边的目标顶点。\r\n\r\n  **返回**  \r\n  The destination vertex.  \r\n  // 返回目标顶点。\r\n\r\n**Private Members**\r\n\r\n- size_t start_  \r\n  // 起始位置。\r\n\r\n- size_t end_  \r\n  // 结束位置。\r\n\r\n- size_t eid_  \r\n  // 边 ID。\r\n\r\n- uint16_t lid_  \r\n  // 标签 ID。\r\n\r\n- int64_t tid_  \r\n  // 时间 ID。\r\n\r\n- bool forward_  \r\n  // 方向标志。\r\n\r\n**Friends**\r\n\r\n- friend class Path  \r\n  // 友元类 Path  \r\n- friend class IteratorHelper  \r\n  // 友元类 IteratorHelper  \r\n- friend class PathTraversal  \r\n  // 友元类 PathTraversal  \r\n\r\n### class FrontierTraversal\r\n\r\n```cpp\r\n#include \r\n```\n\n该块内容位于有关TuGraph图遍历和边操作的描述部分，特别是关于边的基本功能和成员变量的实现，包括获取边的源顶点和目标顶点的方法，以及边的相关私有成员和友元类的定义。"
            },
            {
                "content": "**返回**  \r\n  The destination vertex.  \r\n  // 返回目标顶点。\r\n\r\n**Private Members**\r\n\r\n- size_t start_  \r\n  // 起始位置。\r\n\r\n- size_t end_  \r\n  // 结束位置。\r\n\r\n- size_t eid_  \r\n  // 边 ID。\r\n\r\n- uint16_t lid_  \r\n  // 标签 ID。\r\n\r\n- int64_t tid_  \r\n  // 时间 ID。\r\n\r\n- bool forward_  \r\n  // 方向标志。\r\n\r\n**Friends**\r\n\r\n- friend class Path  \r\n  // 友元类 Path  \r\n- friend class IteratorHelper  \r\n  // 友元类 IteratorHelper  \r\n- friend class PathTraversal  \r\n  // 友元类 PathTraversal  \r\n\r\n### class FrontierTraversal\r\n\r\n```cpp\r\n#include \r\n```\r\nFrontierTraversal provides the most common way to traverse graphs. You can start from a single vertex or a set of vertices (known as the initial frontier), and expand them frontier by frontier, each time visiting neighboring vertices of the current frontier and make those matching specified conditions the new frontier. One powerful feature of FrontierTraversal is that the traversal can be performed in parallel, accelerating those deep queries significantly.\n\n该文本块位于文档的“lgraph_vertex_iterator”类的部分，描述了类的公共函数、私有成员以及朋友类，同时介绍了“FrontierTraversal”类的功能，用于图的遍历。"
            },
            {
                "content": "```cpp\r\n#include \r\n```\r\nFrontierTraversal provides the most common way to traverse graphs. You can start from a single vertex or a set of vertices (known as the initial frontier), and expand them frontier by frontier, each time visiting neighboring vertices of the current frontier and make those matching specified conditions the new frontier. One powerful feature of FrontierTraversal is that the traversal can be performed in parallel, accelerating those deep queries significantly.  \r\n// FrontierTraversal 提供了遍历图的最常用方式。您可以从单个顶点或一个顶点集合（称为初始前沿）开始，然后逐渐扩展每个前沿，每次访问当前前沿的邻居顶点，并使符合指定条件的顶点成为新的前沿。FrontierTraversal 的一个强大特性是遍历可以并行执行，从而显著加速深度查询。\r\n\r\n**Public Functions**\r\n\r\n- **FrontierTraversal(GraphDB &db, Transaction &txn, size_t flags = 0, size_t capacity = MAX_RESULT_SIZE)**\n\n该代码块位于文档中关于图遍历的部分，具体讨论了`FrontierTraversal`类，它是用于在图中执行遍历操作的主要方式。此部分描述了如何从一个或多个顶点开始扩展遍历，同时强调了并行执行的强大功能，以提高深度查询的效率。"
            },
            {
                "content": "// FrontierTraversal 提供了遍历图的最常用方式。您可以从单个顶点或一个顶点集合（称为初始前沿）开始，然后逐渐扩展每个前沿，每次访问当前前沿的邻居顶点，并使符合指定条件的顶点成为新的前沿。FrontierTraversal 的一个强大特性是遍历可以并行执行，从而显著加速深度查询。\r\n\r\n**Public Functions**\r\n\r\n- **FrontierTraversal(GraphDB &db, Transaction &txn, size_t flags = 0, size_t capacity = MAX_RESULT_SIZE)**  \r\n  Construct the FrontierTraversal object. Note that the transaction must be read-only if you want to perform the traversals in parallel (i.e. TRAVERSAL_PARALLEL is specified in flags). Be careful when TRAVERSAL_ALLOW_REVISITS is used, as each vertex may be visited more than once, making the result set huge.  \r\n  // 构造 FrontierTraversal 对象。请注意，如果您希望并行执行遍历，则事务必须是只读的（即在标志中指定了 TRAVERSAL_PARALLEL）。使用 TRAVERSAL_ALLOW_REVISITS 时要小心，因为每个顶点可能会被访问多次，从而使结果集变得庞大。\r\n\r\n  **参数**  \r\n  db – [inout] The GraphDB instance.  \r\n  // db – [输入输出] GraphDB 实例。  \r\n  txn – [inout] The transaction.  \r\n  // txn – [输入输出] 事务。  \r\n  flags – (Optional) The options used during traversals.  \r\n  // flags – （可选）遍历时使用的选项。\r\n\r\n- **ParallelVector &GetFrontier()**\n\n该文档主要介绍了 TuGraph 中的各种接口和类，包括图形数据库、事务、图遍历以及插件框架等。特别地，FrontierTraversal 类提供了一种高效的图遍历方式，允许从单个或多个顶点开始，逐步扩展前沿并进行并行处理，以提高深度查询的性能。这个片段描述了 FrontierTraversal 的构造函数和基本用法。"
            },
            {
                "content": "// 构造 FrontierTraversal 对象。请注意，如果您希望并行执行遍历，则事务必须是只读的（即在标志中指定了 TRAVERSAL_PARALLEL）。使用 TRAVERSAL_ALLOW_REVISITS 时要小心，因为每个顶点可能会被访问多次，从而使结果集变得庞大。\r\n\r\n  **参数**  \r\n  db – [inout] The GraphDB instance.  \r\n  // db – [输入输出] GraphDB 实例。  \r\n  txn – [inout] The transaction.  \r\n  // txn – [输入输出] 事务。  \r\n  flags – (Optional) The options used during traversals.  \r\n  // flags – （可选）遍历时使用的选项。\r\n\r\n- **ParallelVector &GetFrontier()**  \r\n  Retrieve the current (i.e. latest) frontier.  \r\n  // 获取当前（即最新）的前沿。\r\n\r\n  **返回**  \r\n  The frontier.  \r\n  // 返回前沿。\r\n\r\n- **void SetFrontier(size_t root_vid)**  \r\n  Set the (initial) frontier to contain a single vertex.  \r\n  // 设置（初始）前沿为单个顶点。\r\n\r\n  **参数**  \r\n  root_vid – The identifer for the starting vertex.  \r\n  // root_vid – 起始顶点的标识符。\r\n\r\n- **void SetFrontier(ParallelVector &root_vids)**  \r\n  Set the (initial) frontier to contain a set of vertices.  \r\n  // 设置（初始）前沿为一组顶点。\r\n\r\n  **参数**  \r\n  root_vids – [inout] The starting vertex identifiers.  \r\n  // root_vids – [输入输出] 起始顶点的标识符。\n\n该代码块位于文档的“lgraph_traversal”部分，描述了 FrontierTraversal 类的构造和使用方法。FrontierTraversal 类用于图的遍历操作，强调了并行遍历的要求和参数设置，包括初始前沿的设置和获取当前前沿的功能。这部分内容主要关注如何在图数据库中有效地执行遍历操作。"
            },
            {
                "content": "**返回**  \r\n  The frontier.  \r\n  // 返回前沿。\r\n\r\n- **void SetFrontier(size_t root_vid)**  \r\n  Set the (initial) frontier to contain a single vertex.  \r\n  // 设置（初始）前沿为单个顶点。\r\n\r\n  **参数**  \r\n  root_vid – The identifer for the starting vertex.  \r\n  // root_vid – 起始顶点的标识符。\r\n\r\n- **void SetFrontier(ParallelVector &root_vids)**  \r\n  Set the (initial) frontier to contain a set of vertices.  \r\n  // 设置（初始）前沿为一组顶点。\r\n\r\n  **参数**  \r\n  root_vids – [inout] The starting vertex identifiers.  \r\n  // root_vids – [输入输出] 起始顶点的标识符。\r\n\r\n- **void SetFrontier(std::function root_vertex_filter)**  \r\n  Set the (initial) frontier by using a filter function. Each vertex will be checked against the specified filter.  \r\n  // 使用过滤函数设置（初始）前沿。每个顶点将根据指定的过滤器进行检查。\r\n\r\n  **参数**  \r\n  root_vertex_filter – [inout] The filter function.  \r\n  // root_vertex_filter – [输入输出] 过滤函数。\r\n\r\n- **void ExpandOutEdges(std::function out_edge_filter = nullptr, std::function out_neighbour_filter = nullptr)**\n\n该块内容位于文档中关于图遍历的部分，具体介绍了如何设置遍历的初始前沿，包括设置单个顶点、多个顶点或使用过滤函数来定义初始前沿。这对于理解和使用TuGraph图分析引擎中的遍历算法至关重要。"
            },
            {
                "content": "// root_vids – [输入输出] 起始顶点的标识符。\r\n\r\n- **void SetFrontier(std::function root_vertex_filter)**  \r\n  Set the (initial) frontier by using a filter function. Each vertex will be checked against the specified filter.  \r\n  // 使用过滤函数设置（初始）前沿。每个顶点将根据指定的过滤器进行检查。\r\n\r\n  **参数**  \r\n  root_vertex_filter – [inout] The filter function.  \r\n  // root_vertex_filter – [输入输出] 过滤函数。\r\n\r\n- **void ExpandOutEdges(std::function out_edge_filter = nullptr, std::function out_neighbour_filter = nullptr)**  \r\n  Expand the current frontier through outgoing edges using filters. Note that the default value for the two filters (nullptr) means all the expansions of this level should succeed and enables some optimizations.  \r\n  // 通过使用过滤器通过出边扩展当前前沿。请注意，两个过滤器的默认值（nullptr）意味着该级别的所有扩展应该成功，并启用一些优化。\r\n\r\n  **参数**  \r\n  out_edge_filter – [inout] (Optional) The filter for an outgoing edge.  \r\n  // out_edge_filter – [输入输出] （可选）出边的过滤器。  \r\n  out_neighbour_filter – [inout] (Optional) The filter for an destination vertex.\n\n该文本块位于文档的“lgraph_traversal”部分中，介绍了如何使用过滤函数设置初始前沿以及如何通过出边扩展当前前沿的操作。这些功能对于图遍历的实现至关重要，允许用户定义过滤条件以选择性地遍历图中的顶点和边。"
            },
            {
                "content": "Expand the current frontier through outgoing edges using filters. Note that the default value for the two filters (nullptr) means all the expansions of this level should succeed and enables some optimizations.  \r\n  // 通过使用过滤器通过出边扩展当前前沿。请注意，两个过滤器的默认值（nullptr）意味着该级别的所有扩展应该成功，并启用一些优化。\r\n\r\n  **参数**  \r\n  out_edge_filter – [inout] (Optional) The filter for an outgoing edge.  \r\n  // out_edge_filter – [输入输出] （可选）出边的过滤器。  \r\n  out_neighbour_filter – [inout] (Optional) The filter for an destination vertex.  \r\n  // out_neighbour_filter – [输入输出] （可选）目标顶点的过滤器。\r\n\r\n- **void ExpandInEdges(std::function in_edge_filter = nullptr, std::function in_neighbour_filter = nullptr)**  \r\n  Expand the current frontier through incoming edges using filters. Note that the default value for the two filters (nullptr) means all the expansions of this level should succeed and enables some optimizations.  \r\n  // 通过使用过滤器通过入边扩展当前前沿。请注意，两个过滤器的默认值（nullptr）意味着该级别的所有扩展应该成功，并启用一些优化。\r\n\r\n  **参数**\n\n该片段来自于描述如何使用过滤器扩展图遍历的 `FrontierTraversal` 类的部分，具体讲解了如何通过出边和入边来扩展当前前沿。此部分强调了默认过滤器的设定及其对遍历结果的影响，并介绍了相关参数的作用。"
            },
            {
                "content": "// out_neighbour_filter – [输入输出] （可选）目标顶点的过滤器。\r\n\r\n- **void ExpandInEdges(std::function in_edge_filter = nullptr, std::function in_neighbour_filter = nullptr)**  \r\n  Expand the current frontier through incoming edges using filters. Note that the default value for the two filters (nullptr) means all the expansions of this level should succeed and enables some optimizations.  \r\n  // 通过使用过滤器通过入边扩展当前前沿。请注意，两个过滤器的默认值（nullptr）意味着该级别的所有扩展应该成功，并启用一些优化。\r\n\r\n  **参数**  \r\n  in_edge_filter – [inout] (Optional) The filter for an incoming edge.  \r\n  // in_edge_filter – [输入输出] （可选）入边的过滤器。  \r\n  in_neighbour_filter – [inout] (Optional) The filter for an source vertex.  \r\n  // in_neighbour_filter – [输入输出] （可选）源顶点的过滤器。\r\n\r\n- **void ExpandEdges(std::function out_edge_filter = nullptr, std::function in_edge_filter = nullptr, std::function out_neighbour_filter = nullptr, std::function in_neighbour_filter = nullptr)**\n\n该块内容位于文档的 \"lgraph_traversal\" 部分，主要讨论图遍历算法中的前沿扩展方法，包括如何通过入边和出边进行扩展，以及相关的过滤器参数。这些函数在图分析中用于控制遍历过程，确保遍历的灵活性和效率。"
            },
            {
                "content": "**参数**  \r\n  in_edge_filter – [inout] (Optional) The filter for an incoming edge.  \r\n  // in_edge_filter – [输入输出] （可选）入边的过滤器。  \r\n  in_neighbour_filter – [inout] (Optional) The filter for an source vertex.  \r\n  // in_neighbour_filter – [输入输出] （可选）源顶点的过滤器。\r\n\r\n- **void ExpandEdges(std::function out_edge_filter = nullptr, std::function in_edge_filter = nullptr, std::function out_neighbour_filter = nullptr, std::function in_neighbour_filter = nullptr)**  \r\n  Expand the current frontier through both directions using filters. Note that the default value for the two filters (nullptr) means all the expansions of this level should succeed and enables some optimizations.  \r\n  // 通过使用过滤器在两个方向上扩展当前前沿。请注意，两个过滤器的默认值（nullptr）意味着该级别的所有扩展应该成功，并启用一些优化。\r\n\r\n  **参数**  \r\n  out_edge_filter – [inout] (Optional) The filter for an outgoing edge.  \r\n  // out_edge_filter – [输入输出] （可选）出边的过滤器。  \r\n  in_edge_filter – [inout] (Optional) The filter for an incoming edge.  \r\n  // in_edge_filter – [输入输出] （可选）入边的过滤器。\n\n该代码块位于文档中关于图遍历的部分，特别是 `FrontierTraversal` 类中的函数定义，涉及扩展当前前沿的边。它描述了如何使用过滤器扩展当前前沿，包括入边和出边的过滤器参数。这一部分强调了并行遍历图的灵活性和效率，是理解图分析算法实现的关键部分。"
            },
            {
                "content": "// 通过使用过滤器在两个方向上扩展当前前沿。请注意，两个过滤器的默认值（nullptr）意味着该级别的所有扩展应该成功，并启用一些优化。\r\n\r\n  **参数**  \r\n  out_edge_filter – [inout] (Optional) The filter for an outgoing edge.  \r\n  // out_edge_filter – [输入输出] （可选）出边的过滤器。  \r\n  in_edge_filter – [inout] (Optional) The filter for an incoming edge.  \r\n  // in_edge_filter – [输入输出] （可选）入边的过滤器。  \r\n  out_neighbour_filter – [inout] (Optional) The filter for an destination vertex.  \r\n  // out_neighbour_filter – [输入输出] （可选）目标顶点的过滤器。  \r\n  in_neighbour_filter – [inout] (Optional) The filter for an source vertex.  \r\n  // in_neighbour_filter – [输入输出] （可选）源顶点的过滤器。\r\n\r\n- **void Reset()**  \r\n  Reset the traversal.  \r\n  // 重置遍历。\r\n\r\n- **void ResetVisited()**  \r\n  Reset only the visited flags.  \r\n  // 仅重置已访问的标志。\r\n\r\n**Private Members**\r\n\r\n- GraphDB &db_  \r\n  // GraphDB 引用。\r\n\r\n- Transaction &txn_  \r\n  // 事务引用。\r\n\r\n- size_t flags_  \r\n  // 标志。\r\n\r\n- size_t num_vertices_  \r\n  // 顶点数量。\r\n\r\n- ParallelVector curr_frontier_  \r\n  // 当前前沿。\r\n\r\n- ParallelVector next_frontier_  \r\n  // 下一个前沿。\r\n\r\n### class Vertex\n\n该片段位于文档的“lgraph_traversal”部分，描述了使用过滤器在图遍历中如何扩展当前前沿的过程。它详细说明了不同类型的过滤器及其参数，并介绍了重置遍历的相关方法和私有成员变量。"
            },
            {
                "content": "// in_neighbour_filter – [输入输出] （可选）源顶点的过滤器。\r\n\r\n- **void Reset()**  \r\n  Reset the traversal.  \r\n  // 重置遍历。\r\n\r\n- **void ResetVisited()**  \r\n  Reset only the visited flags.  \r\n  // 仅重置已访问的标志。\r\n\r\n**Private Members**\r\n\r\n- GraphDB &db_  \r\n  // GraphDB 引用。\r\n\r\n- Transaction &txn_  \r\n  // 事务引用。\r\n\r\n- size_t flags_  \r\n  // 标志。\r\n\r\n- size_t num_vertices_  \r\n  // 顶点数量。\r\n\r\n- ParallelVector curr_frontier_  \r\n  // 当前前沿。\r\n\r\n- ParallelVector next_frontier_  \r\n  // 下一个前沿。\r\n\r\n### class Vertex\r\n\r\n```cpp\r\n#include \r\n```\r\nRepresent a vertex.  \r\n// 表示一个顶点。\r\n\r\n#### Public Functions\r\n\r\n- **explicit Vertex(size_t vid)**  \r\n  Constructor  \r\n  // 构造函数\r\n\r\n  **参数**  \r\n  vid – The vid.  \r\n  // vid – 顶点 ID。\r\n\r\n- **Vertex(const Vertex &rhs) = default**  \r\n  Copy constructor  \r\n  // 拷贝构造函数\r\n\r\n  **参数**  \r\n  rhs – The right hand side.  \r\n  // rhs – 右侧对象。\r\n\r\n- **size_t GetId() const**  \r\n  Get the Id of this vertex.  \r\n  // 获取此顶点的 ID。\r\n\r\n  **返回**  \r\n  The Id.  \r\n  // 返回 ID。\r\n\r\n#### Private Members\r\n\r\n- size_t vid_  \r\n  // 顶点 ID。\n\n该段落源自《lgraph_traversal》类的描述部分，介绍了图遍历的相关功能，包括重置遍历和重置访问标志的方法。此外，还定义了`Vertex`类，该类用于表示图中的顶点，包含构造函数、拷贝构造函数及获取顶点ID的方法。"
            },
            {
                "content": "```\r\nRepresent a vertex.  \r\n// 表示一个顶点。\r\n\r\n#### Public Functions\r\n\r\n- **explicit Vertex(size_t vid)**  \r\n  Constructor  \r\n  // 构造函数\r\n\r\n  **参数**  \r\n  vid – The vid.  \r\n  // vid – 顶点 ID。\r\n\r\n- **Vertex(const Vertex &rhs) = default**  \r\n  Copy constructor  \r\n  // 拷贝构造函数\r\n\r\n  **参数**  \r\n  rhs – The right hand side.  \r\n  // rhs – 右侧对象。\r\n\r\n- **size_t GetId() const**  \r\n  Get the Id of this vertex.  \r\n  // 获取此顶点的 ID。\r\n\r\n  **返回**  \r\n  The Id.  \r\n  // 返回 ID。\r\n\r\n#### Private Members\r\n\r\n- size_t vid_  \r\n  // 顶点 ID。  \r\n\r\n#### Friends\r\n\r\n- friend class Path  \r\n  // 友元类 Path  \r\n- friend class IteratorHelper  \r\n  // 友元类 IteratorHelper  \r\n- friend class PathTraversal  \r\n  // 友元类 PathTraversal\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  \r\n\r\n\r\n## lgraph_txn\r\n\r\n```cpp\r\nnamespace lgraph\r\nnamespace lgraph_api\r\nclass Transaction\r\n#include \r\n```\r\n\r\nTuGraph operations happen in transactions. A transaction is a sequence of operations that is carried out atomically on the GraphDB. TuGraph transactions provide full ACID guarantees.\n\n该文本块位于文档中关于TuGraph API的部分，具体讨论了顶点（Vertex）的表示和相关操作，包括顶点的构造函数、拷贝构造函数、获取顶点ID的方法以及与之相关的私有成员和友元类。这部分内容为了解TuGraph数据库中顶点的管理和处理奠定了基础。紧接着的部分则介绍了事务（Transaction）在TuGraph操作中的重要性及其对ACID特性的支持。"
            },
            {
                "content": "// 顶点 ID。  \r\n\r\n#### Friends\r\n\r\n- friend class Path  \r\n  // 友元类 Path  \r\n- friend class IteratorHelper  \r\n  // 友元类 IteratorHelper  \r\n- friend class PathTraversal  \r\n  // 友元类 PathTraversal\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  \r\n\r\n\r\n## lgraph_txn\r\n\r\n```cpp\r\nnamespace lgraph\r\nnamespace lgraph_api\r\nclass Transaction\r\n#include \r\n```\r\n\r\nTuGraph operations happen in transactions. A transaction is a sequence of operations that is carried out atomically on the GraphDB. TuGraph transactions provide full ACID guarantees.\r\n// TuGraph 操作在交易中进行。一个交易是一系列在 GraphDB 上原子执行的操作。TuGraph 交易提供完全的 ACID 保证。\r\n\r\nTransactions are created using `GraphDB::CreateReadTxn()` and `GraphDB::CreateWriteTxn()`. A read transaction can only perform read operations, otherwise an exception is thrown. A write transaction can perform reads as well as writes. There are performance differences between read and write operations. So if you only need read in a transaction, you should create a read transaction.\n\n该内容在文档中主要讨论了 `VertexIterator` 类及其相关函数和成员，具体描述了如何遍历图数据库中的顶点，并介绍了顶点的基本操作和属性。随后，文档转向 `Transaction` 类，讲述了图操作在事务中的执行方式，包括事务的创建、读写权限及其对图数据库的完整 ACID 保证。"
            },
            {
                "content": "// TuGraph 操作在交易中进行。一个交易是一系列在 GraphDB 上原子执行的操作。TuGraph 交易提供完全的 ACID 保证。\r\n\r\nTransactions are created using `GraphDB::CreateReadTxn()` and `GraphDB::CreateWriteTxn()`. A read transaction can only perform read operations, otherwise an exception is thrown. A write transaction can perform reads as well as writes. There are performance differences between read and write operations. So if you only need read in a transaction, you should create a read transaction.\r\n// 交易是通过 `GraphDB::CreateReadTxn()` 和 `GraphDB::CreateWriteTxn()` 创建的。读交易只能执行读取操作，否则会抛出异常。写交易可以执行读取和写入操作。读取和写入操作之间存在性能差异。因此，如果您只需要在交易中读取，您应该创建一个读取交易。\r\n\r\nEach transaction must be used in one thread only, and they should not be passed from one thread to another unless it is a forked transaction.\r\n// 每个交易必须只在一个线程中使用，并且它们不应从一个线程传递到另一个线程，除非是一个派生交易。\n\n本段选自有关TuGraph的交易管理部分，详细说明了交易的创建、性质以及并发使用的限制，强调了在不同事务类型之间的性能差异和安全性注意事项。"
            },
            {
                "content": "// 交易是通过 `GraphDB::CreateReadTxn()` 和 `GraphDB::CreateWriteTxn()` 创建的。读交易只能执行读取操作，否则会抛出异常。写交易可以执行读取和写入操作。读取和写入操作之间存在性能差异。因此，如果您只需要在交易中读取，您应该创建一个读取交易。\r\n\r\nEach transaction must be used in one thread only, and they should not be passed from one thread to another unless it is a forked transaction.\r\n// 每个交易必须只在一个线程中使用，并且它们不应从一个线程传递到另一个线程，除非是一个派生交易。\r\n\r\nRead transactions can be forked. The new copy of the transaction will have the same view as the forked one, and it can be used in a separate thread. By forking from one read transaction and using the forked copies in different threads, we can parallelize the execution of specific operations. For example, you can implement a parallel BFS with this capability. Also, you can dump a snapshot of the whole graph using.\r\n// 读交易可以被派生。新副本的交易将与被派生的交易具有相同的视图，并且可以在不同的线程中使用。通过从一个读取交易派生并在不同线程中使用派生的副本，我们可以并行化特定操作的执行。例如，您可以利用此能力实现并行 BFS。同时，您可以使用它导出整个图的快照。\r\n\r\n### Public Functions\r\n\r\n```cpp\r\nTransaction(Transaction &&rhs) = default\n\n该文档主要介绍了TuGraph的C++存储过程接口，包括图数据库操作、事务管理和各种函数定义。在此背景下，上述片段详细描述了事务的创建与使用，强调了读取和写入交易之间的区别，以及读交易能够分叉以实现并行处理的功能。这些内容为理解如何高效管理和操作图数据库中的数据提供了重要信息。"
            },
            {
                "content": "// 读交易可以被派生。新副本的交易将与被派生的交易具有相同的视图，并且可以在不同的线程中使用。通过从一个读取交易派生并在不同线程中使用派生的副本，我们可以并行化特定操作的执行。例如，您可以利用此能力实现并行 BFS。同时，您可以使用它导出整个图的快照。\r\n\r\n### Public Functions\r\n\r\n```cpp\r\nTransaction(Transaction &&rhs) = default\r\nTransaction &operator=(Transaction &&rhs) = default\r\nTransaction(const Transaction&) = delete\r\nTransaction &operator=(const Transaction&) = delete\r\n```\r\n\r\n```cpp\r\nvoid Commit()\r\n```\r\nCommits this transaction. Note that optimistic write transactions may fail to commit (an TxnConflict would be thrown).\r\n// 提交此交易。请注意，乐观写交易可能会无法提交（将抛出 TxnConflict）。\r\n\r\n```cpp\r\nvoid Abort()\r\n```\r\nAborts this transaction.\r\n// 中止此交易。\r\n\r\n```cpp\r\nbool IsValid() const\r\n```\r\nQuery if this transaction is valid. Transaction becomes invalid after calling Abort() or Commit(). Operations on invalid transaction yield exceptions.\r\n// 查询此交易是否有效。交易在调用 Abort() 或 Commit() 后变为无效。在无效交易上执行操作将导致异常。\r\n\r\n返回  \r\nTrue if valid, false if not.\r\n// 如果有效返回 true，否则返回 false。\r\n\r\n```cpp\r\nbool IsReadOnly() const\r\n```\r\nQuery if this txn is read only.\n\n该代码块位于文档的“lgraph_txn”部分，讨论了TuGraph中的事务管理，特别是关于读取事务的派生和使用。它提供了关于事务的构造、提交、撤销和有效性检查的函数，描述了事务在图数据库中的重要性和功能。"
            },
            {
                "content": "// 提交此交易。请注意，乐观写交易可能会无法提交（将抛出 TxnConflict）。\r\n\r\n```cpp\r\nvoid Abort()\r\n```\r\nAborts this transaction.\r\n// 中止此交易。\r\n\r\n```cpp\r\nbool IsValid() const\r\n```\r\nQuery if this transaction is valid. Transaction becomes invalid after calling Abort() or Commit(). Operations on invalid transaction yield exceptions.\r\n// 查询此交易是否有效。交易在调用 Abort() 或 Commit() 后变为无效。在无效交易上执行操作将导致异常。\r\n\r\n返回  \r\nTrue if valid, false if not.\r\n// 如果有效返回 true，否则返回 false。\r\n\r\n```cpp\r\nbool IsReadOnly() const\r\n```\r\nQuery if this txn is read only.\r\n// 查询此交易是否为只读。\r\n\r\n返回  \r\nTrue if read only, false if not.\r\n// 如果是只读返回 true，否则返回 false。\r\n\r\n```cpp\r\nconst std::shared_ptr GetTxn()\r\n```\r\nGet Transaction.\r\n// 获取交易。\r\n\r\n返回  \r\nTransaction.\r\n// 交易。\r\n\r\n```cpp\r\nVertexIterator GetVertexIterator()\r\n```\r\nGet a vertex iterator pointing to the first vertex. If there is no vertex, the iterator is invalid.\r\n// 获取指向第一个顶点的顶点迭代器。如果没有顶点，则迭代器无效。\r\n\r\n返回  \r\nThe vertex iterator.\r\n// 顶点迭代器。\r\n\r\n```cpp\r\nVertexIterator GetVertexIterator(int64_t vid, bool nearest = false)\r\n```\n\n该片段位于文档中关于TuGraph交易（Transaction）类的部分，描述了交易的基本功能和行为，包括提交、回滚、验证交易有效性以及获取相关的顶点迭代器。这部分提供了关于如何在图数据库中进行事务管理的重要信息。"
            },
            {
                "content": "// 查询此交易是否为只读。\r\n\r\n返回  \r\nTrue if read only, false if not.\r\n// 如果是只读返回 true，否则返回 false。\r\n\r\n```cpp\r\nconst std::shared_ptr GetTxn()\r\n```\r\nGet Transaction.\r\n// 获取交易。\r\n\r\n返回  \r\nTransaction.\r\n// 交易。\r\n\r\n```cpp\r\nVertexIterator GetVertexIterator()\r\n```\r\nGet a vertex iterator pointing to the first vertex. If there is no vertex, the iterator is invalid.\r\n// 获取指向第一个顶点的顶点迭代器。如果没有顶点，则迭代器无效。\r\n\r\n返回  \r\nThe vertex iterator.\r\n// 顶点迭代器。\r\n\r\n```cpp\r\nVertexIterator GetVertexIterator(int64_t vid, bool nearest = false)\r\n```\r\nGets a vertex iterator pointing to the Vertex with vid. If the vertex does not exist, the iterator is invalid. If nearest==true, the iterator points to the first vertex sorted by vid, with id>=vid.\r\n// 获取指向具有 vid 的顶点的顶点迭代器。如果该顶点不存在，则迭代器无效。如果 nearest==true，迭代器指向按 vid 排序的第一个顶点，具有 id>=vid。\r\n\r\n参数  \r\nvid – The vid.  \r\n// vid – 顶点 ID。  \r\nnearest – (Optional) True to point to the nearest vertex sorted by vid.\r\n// nearest – （可选）如果为 true，则指向按 vid 排序的最近顶点。\r\n\r\n返回  \r\nThe vertex iterator.\r\n// 顶点迭代器。\r\n\r\n```cpp\n\n该段落位于文档的“lgraph_txn”类部分，描述了交易的有效性、获取交易实例的方法，以及获取特定顶点的迭代器的功能。这部分内容专注于如何在图数据库中管理和操作事务，同时提供有关顶点迭代器的相关信息，使用户能够有效地访问和遍历图中的顶点。"
            },
            {
                "content": "```\r\nGets a vertex iterator pointing to the Vertex with vid. If the vertex does not exist, the iterator is invalid. If nearest==true, the iterator points to the first vertex sorted by vid, with id>=vid.\r\n// 获取指向具有 vid 的顶点的顶点迭代器。如果该顶点不存在，则迭代器无效。如果 nearest==true，迭代器指向按 vid 排序的第一个顶点，具有 id>=vid。\r\n\r\n参数  \r\nvid – The vid.  \r\n// vid – 顶点 ID。  \r\nnearest – (Optional) True to point to the nearest vertex sorted by vid.\r\n// nearest – （可选）如果为 true，则指向按 vid 排序的最近顶点。\r\n\r\n返回  \r\nThe vertex iterator.\r\n// 顶点迭代器。\r\n\r\n```cpp\r\nOutEdgeIterator GetOutEdgeIterator(const EdgeUid &euid, bool nearest = false)\r\n```\r\nGets an out edge iterator pointing to the edge specified by euid. If nearest==true, and the specified edge does not exist, return the first edge that sorts after the specified one.\r\n// 获取指向由 euid 指定的边的出边迭代器。如果 nearest==true，并且指定的边不存在，则返回在指定边之后排序的第一条边。\r\n\r\n参数  \r\neuid – Edge Unique Id.  \r\n// euid – 边的唯一 ID。  \r\nnearest – (Optional) If true, get the first edge that sorts after the specified one if the specified one does not exist.\n\n此代码块位于文档中有关图数据库中顶点和边迭代器的部分，具体描述了如何获取指向特定顶点的迭代器以及获取出边迭代器的相关函数和参数。这些功能是 TuGraph 图数据库操作的核心，用户可以通过它们遍历图中的顶点和边。"
            },
            {
                "content": "```\r\nGets an out edge iterator pointing to the edge specified by euid. If nearest==true, and the specified edge does not exist, return the first edge that sorts after the specified one.\r\n// 获取指向由 euid 指定的边的出边迭代器。如果 nearest==true，并且指定的边不存在，则返回在指定边之后排序的第一条边。\r\n\r\n参数  \r\neuid – Edge Unique Id.  \r\n// euid – 边的唯一 ID。  \r\nnearest – (Optional) If true, get the first edge that sorts after the specified one if the specified one does not exist.\r\n// nearest – （可选）如果为 true，则在指定边不存在时，获取在指定边之后排序的第一条边。\r\n\r\n返回  \r\nThe out edge iterator.\r\n// 出边迭代器。\r\n\r\n```cpp\r\nOutEdgeIterator GetOutEdgeIterator(const int64_t src, const int64_t dst, const int16_t lid)\r\n```\r\n\r\n```cpp\r\nInEdgeIterator GetInEdgeIterator(const EdgeUid &euid, bool nearest = false)\r\n```\r\nGets an in edge iterator pointing to the edge specified by euid. If nearest==true, and the specified edge does not exist, return the first edge that sorts after the specified one.\r\n// 获取指向由 euid 指定的边的入边迭代器。如果 nearest==true，并且指定的边不存在，则返回在指定边之后排序的第一条边。\r\n\r\n参数  \r\neuid – Edge Unique Id.\n\n该代码块位于文档的“lgraph_vertex_iterator”部分，描述了如何获取出边和入边的迭代器，提供了对应函数的参数和返回值说明，以及对这些函数的功能进行详细解释。此部分涵盖了在图数据库中通过边的唯一标识符（EdgeUid）进行边遍历的基本操作。"
            },
            {
                "content": "// 出边迭代器。\r\n\r\n```cpp\r\nOutEdgeIterator GetOutEdgeIterator(const int64_t src, const int64_t dst, const int16_t lid)\r\n```\r\n\r\n```cpp\r\nInEdgeIterator GetInEdgeIterator(const EdgeUid &euid, bool nearest = false)\r\n```\r\nGets an in edge iterator pointing to the edge specified by euid. If nearest==true, and the specified edge does not exist, return the first edge that sorts after the specified one.\r\n// 获取指向由 euid 指定的边的入边迭代器。如果 nearest==true，并且指定的边不存在，则返回在指定边之后排序的第一条边。\r\n\r\n参数  \r\neuid – Edge Unique Id.  \r\n// euid – 边的唯一 ID。  \r\nnearest – (Optional) If true, get the first edge that sorts after the specified one if the specified one does not exist.\r\n// nearest – （可选）如果为 true，则在指定边不存在时，获取在指定边之后排序的第一条边。\r\n\r\n返回  \r\nThe out edge iterator.\r\n//出边迭代器。\r\n\r\n```cpp\r\nInEdgeIterator GetInEdgeIterator(const int64_t src, const int64_t dst, const int16_t lid)\r\n```\r\n\r\n```cpp\r\nsize_t GetNumVertexLabels()\r\n```\r\nGets number of vertex labels.\r\n// 获取顶点标签的数量。\r\n\r\n返回  \r\nThe number of vertex labels.\r\n// 顶点标签的数量。\r\n\r\n```cpp\r\nsize_t GetNumEdgeLabels()\n\n该块内容位于文档的 \"lgraph_txn\" 部分，介绍了与图形数据库中顶点和边的迭代器相关的函数和操作，包括获取出边和入边的迭代器、以及获取顶点和边标签数量的函数。这些函数用于实现图形的遍历和数据操作功能。"
            },
            {
                "content": "nearest – (Optional) If true, get the first edge that sorts after the specified one if the specified one does not exist.\r\n// nearest – （可选）如果为 true，则在指定边不存在时，获取在指定边之后排序的第一条边。\r\n\r\n返回  \r\nThe out edge iterator.\r\n//出边迭代器。\r\n\r\n```cpp\r\nInEdgeIterator GetInEdgeIterator(const int64_t src, const int64_t dst, const int16_t lid)\r\n```\r\n\r\n```cpp\r\nsize_t GetNumVertexLabels()\r\n```\r\nGets number of vertex labels.\r\n// 获取顶点标签的数量。\r\n\r\n返回  \r\nThe number of vertex labels.\r\n// 顶点标签的数量。\r\n\r\n```cpp\r\nsize_t GetNumEdgeLabels()\r\n```\r\nGets number of edge labels.\r\n// 获取边标签的数量。\r\n\r\n返回  \r\nThe number of edge labels.\r\n// 边标签的数量。\r\n\r\n```cpp\r\nstd::vector ListVertexLabels()\r\n```\r\nLists all vertex labels.\r\n// 列出所有顶点标签。\r\n\r\n返回  \r\nLabel names.\r\n// 标签名称。\r\n\r\n```cpp\r\nstd::vector ListEdgeLabels()\r\n```\r\nList all edge labels.\r\n// 列出所有边标签。\r\n\r\n返回  \r\nLabel names.\r\n// 标签名称。\r\n\r\n```cpp\r\nsize_t GetVertexLabelId(const std::string &label)\r\n```\r\nGets vertex label id corresponding to the label name.\r\n// 获取与标签名称对应的顶点标签 ID。\r\n\r\n参数  \r\nlabel – The label name.\n\n该块内容位于文档的数据库操作部分，具体涉及Transaction类中的一些方法。主要描述了如何通过GetInEdgeIterator获取入边迭代器、获取顶点和边标签的数量，以及列出所有顶点和边标签的方法。这些方法用于对图数据库中的顶点和边进行操作和管理。"
            },
            {
                "content": "```\r\nGets number of edge labels.\r\n// 获取边标签的数量。\r\n\r\n返回  \r\nThe number of edge labels.\r\n// 边标签的数量。\r\n\r\n```cpp\r\nstd::vector ListVertexLabels()\r\n```\r\nLists all vertex labels.\r\n// 列出所有顶点标签。\r\n\r\n返回  \r\nLabel names.\r\n// 标签名称。\r\n\r\n```cpp\r\nstd::vector ListEdgeLabels()\r\n```\r\nList all edge labels.\r\n// 列出所有边标签。\r\n\r\n返回  \r\nLabel names.\r\n// 标签名称。\r\n\r\n```cpp\r\nsize_t GetVertexLabelId(const std::string &label)\r\n```\r\nGets vertex label id corresponding to the label name.\r\n// 获取与标签名称对应的顶点标签 ID。\r\n\r\n参数  \r\nlabel – The label name.\r\n// label – 标签名称。\r\n\r\n返回  \r\nThe label id.\r\n// 标签 ID。\r\n\r\n```cpp\r\nsize_t GetEdgeLabelId(const std::string &label)\r\n```\r\nGets edge label id corresponding to the label name.\r\n// 获取与标签名称对应的边标签 ID。\r\n\r\n参数  \r\nlabel – The label.\r\n// label – 标签。\r\n\r\n返回  \r\nThe edge label id.\r\n// 边标签 ID。\r\n\r\n```cpp\r\nstd::vector GetVertexSchema(const std::string &label)\r\n```\r\nGets edge schema definition corresponding to the vertex label.\r\n// 获取与顶点标签对应的边架构定义。\r\n\r\n参数  \r\nlabel – The label.\r\n// label – 标签。\r\n\r\n返回  \r\nThe schema.\r\n// 架构。\r\n\r\n```cpp\n\n该块内容位于文档中关于图数据库（lgraph）操作的部分，具体描述了获取边标签数量、列出顶点和边标签、以及根据标签名称获取对应的顶点和边标签ID的函数。这部分函数是图数据库接口的重要组成部分，旨在提供对图中标签的操作和查询功能。"
            },
            {
                "content": "返回  \r\nThe label id.\r\n// 标签 ID。\r\n\r\n```cpp\r\nsize_t GetEdgeLabelId(const std::string &label)\r\n```\r\nGets edge label id corresponding to the label name.\r\n// 获取与标签名称对应的边标签 ID。\r\n\r\n参数  \r\nlabel – The label.\r\n// label – 标签。\r\n\r\n返回  \r\nThe edge label id.\r\n// 边标签 ID。\r\n\r\n```cpp\r\nstd::vector GetVertexSchema(const std::string &label)\r\n```\r\nGets edge schema definition corresponding to the vertex label.\r\n// 获取与顶点标签对应的边架构定义。\r\n\r\n参数  \r\nlabel – The label.\r\n// label – 标签。\r\n\r\n返回  \r\nThe schema.\r\n// 架构。\r\n\r\n```cpp\r\nstd::vector GetEdgeSchema(const std::string &label)\r\n```\r\nGets edge schema definition corresponding to the edge label.\r\n// 获取与边标签对应的边架构定义。\r\n\r\n参数  \r\nlabel – The label.\r\n// label – 标签。\r\n\r\n返回  \r\nThe edge schema.\r\n// 边架构。\r\n\r\n```cpp\r\nsize_t GetVertexFieldId(size_t label_id, const std::string &field_name)\r\n```\r\nGets vertex field id.\r\n// 获取顶点字段 ID。\r\n\r\n参数  \r\nlabel_id – Identifier for the label.  \r\n// label_id – 标签的标识符。  \r\nfield_name – Field name.\r\n// field_name – 字段名称。\r\n\r\n返回  \r\nThe vertex field identifiers.\r\n// 顶点字段标识符。\r\n\r\n```cpp\n\n此代码片段位于文档的“lgraph_types”部分，主要描述与图形标签和字段相关的操作函数，包括获取边标签 ID、顶点和边架构定义以及获取顶点字段 ID 的方法。这些函数用于操作和查询图形数据库中的结构和属性信息。"
            },
            {
                "content": "```\r\nGets edge schema definition corresponding to the edge label.\r\n// 获取与边标签对应的边架构定义。\r\n\r\n参数  \r\nlabel – The label.\r\n// label – 标签。\r\n\r\n返回  \r\nThe edge schema.\r\n// 边架构。\r\n\r\n```cpp\r\nsize_t GetVertexFieldId(size_t label_id, const std::string &field_name)\r\n```\r\nGets vertex field id.\r\n// 获取顶点字段 ID。\r\n\r\n参数  \r\nlabel_id – Identifier for the label.  \r\n// label_id – 标签的标识符。  \r\nfield_name – Field name.\r\n// field_name – 字段名称。\r\n\r\n返回  \r\nThe vertex field identifiers.\r\n// 顶点字段标识符。\r\n\r\n```cpp\r\nstd::vector GetVertexFieldIds(size_t label_id, const std::vector &field_names)\r\n```\r\nGets vertex field ids.\r\n// 获取顶点字段 ID。\r\n\r\n参数  \r\nlabel_id – Identifier for the label.  \r\n// label_id – 标签的标识符。  \r\nfield_names – Field names.\r\n// field_names – 字段名称。\r\n\r\n返回  \r\nThe vertex field identifiers.\r\n// 顶点字段标识符。\r\n\r\n```cpp\r\nsize_t GetEdgeFieldId(size_t label_id, const std::string &field_name)\r\n```\r\nGets edge field id.\r\n// 获取边字段 ID。\r\n\r\n参数  \r\nlabel_id – Identifier for the label.  \r\n// label_id – 标签的标识符。  \r\nfield_name – Field name.\r\n// field_name – 字段名称。\n\n该块内容位于文档的“lgraph_types”部分，描述了与边标签和顶点字段相关的函数，包括获取边架构定义、获取顶点和边字段ID的函数及其参数和返回值。这部分主要涉及图数据库中标签和字段的相关操作。"
            },
            {
                "content": "```\r\nGets vertex field ids.\r\n// 获取顶点字段 ID。\r\n\r\n参数  \r\nlabel_id – Identifier for the label.  \r\n// label_id – 标签的标识符。  \r\nfield_names – Field names.\r\n// field_names – 字段名称。\r\n\r\n返回  \r\nThe vertex field identifiers.\r\n// 顶点字段标识符。\r\n\r\n```cpp\r\nsize_t GetEdgeFieldId(size_t label_id, const std::string &field_name)\r\n```\r\nGets edge field id.\r\n// 获取边字段 ID。\r\n\r\n参数  \r\nlabel_id – Identifier for the label.  \r\n// label_id – 标签的标识符。  \r\nfield_name – Field name.\r\n// field_name – 字段名称。\r\n\r\n返回  \r\nThe edge field identifier.\r\n// 边字段标识符。\r\n\r\n```cpp\r\nstd::vector GetEdgeFieldIds(size_t label_id, const std::vector &field_names)\r\n```\r\nGets edge field ids.\r\n// 获取边字段 ID。\r\n\r\n参数  \r\nlabel_id – Identifier for the label.  \r\n// label_id – 标签的标识符。  \r\nfield_names – Field names.\r\n// field_names – 字段名称。\r\n\r\n返回  \r\nThe edge field identifier.\r\n// 边字段标识符。\r\n\r\n```cpp\r\nint64_t AddVertex(const std::string &label_name, const std::vector &field_names, const std::vector &field_value_strings)\r\n```\n\n该块内容位于文档的“lgraph_types”部分，主要描述了获取顶点和边的字段 ID 的函数及其参数和返回值。这部分是关于如何管理图数据库中顶点和边的结构和属性的重要内容，涉及到字段的定义和访问。"
            },
            {
                "content": "// field_name – 字段名称。\r\n\r\n返回  \r\nThe edge field identifier.\r\n// 边字段标识符。\r\n\r\n```cpp\r\nstd::vector GetEdgeFieldIds(size_t label_id, const std::vector &field_names)\r\n```\r\nGets edge field ids.\r\n// 获取边字段 ID。\r\n\r\n参数  \r\nlabel_id – Identifier for the label.  \r\n// label_id – 标签的标识符。  \r\nfield_names – Field names.\r\n// field_names – 字段名称。\r\n\r\n返回  \r\nThe edge field identifier.\r\n// 边字段标识符。\r\n\r\n```cpp\r\nint64_t AddVertex(const std::string &label_name, const std::vector &field_names, const std::vector &field_value_strings)\r\n```\r\nAdds a vertex. All non-nullable fields must be specified. VertexIndex is also updated. If a unique_id is indexed for the vertex, and the same unique_id exists, an exception is thrown.\r\n// 添加一个顶点。必须指定所有非空字段。VertexIndex 也会更新。如果为顶点索引了 unique_id，并且相同的 unique_id 已存在，则会抛出异常。\r\n\r\n参数  \r\nlabel_name – Name of the label.  \r\n// label_name – 标签的名称。  \r\nfield_names – List of names of the fields.  \r\n// field_names – 字段名称的列表。  \r\nfield_value_strings – The field values in string representation.\n\n该代码块涉及如何在 TuGraph 中处理边字段以及添加顶点的相关操作。具体包括获取边字段 ID 的方法和添加顶点的函数定义，强调了在添加顶点时必须指定所有非空字段的要求，并提到如果存在相同的 unique_id 将抛出异常。"
            },
            {
                "content": "```\r\nAdds a vertex. All non-nullable fields must be specified. VertexIndex is also updated. If a unique_id is indexed for the vertex, and the same unique_id exists, an exception is thrown.\r\n// 添加一个顶点。必须指定所有非空字段。VertexIndex 也会更新。如果为顶点索引了 unique_id，并且相同的 unique_id 已存在，则会抛出异常。\r\n\r\n参数  \r\nlabel_name – Name of the label.  \r\n// label_name – 标签的名称。  \r\nfield_names – List of names of the fields.  \r\n// field_names – 字段名称的列表。  \r\nfield_value_strings – The field values in string representation.\r\n// field_value_strings – 字段值的字符串表示形式。\r\n\r\n返回  \r\nVertex id of the new vertex.\r\n// 新顶点的 ID。\r\n\r\n```cpp\r\nint64_t AddVertex(const std::string &label_name, const std::vector &field_names, const std::vector &field_values)\r\n```\r\nAdds a vertex. All non-nullable fields must be specified. VertexIndex is also updated. If a unique_id is indexed for the vertex, and the same unique_id exists, an exception is thrown.\r\n// 添加一个顶点。必须指定所有非空字段。VertexIndex 也会更新。如果为顶点索引了 unique_id，并且相同的 unique_id 已存在，则会抛出异常。\r\n\r\n参数  \r\nlabel_name – Name of the label.\n\n该片段位于文档的“lgraph_txn”部分，其中详细描述了在TuGraph中添加顶点的功能。它说明了添加顶点时需要遵循的要求，如必须指定所有非空字段，并指出在唯一ID索引的情况下，如果该ID已存在，将会抛出异常。该部分内容还涵盖了相关参数及其解释。"
            },
            {
                "content": "返回  \r\nVertex id of the new vertex.\r\n// 新顶点的 ID。\r\n\r\n```cpp\r\nint64_t AddVertex(const std::string &label_name, const std::vector &field_names, const std::vector &field_values)\r\n```\r\nAdds a vertex. All non-nullable fields must be specified. VertexIndex is also updated. If a unique_id is indexed for the vertex, and the same unique_id exists, an exception is thrown.\r\n// 添加一个顶点。必须指定所有非空字段。VertexIndex 也会更新。如果为顶点索引了 unique_id，并且相同的 unique_id 已存在，则会抛出异常。\r\n\r\n参数  \r\nlabel_name – Name of the label.  \r\n// label_name – 标签的名称。  \r\nfield_names – List of names of the fields.  \r\n// field_names – 字段名称的列表。  \r\nfield_values – The field values.\r\n// field_values – 字段值。\r\n\r\n返回  \r\nVertex id of the new vertex.\r\n// 新顶点的 ID。\r\n\r\n```cpp\r\nint64_t AddVertex(size_t label_id, const std::vector &field_ids, const std::vector &field_values)\r\n```\r\nAdds a vertex. All non-nullable fields must be specified. VertexIndex is also updated. If a unique_id is indexed for the vertex, and the same unique_id exists, an exception is thrown.\n\n该内容位于文档的**lgraph_txn**部分，具体介绍了如何在TuGraph中添加顶点，包括函数的签名、参数说明以及与VertexIndex的更新机制，强调必须指定所有非空字段，并讨论了处理唯一标识符冲突时抛出的异常情况。"
            },
            {
                "content": "// label_name – 标签的名称。  \r\nfield_names – List of names of the fields.  \r\n// field_names – 字段名称的列表。  \r\nfield_values – The field values.\r\n// field_values – 字段值。\r\n\r\n返回  \r\nVertex id of the new vertex.\r\n// 新顶点的 ID。\r\n\r\n```cpp\r\nint64_t AddVertex(size_t label_id, const std::vector &field_ids, const std::vector &field_values)\r\n```\r\nAdds a vertex. All non-nullable fields must be specified. VertexIndex is also updated. If a unique_id is indexed for the vertex, and the same unique_id exists, an exception is thrown.  \r\n添加一个顶点。必须指定所有不能为空的字段。顶点索引也会被更新。如果顶点的 unique_id 被索引，并且存在相同的 unique_id，将抛出异常。\r\n\r\n参数  \r\nlabel_id – Label id.  \r\nfield_ids – List of field ids.  \r\nfield_values – The field values.  \r\n标签 id – 标签 ID。  \r\nfield_ids – 字段 ID 列表。  \r\nfield_values – 字段值。\r\n\r\n返回  \r\nVertex id of the new vertex.  \r\n新顶点的顶点 ID。\r\n\r\n```cpp\r\nint UpsertVertex(size_t label_id, size_t primary_pos, const std::vector &unique_pos, const std::vector &field_ids, const std::vector &field_values)\r\n```\r\nUpsert a vertex.  \r\n插入或更新一个顶点。\r\n\r\n参数\n\n该块内容位于文档中描述添加和更新图数据库中顶点的相关功能部分，具体包括通过标签名称、字段名称和字段值来添加顶点的函数 `AddVertex` 和 `UpsertVertex` 的定义和说明。这些函数用于处理顶点元数据的插入、更新和索引管理，确保在操作过程中满足数据完整性和约束条件。"
            },
            {
                "content": "添加一个顶点。必须指定所有不能为空的字段。顶点索引也会被更新。如果顶点的 unique_id 被索引，并且存在相同的 unique_id，将抛出异常。\r\n\r\n参数  \r\nlabel_id – Label id.  \r\nfield_ids – List of field ids.  \r\nfield_values – The field values.  \r\n标签 id – 标签 ID。  \r\nfield_ids – 字段 ID 列表。  \r\nfield_values – 字段值。\r\n\r\n返回  \r\nVertex id of the new vertex.  \r\n新顶点的顶点 ID。\r\n\r\n```cpp\r\nint UpsertVertex(size_t label_id, size_t primary_pos, const std::vector &unique_pos, const std::vector &field_ids, const std::vector &field_values)\r\n```\r\nUpsert a vertex.  \r\n插入或更新一个顶点。\r\n\r\n参数  \r\nlabel_id – Label id.  \r\nprimary_pos – The location of the primary field in field_ids.  \r\nunique_pos – The locations of the unique index field in field_ids, can be empty.  \r\nfield_ids – List of field ids.  \r\nfield_values – The field values.  \r\n标签 id – 标签 ID。  \r\nprimary_pos – 字段 ID 中主字段的位置。  \r\nunique_pos – 字段 ID 中唯一索引字段的位置， 可以为空。  \r\nfield_ids – 字段 ID 列表。  \r\nfield_values – 字段值。\r\n\r\n返回  \r\n0: nothing happened because of index conflict 1: the vertex is inserted 2: the vertex is updated.  \r\n0：由于索引冲突而没有发生任何事情 1：顶点已插入 2：顶点已更新。\n\n该片段位于文档的“lgraph_db”部分，具体描述了在图数据库中添加和更新顶点的操作及其相关参数。在此上下文中，提供了如何插入顶点的详细信息，包括必要的字段、标签ID和唯一索引的处理。"
            },
            {
                "content": "primary_pos – The location of the primary field in field_ids.  \r\nunique_pos – The locations of the unique index field in field_ids, can be empty.  \r\nfield_ids – List of field ids.  \r\nfield_values – The field values.  \r\n标签 id – 标签 ID。  \r\nprimary_pos – 字段 ID 中主字段的位置。  \r\nunique_pos – 字段 ID 中唯一索引字段的位置， 可以为空。  \r\nfield_ids – 字段 ID 列表。  \r\nfield_values – 字段值。\r\n\r\n返回  \r\n0: nothing happened because of index conflict 1: the vertex is inserted 2: the vertex is updated.  \r\n0：由于索引冲突而没有发生任何事情 1：顶点已插入 2：顶点已更新。\r\n\r\n```cpp\r\nEdgeUid AddEdge(int64_t src, int64_t dst, const std::string &label, const std::vector &field_names, const std::vector &field_value_strings)\r\n```\r\nAdds an edge. All non-nullable fields must be specified. An exception is thrown if src or dst does not exist.  \r\n添加一条边。必须指定所有不能为空的字段。如果 src 或 dst 不存在，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel – The label name.  \r\nfield_names – List of field names.  \r\nfield_value_strings – List of field values in string representation.\n\n该片段位于文档中与图数据库操作相关的部分，具体涉及边的添加操作和参数说明。它描述了边添加函数的参数，包括主字段位置、唯一索引字段位置以及需要的字段ID和字段值，同时还说明了返回值和面临的潜在索引冲突情况。这部分内容有助于理解如何在图数据库中进行边的插入操作。"
            },
            {
                "content": "EdgeUid AddEdge(int64_t src, int64_t dst, const std::string &label, const std::vector &field_names, const std::vector &field_value_strings)\r\n```\r\nAdds an edge. All non-nullable fields must be specified. An exception is thrown if src or dst does not exist.  \r\n添加一条边。必须指定所有不能为空的字段。如果 src 或 dst 不存在，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel – The label name.  \r\nfield_names – List of field names.  \r\nfield_value_strings – List of field values in string representation.  \r\nsrc – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel – 标签名称。  \r\nfield_names – 字段名称列表。  \r\nfield_value_strings – 字段值字符串表示的列表。\r\n\r\n返回  \r\nEdgeUid of the new edge.  \r\n新边的 EdgeUid。\r\n\r\n```cpp\r\nEdgeUid AddEdge(int64_t src, int64_t dst, const std::string &label, const std::vector &field_names, const std::vector &field_values)\r\n```\r\nAdds an edge. All non-nullable fields must be specified. An exception is thrown if src or dst does not exist.  \r\n添加一条边。必须指定所有不能为空的字段。如果 src 或 dst 不存在，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.\n\n该代码块位于文档关于TuGraph图数据库的操作部分，具体涉及到添加边的功能。定义了 `AddEdge` 方法，它用于在图中添加边，包含了方法的参数说明及使用后的返回值，强调了必须指定所有非空字段的重要性，以及在源或目标顶点不存在时会抛出异常的信息。这部分内容主要用于指导开发者如何在使用图数据库时执行边的添加操作。"
            },
            {
                "content": "src – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel – 标签名称。  \r\nfield_names – 字段名称列表。  \r\nfield_value_strings – 字段值字符串表示的列表。\r\n\r\n返回  \r\nEdgeUid of the new edge.  \r\n新边的 EdgeUid。\r\n\r\n```cpp\r\nEdgeUid AddEdge(int64_t src, int64_t dst, const std::string &label, const std::vector &field_names, const std::vector &field_values)\r\n```\r\nAdds an edge. All non-nullable fields must be specified. An exception is thrown if src or dst does not exist.  \r\n添加一条边。必须指定所有不能为空的字段。如果 src 或 dst 不存在，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel – The label name.  \r\nfield_names – List of field names.  \r\nfield_values – List of field values.  \r\nsrc – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel – 标签名称。  \r\nfield_names – 字段名称列表。  \r\nfield_values – 字段值的列表。\r\n\r\n返回  \r\nEdgeUid of the new edge.  \r\n新边的 EdgeUid。\r\n\r\n```cpp\r\nEdgeUid AddEdge(int64_t src, int64_t dst, size_t label_id, const std::vector &field_ids, const std::vector &field_values)\r\n```\n\n该块内容位于文档中关于向图中添加边的函数描述部分，具体涉及如何通过指定源和目标顶点ID、标签名以及字段名称和字段值来添加边。它说明了函数的参数、返回值以及在特定条件下可能抛出的异常，属于图数据库操作的一个重要环节。"
            },
            {
                "content": "添加一条边。必须指定所有不能为空的字段。如果 src 或 dst 不存在，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel – The label name.  \r\nfield_names – List of field names.  \r\nfield_values – List of field values.  \r\nsrc – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel – 标签名称。  \r\nfield_names – 字段名称列表。  \r\nfield_values – 字段值的列表。\r\n\r\n返回  \r\nEdgeUid of the new edge.  \r\n新边的 EdgeUid。\r\n\r\n```cpp\r\nEdgeUid AddEdge(int64_t src, int64_t dst, size_t label_id, const std::vector &field_ids, const std::vector &field_values)\r\n```\r\nAdds an edge. All non-nullable fields must be specified. An exception is thrown if src or dst does not exist.  \r\n添加一条边。必须指定所有不能为空的字段。如果 src 或 dst 不存在，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel_id – The label id.  \r\nfield_ids – List of field ids.  \r\nfield_values – List of field values.  \r\nsrc – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel_id – 标签 ID。  \r\nfield_ids – 字段 ID 列表。  \r\nfield_values – 字段值的列表。\r\n\r\n返回  \r\nEdgeUid of the new edge.  \r\n新边的 EdgeUid。\r\n\r\n```cpp\n\n该段落位于文档中描述 TuGraph 中的边操作部分，具体涉及如何添加一条边，包括所需参数、返回值及其异常处理。这部分内容帮助用户了解在使用图数据库时如何有效地创建边及其相关数据结构。"
            },
            {
                "content": "```\r\nAdds an edge. All non-nullable fields must be specified. An exception is thrown if src or dst does not exist.  \r\n添加一条边。必须指定所有不能为空的字段。如果 src 或 dst 不存在，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel_id – The label id.  \r\nfield_ids – List of field ids.  \r\nfield_values – List of field values.  \r\nsrc – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel_id – 标签 ID。  \r\nfield_ids – 字段 ID 列表。  \r\nfield_values – 字段值的列表。\r\n\r\n返回  \r\nEdgeUid of the new edge.  \r\n新边的 EdgeUid。\r\n\r\n```cpp\r\nbool UpsertEdge(int64_t src, int64_t dst, const std::string &label, const std::vector &field_names, const std::vector &field_value_strings)\r\n```\r\nUpsert edge. If there is no src->dst edge, insert it. Otherwise, try to update the edge’s property. If the edge exists and the label differs from specified label, an exception is thrown.  \r\n插入或更新边。如果没有 src->dst 的边，则插入它。否则，尝试更新边的属性。如果边存在并且标签与指定标签不同，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel – The label name.\n\n该片段描述了在 TuGraph 数据库中添加边的操作，包括插入和更新边的相关参数与条件。片段中明确指出了必须提供的非空字段及相关参数的含义，同时说明了在特定情况下抛出的异常。这些内容属于文档中关于图数据库操作的部分，具体体现在边的管理和实现上。"
            },
            {
                "content": "```cpp\r\nbool UpsertEdge(int64_t src, int64_t dst, const std::string &label, const std::vector &field_names, const std::vector &field_value_strings)\r\n```\r\nUpsert edge. If there is no src->dst edge, insert it. Otherwise, try to update the edge’s property. If the edge exists and the label differs from specified label, an exception is thrown.  \r\n插入或更新边。如果没有 src->dst 的边，则插入它。否则，尝试更新边的属性。如果边存在并且标签与指定标签不同，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel – The label name.  \r\nfield_names – List of field names.  \r\nfield_value_strings – List of field values in string representation.  \r\nsrc – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel – 标签名称。  \r\nfield_names – 字段名称列表。  \r\nfield_value_strings – 字段值字符串表示的列表。\r\n\r\n返回  \r\nTrue if the edge is inserted, false if the edge is updated.  \r\n如果边已存在，则返回False；如果新建了边，则返回True。\r\n\r\n```cpp\r\nbool UpsertEdge(int64_t src, int64_t dst, const std::string &label, const std::vector &field_names, const std::vector &field_values)\r\n```\n\n该代码段位于文档的“lgraph_txn”部分，描述了在TuGraph数据库中使用的`UpsertEdge`函数。该函数用于插入或更新边的属性，在执行时要求提供源和目标顶点ID、边的标签名称、字段名称列表以及字段值的字符串表示。它强调了函数的行为和返回值，具体说明了操作成功与否。"
            },
            {
                "content": "label – The label name.  \r\nfield_names – List of field names.  \r\nfield_value_strings – List of field values in string representation.  \r\nsrc – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel – 标签名称。  \r\nfield_names – 字段名称列表。  \r\nfield_value_strings – 字段值字符串表示的列表。\r\n\r\n返回  \r\nTrue if the edge is inserted, false if the edge is updated.  \r\n如果边已存在，则返回False；如果新建了边，则返回True。\r\n\r\n```cpp\r\nbool UpsertEdge(int64_t src, int64_t dst, const std::string &label, const std::vector &field_names, const std::vector &field_values)\r\n```\r\nUpsert edge. If there is no src->dst edge, insert it. Otherwise, try to update the edge’s property. If the edge exists and the label differs from specified label, an exception is thrown.  \r\n插入或更新边。如果没有 src->dst 的边，则插入它。否则，尝试更新边的属性。如果边存在并且标签与指定标签不同，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel – The label name.  \r\nfield_names – List of field names.  \r\nfield_values – List of field values.  \r\nsrc – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel – 标签名称。  \r\nfield_names – 字段名称列表。\n\n这个块位于文档中关于图数据库操作的部分，主要讨论如何插入或更新边的功能（UpsertEdge）。它描述了相关参数的信息以及成功或失败时的返回值，属于边操作的具体实现细节。"
            },
            {
                "content": "```\r\nUpsert edge. If there is no src->dst edge, insert it. Otherwise, try to update the edge’s property. If the edge exists and the label differs from specified label, an exception is thrown.  \r\n插入或更新边。如果没有 src->dst 的边，则插入它。否则，尝试更新边的属性。如果边存在并且标签与指定标签不同，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel – The label name.  \r\nfield_names – List of field names.  \r\nfield_values – List of field values.  \r\nsrc – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel – 标签名称。  \r\nfield_names – 字段名称列表。  \r\nfield_values – 字段值的列表。\r\n\r\n返回  \r\nTrue if the edge is inserted, false if the edge is updated.  \r\n如果边已存在，则返回False；如果新建了边，则返回True。\r\n\r\n```cpp\r\nbool UpsertEdge(int64_t src, int64_t dst, size_t label_id, const std::vector &field_ids, const std::vector &field_values)\r\n```\r\nUpsert edge. If there is no src->dst edge, insert it. Otherwise, try to update the edge’s property. If the edge exists and the label differs from specified label, an exception is thrown.\n\n该块内容描述了在TuGraph中插入或更新边的操作，包括相关参数和返回值。这部分位于文档的“lgraph_txn”模块下，涉及图数据库操作的事务管理，具体强调了在图遍历和数据更新过程中如何处理边的唯一性和属性更新。"
            },
            {
                "content": "label – 标签名称。  \r\nfield_names – 字段名称列表。  \r\nfield_values – 字段值的列表。\r\n\r\n返回  \r\nTrue if the edge is inserted, false if the edge is updated.  \r\n如果边已存在，则返回False；如果新建了边，则返回True。\r\n\r\n```cpp\r\nbool UpsertEdge(int64_t src, int64_t dst, size_t label_id, const std::vector &field_ids, const std::vector &field_values)\r\n```\r\nUpsert edge. If there is no src->dst edge, insert it. Otherwise, try to update the edge’s property. If the edge exists and the label differs from specified label, an exception is thrown.  \r\n插入或更新边。如果没有 src->dst 的边，则插入它。否则，尝试更新边的属性。如果边存在并且标签与指定标签不同，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel_id – The label id.  \r\nfield_ids – List of field ids.  \r\nfield_values – List of field values.  \r\nsrc – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel_id – 标签 ID。  \r\nfield_ids – 字段 ID 列表。  \r\nfield_values – 字段值的列表。\r\n\r\n返回  \r\nTrue if the edge is inserted, false if the edge is updated.  \r\n如果边已存在，则返回False；如果新建了边，则返回True。\r\n\r\n```cpp\n\n这段内容位于文档关于 `OlapOnDB` 类的部分，具体描述了在图数据库中插入或更新边（Edge）的操作函数 `UpsertEdge`。它详细说明了函数的参数，包括源顶点 ID、目标顶点 ID、标签 ID，以及字段 ID 列表和字段值列表，同时说明了函数的返回结果。"
            },
            {
                "content": "插入或更新边。如果没有 src->dst 的边，则插入它。否则，尝试更新边的属性。如果边存在并且标签与指定标签不同，将抛出异常。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel_id – The label id.  \r\nfield_ids – List of field ids.  \r\nfield_values – List of field values.  \r\nsrc – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel_id – 标签 ID。  \r\nfield_ids – 字段 ID 列表。  \r\nfield_values – 字段值的列表。\r\n\r\n返回  \r\nTrue if the edge is inserted, false if the edge is updated.  \r\n如果边已存在，则返回False；如果新建了边，则返回True。\r\n\r\n```cpp\r\nint UpsertEdge(int64_t src, int64_t dst, size_t label_id, const std::vector &unique_pos, const std::vector &field_ids, const std::vector &field_values, std::optional pair_unique_pos)\r\n```\r\nUpsert edge. If there is no src->dst edge, insert it. Otherwise, try to update the edge’s property.  \r\n插入或更新边。如果没有 src->dst 的边，则插入它。否则，尝试更新边的属性。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel_id – The label id.  \r\nunique_pos – The locations of the unique index field in field_ids, can be empty.  \r\nfield_ids – List of field ids.\n\n该内容位于文档中的“lgraph_txn”部分，描述了如何插入或更新图中的边。它详细说明了边的操作，包括参数和返回值，从而帮助用户理解在TuGraph图数据库中如何管理边关系。"
            },
            {
                "content": "```\r\nUpsert edge. If there is no src->dst edge, insert it. Otherwise, try to update the edge’s property.  \r\n插入或更新边。如果没有 src->dst 的边，则插入它。否则，尝试更新边的属性。\r\n\r\n参数  \r\nsrc – Source vertex id.  \r\ndst – Destination vertex id.  \r\nlabel_id – The label id.  \r\nunique_pos – The locations of the unique index field in field_ids, can be empty.  \r\nfield_ids – List of field ids.  \r\nfield_values – List of field values.  \r\nsrc – 源顶点 ID。  \r\ndst – 目标顶点 ID。  \r\nlabel_id – 标签 ID。  \r\nunique_pos – 字段 ID 中唯一索引字段的位置，可以为空。  \r\nfield_ids – 字段 ID 列表。  \r\nfield_values – 字段值的列表。\r\n\r\n返回  \r\n0: nothing happened because of index conflict 1: the vertex is inserted 2: the vertex is updated  \r\n0：由于索引冲突而没有发生任何事情 1：顶点已插入 2：顶点已更新\r\n\r\n```cpp\r\nstd::vector ListVertexIndexes()\r\n```\r\nList indexes  \r\n列出索引\r\n\r\n返回  \r\nA vector of vertex index specs.  \r\n一个顶点索引规格的向量。\r\n\r\n```cpp\r\nstd::vector ListVertexCompositeIndexes()\r\n```\r\nList indexes  \r\n列出索引\r\n\r\n返回  \r\nA vector of vertex composite index specs.  \r\n一个顶点组合索引规格的向量。\r\n\r\n```cpp\r\nstd::vector ListEdgeIndexes()\r\n```\n\n该段落位于文档的“lgraph_txn”部分，描述了在图数据库中插入或更新边的功能及其参数。它还提到了如何列出与顶点和边相关的索引，涵盖了边操作的具体细节和返回值的解释。"
            },
            {
                "content": "field_values – 字段值的列表。\r\n\r\n返回  \r\n0: nothing happened because of index conflict 1: the vertex is inserted 2: the vertex is updated  \r\n0：由于索引冲突而没有发生任何事情 1：顶点已插入 2：顶点已更新\r\n\r\n```cpp\r\nstd::vector ListVertexIndexes()\r\n```\r\nList indexes  \r\n列出索引\r\n\r\n返回  \r\nA vector of vertex index specs.  \r\n一个顶点索引规格的向量。\r\n\r\n```cpp\r\nstd::vector ListVertexCompositeIndexes()\r\n```\r\nList indexes  \r\n列出索引\r\n\r\n返回  \r\nA vector of vertex composite index specs.  \r\n一个顶点组合索引规格的向量。\r\n\r\n```cpp\r\nstd::vector ListEdgeIndexes()\r\n```\r\nList indexes  \r\n列出索引\r\n\r\n返回  \r\nA vector of edge index specs.  \r\n一个边索引规格的向量。\r\n\r\n```cpp\r\nVertexIndexIterator GetVertexIndexIterator(size_t label_id, size_t field_id, const FieldData &key_start, const FieldData &key_end)\r\n```\r\nGets vertex index iterator. The iterator has field value [key_start, key_end]. So key_start=key_end=v returns an iterator pointing to all vertexes that has field value v.  \r\n获取顶点索引迭代器。迭代器包含字段值 [key_start, key_end]。因此，如果 key_start=key_end=v，将返回一个指向所有具有字段值 v 的顶点的迭代器。\r\n\r\n参数  \r\nlabel_id – The label id.\n\n该片段位于文档的 \"lgraph_txn\" 部分，描述了在 TuGraph 中插入、更新顶点和列出顶点、边索引的相关操作和函数。具体内容涉及如何处理字段值、处理索引冲突的结果，以及如何获取特定标签和字段的索引迭代器。"
            },
            {
                "content": "列出索引\r\n\r\n返回  \r\nA vector of edge index specs.  \r\n一个边索引规格的向量。\r\n\r\n```cpp\r\nVertexIndexIterator GetVertexIndexIterator(size_t label_id, size_t field_id, const FieldData &key_start, const FieldData &key_end)\r\n```\r\nGets vertex index iterator. The iterator has field value [key_start, key_end]. So key_start=key_end=v returns an iterator pointing to all vertexes that has field value v.  \r\n获取顶点索引迭代器。迭代器包含字段值 [key_start, key_end]。因此，如果 key_start=key_end=v，将返回一个指向所有具有字段值 v 的顶点的迭代器。\r\n\r\n参数  \r\nlabel_id – The label id.  \r\nfield_id – The field id.  \r\nkey_start – The key start.  \r\nkey_end – The key end, inclusive.  \r\nlabel_id – 标签 ID。  \r\nfield_id – 字段 ID。  \r\nkey_start – 起始键。  \r\nkey_end – 结束键（包括）。\r\n\r\n返回  \r\nThe index iterator.  \r\n索引迭代器。\r\n\r\n```cpp\r\nVertexCompositeIndexIterator GetVertexCompositeIndexIterator(size_t label_id, const std::vector &field_id, const std::vector &key_start, const std::vector &key_end)\r\n```\r\n```cpp\n\n该块内容位于文档中关于图数据库操作的部分，具体讨论了如何通过指定标签和字段获取顶点索引迭代器及其参数和返回值。这部分文档涉及图数据模型中的索引机制，旨在为用户提供查询和操作顶点的相关接口详情。"
            },
            {
                "content": "参数  \r\nlabel_id – The label id.  \r\nfield_id – The field id.  \r\nkey_start – The key start.  \r\nkey_end – The key end, inclusive.  \r\nlabel_id – 标签 ID。  \r\nfield_id – 字段 ID。  \r\nkey_start – 起始键。  \r\nkey_end – 结束键（包括）。\r\n\r\n返回  \r\nThe index iterator.  \r\n索引迭代器。\r\n\r\n```cpp\r\nVertexCompositeIndexIterator GetVertexCompositeIndexIterator(size_t label_id, const std::vector &field_id, const std::vector &key_start, const std::vector &key_end)\r\n```\r\n```cpp\r\nEdgeIndexIterator GetEdgeIndexIterator(size_t label_id, size_t field_id, const FieldData &key_start, const FieldData &key_end)\r\n```\r\nGets edge index iterator. The iterator has field value [key_start, key_end]. So key_start=key_end=v returns an iterator pointing to all edges that has field value v.  \r\n获取边索引迭代器。迭代器包含字段值 [key_start, key_end]。因此，如果 key_start=key_end=v，将返回一个指向所有具有字段值 v 的边的迭代器。\r\n\r\n参数  \r\nlabel_id – The label id.  \r\nfield_id – The field id.  \r\nkey_start – The key start.  \r\nkey_end – The key end, inclusive.  \r\nlabel_id – 标签 ID。  \r\nfield_id – 字段 ID。\n\n该代码块位于文档中与图数据库和索引操作相关的部分，具体阐述了如何获取与边相关的索引迭代器以及对应的参数说明。这些函数和参数主要用于处理查询图形数据时的边索引，确保开发者能有效地访问和操作图数据库中的边数据。"
            },
            {
                "content": "```\r\nGets edge index iterator. The iterator has field value [key_start, key_end]. So key_start=key_end=v returns an iterator pointing to all edges that has field value v.  \r\n获取边索引迭代器。迭代器包含字段值 [key_start, key_end]。因此，如果 key_start=key_end=v，将返回一个指向所有具有字段值 v 的边的迭代器。\r\n\r\n参数  \r\nlabel_id – The label id.  \r\nfield_id – The field id.  \r\nkey_start – The key start.  \r\nkey_end – The key end, inclusive.  \r\nlabel_id – 标签 ID。  \r\nfield_id – 字段 ID。  \r\nkey_start – 起始键。  \r\nkey_end – 结束键（包括）。\r\n\r\n返回  \r\nThe index iterator.  \r\n索引迭代器。\r\n\r\n```cpp\r\nEdgeIndexIterator GetEdgePairUniqueIndexIterator(size_t label_id, size_t field_id, int64_t src_vid, int64_t dst_vid, const FieldData &key_start, const FieldData &key_end)\r\n```\r\n```cpp\r\nVertexIndexIterator GetVertexIndexIterator(const std::string &label, const std::string &field, const FieldData &key_start, const FieldData &key_end)\r\n```\n\n该块内容位于文档中关于TuGraph图数据库的索引操作部分，具体介绍如何获取边索引迭代器及其参数和返回值信息。此部分包括对`GetEdgeIndexIterator`和`GetVertexIndexIterator`方法的描述，适用于执行图形查询和操作时的索引功能。"
            },
            {
                "content": "key_end – The key end, inclusive.  \r\nlabel_id – 标签 ID。  \r\nfield_id – 字段 ID。  \r\nkey_start – 起始键。  \r\nkey_end – 结束键（包括）。\r\n\r\n返回  \r\nThe index iterator.  \r\n索引迭代器。\r\n\r\n```cpp\r\nEdgeIndexIterator GetEdgePairUniqueIndexIterator(size_t label_id, size_t field_id, int64_t src_vid, int64_t dst_vid, const FieldData &key_start, const FieldData &key_end)\r\n```\r\n```cpp\r\nVertexIndexIterator GetVertexIndexIterator(const std::string &label, const std::string &field, const FieldData &key_start, const FieldData &key_end)\r\n```\r\nGets vertex index iterator. The iterator has field value [key_start, key_end]. So key_start=key_end=v returns an iterator pointing to all vertexes that has field value v.  \r\n获取顶点索引迭代器。迭代器包含字段值 [key_start, key_end]。因此，如果 key_start=key_end=v，将返回一个指向所有具有字段值 v 的顶点的迭代器。\r\n\r\n参数  \r\nlabel – The label.  \r\nfield – The field.  \r\nkey_start – The key start.  \r\nkey_end – The key end, inclusive.  \r\nlabel – 标签。  \r\nfield – 字段。  \r\nkey_start – 起始键。  \r\nkey_end – 结束键（包括）。\r\n\r\n返回  \r\nThe index iterator.  \r\n索引迭代器。\r\n\r\n```cpp\n\n该块内容位于文档的“lgraph_types”部分，主要涉及图数据库中边和顶点的索引迭代器定义，包括获取特定字段值范围的顶点和边的索引迭代器的函数声明及相关参数。这些内容为使用索引进行数据访问和操作提供了机制和方法。"
            },
            {
                "content": "```\r\nGets vertex index iterator. The iterator has field value [key_start, key_end]. So key_start=key_end=v returns an iterator pointing to all vertexes that has field value v.  \r\n获取顶点索引迭代器。迭代器包含字段值 [key_start, key_end]。因此，如果 key_start=key_end=v，将返回一个指向所有具有字段值 v 的顶点的迭代器。\r\n\r\n参数  \r\nlabel – The label.  \r\nfield – The field.  \r\nkey_start – The key start.  \r\nkey_end – The key end, inclusive.  \r\nlabel – 标签。  \r\nfield – 字段。  \r\nkey_start – 起始键。  \r\nkey_end – 结束键（包括）。\r\n\r\n返回  \r\nThe index iterator.  \r\n索引迭代器。\r\n\r\n```cpp\r\nVertexCompositeIndexIterator GetVertexCompositeIndexIterator(const std::string &label, const std::vector &field, const std::vector &key_start, const std::vector &key_end)\r\n```\r\n```cpp\r\nEdgeIndexIterator GetEdgeIndexIterator(const std::string &label, const std::string &field, const FieldData &key_start, const FieldData &key_end)\r\n```\r\nGets index iterator. The iterator has field value [key_start, key_end]. So key_start=key_end=v returns an iterator pointing to all edges that has field value v.\n\n该块内容位于文档中关于图数据库操作的部分，主要描述了如何获取顶点和边的索引迭代器，包括相关参数和返回值的细节。这些函数属于`lgraph_vertex_iterator`类和`lgraph_edge_index_iterator`类，提供了对索引操作的支持，允许开发者有效地访问和遍历图中的顶点和边。"
            },
            {
                "content": "```cpp\r\nVertexCompositeIndexIterator GetVertexCompositeIndexIterator(const std::string &label, const std::vector &field, const std::vector &key_start, const std::vector &key_end)\r\n```\r\n```cpp\r\nEdgeIndexIterator GetEdgeIndexIterator(const std::string &label, const std::string &field, const FieldData &key_start, const FieldData &key_end)\r\n```\r\nGets index iterator. The iterator has field value [key_start, key_end]. So key_start=key_end=v returns an iterator pointing to all edges that has field value v.  \r\n获取索引迭代器。迭代器包含字段值 [key_start, key_end]。因此，如果 key_start=key_end=v，将返回一个指向所有具有字段值 v 的边的迭代器。\r\n\r\n参数  \r\nlabel – The label.  \r\nfield – The field.  \r\nkey_start – The key start.  \r\nkey_end – The key end, inclusive.  \r\nlabel – 标签。  \r\nfield – 字段。  \r\nkey_start – 起始键。  \r\nkey_end – 结束键（包括）。\r\n\r\n返回  \r\nThe index iterator.  \r\n索引迭代器。\r\n\r\n```cpp\r\nVertexIndexIterator GetVertexIndexIterator(const std::string &label, const std::string &field, const std::string &key_start, const std::string &key_end)\r\n```\n\n该代码块位于文档的“lgraph_types”部分，具体描述了如何获取顶点和边的索引迭代器。这些函数通过指定标签和字段，以及键的范围，允许用户访问具有特定属性值的顶点或边，从而实现图形数据库的索引访问功能。"
            },
            {
                "content": "获取索引迭代器。迭代器包含字段值 [key_start, key_end]。因此，如果 key_start=key_end=v，将返回一个指向所有具有字段值 v 的边的迭代器。\r\n\r\n参数  \r\nlabel – The label.  \r\nfield – The field.  \r\nkey_start – The key start.  \r\nkey_end – The key end, inclusive.  \r\nlabel – 标签。  \r\nfield – 字段。  \r\nkey_start – 起始键。  \r\nkey_end – 结束键（包括）。\r\n\r\n返回  \r\nThe index iterator.  \r\n索引迭代器。\r\n\r\n```cpp\r\nVertexIndexIterator GetVertexIndexIterator(const std::string &label, const std::string &field, const std::string &key_start, const std::string &key_end)\r\n```\r\nGets index iterator. The iterator has field value [key_start, key_end]. So key_start=key_end=v returns an iterator pointing to all vertexes that has field value v.  \r\n获取索引迭代器。迭代器具有字段值 [key_start, key_end]。因此，当 key_start=key_end=v 时，它将返回一个指向所有字段值为 v 的顶点的迭代器。\r\n\r\n参数  \r\nlabel – The label.  标签名称  \r\nfield – The field.  字段名称  \r\nkey_start – The key start.  键的起始值  \r\nkey_end – The key end.  键的结束值  \r\n\r\n返回  \r\nThe index iterator.  索引迭代器  \r\n\r\n```cpp\n\n该块内容位于文档中与索引迭代器相关的部分，具体描述了如何获取基于标签和字段的索引迭代器，包括参数定义和返回值说明。它详细阐述了在图数据库中通过索引进行顶点和边的查询机制。"
            },
            {
                "content": "```\r\nGets index iterator. The iterator has field value [key_start, key_end]. So key_start=key_end=v returns an iterator pointing to all vertexes that has field value v.  \r\n获取索引迭代器。迭代器具有字段值 [key_start, key_end]。因此，当 key_start=key_end=v 时，它将返回一个指向所有字段值为 v 的顶点的迭代器。\r\n\r\n参数  \r\nlabel – The label.  标签名称  \r\nfield – The field.  字段名称  \r\nkey_start – The key start.  键的起始值  \r\nkey_end – The key end.  键的结束值  \r\n\r\n返回  \r\nThe index iterator.  索引迭代器  \r\n\r\n```cpp\r\nVertexCompositeIndexIterator GetVertexCompositeIndexIterator(const std::string &label, const std::vector &field, const std::vector &key_start, const std::vector &key_end)\r\n```\r\n\r\n```cpp\r\nEdgeIndexIterator GetEdgeIndexIterator(const std::string &label, const std::string &field, const std::string &key_start, const std::string &key_end)\r\n```\r\nGets index iterator. The iterator has field value [key_start, key_end]. So key_start=key_end=v returns an iterator pointing to all edges that has field value v.\n\n该块内容位于文档中关于获取索引迭代器的部分，详细描述了如何通过唯一索引获取顶点和边的迭代器，包含参数说明和返回值类型。在此上下文中，该块为用户提供了有关图数据库操作中索引功能的具体实现细节和使用方法。"
            },
            {
                "content": "VertexCompositeIndexIterator GetVertexCompositeIndexIterator(const std::string &label, const std::vector &field, const std::vector &key_start, const std::vector &key_end)\r\n```\r\n\r\n```cpp\r\nEdgeIndexIterator GetEdgeIndexIterator(const std::string &label, const std::string &field, const std::string &key_start, const std::string &key_end)\r\n```\r\nGets index iterator. The iterator has field value [key_start, key_end]. So key_start=key_end=v returns an iterator pointing to all edges that has field value v.  \r\n获取索引迭代器。迭代器具有字段值 [key_start, key_end]。因此，当 key_start=key_end=v 时，它将返回一个指向所有字段值为 v 的边的迭代器。\r\n\r\n参数  \r\nlabel – The label.  标签名称  \r\nfield – The field.  字段名称  \r\nkey_start – The key start.  键的起始值  \r\nkey_end – The key end.  键的结束值  \r\n\r\n返回  \r\nThe index iterator.  索引迭代器  \r\n\r\n```cpp\r\nbool IsVertexIndexed(const std::string &label, const std::string &field)\r\n```\r\nQuery if index is ready for use. This should be used only to decide whether to use an index. To wait for an index to be ready, use lgraphDB::WaitIndexReady().\n\n该块内容位于文档中关于图数据库操作的部分，主要描述与边和顶点索引相关的迭代器的功能和用法。通过提供获取索引迭代器的方法和如何检查索引的有效性，增强了对图数据库中结构和性能的理解。"
            },
            {
                "content": "参数  \r\nlabel – The label.  标签名称  \r\nfield – The field.  字段名称  \r\nkey_start – The key start.  键的起始值  \r\nkey_end – The key end.  键的结束值  \r\n\r\n返回  \r\nThe index iterator.  索引迭代器  \r\n\r\n```cpp\r\nbool IsVertexIndexed(const std::string &label, const std::string &field)\r\n```\r\nQuery if index is ready for use. This should be used only to decide whether to use an index. To wait for an index to be ready, use lgraphDB::WaitIndexReady().  \r\n查询索引是否准备好使用。这只能用于决定是否使用索引。要等待索引准备就绪，请使用 lgraphDB::WaitIndexReady()。\r\n\r\nVertexIndex building is async, especially when added for a (label, field) that already has a lot of vertices. This function tells us if the index building is finished.  \r\nVertexIndex 的构建是异步的，尤其是在已经有很多顶点的 (label, field) 上添加时。此函数告诉我们索引构建是否完成。\r\n\r\nDO NOT wait for index building in a transaction. Write transactions block other write transactions, so blocking in a write transaction is always a bad idea. And long-living read transactions interfere with GC, making the DB grow unexpectedly.\n\n该块内容位于文档的“lgraph_types”部分，描述了与图数据库中顶点和边的索引相关的函数和功能。具体而言，它提供了如何检查索引是否准备好使用的函数（`IsVertexIndexed`）及其相关参数和返回值的详细说明。这部分内容是图数据库操作的关键部分，涉及到索引的管理和查询性能的优化。"
            },
            {
                "content": "VertexIndex building is async, especially when added for a (label, field) that already has a lot of vertices. This function tells us if the index building is finished.  \r\nVertexIndex 的构建是异步的，尤其是在已经有很多顶点的 (label, field) 上添加时。此函数告诉我们索引构建是否完成。\r\n\r\nDO NOT wait for index building in a transaction. Write transactions block other write transactions, so blocking in a write transaction is always a bad idea. And long-living read transactions interfere with GC, making the DB grow unexpectedly.  \r\n请勿在事务中等待索引构建。写事务会阻止其他写事务，因此在写事务中阻塞始终是个坏主意。长期存在的读事务会干扰 GC，导致数据库意外增长。\r\n\r\n参数  \r\nlabel – The label.  标签名称  \r\nfield – The field.  字段名称  \r\n\r\n返回  \r\nTrue if index ready, false if not.  如果索引准备好，则返回 true，否则返回 false。  \r\n\r\n```cpp\r\nbool IsEdgeIndexed(const std::string &label, const std::string &field)\r\n```\r\nQuery if index is ready for use. This should be used only to decide whether to use an index. To wait for an index to be ready, use lgraphDB::WaitIndexReady().  \r\n查询索引是否准备好使用。这只能用于决定是否使用索引。要等待索引准备就绪，请使用 lgraphDB::WaitIndexReady()。\n\n该片段位于文档的lgraph_types部分，具体讨论了图的索引构建过程，强调了在事务中等待索引构建的潜在问题，同时提供了检查边索引是否准备好的相关函数定义。"
            },
            {
                "content": "参数  \r\nlabel – The label.  标签名称  \r\nfield – The field.  字段名称  \r\n\r\n返回  \r\nTrue if index ready, false if not.  如果索引准备好，则返回 true，否则返回 false。  \r\n\r\n```cpp\r\nbool IsEdgeIndexed(const std::string &label, const std::string &field)\r\n```\r\nQuery if index is ready for use. This should be used only to decide whether to use an index. To wait for an index to be ready, use lgraphDB::WaitIndexReady().  \r\n查询索引是否准备好使用。这只能用于决定是否使用索引。要等待索引准备就绪，请使用 lgraphDB::WaitIndexReady()。\r\n\r\nVertexIndex building is async, especially when added for a (label, field) that already has a lot of edges. This function tells us if the index building is finished.  \r\nVertexIndex 的构建是异步的，尤其是在已经有很多边的 (label, field) 上添加时。此函数告诉我们索引构建是否完成。\r\n\r\nDO NOT wait for index building in a transaction. Write transactions block other write transactions, so blocking in a write transaction is always a bad idea. And long-living read transactions interfere with GC, making the DB grow unexpectedly.  \r\n请勿在事务中等待索引构建。写事务会阻止其他写事务，因此在写事务中阻塞始终是个坏主意。长期存在的读事务会干扰 GC，导致数据库意外增长。\r\n\r\n参数\n\n该块内容位于文档的 \"lgraph_types\" 部分，具体涉及到用于查询边索引是否准备好的函数 `IsEdgeIndexed`。此函数的定义、参数说明及其用途是在图数据库中检查索引可用性的重要部分，特别是在处理边的索引时。文档中提及了索引构建的异步性及其在事务中的使用注意事项，帮助用户更好地理解如何有效利用索引。"
            },
            {
                "content": "VertexIndex 的构建是异步的，尤其是在已经有很多边的 (label, field) 上添加时。此函数告诉我们索引构建是否完成。\r\n\r\nDO NOT wait for index building in a transaction. Write transactions block other write transactions, so blocking in a write transaction is always a bad idea. And long-living read transactions interfere with GC, making the DB grow unexpectedly.  \r\n请勿在事务中等待索引构建。写事务会阻止其他写事务，因此在写事务中阻塞始终是个坏主意。长期存在的读事务会干扰 GC，导致数据库意外增长。\r\n\r\n参数  \r\nlabel – The label.  标签名称  \r\nfield – The field.  字段名称  \r\n\r\n返回  \r\nTrue if index ready, false if not.  如果索引准备好，则返回 true，否则返回 false。  \r\n\r\n```cpp\r\nVertexIterator GetVertexByUniqueIndex(const std::string &label_name, const std::string &field_name, const std::string &field_value_string)\r\n```\r\nGets vertex by unique index. Throws exception if there is no such vertex.  \r\n通过唯一索引获取顶点。如果没有这样的顶点，抛出异常。\r\n\r\n参数  \r\nlabel_name – Name of the label.  标签的名称  \r\nfield_name – Name of the field.  字段的名称  \r\nfield_value_string – The field value string.  字段值字符串  \r\n\r\n返回  \r\nThe vertex by unique index.  通过唯一索引返回顶点  \r\n\r\n```cpp\n\n该文档包含有关C++开发存储过程接口的详细说明，其中包括Base64编码、图数据库（GraphDB）、图遍历、异常处理等内容。在讨论索引功能时，文中提到VertexIndex的构建是异步的，并警告不要在事务中等待索引构建，以防止阻塞和影响性能。此处的内容涉及如何通过唯一索引获取顶点的信息及索引构建的相关注意事项。"
            },
            {
                "content": "```cpp\r\nVertexIterator GetVertexByUniqueIndex(const std::string &label_name, const std::string &field_name, const std::string &field_value_string)\r\n```\r\nGets vertex by unique index. Throws exception if there is no such vertex.  \r\n通过唯一索引获取顶点。如果没有这样的顶点，抛出异常。\r\n\r\n参数  \r\nlabel_name – Name of the label.  标签的名称  \r\nfield_name – Name of the field.  字段的名称  \r\nfield_value_string – The field value string.  字段值字符串  \r\n\r\n返回  \r\nThe vertex by unique index.  通过唯一索引返回顶点  \r\n\r\n```cpp\r\nVertexIterator GetVertexByUniqueCompositeIndex(const std::string &label_name, const std::vector &field_name, const std::vector &field_value_string)\r\n```\r\n\r\n```cpp\r\nOutEdgeIterator GetEdgeByUniqueIndex(const std::string &label_name, const std::string &field_name, const std::string &field_value_string)\r\n```\r\nGets edge by unique index. Throws exception if there is no such vertex.  \r\n通过唯一索引获取边。如果没有这样的顶点，抛出异常。\r\n\r\n参数  \r\nlabel_name – Name of the label.  标签的名称  \r\nfield_name – Name of the field.  字段的名称\n\n该代码片段位于文档的 \"lgraph_txn\" 部分，描述了通过唯一索引获取顶点和边的函数。这些函数允许用户通过指定的标签和字段检索图数据库中的顶点和边，提供了图形操作过程中的重要接口，确保在进行图分析时能够高效地访问特定的数据。"
            },
            {
                "content": "```cpp\r\nVertexIterator GetVertexByUniqueCompositeIndex(const std::string &label_name, const std::vector &field_name, const std::vector &field_value_string)\r\n```\r\n\r\n```cpp\r\nOutEdgeIterator GetEdgeByUniqueIndex(const std::string &label_name, const std::string &field_name, const std::string &field_value_string)\r\n```\r\nGets edge by unique index. Throws exception if there is no such vertex.  \r\n通过唯一索引获取边。如果没有这样的顶点，抛出异常。\r\n\r\n参数  \r\nlabel_name – Name of the label.  标签的名称  \r\nfield_name – Name of the field.  字段的名称  \r\nfield_value_string – The field value string.  字段值字符串  \r\n\r\n返回  \r\nThe vertex by unique index.  通过唯一索引返回顶点  \r\n\r\n```cpp\r\nVertexIterator GetVertexByUniqueIndex(const std::string &label_name, const std::string &field_name, const FieldData &field_value)\r\n```\r\nGets vertex by unique index. Throws exception if there is no such vertex.  \r\n通过唯一索引获取顶点。如果没有这样的顶点，抛出异常。\r\n\r\n参数  \r\nlabel_name – Name of the label.  标签的名称  \r\nfield_name – Name of the field.  字段的名称  \r\nfield_value – The field value.  字段值  \r\n\r\n返回\n\n该代码段位于文档的 `lgraph_txn` 章节中，主要描述了通过唯一索引获取顶点和边的函数，包括 `GetVertexByUniqueCompositeIndex` 和 `GetEdgeByUniqueIndex`，以及相关的参数和返回值说明。这些函数用于在图数据库中高效地检索特定的顶点和边，确保在不存在时抛出异常。"
            },
            {
                "content": "field_value_string – The field value string.  字段值字符串  \r\n\r\n返回  \r\nThe vertex by unique index.  通过唯一索引返回顶点  \r\n\r\n```cpp\r\nVertexIterator GetVertexByUniqueIndex(const std::string &label_name, const std::string &field_name, const FieldData &field_value)\r\n```\r\nGets vertex by unique index. Throws exception if there is no such vertex.  \r\n通过唯一索引获取顶点。如果没有这样的顶点，抛出异常。\r\n\r\n参数  \r\nlabel_name – Name of the label.  标签的名称  \r\nfield_name – Name of the field.  字段的名称  \r\nfield_value – The field value.  字段值  \r\n\r\n返回  \r\nThe vertex by unique index.  通过唯一索引返回顶点  \r\n\r\n```cpp\r\nVertexIterator GetVertexByUniqueCompositeIndex(const std::string &label_name, const std::vector &field_name, const std::vector &field_value)\r\n```\r\n\r\n```cpp\r\nOutEdgeIterator GetEdgeByUniqueIndex(const std::string &label_name, const std::string &field_name, const FieldData &field_value)\r\n```\r\nGets edge by unique index. Throws exception if there is no such vertex.  \r\n通过唯一索引获取边。如果没有这样的顶点，抛出异常。\r\n\r\n参数  \r\nlabel_name – Name of the label.  标签的名称\n\n该代码块位于文档的“lgraph_types”部分，具体涉及通过唯一索引获取顶点和边的函数声明及其参数说明。主要介绍了如何根据标签和字段名以及对应的字段值获取特定的顶点或边，并包括异常处理和返回值的描述。"
            },
            {
                "content": "返回  \r\nThe vertex by unique index.  通过唯一索引返回顶点  \r\n\r\n```cpp\r\nVertexIterator GetVertexByUniqueCompositeIndex(const std::string &label_name, const std::vector &field_name, const std::vector &field_value)\r\n```\r\n\r\n```cpp\r\nOutEdgeIterator GetEdgeByUniqueIndex(const std::string &label_name, const std::string &field_name, const FieldData &field_value)\r\n```\r\nGets edge by unique index. Throws exception if there is no such vertex.  \r\n通过唯一索引获取边。如果没有这样的顶点，抛出异常。\r\n\r\n参数  \r\nlabel_name – Name of the label.  标签的名称  \r\nfield_name – Name of the field.  字段的名称  \r\nfield_value – The field value.  字段值  \r\n\r\n返回  \r\nThe vertex by unique index.  通过唯一索引返回顶点  \r\n\r\n```cpp\r\nVertexIterator GetVertexByUniqueIndex(size_t label_id, size_t field_id, const FieldData &field_value)\r\n```\r\nGets vertex by unique index. Throws exception if there is no such vertex.  \r\n通过唯一索引获取顶点。如果没有这样的顶点，抛出异常。\r\n\r\n参数  \r\nlabel_id – Identifier for the label.  标签的标识符  \r\nfield_id – Identifier for the field.  字段的标识符  \r\nfield_value – The field value.  字段值  \r\n\r\n返回\n\n该片段位于文档的 \"lgraph_vertex_iterator\" 类部分，描述如何通过唯一索引获取顶点和边的相关函数。这些函数允许用户根据特定的属性快速检索图中的元素，并且详细说明了参数和返回值。"
            },
            {
                "content": "field_name – Name of the field.  字段的名称  \r\nfield_value – The field value.  字段值  \r\n\r\n返回  \r\nThe vertex by unique index.  通过唯一索引返回顶点  \r\n\r\n```cpp\r\nVertexIterator GetVertexByUniqueIndex(size_t label_id, size_t field_id, const FieldData &field_value)\r\n```\r\nGets vertex by unique index. Throws exception if there is no such vertex.  \r\n通过唯一索引获取顶点。如果没有这样的顶点，抛出异常。\r\n\r\n参数  \r\nlabel_id – Identifier for the label.  标签的标识符  \r\nfield_id – Identifier for the field.  字段的标识符  \r\nfield_value – The field value.  字段值  \r\n\r\n返回  \r\nThe vertex by unique index.  通过唯一索引返回顶点  \r\n\r\n```cpp\r\nVertexIterator GetVertexByUniqueCompositeIndex(size_t label_id, const std::vector &field_id, const std::vector &field_value)\r\n```\r\n\r\n```cpp\r\nOutEdgeIterator GetEdgeByUniqueIndex(size_t label_id, size_t field_id, const FieldData &field_value)\r\n```\r\nGets edge by unique index. Throws exception if there is no such vertex.  \r\n通过唯一索引获取边。如果没有这样的顶点，抛出异常。\r\n\r\n参数  \r\nlabel_id – Identifier for the label.  标签的标识符  \r\nfield_id – Identifier for the field.  字段的标识符\n\n该块内容位于文档中描述图数据库操作的部分，具体涉及如何通过唯一索引获取顶点和边的函数方法。它详细说明了参数及返回值，帮助用户理解如何在TuGraph中利用唯一索引访问特定的图元素。"
            },
            {
                "content": "The vertex by unique index.  通过唯一索引返回顶点  \r\n\r\n```cpp\r\nVertexIterator GetVertexByUniqueCompositeIndex(size_t label_id, const std::vector &field_id, const std::vector &field_value)\r\n```\r\n\r\n```cpp\r\nOutEdgeIterator GetEdgeByUniqueIndex(size_t label_id, size_t field_id, const FieldData &field_value)\r\n```\r\nGets edge by unique index. Throws exception if there is no such vertex.  \r\n通过唯一索引获取边。如果没有这样的顶点，抛出异常。\r\n\r\n参数  \r\nlabel_id – Identifier for the label.  标签的标识符  \r\nfield_id – Identifier for the field.  字段的标识符  \r\nfield_value – The field value.  字段值  \r\n\r\n返回  \r\nThe vertex by unique index.  通过唯一索引返回顶点  \r\n\r\n```cpp\r\nsize_t GetNumVertices()\r\n```\r\nGets the number of vertices.  \r\n获取顶点的数量。\r\n\r\n返回  \r\nThe number of vertices.  顶点的数量  \r\n\r\n```cpp\r\nconst std::string &GetVertexPrimaryField(const std::string &label)\r\n```\r\nGets vertex primary field  \r\n获取顶点的主字段  \r\n\r\n返回  \r\nThe primary field.  主字段  \r\n\r\n```cpp\r\nstd::pair Count()\r\n```\r\nGet the total number of vertex and edge  \r\n获取顶点和边的总数  \r\n\r\n返回\n\n该块内容位于文档的“lgraph_vertex_iterator”部分，主要描述如何通过唯一索引获取顶点和边，包括相关函数的定义和参数说明。它还涉及如何获取图中的顶点数量以及获取顶点的主字段等功能，属于图数据库操作与查询的细节。"
            },
            {
                "content": "field_value – The field value.  字段值  \r\n\r\n返回  \r\nThe vertex by unique index.  通过唯一索引返回顶点  \r\n\r\n```cpp\r\nsize_t GetNumVertices()\r\n```\r\nGets the number of vertices.  \r\n获取顶点的数量。\r\n\r\n返回  \r\nThe number of vertices.  顶点的数量  \r\n\r\n```cpp\r\nconst std::string &GetVertexPrimaryField(const std::string &label)\r\n```\r\nGets vertex primary field  \r\n获取顶点的主字段  \r\n\r\n返回  \r\nThe primary field.  主字段  \r\n\r\n```cpp\r\nstd::pair Count()\r\n```\r\nGet the total number of vertex and edge  \r\n获取顶点和边的总数  \r\n\r\n返回  \r\nstd::pair object, first element is vertex number, second is edge number.  \r\n返回一个 std::pair 对象，第一个元素是顶点数量，第二个元素是边的数量。  \r\n\r\n```cpp\r\nstd::vector> CountDetail()\r\n```\r\nGet the total number of vertex or edge for each label  \r\n获取每个标签的顶点或边的总数  \r\n\r\n返回  \r\nstd::tuple object list, first element indicates whether it is VERTEX or EDGE, second is label name, third is number.  \r\n返回一个 std::tuple 对象列表，第一个元素指示它是 VERTEX 还是 EDGE，第二个是标签名称，第三个是数量。  \r\n\r\n### Private Functions\r\n\r\n#### explicit Transaction(lgraph::Transaction&&)  \r\n显式事务\r\n\r\n### Private Members\n\n该片段位于文档中关于**TuGraph**的**事务**部分，特别是在描述图数据库相关操作时，强调了如何获取顶点数量以及顶点的主字段等基本信息。此外，还提到了如何计算图中顶点和边的总数，以及各标签的详细计数。这些内容在使用图数据库进行分析和查询时尤为重要。"
            },
            {
                "content": "返回一个 std::pair 对象，第一个元素是顶点数量，第二个元素是边的数量。  \r\n\r\n```cpp\r\nstd::vector> CountDetail()\r\n```\r\nGet the total number of vertex or edge for each label  \r\n获取每个标签的顶点或边的总数  \r\n\r\n返回  \r\nstd::tuple object list, first element indicates whether it is VERTEX or EDGE, second is label name, third is number.  \r\n返回一个 std::tuple 对象列表，第一个元素指示它是 VERTEX 还是 EDGE，第二个是标签名称，第三个是数量。  \r\n\r\n### Private Functions\r\n\r\n#### explicit Transaction(lgraph::Transaction&&)  \r\n显式事务\r\n\r\n### Private Members\r\n\r\n#### std::shared_ptr txn_  \r\n共享指针类型的事务  \r\n\r\n### Friends\r\n\r\n#### friend class GraphDB  \r\n友元类 GraphDB  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_types\r\n\r\nnamespace lgraph_api\r\n\r\n### Typedefs\r\n\r\ntypedef std::vector> EdgeConstraints  \r\n// Edge constraints type define  \r\n// 边约束类型定义\r\n\r\n### Enums\r\n\r\nenum class AccessLevel\n\n该段落位于关于TuGraph的OLAP接口部分，具体描述了获取图中顶点和边的总数的方法及其返回值结构。它还提到了处理顶点和边的相关私有函数和成员，包括事务的显式构造函数以及与图数据库的友元关系。这部分内容主要集中在图形分析和处理的内部机制上。"
            },
            {
                "content": "返回一个 std::tuple 对象列表，第一个元素指示它是 VERTEX 还是 EDGE，第二个是标签名称，第三个是数量。  \r\n\r\n### Private Functions\r\n\r\n#### explicit Transaction(lgraph::Transaction&&)  \r\n显式事务\r\n\r\n### Private Members\r\n\r\n#### std::shared_ptr txn_  \r\n共享指针类型的事务  \r\n\r\n### Friends\r\n\r\n#### friend class GraphDB  \r\n友元类 GraphDB  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_types\r\n\r\nnamespace lgraph_api\r\n\r\n### Typedefs\r\n\r\ntypedef std::vector> EdgeConstraints  \r\n// Edge constraints type define  \r\n// 边约束类型定义\r\n\r\n### Enums\r\n\r\nenum class AccessLevel  \r\n// Access level a user or role has on a graph. NONE: no permission. READ: read-only, no write access. WRITE: can read and write vertex and edge, but cannot change meta data such as schema or access. FULL: full access, can modify schema, grant access to other users, or even delete this graph.\r\n// 用户或角色在图上的访问级别。NONE：没有权限。READ：只读，没有写入权限。WRITE：可以读取和写入顶点和边，但不能更改元数据，如模式或访问。FULL：完全访问，可以修改模式，授予其他用户访问权限，甚至删除此图。\r\n\r\nValues:\r\n\r\n- enumerator NONE  \r\n- enumerator READ  \r\n- enumerator WRITE  \r\n- enumerator FULL\n\n该区块位于文档中关于图数据库事务的部分，主要讨论了事务的私有函数、私有成员，以及与其他类（如 GraphDB）的友元关系。同时，它还延续到图类型和权限相关的定义，说明了用户或角色在图上的访问级别。"
            },
            {
                "content": "// Access level a user or role has on a graph. NONE: no permission. READ: read-only, no write access. WRITE: can read and write vertex and edge, but cannot change meta data such as schema or access. FULL: full access, can modify schema, grant access to other users, or even delete this graph.\r\n// 用户或角色在图上的访问级别。NONE：没有权限。READ：只读，没有写入权限。WRITE：可以读取和写入顶点和边，但不能更改元数据，如模式或访问。FULL：完全访问，可以修改模式，授予其他用户访问权限，甚至删除此图。\r\n\r\nValues:\r\n\r\n- enumerator NONE  \r\n- enumerator READ  \r\n- enumerator WRITE  \r\n- enumerator FULL  \r\n\r\nenum class FieldAccessLevel  \r\n// Field access level.  \r\n// 字段访问级别。\r\n\r\nValues:\r\n\r\n- enumerator NONE  \r\n- enumerator READ  \r\n- enumerator WRITE  \r\n\r\nenum class GraphQueryType  \r\n// Graph query type.  \r\n// 图查询类型。\r\n\r\nValues:\r\n\r\n- enumerator CYPHER  \r\n- enumerator GQL  \r\n\r\nenum FieldType  \r\n// Field and value types.  \r\n// 字段和值类型。\r\n\r\nValues:\r\n\r\n- enumerator NUL  \r\n- enumerator NUL  \r\n- enumerator NUL  \r\n- enumerator BOOL  \r\n- enumerator INT8  \r\n- enumerator INT16  \r\n- enumerator INT32  \r\n- enumerator INT64\n\n该内容位于文档的类型定义部分，主要描述了用户或角色在图数据库中的访问级别，包括不同的权限类型（如NONE、READ、WRITE和FULL）以及字段访问级别。该部分还定义了用于图查询的类型（如CYPHER和GQL）以及各种字段和数值类型的枚举值。这些定义对于理解图数据库中权限控制和查询操作至关重要。"
            },
            {
                "content": "enum class FieldAccessLevel  \r\n// Field access level.  \r\n// 字段访问级别。\r\n\r\nValues:\r\n\r\n- enumerator NONE  \r\n- enumerator READ  \r\n- enumerator WRITE  \r\n\r\nenum class GraphQueryType  \r\n// Graph query type.  \r\n// 图查询类型。\r\n\r\nValues:\r\n\r\n- enumerator CYPHER  \r\n- enumerator GQL  \r\n\r\nenum FieldType  \r\n// Field and value types.  \r\n// 字段和值类型。\r\n\r\nValues:\r\n\r\n- enumerator NUL  \r\n- enumerator NUL  \r\n- enumerator NUL  \r\n- enumerator BOOL  \r\n- enumerator INT8  \r\n- enumerator INT16  \r\n- enumerator INT32  \r\n- enumerator INT64  \r\n- enumerator FLOAT  \r\n- enumerator DOUBLE  \r\n- enumerator DATE  \r\n- enumerator DATETIME  \r\n- enumerator STRING  \r\n- enumerator BLOB  \r\n- enumerator POINT  \r\n- enumerator POINT  \r\n- enumerator LINESTRING  \r\n- enumerator LINESTRING  \r\n- enumerator POLYGON  \r\n- enumerator POLYGON  \r\n- enumerator SPATIAL  \r\n- enumerator FLOAT_VECTOR  \r\n\r\nenum class LGraphType : uint16_t  \r\n// a type of value used in result entry and parameter in procedure or plugin signature  \r\n// 在结果条目和过程或插件签名中使用的值类型。\r\n\r\n- Param INTEGER\n\n该代码段定义了与图数据库相关的枚举类型，包括字段访问级别、图查询类型和字段类型。这些枚举用于表示用户在图形操作中的权限、查询语言类型以及支持的数据类型，确保在图分析和处理过程中的数据有效性与一致性。"
            },
            {
                "content": "- enumerator FLOAT  \r\n- enumerator DOUBLE  \r\n- enumerator DATE  \r\n- enumerator DATETIME  \r\n- enumerator STRING  \r\n- enumerator BLOB  \r\n- enumerator POINT  \r\n- enumerator POINT  \r\n- enumerator LINESTRING  \r\n- enumerator LINESTRING  \r\n- enumerator POLYGON  \r\n- enumerator POLYGON  \r\n- enumerator SPATIAL  \r\n- enumerator FLOAT_VECTOR  \r\n\r\nenum class LGraphType : uint16_t  \r\n// a type of value used in result entry and parameter in procedure or plugin signature  \r\n// 在结果条目和过程或插件签名中使用的值类型。\r\n\r\n- Param INTEGER  \r\n- Param FLOAT  \r\n- Param DOUBLE  \r\n- Param BOOLEAN  \r\n- Param STRING  \r\n- Param MAP  \r\n    \r\n- Param NODE  \r\n  VertexIterator, VertexId  \r\n- Param RELATIONSHIP  \r\n  InEdgeIterator || OutEdgeIterator, EdgeUid  \r\n- Param PATH  \r\n  lgraph_api::Path  \r\n- Param LIST  \r\n    \r\n- Param ANY  \r\n  like Object in Java, its procedure author’s responsibility to check the underlying concrete type whether valid in runtime.  \r\n  类似于Java中的对象，程序作者负责在运行时检查底层具体类型是否有效。\r\n\r\nValues:\r\n\r\n- enumerator NUL  \r\n- enumerator INTEGER\n\n该块内容位于文档中的“lgraph_types”部分，定义了不同的数据类型和参数类型，包括浮点数、日期、时间戳、字符串、BLOB、空间数据等，适用于结果条目和过程或插件签名的值类型。"
            },
            {
                "content": "- Param FLOAT  \r\n- Param DOUBLE  \r\n- Param BOOLEAN  \r\n- Param STRING  \r\n- Param MAP  \r\n    \r\n- Param NODE  \r\n  VertexIterator, VertexId  \r\n- Param RELATIONSHIP  \r\n  InEdgeIterator || OutEdgeIterator, EdgeUid  \r\n- Param PATH  \r\n  lgraph_api::Path  \r\n- Param LIST  \r\n    \r\n- Param ANY  \r\n  like Object in Java, its procedure author’s responsibility to check the underlying concrete type whether valid in runtime.  \r\n  类似于Java中的对象，程序作者负责在运行时检查底层具体类型是否有效。\r\n\r\nValues:\r\n\r\n- enumerator NUL  \r\n- enumerator INTEGER  \r\n- enumerator FLOAT  \r\n- enumerator DOUBLE  \r\n- enumerator BOOLEAN  \r\n- enumerator STRING  \r\n- enumerator NODE  \r\n- enumerator RELATIONSHIP  \r\n- enumerator PATH  \r\n- enumerator LIST  \r\n- enumerator MAP  \r\n- enumerator ANY  \r\n\r\nenum PluginCodeType  \r\n// Type of code given when loading a new plugin.  \r\n// 加载新插件时给定的代码类型。\r\n\r\nValues:\r\n\r\n- enumerator PY  \r\n- enumerator SO  \r\n- enumerator CPP  \r\n- enumerator ZIP  \r\n\r\nenum class IndexType  \r\n// index type  \r\n// 索引类型。\r\n\r\nValues:\r\n\r\n- enumerator NonuniqueIndex\n\n该块内容位于文档的类型定义部分，描述了不同类型的参数（如FLOAT、DOUBLE、BOOLEAN等）及其在TuGraph中的用途，特别是涉及用户自定义过程和插件时使用的类型。这部分定义了参数的枚举值及代码类型，为插件开发者提供必要的信息，以确保在编写和加载插件时能够正确使用这些数据类型。"
            },
            {
                "content": "- enumerator FLOAT  \r\n- enumerator DOUBLE  \r\n- enumerator BOOLEAN  \r\n- enumerator STRING  \r\n- enumerator NODE  \r\n- enumerator RELATIONSHIP  \r\n- enumerator PATH  \r\n- enumerator LIST  \r\n- enumerator MAP  \r\n- enumerator ANY  \r\n\r\nenum PluginCodeType  \r\n// Type of code given when loading a new plugin.  \r\n// 加载新插件时给定的代码类型。\r\n\r\nValues:\r\n\r\n- enumerator PY  \r\n- enumerator SO  \r\n- enumerator CPP  \r\n- enumerator ZIP  \r\n\r\nenum class IndexType  \r\n// index type  \r\n// 索引类型。\r\n\r\nValues:\r\n\r\n- enumerator NonuniqueIndex  \r\n  this is not unique index  \r\n  // 这不是唯一索引\r\n- enumerator GlobalUniqueIndex  \r\n  this is a global unique index  \r\n  // 这是一个全局唯一索引\r\n- enumerator PairUniqueIndex  \r\n  this is a pair unique index, for edge index only key of pair unique index is one of the follow case : if src_vid < dst_vid ,key is (index field value + src_vid + dst_vid) if src_vid > dst_vid ,key is (index field value + dst_vid + src_vid)\n\n该段落位于文档中关于`lgraph_types`部分，定义了不同的枚举类型，包括字段类型（如FLOAT、DOUBLE、BOOLEAN等）、插件代码类型（如PY、SO、CPP、ZIP）和索引类型（如非唯一索引、全局唯一索引、对唯一索引），这些定义对TuGraph的图数据处理和插件扩展功能至关重要。"
            },
            {
                "content": "enum class IndexType  \r\n// index type  \r\n// 索引类型。\r\n\r\nValues:\r\n\r\n- enumerator NonuniqueIndex  \r\n  this is not unique index  \r\n  // 这不是唯一索引\r\n- enumerator GlobalUniqueIndex  \r\n  this is a global unique index  \r\n  // 这是一个全局唯一索引\r\n- enumerator PairUniqueIndex  \r\n  this is a pair unique index, for edge index only key of pair unique index is one of the follow case : if src_vid < dst_vid ,key is (index field value + src_vid + dst_vid) if src_vid > dst_vid ,key is (index field value + dst_vid + src_vid)  \r\n  // 这是一个对唯一索引，仅边索引的对唯一索引的键是以下情况之一：如果src_vid < dst_vid，则键为（索引字段值 + src_vid + dst_vid），如果src_vid > dst_vid，则键为（索引字段值 + dst_vid + src_vid）\r\n\r\nenum class CompositeIndexType  \r\n\r\nValues:\r\n\r\n- enumerator UniqueIndex  \r\n  this is unique composite index  \r\n  // 这是唯一复合索引\r\n- enumerator NonUniqueIndex  \r\n  this is not unique composite index  \r\n  // 这不是唯一复合索引\r\n\r\n### Functions\r\n\r\nstatic inline std::string to_string(const AccessLevel &v)  \r\n// Convert AccessLevel to string.  \r\n// 将AccessLevel转换为字符串\n\n该块位于文档的类型定义部分，具体描述了索引类型（`IndexType`）和复合索引类型（`CompositeIndexType`）的枚举，包括对每种类型的具体说明及其适用场景，为图数据库的索引管理提供基础。"
            },
            {
                "content": "// 这是一个对唯一索引，仅边索引的对唯一索引的键是以下情况之一：如果src_vid < dst_vid，则键为（索引字段值 + src_vid + dst_vid），如果src_vid > dst_vid，则键为（索引字段值 + dst_vid + src_vid）\r\n\r\nenum class CompositeIndexType  \r\n\r\nValues:\r\n\r\n- enumerator UniqueIndex  \r\n  this is unique composite index  \r\n  // 这是唯一复合索引\r\n- enumerator NonUniqueIndex  \r\n  this is not unique composite index  \r\n  // 这不是唯一复合索引\r\n\r\n### Functions\r\n\r\nstatic inline std::string to_string(const AccessLevel &v)  \r\n// Convert AccessLevel to string.  \r\n// 将AccessLevel转换为字符串\r\nstatic inline std::string to_string(const FieldAccessLevel &v)  \r\n// Convert FieldAccessLevel to string.  \r\n// 将FieldAccessLevel转换为字符串\r\nstatic inline std::string to_string(const GraphQueryType &v)  \r\n// Convert GraphQueryType to string.  \r\n// 将GraphQueryType转换为字符串\r\ninline const std::string to_string(FieldType v)  \r\n// Get the name of the given FieldType.  \r\n// 获取给定FieldType的名称。\r\n\r\n抛出  \r\nstd::runtime_error – when an unrecognizable FieldType is given.  \r\n// 当给定不可识别的FieldType时抛出。\r\n\r\n参数  \r\nv – A FieldType.  \r\n// v – 一个FieldType。\n\n该块内容位于文档中关于图数据库索引类型的部分，主要介绍了唯一索引及其相关定义和功能，包括如何通过字段类型和访问级别转换成字符串的函数。此部分为理解图数据库的索引机制和查询类型提供了基础信息。"
            },
            {
                "content": "// Convert FieldAccessLevel to string.  \r\n// 将FieldAccessLevel转换为字符串\r\nstatic inline std::string to_string(const GraphQueryType &v)  \r\n// Convert GraphQueryType to string.  \r\n// 将GraphQueryType转换为字符串\r\ninline const std::string to_string(FieldType v)  \r\n// Get the name of the given FieldType.  \r\n// 获取给定FieldType的名称。\r\n\r\n抛出  \r\nstd::runtime_error – when an unrecognizable FieldType is given.  \r\n// 当给定不可识别的FieldType时抛出。\r\n\r\n参数  \r\nv – A FieldType.  \r\n// v – 一个FieldType。\r\n\r\n返回  \r\nName of the given FieldType.  \r\n// 给定FieldType的名称。\r\n\r\ninline auto LGraphTypeIsField(LGraphType type) -> bool  \r\n// Check if the type is a field type.  \r\n// 检查该类型是否为字段类型\r\ninline auto LGraphTypeIsGraphElement(LGraphType type) -> bool  \r\n// Check if the type is a graph element type.  \r\n// 检查该类型是否为图形元素类型\r\ninline auto LGraphTypeIsCollection(LGraphType type) -> bool  \r\n// Check if the type is a collection type.  \r\n// 检查该类型是否为集合类型\r\ninline auto LGraphTypeIsAny(LGraphType type) -> bool  \r\n// Check if the type is ANY type.  \r\n// 检查该类型是否为ANY类型\n\n该块内容位于文档的`lgraph_types`部分，主要讨论了如何将不同类型转换为字符串，包括`FieldAccessLevel`、`GraphQueryType`和`FieldType`。同时，该部分还包含了一系列用于判断类型的函数，帮助用户识别不同的类型特性，如字段类型、图形元素类型、集合类型等。这些内容对于理解和使用图数据库中的类型定义和转换至关重要。"
            },
            {
                "content": "// 给定FieldType的名称。\r\n\r\ninline auto LGraphTypeIsField(LGraphType type) -> bool  \r\n// Check if the type is a field type.  \r\n// 检查该类型是否为字段类型\r\ninline auto LGraphTypeIsGraphElement(LGraphType type) -> bool  \r\n// Check if the type is a graph element type.  \r\n// 检查该类型是否为图形元素类型\r\ninline auto LGraphTypeIsCollection(LGraphType type) -> bool  \r\n// Check if the type is a collection type.  \r\n// 检查该类型是否为集合类型\r\ninline auto LGraphTypeIsAny(LGraphType type) -> bool  \r\n// Check if the type is ANY type.  \r\n// 检查该类型是否为ANY类型\r\ninline const std::string to_string(LGraphType type)  \r\n// Convert LGraphType to string.  \r\n// 将LGraphType转换为字符串\r\ninline std::string PluginCodeTypeStr(PluginCodeType code_type)  \r\n// Get the name of plugin code types.  \r\n// 获取插件代码类型的名称。\r\n\r\nstruct CompositeIndexSpec  \r\n#include   \r\n// A composite index specifier.  \r\n// 复合索引说明符。\r\n\r\nPublic Members\r\n\r\n- std::string label  \r\n  label name  \r\n  // 标签名称\r\n- std::vector fields  \r\n  fields name  \r\n  // 字段名称\r\n- CompositeIndexType type\n\n该块内容位于文档中关于LGraphType和相关函数的定义部分，主要涉及如何检查和转换各种数据类型，包括字段类型、图形元素类型和集合类型的函数，以及复合索引的说明符。相关函数用于处理图数据库的查询和数据类型表示。"
            },
            {
                "content": "// 检查该类型是否为ANY类型\r\ninline const std::string to_string(LGraphType type)  \r\n// Convert LGraphType to string.  \r\n// 将LGraphType转换为字符串\r\ninline std::string PluginCodeTypeStr(PluginCodeType code_type)  \r\n// Get the name of plugin code types.  \r\n// 获取插件代码类型的名称。\r\n\r\nstruct CompositeIndexSpec  \r\n#include   \r\n// A composite index specifier.  \r\n// 复合索引说明符。\r\n\r\nPublic Members\r\n\r\n- std::string label  \r\n  label name  \r\n  // 标签名称\r\n- std::vector fields  \r\n  fields name  \r\n  // 字段名称\r\n- CompositeIndexType type  \r\n\r\nstruct EdgeOptions : public LabelOptions  \r\n#include   \r\n// Edge label options, contain fields only edge have  \r\n// 边标签选项，仅包含边具有的字段。\r\n\r\nPublic Types\r\n\r\nenum class TemporalFieldOrder  \r\n// Order of temporal field.  \r\n// 时间字段的顺序。\r\n\r\nValues:\r\n\r\n- enumerator ASC  \r\n- enumerator DESC  \r\n\r\nPublic Functions\r\n\r\nEdgeOptions() = default  \r\n// Default constructor.  \r\n// 默认构造函数\r\ninline explicit EdgeOptions(const EdgeConstraints &edge_constraints)  \r\n// Construct EdgeOptions with edge constraints.  \r\n// 根据边约束构造EdgeOptions\n\n该代码片段位于文档的类型定义部分，主要涉及LGraphType和PluginCodeType的转换函数，以及与复合索引和边标签选项相关的结构体定义。它包含对标签名、字段名和时间字段顺序的描述，定义了边标签的选项，并提供了相关的构造函数和枚举类型。"
            },
            {
                "content": "#include   \r\n// Edge label options, contain fields only edge have  \r\n// 边标签选项，仅包含边具有的字段。\r\n\r\nPublic Types\r\n\r\nenum class TemporalFieldOrder  \r\n// Order of temporal field.  \r\n// 时间字段的顺序。\r\n\r\nValues:\r\n\r\n- enumerator ASC  \r\n- enumerator DESC  \r\n\r\nPublic Functions\r\n\r\nEdgeOptions() = default  \r\n// Default constructor.  \r\n// 默认构造函数\r\ninline explicit EdgeOptions(const EdgeConstraints &edge_constraints)  \r\n// Construct EdgeOptions with edge constraints.  \r\n// 根据边约束构造EdgeOptions\r\ninline virtual std::string to_string() const  \r\n// Convert EdgeOptions to string.  \r\n// 将EdgeOptions转换为字符串\r\ninline virtual void clear()  \r\n// Clear EdgeOptions.  \r\n// 清除EdgeOptions\r\n\r\nPublic Members\r\n\r\n- EdgeConstraints edge_constraints  \r\n- std::string temporal_field  \r\n- enum lgraph_api::EdgeOptions::TemporalFieldOrder temporal_field_order = TemporalFieldOrder::ASC  \r\n\r\nPublic Static Functions\r\n\r\nstatic inline std::string to_string(const TemporalFieldOrder &v)  \r\n// Convert TemporalFieldOrder to string.  \r\n// 将TemporalFieldOrder转换为字符串\n\n该部分位于文档中描述边标签选项的类别下，具体介绍了边标签的设置和属性，包括时间字段的顺序以及边选项如何根据特定约束进行构造。此内容对于理解如何配置边的属性和行为至关重要。"
            },
            {
                "content": "// Convert EdgeOptions to string.  \r\n// 将EdgeOptions转换为字符串\r\ninline virtual void clear()  \r\n// Clear EdgeOptions.  \r\n// 清除EdgeOptions\r\n\r\nPublic Members\r\n\r\n- EdgeConstraints edge_constraints  \r\n- std::string temporal_field  \r\n- enum lgraph_api::EdgeOptions::TemporalFieldOrder temporal_field_order = TemporalFieldOrder::ASC  \r\n\r\nPublic Static Functions\r\n\r\nstatic inline std::string to_string(const TemporalFieldOrder &v)  \r\n// Convert TemporalFieldOrder to string.  \r\n// 将TemporalFieldOrder转换为字符串\r\n\r\n### struct EdgeUid\r\n\r\n#include \r\n\r\n#### Public Functions\r\n\r\ninline EdgeUid()  \r\n// Default constructor for EdgeUid.  \r\n// EdgeUid的默认构造函数\r\ninline EdgeUid(int64_t s, int64_t d, uint16_t l, int64_t t, int64_t e)  \r\n// Constructor for EdgeUid with parameters.  \r\n// 带参数的EdgeUid构造函数\r\ninline void Reverse()  \r\n// Reverses side of this edge  \r\n// 反转此边的方向\r\n\r\ninline bool operator==(const EdgeUid &rhs) const  \r\n// Equality operator for EdgeUid.  \r\n// EdgeUid的相等运算符\r\ninline bool operator!=(const EdgeUid &rhs) const\n\n此代码块位于文档中关于 TuGraph 图分析引擎的定义部分，主要涉及 `EdgeOptions` 类的函数和成员，特别是转换和清除操作，以及对 `EdgeUid` 类的构造函数和运算符重载的定义。这些内容提供了图的边属性及其识别的处理方法，适用于图形数据管理和操作。"
            },
            {
                "content": "### struct EdgeUid\r\n\r\n#include \r\n\r\n#### Public Functions\r\n\r\ninline EdgeUid()  \r\n// Default constructor for EdgeUid.  \r\n// EdgeUid的默认构造函数\r\ninline EdgeUid(int64_t s, int64_t d, uint16_t l, int64_t t, int64_t e)  \r\n// Constructor for EdgeUid with parameters.  \r\n// 带参数的EdgeUid构造函数\r\ninline void Reverse()  \r\n// Reverses side of this edge  \r\n// 反转此边的方向\r\n\r\ninline bool operator==(const EdgeUid &rhs) const  \r\n// Equality operator for EdgeUid.  \r\n// EdgeUid的相等运算符\r\ninline bool operator!=(const EdgeUid &rhs) const  \r\n// Inequality operator for EdgeUid.  \r\n// EdgeUid的不等运算符\r\ninline bool operator<(const EdgeUid &rhs) const  \r\n// Less than operator for EdgeUid.  \r\n// EdgeUid的小于运算符\r\ninline bool operator>(const EdgeUid &rhs) const  \r\n// Greater than operator for EdgeUid.  \r\n// EdgeUid的大于运算符\r\ninline std::string ToString() const  \r\n// Get string representation of this object  \r\n// 获取该对象的字符串表示\r\n\r\n#### Public Members\r\n\r\n- int64_t src  \r\n  source vertex id  \r\n  // 源顶点ID\r\n- int64_t dst  \r\n  destination vertex id  \r\n  // 目的顶点ID\n\n该结构 `EdgeUid` 定义了图中的边的唯一标识符，包括源顶点和目的顶点的 ID。它定义了边的构造函数、比较运算符以及获取边的字符串表示的函数。此结构是图数据库及其操作的重要组成部分，特别是在处理边的查询和管理时。"
            },
            {
                "content": "// Inequality operator for EdgeUid.  \r\n// EdgeUid的不等运算符\r\ninline bool operator<(const EdgeUid &rhs) const  \r\n// Less than operator for EdgeUid.  \r\n// EdgeUid的小于运算符\r\ninline bool operator>(const EdgeUid &rhs) const  \r\n// Greater than operator for EdgeUid.  \r\n// EdgeUid的大于运算符\r\ninline std::string ToString() const  \r\n// Get string representation of this object  \r\n// 获取该对象的字符串表示\r\n\r\n#### Public Members\r\n\r\n- int64_t src  \r\n  source vertex id  \r\n  // 源顶点ID\r\n- int64_t dst  \r\n  destination vertex id  \r\n  // 目的顶点ID\r\n- uint16_t lid  \r\n  label id  \r\n  // 标签ID\r\n- int64_t tid  \r\n  timestamp  \r\n  // 时间戳\r\n- int64_t eid  \r\n  additional edge id to distinguish edges with the same tid  \r\n  // 额外的边ID以区分具有相同时间戳的边\r\n\r\n#### Public Static Functions\r\n\r\nstatic inline EdgeUid AnyEdge()  \r\n// Get a generic edge identifier.  \r\n// 获取通用边标识符\r\n\r\n---\r\n\r\n### struct Hash\r\n\r\n#include \r\n\r\n#### Public Functions\r\n\r\ninline size_t operator()(const EdgeUid &edgeUid) const  \r\n// Hash function for EdgeUid.  \r\n// EdgeUid的哈希函数\r\n\r\n---\n\n该文档主要描述了TuGraph的C++接口，包括图数据库的操作、类型定义、事务管理、遍历等功能。在此上下文中，提到的`EdgeUid`结构用于表示边的唯一标识，它包含源顶点、目标顶点、标签ID、时间戳和边ID等属性。此外，还定义了与`EdgeUid`相关的比较操作符和哈希函数，便于在图查询和操作中使用。"
            },
            {
                "content": "// 目的顶点ID\r\n- uint16_t lid  \r\n  label id  \r\n  // 标签ID\r\n- int64_t tid  \r\n  timestamp  \r\n  // 时间戳\r\n- int64_t eid  \r\n  additional edge id to distinguish edges with the same tid  \r\n  // 额外的边ID以区分具有相同时间戳的边\r\n\r\n#### Public Static Functions\r\n\r\nstatic inline EdgeUid AnyEdge()  \r\n// Get a generic edge identifier.  \r\n// 获取通用边标识符\r\n\r\n---\r\n\r\n### struct Hash\r\n\r\n#include \r\n\r\n#### Public Functions\r\n\r\ninline size_t operator()(const EdgeUid &edgeUid) const  \r\n// Hash function for EdgeUid.  \r\n// EdgeUid的哈希函数\r\n\r\n---\r\n\r\n### struct InEdgeSortOrder\r\n\r\n#include   \r\n// Comparator for EdgeUid of in-coming edges.  \r\n// 传入边的EdgeUid的比较器。\r\n\r\n#### Public Functions\r\n\r\ninline bool operator()(const EdgeUid &lhs, const EdgeUid &rhs) const  \r\n// Compare two EdgeUid for ordering.  \r\n// 比较两个EdgeUid以进行排序\r\n\r\n---\r\n\r\n### struct OutEdgeSortOrder\r\n\r\n#include   \r\n// Comparator for EdgeUid of out-going edges.  \r\n// 传出边的EdgeUid的比较器。\r\n\r\n#### Public Functions\r\n\r\ninline bool operator()(const EdgeUid &lhs, const EdgeUid &rhs) const\n\n该内容位于文档的 \"lgraph_types\" 部分，具体涉及 `EdgeUid` 结构体的定义及其相关函数和比较器。这些结构体和函数用于处理图形中边的标识符及其排序逻辑。"
            },
            {
                "content": "---\r\n\r\n### struct InEdgeSortOrder\r\n\r\n#include   \r\n// Comparator for EdgeUid of in-coming edges.  \r\n// 传入边的EdgeUid的比较器。\r\n\r\n#### Public Functions\r\n\r\ninline bool operator()(const EdgeUid &lhs, const EdgeUid &rhs) const  \r\n// Compare two EdgeUid for ordering.  \r\n// 比较两个EdgeUid以进行排序\r\n\r\n---\r\n\r\n### struct OutEdgeSortOrder\r\n\r\n#include   \r\n// Comparator for EdgeUid of out-going edges.  \r\n// 传出边的EdgeUid的比较器。\r\n\r\n#### Public Functions\r\n\r\ninline bool operator()(const EdgeUid &lhs, const EdgeUid &rhs) const  \r\n// Compare two EdgeUid for ordering.  \r\n// 比较两个EdgeUid以进行排序\r\n\r\n---\r\n\r\n### struct FieldData\r\n\r\n#include   \r\n// A class that represents variant type.  \r\n// 表示变体类型的类。\r\n\r\n#### Public Functions\r\n\r\ninline FieldData()  \r\n// Default constructor.  \r\n// 默认构造函数\r\ninline explicit FieldData(bool b)  \r\n// Construct FieldData from bool.  \r\n// 从布尔值构造FieldData\r\ninline explicit FieldData(int8_t integer)  \r\n// Construct FieldData from int8_t.  \r\n// 从int8_t构造FieldData\r\ninline explicit FieldData(int16_t integer)\n\n该块内容位于文档中关于图数据处理和遍历的部分，具体涵盖了对图中边的排序比较器，包括入边（InEdgeSortOrder）和出边（OutEdgeSortOrder）的定义，以及对变体类型的类（FieldData）的详细描述。这些结构及其函数在执行图遍历操作和处理边数据时具有重要作用。"
            },
            {
                "content": "// Compare two EdgeUid for ordering.  \r\n// 比较两个EdgeUid以进行排序\r\n\r\n---\r\n\r\n### struct FieldData\r\n\r\n#include   \r\n// A class that represents variant type.  \r\n// 表示变体类型的类。\r\n\r\n#### Public Functions\r\n\r\ninline FieldData()  \r\n// Default constructor.  \r\n// 默认构造函数\r\ninline explicit FieldData(bool b)  \r\n// Construct FieldData from bool.  \r\n// 从布尔值构造FieldData\r\ninline explicit FieldData(int8_t integer)  \r\n// Construct FieldData from int8_t.  \r\n// 从int8_t构造FieldData\r\ninline explicit FieldData(int16_t integer)  \r\n// Construct FieldData from int16_t.  \r\n// 从int16_t构造FieldData\r\ninline explicit FieldData(int32_t integer)  \r\n// Construct FieldData from int32_t.  \r\n// 从int32_t构造FieldData\r\ninline explicit FieldData(int64_t integer)  \r\n// Construct FieldData from int64_t.  \r\n// 从int64_t构造FieldData\r\ninline explicit FieldData(float real)  \r\n// Construct FieldData from float.  \r\n// 从浮点数构造FieldData\r\ninline explicit FieldData(double real)  \r\n// Construct FieldData from double.  \r\n// 从双精度浮点数构造FieldData\n\n该文档详细描述了C++中的TuGraph库，包括各种类的定义、函数的实现和数据结构的描述。特别是在“lgraph_types”命名空间中，定义了多个相关的类型和结构体，包括“FieldData”结构，它表示一种变体类型，允许不同数据类型的存储，并提供多种构造函数以便于数据的初始化和使用。在此结构体内，还包含了一些用于获取和转换数据的方法。"
            },
            {
                "content": "// Construct FieldData from int16_t.  \r\n// 从int16_t构造FieldData\r\ninline explicit FieldData(int32_t integer)  \r\n// Construct FieldData from int32_t.  \r\n// 从int32_t构造FieldData\r\ninline explicit FieldData(int64_t integer)  \r\n// Construct FieldData from int64_t.  \r\n// 从int64_t构造FieldData\r\ninline explicit FieldData(float real)  \r\n// Construct FieldData from float.  \r\n// 从浮点数构造FieldData\r\ninline explicit FieldData(double real)  \r\n// Construct FieldData from double.  \r\n// 从双精度浮点数构造FieldData\r\ninline explicit FieldData(const Date &d)  \r\n// Construct FieldData from Date.  \r\n// 从日期构造FieldData\r\ninline explicit FieldData(const DateTime &d)  \r\n// Construct FieldData from DateTime.  \r\n// 从日期时间构造FieldData\r\ninline explicit FieldData(const std::string &buf)  \r\n// Construct FieldData from std::string.  \r\n// 从std::string构造FieldData\r\ninline explicit FieldData(std::string &&str)  \r\n// Construct FieldData from std::string (move).  \r\n// 从std::string（移动）构造FieldData\r\ninline explicit FieldData(const char *buf)\n\n该块内容主要来自于 `FieldData` 结构的定义，描述了如何通过不同的数据类型（如 `int16_t`、`int32_t`、`int64_t`、`float`、`double`、`Date` 和 `DateTime`）构造 `FieldData` 对象。这些构造函数的详细注释和语法展示在 `lgraph_types` 命名空间中，其中 `FieldData` 被用于表示图数据库中各种数据字段的类型。"
            },
            {
                "content": "inline explicit FieldData(const Date &d)  \r\n// Construct FieldData from Date.  \r\n// 从日期构造FieldData\r\ninline explicit FieldData(const DateTime &d)  \r\n// Construct FieldData from DateTime.  \r\n// 从日期时间构造FieldData\r\ninline explicit FieldData(const std::string &buf)  \r\n// Construct FieldData from std::string.  \r\n// 从std::string构造FieldData\r\ninline explicit FieldData(std::string &&str)  \r\n// Construct FieldData from std::string (move).  \r\n// 从std::string（移动）构造FieldData\r\ninline explicit FieldData(const char *buf)  \r\n// Construct FieldData from C-string.  \r\n// 从C字符串构造FieldData\r\ninline explicit FieldData(const char *buf, size_t s)  \r\n// Construct FieldData from C-string with size.  \r\n// 从具有大小的C字符串构造FieldData\r\ninline explicit FieldData(const Point &p)  \r\n// Construct FieldData from Cartesian Point.  \r\n// 从笛卡尔点构造FieldData\r\ninline explicit FieldData(const Point &p)  \r\n// Construct FieldData from Wgs84 Point.  \r\n// 从Wgs84点构造FieldData\r\ninline explicit FieldData(const LineString &l)\n\n该代码块位于文档中关于 `FieldData` 类的部分，描述了用于构造 `FieldData` 对象的各个构造函数，包括从日期、日期时间、字符串和点等类型构造的功能。这些构造函数使得 `FieldData` 能够以多种方式初始化，以适应不同的数据类型需求。"
            },
            {
                "content": "// Construct FieldData from C-string.  \r\n// 从C字符串构造FieldData\r\ninline explicit FieldData(const char *buf, size_t s)  \r\n// Construct FieldData from C-string with size.  \r\n// 从具有大小的C字符串构造FieldData\r\ninline explicit FieldData(const Point &p)  \r\n// Construct FieldData from Cartesian Point.  \r\n// 从笛卡尔点构造FieldData\r\ninline explicit FieldData(const Point &p)  \r\n// Construct FieldData from Wgs84 Point.  \r\n// 从Wgs84点构造FieldData\r\ninline explicit FieldData(const LineString &l)  \r\n// Construct FieldData from Cartesian LineString.  \r\n// 从笛卡尔线段构造FieldData\r\ninline explicit FieldData(const LineString &l)  \r\n// Construct FieldData from Wgs84 LineString.  \r\n// 从Wgs84线段构造FieldData\r\ninline explicit FieldData(const Polygon &p)  \r\n// Construct FieldData from Cartesian Polygon.  \r\n// 从笛卡尔多边形构造FieldData\r\ninline explicit FieldData(const Polygon &p)  \r\n// Construct FieldData from Wgs84 Polygon.  \r\n// 从Wgs84多边形构造FieldData\r\ninline explicit FieldData(const Spatial &s)  \r\n// Construct FieldData from Cartesian Spatial.\n\n这是在`FieldData`类的定义部分，描述了如何从不同类型的数据（如C字符串、点、线段和多边形）构造`FieldData`对象的构造函数。这些构造函数允许用户根据特定格式来创建字段数据，便于在图数据库中使用。"
            },
            {
                "content": "// 从笛卡尔线段构造FieldData\r\ninline explicit FieldData(const LineString &l)  \r\n// Construct FieldData from Wgs84 LineString.  \r\n// 从Wgs84线段构造FieldData\r\ninline explicit FieldData(const Polygon &p)  \r\n// Construct FieldData from Cartesian Polygon.  \r\n// 从笛卡尔多边形构造FieldData\r\ninline explicit FieldData(const Polygon &p)  \r\n// Construct FieldData from Wgs84 Polygon.  \r\n// 从Wgs84多边形构造FieldData\r\ninline explicit FieldData(const Spatial &s)  \r\n// Construct FieldData from Cartesian Spatial.  \r\n// 从笛卡尔空间构造FieldData\r\ninline explicit FieldData(const Spatial &s)  \r\n// Construct FieldData from Wgs84 Spatial.  \r\n// 从Wgs84空间构造FieldData\r\ninline explicit FieldData(const std::vector &fv)  \r\n// Construct FieldData from a vector of floats.  \r\n// 从浮点数向量构造FieldData\r\ninline explicit FieldData(std::vector &&fv)  \r\n// Construct FieldData from a vector of floats (move).  \r\n// 从浮点数向量（移动）构造FieldData\r\ninline ~FieldData()  \r\n// Destructor.  \r\n// 析构函数\r\ninline FieldData(const FieldData &rhs)  \r\n// Copy constructor.  \r\n// 拷贝构造函数\n\n该块内容位于文档中关于`FieldData`类的定义部分，描述了`FieldData`类的构造函数，特别是用于从不同数据类型（如线段、多边形、空间数据及浮点数向量）构造`FieldData`对象的方法。这些构造函数允许用户灵活地根据不同输入类型创建`FieldData`实例，增强了图数据库的灵活性和可用性。同时，文档还提及了该类的析构函数和拷贝构造函数。"
            },
            {
                "content": "inline explicit FieldData(const Spatial &s)  \r\n// Construct FieldData from Wgs84 Spatial.  \r\n// 从Wgs84空间构造FieldData\r\ninline explicit FieldData(const std::vector &fv)  \r\n// Construct FieldData from a vector of floats.  \r\n// 从浮点数向量构造FieldData\r\ninline explicit FieldData(std::vector &&fv)  \r\n// Construct FieldData from a vector of floats (move).  \r\n// 从浮点数向量（移动）构造FieldData\r\ninline ~FieldData()  \r\n// Destructor.  \r\n// 析构函数\r\ninline FieldData(const FieldData &rhs)  \r\n// Copy constructor.  \r\n// 拷贝构造函数\r\ninline FieldData(FieldData &&rhs)  \r\n// Move constructor.  \r\n// 移动构造函数\r\ninline FieldData &operator=(const FieldData &rhs)  \r\n// Copy assignment operator.  \r\n// 拷贝赋值运算符\r\ninline FieldData &operator=(FieldData &&rhs)  \r\n// Move assignment operator.  \r\n// 移动赋值运算符\r\n\r\ninline int64_t integer() const  \r\n// Access the FieldData as int64. Valid only when the FieldData is of INT8, INT16, INT32, or INT64 types.  \r\n// 将FieldData作为int64访问。仅当FieldData为INT8、INT16、INT32或INT64类型时有效。\r\n\r\n抛出\n\n该代码块位于文档的 \"lgraph_types\" 部分，主要描述了 `FieldData` 类的构造函数、析构函数和赋值运算符。这些函数涉及如何从不同类型（如 WGS84 空间和浮点数向量）初始化 `FieldData` 实例，以及如何进行拷贝和移动操作。此部分对理解数据处理和图形数据库结构中的字段类型非常重要。"
            },
            {
                "content": "// 拷贝构造函数\r\ninline FieldData(FieldData &&rhs)  \r\n// Move constructor.  \r\n// 移动构造函数\r\ninline FieldData &operator=(const FieldData &rhs)  \r\n// Copy assignment operator.  \r\n// 拷贝赋值运算符\r\ninline FieldData &operator=(FieldData &&rhs)  \r\n// Move assignment operator.  \r\n// 移动赋值运算符\r\n\r\ninline int64_t integer() const  \r\n// Access the FieldData as int64. Valid only when the FieldData is of INT8, INT16, INT32, or INT64 types.  \r\n// 将FieldData作为int64访问。仅当FieldData为INT8、INT16、INT32或INT64类型时有效。\r\n\r\n抛出  \r\nstd::bad_cast – Thrown when the FieldData is not of int types.  \r\n// 当FieldData不是整数类型时抛出。\r\n\r\n返回  \r\nAn int64_t.  \r\n// 一个int64_t。\r\n\r\ninline double real() const  \r\n// Access the FieldData as a double. The FieldData must be of FLOAT or DOUBLE types.\r\n// 将FieldData作为双精度浮点数访问。FieldData必须是FLOAT或DOUBLE类型。\r\n\r\n// 抛出  \r\nstd::bad_cast – Thrown if the FieldData is not of FLOAT or DOUBLE types.\r\n// 抛出std::bad_cast – 如果FieldData不是FLOAT或DOUBLE类型，则抛出此异常。\r\n\r\n// 返回  \r\nA double.\r\n// 返回一个双精度浮点数。\r\n\r\ninline const std::string &string() const\n\n该段落位于文档的 `FieldData` 类部分，主要描述了 `FieldData` 的移动构造函数、拷贝赋值运算符、移动赋值运算符，以及如何以特定类型（如整数和浮点数）访问 `FieldData` 的值。阐述了使用这些方法的条件及可能抛出的异常。"
            },
            {
                "content": "// 当FieldData不是整数类型时抛出。\r\n\r\n返回  \r\nAn int64_t.  \r\n// 一个int64_t。\r\n\r\ninline double real() const  \r\n// Access the FieldData as a double. The FieldData must be of FLOAT or DOUBLE types.\r\n// 将FieldData作为双精度浮点数访问。FieldData必须是FLOAT或DOUBLE类型。\r\n\r\n// 抛出  \r\nstd::bad_cast – Thrown if the FieldData is not of FLOAT or DOUBLE types.\r\n// 抛出std::bad_cast – 如果FieldData不是FLOAT或DOUBLE类型，则抛出此异常。\r\n\r\n// 返回  \r\nA double.\r\n// 返回一个双精度浮点数。\r\n\r\ninline const std::string &string() const  \r\n// Access the FieldData as std::string. Valid only for STRING, BLOB and SPATIAL. BLOB data is returned as-is, since std::string can also hold byte array.\r\n// 将FieldData作为std::string访问。仅适用于STRING、BLOB和SPATIAL。BLOB数据原样返回，因为std::string也可以保存字节数组。\r\n\r\n// 抛出  \r\nstd::bad_cast – Thrown when a bad cast error condition occurs.\r\n// 抛出std::bad_cast – 当发生错误转换时抛出此异常。\r\n\r\n// 返回  \r\nA reference to a const std::string.\r\n// 返回对const std::string的引用。\r\n\r\ninline bool AsBool() const  \r\n// Convert FieldData to bool.\r\n// 将FieldData转换为布尔值。\r\n\r\ninline int8_t AsInt8() const\n\n该文本片段位于文档的有关 `FieldData` 类的部分，该类用于表示多种类型的字段值。在这部分中，描述了如何访问 `FieldData` 的不同数据类型，包括整数、浮点数和字符串，并说明了在尝试将 `FieldData` 转换为特定类型时可能抛出的异常。这些信息对于理解数据类型处理及其对应的错误处理机制至关重要。"
            },
            {
                "content": "// 将FieldData作为std::string访问。仅适用于STRING、BLOB和SPATIAL。BLOB数据原样返回，因为std::string也可以保存字节数组。\r\n\r\n// 抛出  \r\nstd::bad_cast – Thrown when a bad cast error condition occurs.\r\n// 抛出std::bad_cast – 当发生错误转换时抛出此异常。\r\n\r\n// 返回  \r\nA reference to a const std::string.\r\n// 返回对const std::string的引用。\r\n\r\ninline bool AsBool() const  \r\n// Convert FieldData to bool.\r\n// 将FieldData转换为布尔值。\r\n\r\ninline int8_t AsInt8() const  \r\n// Convert FieldData to INT8.\r\n// 将FieldData转换为INT8。\r\n\r\ninline int16_t AsInt16() const  \r\n// Convert FieldData to INT16.\r\n// 将FieldData转换为INT16。\r\n\r\ninline int32_t AsInt32() const  \r\n// Convert FieldData to INT32.\r\n// 将FieldData转换为INT32。\r\n\r\ninline int64_t AsInt64() const  \r\n// Convert FieldData to INT64.\r\n// 将FieldData转换为INT64。\r\n\r\ninline float AsFloat() const  \r\n// Convert FieldData to float.\r\n// 将FieldData转换为浮点数。\r\n\r\ninline double AsDouble() const  \r\n// Convert FieldData to double.\r\n// 将FieldData转换为双精度浮点数。\r\n\r\ninline inline ::lgraph_api::Date AsDate () const  \r\n// Convert FieldData to Date.\r\n// 将FieldData转换为日期。\n\n该段落位于文档的 `lgraph_types` 部分，具体描述了 `FieldData` 类中的方法和属性，用于将字段数据转换为各种类型，包括布尔值、整数、浮点数和日期等，旨在帮助用户理解如何从 `FieldData` 中获取不同格式的数据。"
            },
            {
                "content": "// 将FieldData转换为INT16。\r\n\r\ninline int32_t AsInt32() const  \r\n// Convert FieldData to INT32.\r\n// 将FieldData转换为INT32。\r\n\r\ninline int64_t AsInt64() const  \r\n// Convert FieldData to INT64.\r\n// 将FieldData转换为INT64。\r\n\r\ninline float AsFloat() const  \r\n// Convert FieldData to float.\r\n// 将FieldData转换为浮点数。\r\n\r\ninline double AsDouble() const  \r\n// Convert FieldData to double.\r\n// 将FieldData转换为双精度浮点数。\r\n\r\ninline inline ::lgraph_api::Date AsDate () const  \r\n// Convert FieldData to Date.\r\n// 将FieldData转换为日期。\r\n\r\ninline inline ::lgraph_api::DateTime AsDateTime () const  \r\n// Convert FieldData to DateTime.\r\n// 将FieldData转换为日期时间。\r\n\r\ninline std::string AsString() const  \r\n// Convert FieldData to std::string.\r\n// 将FieldData转换为std::string。\r\n\r\ninline std::string AsBlob() const  \r\n// Convert FieldData to BLOB.\r\n// 将FieldData转换为BLOB。\r\n\r\ninline std::string AsBase64Blob() const  \r\n// Convert FieldData to Base64 BLOB.\r\n// 将FieldData转换为Base64 BLOB。\r\n\r\ninline inline ::lgraph_api::SRID GetSRID () const  \r\n// Get the SRID from the FieldData.\n\n该代码块位于文档的 `lgraph_types` 部分，具体是在 `FieldData` 结构体中，描述了如何将 `FieldData` 转换为不同的数据类型，包括 INT16、INT32、INT64、浮点数、双精度浮点数、日期、日期时间、字符串、BLOB 和 Base64 BLOB。"
            },
            {
                "content": "// Convert FieldData to DateTime.\r\n// 将FieldData转换为日期时间。\r\n\r\ninline std::string AsString() const  \r\n// Convert FieldData to std::string.\r\n// 将FieldData转换为std::string。\r\n\r\ninline std::string AsBlob() const  \r\n// Convert FieldData to BLOB.\r\n// 将FieldData转换为BLOB。\r\n\r\ninline std::string AsBase64Blob() const  \r\n// Convert FieldData to Base64 BLOB.\r\n// 将FieldData转换为Base64 BLOB。\r\n\r\ninline inline ::lgraph_api::SRID GetSRID () const  \r\n// Get the SRID from the FieldData.\r\n// 从FieldData中获取SRID。\r\n\r\ninline inline ::lgraph_api::Point<::lgraph_api::Wgs84 > AsWgsPoint () const  \r\n// Convert FieldData to WGS84 Point.\r\n// 将FieldData转换为WGS84坐标点。\r\n\r\ninline inline ::lgraph_api::Point<::lgraph_api::Cartesian > AsCartesianPoint () const  \r\n// Convert FieldData to Cartesian Point.\r\n// 将FieldData转换为笛卡尔坐标点。\r\n\r\ninline inline ::lgraph_api::LineString<::lgraph_api::Wgs84 > AsWgsLineString () const  \r\n// Convert FieldData to WGS84 LineString.\r\n// 将FieldData转换为WGS84线串。\n\n该文本块位于文档的 `lgraph_types` 部分，具体描述了 `FieldData` 类的公共函数，包括如何将 `FieldData` 类型转换为多种数据格式，如日期时间、字符串、BLOB 及其各自的 WGS84 和笛卡尔坐标点等。此部分为用户提供了处理和转换图数据字段的接口和功能。"
            },
            {
                "content": "// 从FieldData中获取SRID。\r\n\r\ninline inline ::lgraph_api::Point<::lgraph_api::Wgs84 > AsWgsPoint () const  \r\n// Convert FieldData to WGS84 Point.\r\n// 将FieldData转换为WGS84坐标点。\r\n\r\ninline inline ::lgraph_api::Point<::lgraph_api::Cartesian > AsCartesianPoint () const  \r\n// Convert FieldData to Cartesian Point.\r\n// 将FieldData转换为笛卡尔坐标点。\r\n\r\ninline inline ::lgraph_api::LineString<::lgraph_api::Wgs84 > AsWgsLineString () const  \r\n// Convert FieldData to WGS84 LineString.\r\n// 将FieldData转换为WGS84线串。\r\n\r\ninline inline ::lgraph_api::LineString<::lgraph_api::Cartesian > AsCartesianLineString () const  \r\n// Convert FieldData to Cartesian LineString.\r\n// 将FieldData转换为笛卡尔线串。\r\n\r\ninline inline ::lgraph_api::Polygon<::lgraph_api::Wgs84 > AsWgsPolygon () const  \r\n// Convert FieldData to WGS84 Polygon.\r\n// 将FieldData转换为WGS84多边形。\r\n\r\ninline inline ::lgraph_api::Polygon<::lgraph_api::Cartesian > AsCartesianPolygon () const  \r\n// Convert FieldData to Cartesian Polygon.\r\n// 将FieldData转换为笛卡尔多边形。\n\n该片段位于文档中关于`FieldData`类的部分，主要描述了如何将`FieldData`转换为不同类型的空间数据（如WGS84坐标系和笛卡尔坐标系的点、线串和多边形）的具体实现方法。此部分强调了数据转换功能，是与地理信息数据处理相关的重要内容。"
            },
            {
                "content": "inline inline ::lgraph_api::LineString<::lgraph_api::Cartesian > AsCartesianLineString () const  \r\n// Convert FieldData to Cartesian LineString.\r\n// 将FieldData转换为笛卡尔线串。\r\n\r\ninline inline ::lgraph_api::Polygon<::lgraph_api::Wgs84 > AsWgsPolygon () const  \r\n// Convert FieldData to WGS84 Polygon.\r\n// 将FieldData转换为WGS84多边形。\r\n\r\ninline inline ::lgraph_api::Polygon<::lgraph_api::Cartesian > AsCartesianPolygon () const  \r\n// Convert FieldData to Cartesian Polygon.\r\n// 将FieldData转换为笛卡尔多边形。\r\n\r\ninline inline ::lgraph_api::Spatial<::lgraph_api::Wgs84 > AsWgsSpatial () const  \r\n// Convert FieldData to WGS84 Spatial data.\r\n// 将FieldData转换为WGS84空间数据。\r\n\r\ninline inline ::lgraph_api::Spatial<::lgraph_api::Cartesian > AsCartesianSpatial () const  \r\n// Convert FieldData to Cartesian Spatial data.\r\n// 将FieldData转换为笛卡尔空间数据。\r\n\r\ninline std::vector AsFloatVector() const  \r\n// Convert FieldData to a vector of floats.\r\n// 将FieldData转换为浮点数向量。\r\n\r\nstd::any ToBolt() const  \r\n// Convert FieldData to a Bolt representation.\n\n该代码块位于文档的 `lgraph_types` 部分，其中定义了 `FieldData` 结构的成员函数。这些函数主要用于将 `FieldData` 对象转换为不同的几何类型，如笛卡尔线串、WGS84多边形、笛卡尔多边形、WGS84空间数据、笛卡尔空间数据以及浮点向量，提供了对图形数据的灵活处理和访问功能。"
            },
            {
                "content": "// Convert FieldData to WGS84 Spatial data.\r\n// 将FieldData转换为WGS84空间数据。\r\n\r\ninline inline ::lgraph_api::Spatial<::lgraph_api::Cartesian > AsCartesianSpatial () const  \r\n// Convert FieldData to Cartesian Spatial data.\r\n// 将FieldData转换为笛卡尔空间数据。\r\n\r\ninline std::vector AsFloatVector() const  \r\n// Convert FieldData to a vector of floats.\r\n// 将FieldData转换为浮点数向量。\r\n\r\nstd::any ToBolt() const  \r\n// Convert FieldData to a Bolt representation.\r\n// 将FieldData转换为Bolt表示。\r\n\r\ninline std::string ToString(const std::string &null_value = \"NUL\") const  \r\n// Get string representation of this FieldData.\r\n// 获取此FieldData的字符串表示。\r\n\r\ninline bool operator==(const FieldData &rhs) const  \r\n// Check for equality between two FieldData objects.\r\n// 检查两个FieldData对象是否相等。\r\n\r\ninline bool operator!=(const FieldData &rhs) const  \r\n// Check for inequality between two FieldData objects.\r\n// 检查两个FieldData对象是否不相等。\r\n\r\ninline bool operator>(const FieldData &rhs) const  \r\n// Compare if this FieldData is greater than another FieldData.\n\n该块内容位于文档的“lgraph_types”部分，主要讨论`FieldData`类的各种方法，包括类型转换、比较操作符的重载以及生成字符串表示。这些方法允许用户处理图数据中的空间数据和字段数据，用于图数据库的操作和查询。"
            },
            {
                "content": "// Get string representation of this FieldData.\r\n// 获取此FieldData的字符串表示。\r\n\r\ninline bool operator==(const FieldData &rhs) const  \r\n// Check for equality between two FieldData objects.\r\n// 检查两个FieldData对象是否相等。\r\n\r\ninline bool operator!=(const FieldData &rhs) const  \r\n// Check for inequality between two FieldData objects.\r\n// 检查两个FieldData对象是否不相等。\r\n\r\ninline bool operator>(const FieldData &rhs) const  \r\n// Compare if this FieldData is greater than another FieldData.\r\n// 比较此FieldData是否大于另一个FieldData。\r\n\r\ninline bool operator>=(const FieldData &rhs) const  \r\n// Compare if this FieldData is greater than or equal to another FieldData.\r\n// 比较此FieldData是否大于或等于另一个FieldData。\r\n\r\ninline bool operator<(const FieldData &rhs) const  \r\n// Compare if this FieldData is less than another FieldData.\r\n// 比较此FieldData是否小于另一个FieldData。\r\n\r\ninline bool operator<=(const FieldData &rhs) const  \r\n// Compare if this FieldData is less than or equal to another FieldData.\r\n// 比较此FieldData是否小于或等于另一个FieldData。\n\n该段落位于文档的 \"lgraph_types\" 部分，定义了 `FieldData` 结构的比较运算符，包括相等、不相等、大于、大于等于、小于和小于等于的操作。这些运算符允许对 `FieldData` 对象进行直接比较，方便在处理图数据库中的字段数据时进行逻辑判断和排序操作。"
            },
            {
                "content": "inline bool operator>=(const FieldData &rhs) const  \r\n// Compare if this FieldData is greater than or equal to another FieldData.\r\n// 比较此FieldData是否大于或等于另一个FieldData。\r\n\r\ninline bool operator<(const FieldData &rhs) const  \r\n// Compare if this FieldData is less than another FieldData.\r\n// 比较此FieldData是否小于另一个FieldData。\r\n\r\ninline bool operator<=(const FieldData &rhs) const  \r\n// Compare if this FieldData is less than or equal to another FieldData.\r\n// 比较此FieldData是否小于或等于另一个FieldData。\r\n\r\ninline FieldType GetType() const  \r\n// Get the type of the FieldData.\r\n// 获取FieldData的类型。\r\n\r\ninline bool is_null() const  \r\n// Check if this FieldData is null.\r\n// 检查此FieldData是否为空。\r\n\r\ninline bool is_buf() const  \r\n// Check if this FieldData is a buffer type.\r\n// 检查此FieldData是否为缓冲区类型。\r\n\r\ninline bool is_empty_buf() const  \r\n// Check if this FieldData is an empty buffer.\r\n// 检查此FieldData是否为空缓冲区。\r\n\r\ninline bool IsNull() const  \r\n// Query if this object is null.\r\n// 查询此对象是否为空。\r\n\r\ninline bool IsBool() const\n\n该代码块位于文档的类型定义部分，主要定义了 `FieldData` 类的比较运算符和一些方法，包括获取类型、检查空值和缓冲区类型等。此类用于表示图数据库中字段的变体类型，并支持多种基本操作。"
            },
            {
                "content": "inline FieldType GetType() const  \r\n// Get the type of the FieldData.\r\n// 获取FieldData的类型。\r\n\r\ninline bool is_null() const  \r\n// Check if this FieldData is null.\r\n// 检查此FieldData是否为空。\r\n\r\ninline bool is_buf() const  \r\n// Check if this FieldData is a buffer type.\r\n// 检查此FieldData是否为缓冲区类型。\r\n\r\ninline bool is_empty_buf() const  \r\n// Check if this FieldData is an empty buffer.\r\n// 检查此FieldData是否为空缓冲区。\r\n\r\ninline bool IsNull() const  \r\n// Query if this object is null.\r\n// 查询此对象是否为空。\r\n\r\ninline bool IsBool() const  \r\n// Query if this object is bool.\r\n// 查询此对象是否为布尔值。\r\n\r\ninline bool IsBlob() const  \r\n// Query if this object is BLOB.\r\n// 查询此对象是否为BLOB。\r\n\r\ninline bool IsString() const  \r\n// Query if this object is string.\r\n// 查询此对象是否为字符串。\r\n\r\ninline bool IsInt8() const  \r\n// Query if this object is INT8.\r\n// 查询此对象是否为INT8。\r\n\r\ninline bool IsInt16() const  \r\n// Query if this object is INT16.\r\n// 查询此对象是否为INT16。\r\n\r\ninline bool IsInt32() const  \r\n// Query if this object is INT32.\r\n// 查询此对象是否为INT32。\r\n\r\ninline bool IsInt64() const\n\n该代码块位于文档的 `lgraph_types` 章节中，重点介绍了 `FieldData` 类的成员函数，用于查询和检查字段数据的类型和状态，包括是否为空、是否为缓冲区类型以及具体的数值类型检测（如布尔值、整型等）。这些函数为用户提供了对字段数据的详细检查和处理能力。"
            },
            {
                "content": "// 查询此对象是否为布尔值。\r\n\r\ninline bool IsBlob() const  \r\n// Query if this object is BLOB.\r\n// 查询此对象是否为BLOB。\r\n\r\ninline bool IsString() const  \r\n// Query if this object is string.\r\n// 查询此对象是否为字符串。\r\n\r\ninline bool IsInt8() const  \r\n// Query if this object is INT8.\r\n// 查询此对象是否为INT8。\r\n\r\ninline bool IsInt16() const  \r\n// Query if this object is INT16.\r\n// 查询此对象是否为INT16。\r\n\r\ninline bool IsInt32() const  \r\n// Query if this object is INT32.\r\n// 查询此对象是否为INT32。\r\n\r\ninline bool IsInt64() const  \r\n// Query if this object is INT64.\r\n// 查询此对象是否为INT64。\r\n\r\ninline bool IsInteger() const  \r\n// Is this a INT8, INT16, INT32 or INT64?\r\n// 这是否为INT8、INT16、INT32或INT64？\r\n\r\ninline bool IsFloat() const  \r\n// Query if this object is float.\r\n// 查询此对象是否为浮点数。\r\n\r\ninline bool IsDouble() const  \r\n// Query if this object is double.\r\n// 查询此对象是否为双精度浮点数。\r\n\r\ninline bool IsReal() const  \r\n// Is this a FLOAT or DOUBLE?\r\n// 这是否为FLOAT或DOUBLE？\r\n\r\ninline bool IsDate() const  \r\n// Query if this object is date.\r\n// 查询此对象是否为日期。\r\n\r\ninline bool IsDateTime() const\n\n该代码块位于文档中关于数据类型判断的部分，主要涉及`FieldData`类的方法，用于查询该对象是否为不同的数据类型，如布尔值、字符串、整数、浮点数等。这些查询函数对于在执行图数据库操作时检查字段数据的类型非常重要。"
            },
            {
                "content": "// 查询此对象是否为INT64。\r\n\r\ninline bool IsInteger() const  \r\n// Is this a INT8, INT16, INT32 or INT64?\r\n// 这是否为INT8、INT16、INT32或INT64？\r\n\r\ninline bool IsFloat() const  \r\n// Query if this object is float.\r\n// 查询此对象是否为浮点数。\r\n\r\ninline bool IsDouble() const  \r\n// Query if this object is double.\r\n// 查询此对象是否为双精度浮点数。\r\n\r\ninline bool IsReal() const  \r\n// Is this a FLOAT or DOUBLE?\r\n// 这是否为FLOAT或DOUBLE？\r\n\r\ninline bool IsDate() const  \r\n// Query if this object is date.\r\n// 查询此对象是否为日期。\r\n\r\ninline bool IsDateTime() const  \r\n// Query if this object is date time.\r\n// 查询此对象是否为日期时间。\r\n\r\ninline bool IsPoint() const  \r\n// Query if this object is Point.\r\n// 查询此对象是否为点。\r\n\r\ninline bool IsLineString() const  \r\n// Query if this object is LineString.\r\n// 查询此对象是否为线串。\r\n\r\ninline bool IsPolygon() const  \r\n// Query if this object is Polygon.\r\n// 查询此对象是否为多边形。\r\n\r\ninline bool IsSpatial() const  \r\n// Query if this object is spatial.\r\n// 查询此对象是否为空间数据。\r\n\r\ninline bool IsFloatVector() const  \r\n// Query if this object is float vector.\r\n// 查询此对象是否为浮点数向量。\n\n该文本块位于文档中的 `FieldData` 结构部分，主要描述了如何检查和识别不同数据类型的方法，包括整数、浮点数、日期和空间数据等。这些方法用于处理和操作图数据库中字段的数据类型，从而为用户定义的程序和插件提供支持。"
            },
            {
                "content": "// 查询此对象是否为日期时间。\r\n\r\ninline bool IsPoint() const  \r\n// Query if this object is Point.\r\n// 查询此对象是否为点。\r\n\r\ninline bool IsLineString() const  \r\n// Query if this object is LineString.\r\n// 查询此对象是否为线串。\r\n\r\ninline bool IsPolygon() const  \r\n// Query if this object is Polygon.\r\n// 查询此对象是否为多边形。\r\n\r\ninline bool IsSpatial() const  \r\n// Query if this object is spatial.\r\n// 查询此对象是否为空间数据。\r\n\r\ninline bool IsFloatVector() const  \r\n// Query if this object is float vector.\r\n// 查询此对象是否为浮点数向量。\r\n\r\n#### Public Members\r\n\r\n- FieldType type  \r\n// The type of the FieldData.  \r\n// FieldData的类型。\r\n\r\n- bool boolean  \r\n// Boolean value of the FieldData.  \r\n// FieldData的布尔值。\r\n\r\n- int8_t int8  \r\n// INT8 value of the FieldData.  \r\n// FieldData的INT8值。\r\n\r\n- int16_t int16  \r\n// INT16 value of the FieldData.  \r\n// FieldData的INT16值。\r\n\r\n- int32_t int32  \r\n// INT32 value of the FieldData.  \r\n// FieldData的INT32值。\r\n\r\n- int64_t int64  \r\n// INT64 value of the FieldData.  \r\n// FieldData的INT64值。\r\n\r\n- float sp  \r\n// FLOAT value of the FieldData.\n\n该代码块位于关于`FieldData`类的部分中，该类用于表示不同类型的数据，包括布尔值、整数、浮点数、日期、空间数据等。块中的方法和成员变量涉及到各种数据类型的检查和访问，帮助用户获取`FieldData`对象的具体类型和相关值。在整个文档中，这部分主要讨论数据类型及其操作，属于对图数据库中数据存储和处理的重要内容。"
            },
            {
                "content": "- FieldType type  \r\n// The type of the FieldData.  \r\n// FieldData的类型。\r\n\r\n- bool boolean  \r\n// Boolean value of the FieldData.  \r\n// FieldData的布尔值。\r\n\r\n- int8_t int8  \r\n// INT8 value of the FieldData.  \r\n// FieldData的INT8值。\r\n\r\n- int16_t int16  \r\n// INT16 value of the FieldData.  \r\n// FieldData的INT16值。\r\n\r\n- int32_t int32  \r\n// INT32 value of the FieldData.  \r\n// FieldData的INT32值。\r\n\r\n- int64_t int64  \r\n// INT64 value of the FieldData.  \r\n// FieldData的INT64值。\r\n\r\n- float sp  \r\n// FLOAT value of the FieldData.  \r\n// FieldData的FLOAT值。\r\n\r\n- double dp  \r\n// DOUBLE value of the FieldData.  \r\n// FieldData的DOUBLE值。\r\n\r\n- std::string *buf  \r\n// Buffer of the FieldData.  \r\n// FieldData的缓冲区。\r\n\r\n- std::vector *vp  \r\n// Vector of floats in the FieldData.  \r\n// FieldData中的浮点数向量。\r\n\r\n- union lgraph_api::FieldData::[anonymous] data  \r\n// Anonymous union to hold different types of data.\r\n// 匿名联合用于存放不同类型的数据。\r\n\r\n#### Public Static Functions\r\n\r\nstatic inline FieldData Bool(bool b)  // 创建一个布尔值的字段数据\n\n该代码块位于文档的“lgraph_types”部分，定义了`FieldData`类的成员变量和公共静态函数。这些变量表示不同数据类型的值，包括布尔值、整数、浮点数和字符串，以及一个匿名联合体用于存储多种类型的数据。该部分的目的是提供用于图数据存储和操作的具体数据类型定义。"
            },
            {
                "content": "// FLOAT value of the FieldData.  \r\n// FieldData的FLOAT值。\r\n\r\n- double dp  \r\n// DOUBLE value of the FieldData.  \r\n// FieldData的DOUBLE值。\r\n\r\n- std::string *buf  \r\n// Buffer of the FieldData.  \r\n// FieldData的缓冲区。\r\n\r\n- std::vector *vp  \r\n// Vector of floats in the FieldData.  \r\n// FieldData中的浮点数向量。\r\n\r\n- union lgraph_api::FieldData::[anonymous] data  \r\n// Anonymous union to hold different types of data.\r\n// 匿名联合用于存放不同类型的数据。\r\n\r\n#### Public Static Functions\r\n\r\nstatic inline FieldData Bool(bool b)  // 创建一个布尔值的字段数据\r\nstatic inline FieldData Int8(int8_t i)  // 创建一个8位整数的字段数据\r\nstatic inline FieldData Int16(int16_t i)  // 创建一个16位整数的字段数据\r\nstatic inline FieldData Int32(int32_t i)  // 创建一个32位整数的字段数据\r\nstatic inline FieldData Int64(int64_t i)  // 创建一个64位整数的字段数据\r\nstatic inline FieldData Float(float d)  // 创建一个浮点数的字段数据\r\nstatic inline FieldData Double(double d)  // 创建一个双精度浮点数的字段数据\r\nstatic inline FieldData Date(const std::string &str)  // 创建一个日期的字段数据，从字符串转换\n\n该块内容位于文档的 `lgraph_types` 部分，具体描述了 `FieldData` 类的实现，包括存储不同数据类型（如 FLOAT 和 DOUBLE）所需的变量及其构造函数。这个部分用于定义在图数据库中字段的数据类型及其相关操作。"
            },
            {
                "content": "static inline FieldData Bool(bool b)  // 创建一个布尔值的字段数据\r\nstatic inline FieldData Int8(int8_t i)  // 创建一个8位整数的字段数据\r\nstatic inline FieldData Int16(int16_t i)  // 创建一个16位整数的字段数据\r\nstatic inline FieldData Int32(int32_t i)  // 创建一个32位整数的字段数据\r\nstatic inline FieldData Int64(int64_t i)  // 创建一个64位整数的字段数据\r\nstatic inline FieldData Float(float d)  // 创建一个浮点数的字段数据\r\nstatic inline FieldData Double(double d)  // 创建一个双精度浮点数的字段数据\r\nstatic inline FieldData Date(const std::string &str)  // 创建一个日期的字段数据，从字符串转换\r\nstatic inline FieldData Date(const ::lgraph_api::Date &d)  // 创建一个日期的字段数据，从日期对象转换\r\nstatic inline FieldData DateTime(const std::string &str)  // 创建一个日期时间的字段数据，从字符串转换\r\nstatic inline FieldData DateTime(const ::lgraph_api::DateTime &d)  // 创建一个日期时间的字段数据，从日期时间对象转换\r\nstatic inline FieldData String(const std::string &str)  // 创建一个字符串的字段数据\r\nstatic inline FieldData String(std::string &&str)  // 创建一个字符串的字段数据，从右值引用\r\nstatic inline FieldData String(const char *str)  // 创建一个字符串的字段数据，从C风格字符串\n\n在文档的“lgraph_types”部分中，定义了一系列用于创建不同类型字段数据的静态内联函数。这些函数包括布尔值、整数（8位、16位、32位和64位）、浮点数、双精度浮点数、日期和日期时间等类型的字段数据。这些字段数据的创建函数为用户提供了在构建图数据库时初始化不同数据类型的便捷方式。"
            },
            {
                "content": "static inline FieldData Date(const ::lgraph_api::Date &d)  // 创建一个日期的字段数据，从日期对象转换\r\nstatic inline FieldData DateTime(const std::string &str)  // 创建一个日期时间的字段数据，从字符串转换\r\nstatic inline FieldData DateTime(const ::lgraph_api::DateTime &d)  // 创建一个日期时间的字段数据，从日期时间对象转换\r\nstatic inline FieldData String(const std::string &str)  // 创建一个字符串的字段数据\r\nstatic inline FieldData String(std::string &&str)  // 创建一个字符串的字段数据，从右值引用\r\nstatic inline FieldData String(const char *str)  // 创建一个字符串的字段数据，从C风格字符串\r\nstatic inline FieldData String(const char *p, size_t s)  // 创建一个字符串的字段数据，从C风格字符串及其大小\r\nstatic inline FieldData Point(const ::lgraph_api::Point &p)  // 创建一个笛卡尔坐标点的字段数据\r\nstatic inline FieldData Point(const ::lgraph_api::Point &p)  // 创建一个WGS84坐标点的字段数据\r\nstatic inline FieldData Point(const std::string &str)  // 创建一个点的字段数据，从字符串转换\r\nstatic inline FieldData LineString(const ::lgraph_api::LineString &l)  // 创建一个笛卡尔坐标线串的字段数据\r\nstatic inline FieldData LineString(const ::lgraph_api::LineString &l)  // 创建一个WGS84坐标线串的字段数据\n\n该代码块定义了多个静态内联函数，这些函数用于从不同的数据类型（如日期、日期时间、字符串和几何对象）构建 `FieldData` 实例，`FieldData` 是一个用于表示多种数据类型的变体类。这些函数在 `lgraph_types` 命名空间下定义，旨在支持图数据库中字段的数据处理和转换。"
            },
            {
                "content": "static inline FieldData Point(const ::lgraph_api::Point &p)  // 创建一个笛卡尔坐标点的字段数据\r\nstatic inline FieldData Point(const ::lgraph_api::Point &p)  // 创建一个WGS84坐标点的字段数据\r\nstatic inline FieldData Point(const std::string &str)  // 创建一个点的字段数据，从字符串转换\r\nstatic inline FieldData LineString(const ::lgraph_api::LineString &l)  // 创建一个笛卡尔坐标线串的字段数据\r\nstatic inline FieldData LineString(const ::lgraph_api::LineString &l)  // 创建一个WGS84坐标线串的字段数据\r\nstatic inline FieldData LineString(const std::string &str)  // 创建一个线串的字段数据，从字符串转换\r\nstatic inline FieldData Polygon(const ::lgraph_api::Polygon &p)  // 创建一个笛卡尔坐标多边形的字段数据\r\nstatic inline FieldData Polygon(const ::lgraph_api::Polygon &p)  // 创建一个WGS84坐标多边形的字段数据\r\nstatic inline FieldData Polygon(const std::string &str)  // 创建一个多边形的字段数据，从字符串转换\r\nstatic inline FieldData Spatial(const ::lgraph_api::Spatial &s)  // 创建一个笛卡尔坐标空间数据的字段数据\r\nstatic inline FieldData Spatial(const ::lgraph_api::Spatial &s)  // 创建一个WGS84坐标空间数据的字段数据\n\n该代码段属于TuGraph的类型定义部分，涉及创建不同空间数据类型（如点、线串和多边形）的字段数据的函数。这些函数用于将笛卡尔坐标和WGS84坐标转换为字段数据格式，以便在图数据库中进行存储和处理。"
            },
            {
                "content": "static inline FieldData Polygon(const ::lgraph_api::Polygon &p)  // 创建一个笛卡尔坐标多边形的字段数据\r\nstatic inline FieldData Polygon(const ::lgraph_api::Polygon &p)  // 创建一个WGS84坐标多边形的字段数据\r\nstatic inline FieldData Polygon(const std::string &str)  // 创建一个多边形的字段数据，从字符串转换\r\nstatic inline FieldData Spatial(const ::lgraph_api::Spatial &s)  // 创建一个笛卡尔坐标空间数据的字段数据\r\nstatic inline FieldData Spatial(const ::lgraph_api::Spatial &s)  // 创建一个WGS84坐标空间数据的字段数据\r\nstatic inline FieldData Spatial(const std::string &str)  // 创建一个空间数据的字段数据，从字符串转换\r\nstatic inline FieldData FloatVector(const std::vector &fv)  // 创建一个浮点向量的字段数据\r\nstatic inline FieldData Blob(const std::string &str)  // 从字符串构建BLOB字段数据\r\nstatic inline FieldData Blob(std::string &&str)  // 从右值引用字符串构建BLOB字段数据\r\nstatic inline FieldData Blob(const std::vector &str)  // 从uint8_t的向量构建BLOB字段数据, 将其视为字节数组。\r\nConstructs a Blob from vector of uint8_t, treated as byte array.\r\n\r\nstatic inline FieldData BlobFromBase64(const std::string &base64_encoded)  // 从Base64编码的字符串构建BLOB字段数据\n\n该文本块位于文档中关于 `FieldData` 类的定义部分，具体介绍了如何创建不同类型的字段数据，包括多边形、空间数据、浮点向量和 BLOB 数据。它详细描述了通过多边形、空间和 BLOB 数据的构造函数来初始化字段数据的各种方法。这部分内容对于理解如何在图数据库中处理和存储空间数据以及与图形对象相关的字段数据非常重要。"
            },
            {
                "content": "static inline FieldData FloatVector(const std::vector &fv)  // 创建一个浮点向量的字段数据\r\nstatic inline FieldData Blob(const std::string &str)  // 从字符串构建BLOB字段数据\r\nstatic inline FieldData Blob(std::string &&str)  // 从右值引用字符串构建BLOB字段数据\r\nstatic inline FieldData Blob(const std::vector &str)  // 从uint8_t的向量构建BLOB字段数据, 将其视为字节数组。\r\nConstructs a Blob from vector of uint8_t, treated as byte array.\r\n\r\nstatic inline FieldData BlobFromBase64(const std::string &base64_encoded)  // 从Base64编码的字符串构建BLOB字段数据\r\nConstructs a BLOB from Base64 encoded string.\r\n\r\n#### Private Static Functions\r\n\r\nstatic inline bool IsBufType(FieldType t)  // 查询“t”是否为BLOB或STRING类型\r\nQuery if ‘t’ is BLOB or STRING\r\n\r\nstatic inline bool IsInteger(FieldType t)  // 查询“t”是否为INT8, 16, 32或者64类型\r\nQuery if ‘t’ is INT8, 16, 32, or 64\r\n\r\nstatic inline bool IsReal(FieldType t)  // 查询“t”是否为FLOAT或DOUBLE类型\r\nQuery if ‘t’ is FLLOAT or DOUBLE\r\n\r\n### struct FieldSpec\r\n\r\n#include   // 引入lgraph_types.h文件\r\nSpecification for a field.\r\n\r\n#### Public Functions\n\n该块内容位于文档的类型定义部分，主要涉及GraphDB中的字段数据类型和相关操作，包括创建浮点向量和BLOB字段数据的方法，以及一些辅助函数的定义。这部分内容有助于理解如何在TuGraph数据库中处理不同类型的数据字段。"
            },
            {
                "content": "#### Private Static Functions\r\n\r\nstatic inline bool IsBufType(FieldType t)  // 查询“t”是否为BLOB或STRING类型\r\nQuery if ‘t’ is BLOB or STRING\r\n\r\nstatic inline bool IsInteger(FieldType t)  // 查询“t”是否为INT8, 16, 32或者64类型\r\nQuery if ‘t’ is INT8, 16, 32, or 64\r\n\r\nstatic inline bool IsReal(FieldType t)  // 查询“t”是否为FLOAT或DOUBLE类型\r\nQuery if ‘t’ is FLLOAT or DOUBLE\r\n\r\n### struct FieldSpec\r\n\r\n#include   // 引入lgraph_types.h文件\r\nSpecification for a field.\r\n\r\n#### Public Functions\r\n\r\ninline FieldSpec()  // 默认构造函数\r\ninline FieldSpec(const std::string &n, FieldType t, bool nu)  // 构造函数\r\nConstructor  \r\n\r\n**参数**  \r\nn – Field name  // 字段名称  \r\n\r\nt – Field type  // 字段类型  \r\n\r\nnu – True if field is optional  // 如果字段是可选的则为真  \r\n\r\ninline FieldSpec(std::string &&n, FieldType t, bool nu)  // 从右值引用构造函数\r\ninline bool operator==(const FieldSpec &rhs) const  // 重载相等运算符\r\ninline std::string ToString() const  // 获取FieldSpec的字符串表示\r\nGet the string representation of the FieldSpec.\r\n\r\n#### Public Members\r\n\r\n- std::string name  // 字段的名称\n\n该块内容位于文档的类型定义部分，主要包括关于字段规范（FieldSpec）和辅助函数的静态定义。这些函数用于检查字段数据类型，例如判断是否为BLOB、STRING、整数或浮点数等，属于数据库操作和数据结构的基础定义部分。"
            },
            {
                "content": "inline FieldSpec(const std::string &n, FieldType t, bool nu)  // 构造函数\r\nConstructor  \r\n\r\n**参数**  \r\nn – Field name  // 字段名称  \r\n\r\nt – Field type  // 字段类型  \r\n\r\nnu – True if field is optional  // 如果字段是可选的则为真  \r\n\r\ninline FieldSpec(std::string &&n, FieldType t, bool nu)  // 从右值引用构造函数\r\ninline bool operator==(const FieldSpec &rhs) const  // 重载相等运算符\r\ninline std::string ToString() const  // 获取FieldSpec的字符串表示\r\nGet the string representation of the FieldSpec.\r\n\r\n#### Public Members\r\n\r\n- std::string name  // 字段的名称\r\n  name of the field  \r\n- FieldType type  // 字段的类型\r\n  type of that field  \r\n- bool optional  // 该字段是否可选？\r\n  is this field optional?  \r\n\r\n---\r\n\r\n### struct IndexSpec\r\n\r\n#include   \r\nAn index specifier. // 索引说明符\r\n\r\n#### Public Members\r\n\r\n- std::string label  \r\n  label name  // 标签名称  \r\n- std::string field  \r\n  field name  // 字段名称  \r\n- IndexType type  // 索引类型  \r\n\r\n---\r\n\r\n### struct LabelOptions\r\n\r\n#include   \r\nLabel options, base class, define some common fields and methods // 标签选项，基类，定义一些通用字段和方法\n\n该块内容位于文档的“lgraph_types”部分，主要介绍了字段规格（FieldSpec）及其构造函数、成员变量和相关操作。这些字段用于在图数据库中定义边和顶点的属性，包括索引规范（IndexSpec）和标签选项（LabelOptions），适用于图形的结构和数据管理。"
            },
            {
                "content": "name of the field  \r\n- FieldType type  // 字段的类型\r\n  type of that field  \r\n- bool optional  // 该字段是否可选？\r\n  is this field optional?  \r\n\r\n---\r\n\r\n### struct IndexSpec\r\n\r\n#include   \r\nAn index specifier. // 索引说明符\r\n\r\n#### Public Members\r\n\r\n- std::string label  \r\n  label name  // 标签名称  \r\n- std::string field  \r\n  field name  // 字段名称  \r\n- IndexType type  // 索引类型  \r\n\r\n---\r\n\r\n### struct LabelOptions\r\n\r\n#include   \r\nLabel options, base class, define some common fields and methods // 标签选项，基类，定义一些通用字段和方法\r\n\r\n**Subclassed by** EdgeOptions, VertexOptions // 由 EdgeOptions 和 VertexOptions 继承\r\n\r\n#### Public Functions\r\n\r\nvirtual std::string to_string() const = 0  \r\n// 返回对象的字符串表示形式  \r\nvirtual void clear() = 0  \r\n// 清除对象的状态  \r\ninline virtual ~LabelOptions()  \r\n// 析构函数  \r\n\r\n#### Public Members\r\n\r\n- bool detach_property = false  \r\n// 是否分离属性  \r\n\r\n---\r\n\r\n### struct Parameter\r\n\r\n#include   \r\nThe parameter of procedure/plugin // 过程/插件的参数\r\n\r\n#### Public Members\r\n\r\n- std::string name  \r\n  name of the parameter  // 参数名称  \r\n- int index\n\n该块内容位于文档的“lgraph_types”部分，主要描述了字段类型、索引说明符、标签选项和参数的结构体定义，包括它们的公共成员和函数，用于实现TuGraph图形数据库中字段、索引和标签的相关操作。"
            },
            {
                "content": "#### Public Functions\r\n\r\nvirtual std::string to_string() const = 0  \r\n// 返回对象的字符串表示形式  \r\nvirtual void clear() = 0  \r\n// 清除对象的状态  \r\ninline virtual ~LabelOptions()  \r\n// 析构函数  \r\n\r\n#### Public Members\r\n\r\n- bool detach_property = false  \r\n// 是否分离属性  \r\n\r\n---\r\n\r\n### struct Parameter\r\n\r\n#include   \r\nThe parameter of procedure/plugin // 过程/插件的参数\r\n\r\n#### Public Members\r\n\r\n- std::string name  \r\n  name of the parameter  // 参数名称  \r\n- int index  \r\n  index of the parameter list in which the parameter stay  // 参数在参数列表中的索引  \r\n\r\n---\r\n\r\n### struct RoleInfo\r\n\r\n#include   \r\nInformation about the role. // 角色的信息\r\n\r\n#### Public Members\r\n\r\n- std::string desc  \r\n  description  // 描述  \r\n- std::map graph_access  \r\n  access levels on different graphs  // 在不同图上的访问级别  \r\n- bool disabled = false  \r\n  is this role disabled?  // 此角色是否被禁用?  \r\n\r\n---\r\n\r\n### struct SigSpec\r\n\r\n#include   \r\n\r\n#### Public Members\r\n\r\n- std::vector input_list  \r\n// 输入参数列表  \r\n- std::vector result_list  \r\n  input parameter list  // 输入参数列表  \r\n\r\n---\n\n该内容位于文档中介绍标签选项和参数的部分，主要描述了标签选项的公共函数和成员变量，以及参数和角色信息的结构体。这些结构体的定义是 TuGraph 系统中用户定义过程和插件的重要组成部分，涉及到权限管理和参数设置。"
            },
            {
                "content": "---\r\n\r\n### struct RoleInfo\r\n\r\n#include   \r\nInformation about the role. // 角色的信息\r\n\r\n#### Public Members\r\n\r\n- std::string desc  \r\n  description  // 描述  \r\n- std::map graph_access  \r\n  access levels on different graphs  // 在不同图上的访问级别  \r\n- bool disabled = false  \r\n  is this role disabled?  // 此角色是否被禁用?  \r\n\r\n---\r\n\r\n### struct SigSpec\r\n\r\n#include   \r\n\r\n#### Public Members\r\n\r\n- std::vector input_list  \r\n// 输入参数列表  \r\n- std::vector result_list  \r\n  input parameter list  // 输入参数列表  \r\n\r\n---\r\n\r\n### struct UserInfo\r\n\r\n#include   \r\nInformation about the user. // 用户的信息\r\n\r\n#### Public Members\r\n\r\n- std::string desc  \r\n  description of the user  // 用户的描述  \r\n- std::set roles  \r\n  roles of this user  // 此用户的角色  \r\n- bool disabled = false  \r\n  is this user disabled?  // 此用户是否被禁用?  \r\n- size_t memory_limit  \r\n  memory limit for this user  // 此用户的内存限制  \r\n\r\n---\r\n\r\n### struct VectorIndexSpec\r\n\r\n#include   \r\n\r\n#### Public Members\r\n\r\n- std::string label  \r\n// 标签  \r\n- std::string field  \r\n// 字段  \r\n- std::string index_type  \r\n// 索引类型\n\n该块内容位于文档的类型定义和结构描述部分，主要涉及角色信息、用户信息、参数定义以及向量索引规格等结构的公共成员。这些结构在图数据库和图分析引擎中用于定义用户权限、存储用户相关信息以及管理图形数据的索引。"
            },
            {
                "content": "#include   \r\nInformation about the user. // 用户的信息\r\n\r\n#### Public Members\r\n\r\n- std::string desc  \r\n  description of the user  // 用户的描述  \r\n- std::set roles  \r\n  roles of this user  // 此用户的角色  \r\n- bool disabled = false  \r\n  is this user disabled?  // 此用户是否被禁用?  \r\n- size_t memory_limit  \r\n  memory limit for this user  // 此用户的内存限制  \r\n\r\n---\r\n\r\n### struct VectorIndexSpec\r\n\r\n#include   \r\n\r\n#### Public Members\r\n\r\n- std::string label  \r\n// 标签  \r\n- std::string field  \r\n// 字段  \r\n- std::string index_type  \r\n// 索引类型  \r\n- int dimension  \r\n// 维度  \r\n- std::string distance_type  \r\n// 距离类型  \r\n- int hnsm_m  \r\n// hnsm 的 m 值  \r\n- int hnsm_ef_construction  \r\n// hnsm 的 ef_construction 值  \r\n\r\n---\r\n\r\n### struct VertexOptions : public LabelOptions\r\n\r\n#include   \r\nVertex label options, contain fields only vertex have // 顶点标签选项，仅包含顶点拥有的字段\r\n\r\n#### Public Functions\r\n\r\nVertexOptions() = default  \r\n// 默认构造函数  \r\ninline explicit VertexOptions(const std::string &primary_field)  \r\n// 带有主字段的显式构造函数\n\n该文档详细描述了C++中TuGraph数据库的各种接口和功能，包括存储过程、原子操作、日期时间处理、图数据库操作等。此块内容主要涉及用户信息和顶点选项的结构定义，分别包含用户的角色、描述和内存限制，以及顶点标签的字段选项。"
            },
            {
                "content": "- std::string index_type  \r\n// 索引类型  \r\n- int dimension  \r\n// 维度  \r\n- std::string distance_type  \r\n// 距离类型  \r\n- int hnsm_m  \r\n// hnsm 的 m 值  \r\n- int hnsm_ef_construction  \r\n// hnsm 的 ef_construction 值  \r\n\r\n---\r\n\r\n### struct VertexOptions : public LabelOptions\r\n\r\n#include   \r\nVertex label options, contain fields only vertex have // 顶点标签选项，仅包含顶点拥有的字段\r\n\r\n#### Public Functions\r\n\r\nVertexOptions() = default  \r\n// 默认构造函数  \r\ninline explicit VertexOptions(const std::string &primary_field)  \r\n// 带有主字段的显式构造函数  \r\ninline virtual std::string to_string() const  \r\n// 返回对象的字符串表示形式  \r\ninline virtual void clear()  \r\n// 清除对象的状态  \r\n\r\n#### Public Members\r\n\r\n- std::string primary_field  \r\n// 主字段  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_utils\r\n\r\n### Typedefs\r\n```cpp\r\nusing json = nlohmann::json // 使用 nlohmann::json 作为 json 的类型别名\r\n```\r\n\r\n### Namespace lgraph_api\r\n\r\n### Functions\r\n```cpp\r\ndouble get_time() \r\n```\r\nGet current time.  // 获取当前时间。\r\n\r\n返回  \r\nDigit value of current time.  // 当前时间的数字值。\r\n\r\n```cpp\n\n该块内容位于文档的“lgraph_types”部分，主要介绍与图数据库相关的索引和顶点标签选项，包括索引类型、维度、距离类型以及顶点标签的构造函数和公共成员。此部分为用户在创建和管理图数据库时提供对索引和标签的重要信息。"
            },
            {
                "content": "inline virtual std::string to_string() const  \r\n// 返回对象的字符串表示形式  \r\ninline virtual void clear()  \r\n// 清除对象的状态  \r\n\r\n#### Public Members\r\n\r\n- std::string primary_field  \r\n// 主字段  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_utils\r\n\r\n### Typedefs\r\n```cpp\r\nusing json = nlohmann::json // 使用 nlohmann::json 作为 json 的类型别名\r\n```\r\n\r\n### Namespace lgraph_api\r\n\r\n### Functions\r\n```cpp\r\ndouble get_time() \r\n```\r\nGet current time.  // 获取当前时间。\r\n\r\n返回  \r\nDigit value of current time.  // 当前时间的数字值。\r\n\r\n```cpp\r\nvoid split_string(std::string origin_string, std::vector ⊂_strings, std::string string_delimiter) \r\n```\r\nSplit the original string by format.  //按照某种格式分割原始字符串。\r\n\r\n参数  \r\norigin_string – Original string to be split.  // 原始字符串。  \r\nsub_strings – Split substring.  // 分割后的子字符串。  \r\nstring_delimiter – Split format.  // 分割格式。\r\n\r\n```cpp\r\nstd::string rc4(std::string &input, std::string key, std::string mode) \r\n```\r\nEncrypt the input string in RC4 format.  // 使用 RC4 格式加密输入字符串。\r\n\r\n参数  \r\ninput – Input string.  // 输入字符串。\n\n该块内容位于文档中定义了`LabelOptions`类的部分，主要包含`to_string()`和`clear()`等公共函数的声明以及公共成员`primary_field`的描述，属于TuGraph的标签选项实现。此段落之后文档继续介绍`lgraph_utils`命名空间及其相关函数和类型的定义。"
            },
            {
                "content": "```\r\nSplit the original string by format.  //按照某种格式分割原始字符串。\r\n\r\n参数  \r\norigin_string – Original string to be split.  // 原始字符串。  \r\nsub_strings – Split substring.  // 分割后的子字符串。  \r\nstring_delimiter – Split format.  // 分割格式。\r\n\r\n```cpp\r\nstd::string rc4(std::string &input, std::string key, std::string mode) \r\n```\r\nEncrypt the input string in RC4 format.  // 使用 RC4 格式加密输入字符串。\r\n\r\n参数  \r\ninput – Input string.  // 输入字符串。  \r\nkey – Encryption key.  // 加密密钥。  \r\nmode – Encryption mode.  // 加密模式。\r\n\r\n返回  \r\nEncrypted string.  // 加密后的字符串。\r\n\r\n```cpp\r\nstd::string encode_base64(const std::string input) \r\n```\r\nEncode the input string in Base64 format.  // 将输入字符串编码为 Base64 格式。\r\n\r\n参数  \r\ninput – Input string.  // 输入字符串。\r\n\r\n返回  \r\nEncrypted string.  // 编码后的字符串。\r\n\r\n```cpp\r\nstd::string decode_base64(const std::string input) \r\n```\r\nDecode the input string in Base64 format.  // 将输入字符串解码为 Base64 格式。\r\n\r\n参数  \r\ninput – Input string.  // 输入字符串。\r\n\r\n返回  \r\nDecrypted string.  // 解码后的字符串。\r\n\r\n```cpp\r\nvoid *alloc_buffer(size_t bytes) \r\n```\n\n该chunk位于文档中的lgraph_utils部分，主要介绍了一些实用函数，包括字符串分割、RC4加密、Base64编码与解码，以及内存分配等功能。这些函数用于处理字符串和内存操作，旨在为TuGraph数据库提供便利的工具。"
            },
            {
                "content": "```cpp\r\nstd::string encode_base64(const std::string input) \r\n```\r\nEncode the input string in Base64 format.  // 将输入字符串编码为 Base64 格式。\r\n\r\n参数  \r\ninput – Input string.  // 输入字符串。\r\n\r\n返回  \r\nEncrypted string.  // 编码后的字符串。\r\n\r\n```cpp\r\nstd::string decode_base64(const std::string input) \r\n```\r\nDecode the input string in Base64 format.  // 将输入字符串解码为 Base64 格式。\r\n\r\n参数  \r\ninput – Input string.  // 输入字符串。\r\n\r\n返回  \r\nDecrypted string.  // 解码后的字符串。\r\n\r\n```cpp\r\nvoid *alloc_buffer(size_t bytes) \r\n```\r\nAllocate memory with size in bytes.  // 按字节数分配内存。\r\n\r\n参数  \r\nbytes – Size in bytes of requested memory.  // 请求内存的字节大小。\r\n\r\n返回  \r\nPointer of allocated memory.  // 分配内存的指针。\r\n\r\n```cpp\r\nvoid dealloc_buffer(void *buffer, size_t bytes) \r\n```\r\nFree memory with size in bytes.  // 按字节数释放内存。\r\n\r\n参数  \r\nbuffer – Pointer of memory to free.  // 要释放的内存指针。  \r\nbytes – Size in bytes of requested memory.  // 请求内存的字节大小。\r\n\r\n```cpp\r\ntemplate\r\nvoid parse_from_json(DataType &value, const char *key, json &input) \r\n```\n\n这个代码块位于文档的 `lgraph_utils` 部分，主要涉及Base64编码和内存分配函数的实现。这些函数包括编码和解码字符串的功能，以及动态内存管理的相关函数，如分配和释放内存。该部分为图数据库的操作提供了基础工具，方便用户进行数据转换和内存管理。"
            },
            {
                "content": "```\r\nAllocate memory with size in bytes.  // 按字节数分配内存。\r\n\r\n参数  \r\nbytes – Size in bytes of requested memory.  // 请求内存的字节大小。\r\n\r\n返回  \r\nPointer of allocated memory.  // 分配内存的指针。\r\n\r\n```cpp\r\nvoid dealloc_buffer(void *buffer, size_t bytes) \r\n```\r\nFree memory with size in bytes.  // 按字节数释放内存。\r\n\r\n参数  \r\nbuffer – Pointer of memory to free.  // 要释放的内存指针。  \r\nbytes – Size in bytes of requested memory.  // 请求内存的字节大小。\r\n\r\n```cpp\r\ntemplate\r\nvoid parse_from_json(DataType &value, const char *key, json &input) \r\n```\r\nParse parameter from `nlohmann::json`.  // 从 `nlohmann::json` 中解析参数。\r\n\r\n参数  \r\nvalue – [out] Value to store parameter.  // [输出] 存储参数的值。  \r\nkey – Key of the parameter in the input.  // 输入中参数的键。  \r\ninput – Input JSON.  // 输入的 JSON。\r\n\r\n```cpp\r\ntemplate\r\nvoid parse_from_json(std::vector &value, const char *key, json &input) \r\n```\r\nParse vector parameter from `nlohmann::json`.  // 从 `nlohmann::json` 中解析向量参数。\r\n\r\n参数  \r\nvalue – [out] Value to store parameter.  // [输出] 存储参数的值。\n\n该段落位于文档中的内存管理部分，具体描述了如何分配和释放按字节数计算的内存，以及如何从 `nlohmann::json` 解析参数。这些函数的使用对于确保内存有效利用和数据解析至关重要，适用于处理图数据库中的数据结构和操作。"
            },
            {
                "content": "```\r\nParse parameter from `nlohmann::json`.  // 从 `nlohmann::json` 中解析参数。\r\n\r\n参数  \r\nvalue – [out] Value to store parameter.  // [输出] 存储参数的值。  \r\nkey – Key of the parameter in the input.  // 输入中参数的键。  \r\ninput – Input JSON.  // 输入的 JSON。\r\n\r\n```cpp\r\ntemplate\r\nvoid parse_from_json(std::vector &value, const char *key, json &input) \r\n```\r\nParse vector parameter from `nlohmann::json`.  // 从 `nlohmann::json` 中解析向量参数。\r\n\r\n参数  \r\nvalue – [out] Value to store parameter.  // [输出] 存储参数的值。  \r\nkey – Key of the parameter in the input.  // 输入中参数的键。  \r\ninput – Input JSON.  // 输入的 JSON。\r\n\r\n```cpp\r\nsize_t GetVidFromNodeString(const std::string &node_string) \r\n```\r\nParse vid from the node passed in by Cypher. For V2 procedure.  // 从 Cypher 传入的节点中解析 vid。适用于 V2 过程。\r\n\r\n参数  \r\nnode_string – [in] Node.  // 节点。\r\n\r\n返回  \r\nvid.  // vid。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_vertex_index_iterator\r\n\r\n### Namespace\r\n- `lgraph`\r\n- `lgraph_api`\r\n\r\n### Class VertexIndexIterator\r\n```cpp\r\n#include \r\n```\n\n该块内容位于文档中的“lgraph_utils”部分，主要描述了从 `nlohmann::json` 中解析参数及向量参数的函数及其用法。此外，还提到了解析节点字符串以获取顶点ID的函数。此部分提供了函数的签名、参数及其返回值的详细信息，关联到图数据库操作和数据解析。"
            },
            {
                "content": "key – Key of the parameter in the input.  // 输入中参数的键。  \r\ninput – Input JSON.  // 输入的 JSON。\r\n\r\n```cpp\r\nsize_t GetVidFromNodeString(const std::string &node_string) \r\n```\r\nParse vid from the node passed in by Cypher. For V2 procedure.  // 从 Cypher 传入的节点中解析 vid。适用于 V2 过程。\r\n\r\n参数  \r\nnode_string – [in] Node.  // 节点。\r\n\r\n返回  \r\nvid.  // vid。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_vertex_index_iterator\r\n\r\n### Namespace\r\n- `lgraph`\r\n- `lgraph_api`\r\n\r\n### Class VertexIndexIterator\r\n```cpp\r\n#include \r\n```\r\n`VertexIndexIterator` can be used to access a set of vertices that has the same indexed value. If the index is unique (that is, each vertex has a unique index value), then each `VertexIndexIterator` will only have one `VertexId`, and will become invalid after `Next()` is called.\r\n\r\n`VertexIndexIterator` 可以用于访问具有相同索引值的一组顶点。如果索引是唯一的（即每个顶点有一个唯一的索引值），那么每个 `VertexIndexIterator` 只会有一个 `VertexId`，并且在调用 `Next()` 后会变得无效。\n\n该文本块包含对 `GetVidFromNodeString` 函数的描述，该函数功能是从通过 Cypher 传入的节点中解析出顶点ID（vid），并用于 V2 过程。这一部分位于有关 TuGraph 操作和事务管理的文档中，具体讨论了如何解析图形数据库中的节点信息和相关的参数定义。"
            },
            {
                "content": "- `lgraph`\r\n- `lgraph_api`\r\n\r\n### Class VertexIndexIterator\r\n```cpp\r\n#include \r\n```\r\n`VertexIndexIterator` can be used to access a set of vertices that has the same indexed value. If the index is unique (that is, each vertex has a unique index value), then each `VertexIndexIterator` will only have one `VertexId`, and will become invalid after `Next()` is called.\r\n\r\n`VertexIndexIterator` 可以用于访问具有相同索引值的一组顶点。如果索引是唯一的（即每个顶点有一个唯一的索引值），那么每个 `VertexIndexIterator` 只会有一个 `VertexId`，并且在调用 `Next()` 后会变得无效。\r\n\r\nA `VertexIndexIterator` is valid iff it points to a valid `(index_value, vid)` pair; otherwise, it is invalid. Calling member functions on an invalid `VertexIndexIterator` throws an exception, except for the `IsValid()` function.\r\n\r\n`VertexIndexIterator` 是有效的当且仅当它指向一个有效的 `(index_value, vid)` 对；否则，它是无效的。在无效的 `VertexIndexIterator` 上调用成员函数会抛出异常，除了 `IsValid()` 函数。\r\n\r\n#### Public Functions\r\n```cpp\r\nVertexIndexIterator(VertexIndexIterator &&rhs)\r\n```\r\n构造函数，移动构造 `VertexIndexIterator`。\r\n\r\n```cpp\n\n该块内容位于文档的“lgraph”命名空间和“lgraph_api”命名空间下，主要介绍 `VertexIndexIterator` 类的功能和特性。此类用于访问具有相同索引值的顶点集合，描述了如何判断迭代器的有效性以及如何构造和操作该迭代器的相关方法。这部分内容属于图数据库接口的遍历功能模块。"
            },
            {
                "content": "A `VertexIndexIterator` is valid iff it points to a valid `(index_value, vid)` pair; otherwise, it is invalid. Calling member functions on an invalid `VertexIndexIterator` throws an exception, except for the `IsValid()` function.\r\n\r\n`VertexIndexIterator` 是有效的当且仅当它指向一个有效的 `(index_value, vid)` 对；否则，它是无效的。在无效的 `VertexIndexIterator` 上调用成员函数会抛出异常，除了 `IsValid()` 函数。\r\n\r\n#### Public Functions\r\n```cpp\r\nVertexIndexIterator(VertexIndexIterator &&rhs)\r\n```\r\n构造函数，移动构造 `VertexIndexIterator`。\r\n\r\n```cpp\r\nVertexIndexIterator &operator=(VertexIndexIterator&&)\r\n```\r\n移动赋值运算符。\r\n\r\n```cpp\r\n~VertexIndexIterator()\r\n```\r\n析构函数。\r\n\r\n```cpp\r\nvoid Close()\r\n```\r\nCloses this iterator.\r\n\r\n关闭此迭代器。\r\n\r\n```cpp\r\nbool IsValid() const\r\n```\r\nQuery if this iterator is valid, i.e., the Key and Vid can be queried.\r\n\r\n查询此迭代器是否有效，即 Key 和 Vid 是否可以被查询。\r\n\r\n返回  \r\nTrue if valid, false if not.\r\n\r\n返回  \r\n如果有效则返回 true，否则返回 false。\r\n\r\n```cpp\r\nbool Next()\r\n```\n\n该文本块位于文档中关于 `lgraph_vertex_index_iterator` 类的部分，主要描述了 `VertexIndexIterator` 的有效性及相关公有函数。这些函数用于操作和查询具有相同索引值的顶点，通过 `VertexIndexIterator` 可以遍历、检查有效性及关闭迭代器。"
            },
            {
                "content": "```\r\n构造函数，移动构造 `VertexIndexIterator`。\r\n\r\n```cpp\r\nVertexIndexIterator &operator=(VertexIndexIterator&&)\r\n```\r\n移动赋值运算符。\r\n\r\n```cpp\r\n~VertexIndexIterator()\r\n```\r\n析构函数。\r\n\r\n```cpp\r\nvoid Close()\r\n```\r\nCloses this iterator.\r\n\r\n关闭此迭代器。\r\n\r\n```cpp\r\nbool IsValid() const\r\n```\r\nQuery if this iterator is valid, i.e., the Key and Vid can be queried.\r\n\r\n查询此迭代器是否有效，即 Key 和 Vid 是否可以被查询。\r\n\r\n返回  \r\nTrue if valid, false if not.\r\n\r\n返回  \r\n如果有效则返回 true，否则返回 false。\r\n\r\n```cpp\r\nbool Next()\r\n```\r\nMove to the next vertex id in the list, which consists of all the valid vertex ids of the iterator and is sorted from small to large. If we hit the end of the list, the iterator will become invalid and false is returned.\r\n\r\n移动到列表中的下一个顶点 id，该列表由迭代器的所有有效顶点 id 组成，并按从小到大排序。如果到达列表末尾，则迭代器将变得无效，返回 false。\r\n\r\n返回  \r\nTrue if it succeeds, otherwise false.\r\n\r\n返回  \r\n如果成功则返回 true，否则返回 false。\r\n\r\n```cpp\r\nFieldData GetIndexValue() const\r\n```\n\n该块内容位于文档中关于 `VertexIndexIterator` 类的部分，描述了该类的构造函数、移动赋值运算符、析构函数以及主要成员函数的功能和使用，包括迭代器的有效性检查和遍历下一个顶点的操作。这些功能对于图数据库中的顶点遍历和数据访问至关重要。"
            },
            {
                "content": "返回  \r\n如果有效则返回 true，否则返回 false。\r\n\r\n```cpp\r\nbool Next()\r\n```\r\nMove to the next vertex id in the list, which consists of all the valid vertex ids of the iterator and is sorted from small to large. If we hit the end of the list, the iterator will become invalid and false is returned.\r\n\r\n移动到列表中的下一个顶点 id，该列表由迭代器的所有有效顶点 id 组成，并按从小到大排序。如果到达列表末尾，则迭代器将变得无效，返回 false。\r\n\r\n返回  \r\nTrue if it succeeds, otherwise false.\r\n\r\n返回  \r\n如果成功则返回 true，否则返回 false。\r\n\r\n```cpp\r\nFieldData GetIndexValue() const\r\n```\r\nGets the current index value. The vids are sorted in `(IndexValue, Vid)` order. When `Next()` is called, the iterator moves from one vid to next, possibly moving from one IndexValue to another. This function tells the IndexValue currently pointed to.\r\n\r\n获取当前的索引值。vids 按 `(IndexValue, Vid)` 顺序排序。当调用 `Next()` 时，迭代器从一个 vid 移动到下一个，可能会从一个 IndexValue 移动到另一个。此函数返回当前指向的 IndexValue。\r\n\r\n返回  \r\nThe key.\r\n\r\n返回  \r\n键（key）。\r\n\r\n```cpp\r\nint64_t GetVid() const\r\n```\r\nGets the current vertex id.\r\n\r\n获取当前顶点 id。\r\n\r\n返回  \r\nThe current vertex id.\n\n此代码块位于文档中关于 `VertexIterator` 类的部分，描述了该类如何用于遍历图数据库中的顶点。它详细说明了 `Next()`、`GetIndexValue()` 和 `GetVid()` 函数的功能，以及它们在迭代器操作中的用途，帮助用户理解如何在图中获取和操作顶点数据。"
            },
            {
                "content": "获取当前的索引值。vids 按 `(IndexValue, Vid)` 顺序排序。当调用 `Next()` 时，迭代器从一个 vid 移动到下一个，可能会从一个 IndexValue 移动到另一个。此函数返回当前指向的 IndexValue。\r\n\r\n返回  \r\nThe key.\r\n\r\n返回  \r\n键（key）。\r\n\r\n```cpp\r\nint64_t GetVid() const\r\n```\r\nGets the current vertex id.\r\n\r\n获取当前顶点 id。\r\n\r\n返回  \r\nThe current vertex id.\r\n\r\n返回  \r\n当前顶点 id。\r\n\r\n#### Private Functions\r\n```cpp\r\nVertexIndexIterator(lgraph::VertexIndexIterator &⁢, const std::shared_ptr &txn)\r\n```\r\n\r\n```cpp\r\nVertexIndexIterator(const VertexIndexIterator&) = delete\r\n```\r\n拷贝构造函数被删除，禁止使用拷贝构造。\r\n\r\n```cpp\r\nVertexIndexIterator &operator=(const VertexIndexIterator&) = delete\r\n```\r\n拷贝赋值运算符被删除，禁止使用拷贝赋值。\r\n\r\n#### Private Members\r\n- `std::unique_ptr it_`\r\n- `std::shared_ptr txn_`\r\n\r\n#### Friends\r\n- `friend class Transaction`\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_vertex_iterator\r\n\r\n### Namespace\r\n- `lgraph`\r\n- `graph`\r\n- `lgraph_api`\r\n\r\n### Class VertexIterator\r\n```cpp\r\n#include \r\n```\r\n`VertexIterator` can be used to iterate through vertices in the DB. Vertices are sorted according to vertex id in the DB.\n\n该摘录位于文档的\"lgraph_vertex_index_iterator\"类部分，主要描述了该类的方法和成员，包括获取当前顶点ID和索引值的相关功能。此外，它还详细说明了构造函数、拷贝构造函数的删除、拷贝赋值运算符的禁止，以及与事务类的友元关系。这部分内容对理解顶点迭代器的操作和使用非常重要。"
            },
            {
                "content": "VertexIndexIterator &operator=(const VertexIndexIterator&) = delete\r\n```\r\n拷贝赋值运算符被删除，禁止使用拷贝赋值。\r\n\r\n#### Private Members\r\n- `std::unique_ptr it_`\r\n- `std::shared_ptr txn_`\r\n\r\n#### Friends\r\n- `friend class Transaction`\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## lgraph_vertex_iterator\r\n\r\n### Namespace\r\n- `lgraph`\r\n- `graph`\r\n- `lgraph_api`\r\n\r\n### Class VertexIterator\r\n```cpp\r\n#include \r\n```\r\n`VertexIterator` can be used to iterate through vertices in the DB. Vertices are sorted according to vertex id in the DB.  \r\n`VertexIterator`可以用来遍历数据库中的顶点。顶点根据数据库中的顶点ID进行排序。\r\n\r\nA `VertexIterator` is valid iff it points to a valid vertex. Calling method functions on an invalid `VertexIterator` throws an `InvalidIterator`, except for the `IsValid()` and `Goto()` functions.  \r\n当`VertexIterator`指向一个有效顶点时，才被认为是有效的。对无效的`VertexIterator`调用方法函数将抛出`InvalidIterator`，但`IsValid()`和`Goto()`函数除外。\r\n\r\nThe following operations invalidate a `VertexIterator`:  \r\n以下操作将使`VertexIterator`无效：\r\n- Constructing a `VertexIterator` for a non-existing vertex.\n\n该块内容位于文档中关于`VertexIndexIterator`类的部分，描述了其拷贝赋值运算符被删除以禁止拷贝赋值的特性。此外，文档还紧接着介绍了`VertexIterator`类，提供了对数据库中顶点的迭代功能，并讨论了`VertexIterator`的有效性及其失效的操作。"
            },
            {
                "content": "A `VertexIterator` is valid iff it points to a valid vertex. Calling method functions on an invalid `VertexIterator` throws an `InvalidIterator`, except for the `IsValid()` and `Goto()` functions.  \r\n当`VertexIterator`指向一个有效顶点时，才被认为是有效的。对无效的`VertexIterator`调用方法函数将抛出`InvalidIterator`，但`IsValid()`和`Goto()`函数除外。\r\n\r\nThe following operations invalidate a `VertexIterator`:  \r\n以下操作将使`VertexIterator`无效：\r\n- Constructing a `VertexIterator` for a non-existing vertex.  \r\n  为不存在的顶点构造`VertexIterator`。\r\n- Calling `Goto()` with the id of a non-existing vertex.  \r\n  使用不存在的顶点ID调用`Goto()`。\r\n- Calling `Next()` on the last vertex.  \r\n  在最后一个顶点上调用`Next()`。\r\n- Calling `Delete()` on the last vertex.  \r\n  在最后一个顶点上调用`Delete()`。\r\n\r\n#### Public Functions\r\n```cpp\r\nVertexIterator(VertexIterator &&rhs)\r\n```\r\n```cpp\r\nVertexIterator &operator=(VertexIterator &&rhs)\r\n```\r\n```cpp\r\n~VertexIterator()\r\n```\r\n```cpp\r\nvoid Close()\r\n```\r\nCloses this iterator.  \r\n关闭此迭代器。\r\n\r\n```cpp\r\nbool Next()\r\n```\r\nMove to the next vertex.  \r\n移动到下一个顶点。\r\n\r\n抛出\n\n该片段位于文档中关于`VertexIterator`类的部分，详细描述了`VertexIterator`的有效性、无效化操作及其公共函数。这部分内容是图遍历和处理类的整体介绍，旨在为用户提供如何有效使用和管理顶点迭代器的信息。"
            },
            {
                "content": "使用不存在的顶点ID调用`Goto()`。\r\n- Calling `Next()` on the last vertex.  \r\n  在最后一个顶点上调用`Next()`。\r\n- Calling `Delete()` on the last vertex.  \r\n  在最后一个顶点上调用`Delete()`。\r\n\r\n#### Public Functions\r\n```cpp\r\nVertexIterator(VertexIterator &&rhs)\r\n```\r\n```cpp\r\nVertexIterator &operator=(VertexIterator &&rhs)\r\n```\r\n```cpp\r\n~VertexIterator()\r\n```\r\n```cpp\r\nvoid Close()\r\n```\r\nCloses this iterator.  \r\n关闭此迭代器。\r\n\r\n```cpp\r\nbool Next()\r\n```\r\nMove to the next vertex.  \r\n移动到下一个顶点。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n返回  \r\nTrue if it succeeds, otherwise return false (no more vertex) and invalidate the iterator.  \r\n如果成功则返回True，否则返回false（没有更多顶点）并使迭代器无效。\r\n\r\n```cpp\r\nbool Goto(int64_t vid, bool nearest = false)\r\n```\r\nGoto the vertex with id `src`. If there is no vertex with exactly the same vid, and `nearest==true`, go to the next vertex with id >= vid; otherwise, return false and invalidate the iterator.\n\n该块内容位于关于`VertexIterator`类的部分，详细描述了该类的公有函数，包括构造函数、析构函数以及用于移动到下一个顶点和跳转到指定顶点的`Next()`和`Goto()`函数。同时指出了在特定条件下，如何使用这些函数以及可能抛出的异常。该内容对于理解图的遍历操作至关重要。"
            },
            {
                "content": "`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n返回  \r\nTrue if it succeeds, otherwise return false (no more vertex) and invalidate the iterator.  \r\n如果成功则返回True，否则返回false（没有更多顶点）并使迭代器无效。\r\n\r\n```cpp\r\nbool Goto(int64_t vid, bool nearest = false)\r\n```\r\nGoto the vertex with id `src`. If there is no vertex with exactly the same vid, and `nearest==true`, go to the next vertex with id >= vid; otherwise, return false and invalidate the iterator.  \r\n跳转到ID为`src`的顶点。如果没有与给定vid完全相同的顶点，并且`nearest==true`，则跳转到ID >= vid的下一个顶点；否则返回false并使迭代器无效。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出\r\n\r\n参数  \r\n`vid` – Vertex id of the vertex to go.  // 要跳转的顶点ID  \r\n`nearest` – (Optional) True to go to the closest vertex with id >= vid.  // （可选）如果设置为True，跳转到ID >= vid的最近顶点\r\n\r\n返回  \r\nTrue if it succeeds, otherwise false (no such vertex).  \r\n如果成功则返回True，否则返回false（没有这样的顶点）。\r\n\r\n```cpp\r\nint64_t GetId() const\r\n```\r\nGets the vertex id.  \r\n获取顶点ID。\r\n\r\n抛出\n\n该文段位于文档中与 `VertexIterator` 类相关的部分，描述了在无效事务中调用时抛出的 `InvalidIterator` 异常，以及如何使用 `Goto()` 方法跳转到特定顶点的逻辑。此部分重点阐述了迭代器的有效性检查和相应的操作返回值。"
            },
            {
                "content": "抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出\r\n\r\n参数  \r\n`vid` – Vertex id of the vertex to go.  // 要跳转的顶点ID  \r\n`nearest` – (Optional) True to go to the closest vertex with id >= vid.  // （可选）如果设置为True，跳转到ID >= vid的最近顶点\r\n\r\n返回  \r\nTrue if it succeeds, otherwise false (no such vertex).  \r\n如果成功则返回True，否则返回false（没有这样的顶点）。\r\n\r\n```cpp\r\nint64_t GetId() const\r\n```\r\nGets the vertex id.  \r\n获取顶点ID。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n返回  \r\nThe id.  \r\n返回ID。\r\n\r\n```cpp\r\nOutEdgeIterator GetOutEdgeIterator() const\r\n```\r\nGets an `OutEdgeIterator` pointing to the first out-going edge.  \r\n获取指向第一个出边的`OutEdgeIterator`。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n返回  \r\nThe `OutEdgeIterator`.  \r\n返回`OutEdgeIterator`。\r\n\r\n```cpp\n\n该块内容位于文档的“lgraph_txn”部分，主要描述了“Transaction”类的公共函数，包括获取顶点ID和指向出边的迭代器的相关方法。这些函数涉及事务的有效性检查和边的遍历操作。"
            },
            {
                "content": "`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n返回  \r\nThe id.  \r\n返回ID。\r\n\r\n```cpp\r\nOutEdgeIterator GetOutEdgeIterator() const\r\n```\r\nGets an `OutEdgeIterator` pointing to the first out-going edge.  \r\n获取指向第一个出边的`OutEdgeIterator`。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n返回  \r\nThe `OutEdgeIterator`.  \r\n返回`OutEdgeIterator`。\r\n\r\n```cpp\r\nOutEdgeIterator GetOutEdgeIterator(const EdgeUid &euid, bool nearest = false) const\r\n```\r\nReturns an `OutEdgeIterator` pointing to the edge specified by `euid`. If there is no such edge, and `nearest==false`, an invalid iterator is returned. If the specified out-edge does not exist, and `nearest==true`, get the first out-edge that sorts after the specified one.  \r\n返回指向由`euid`指定的边的`OutEdgeIterator`。如果没有这样的边，并且`nearest==false`，则返回无效迭代器。如果指定的出边不存在并且`nearest==true`，则获取排序在指定边之后的第一个出边。\r\n\r\n抛出\n\n该块内容位于文档的“lgraph_vertex_iterator”类部分，用于描述顶点迭代器的功能，包括获取出边迭代器的方法和相关异常处理。当迭代器无效时会抛出`InvalidIterator`异常，同时提供了如何通过`EdgeUid`获取特定出边的功能。"
            },
            {
                "content": "```cpp\r\nOutEdgeIterator GetOutEdgeIterator(const EdgeUid &euid, bool nearest = false) const\r\n```\r\nReturns an `OutEdgeIterator` pointing to the edge specified by `euid`. If there is no such edge, and `nearest==false`, an invalid iterator is returned. If the specified out-edge does not exist, and `nearest==true`, get the first out-edge that sorts after the specified one.  \r\n返回指向由`euid`指定的边的`OutEdgeIterator`。如果没有这样的边，并且`nearest==false`，则返回无效迭代器。如果指定的出边不存在并且`nearest==true`，则获取排序在指定边之后的第一个出边。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n参数  \r\n`euid` – The Edge Unique Id.  // 边的唯一ID  \r\n`nearest` – (Optional) If set to true and the specified edge does not exist, get the edge that sorts right after it.  // （可选）如果设置为true且指定边不存在，则获取排序在其后面的边。\r\n\r\n返回  \r\nThe out edge iterator.  \r\n出边迭代器。\r\n\r\n```cpp\r\nInEdgeIterator GetInEdgeIterator() const\r\n```\n\n该代码块位于有关 `VertexIterator` 类的部分，描述了如何通过边的唯一标识符 `EdgeUid` 获取指向特定出边的迭代器。它详细说明了函数的参数、返回值和可能抛出的异常，以便用户在遍历图形时使用。"
            },
            {
                "content": "抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n参数  \r\n`euid` – The Edge Unique Id.  // 边的唯一ID  \r\n`nearest` – (Optional) If set to true and the specified edge does not exist, get the edge that sorts right after it.  // （可选）如果设置为true且指定边不存在，则获取排序在其后面的边。\r\n\r\n返回  \r\nThe out edge iterator.  \r\n出边迭代器。\r\n\r\n```cpp\r\nInEdgeIterator GetInEdgeIterator() const\r\n```\r\nGets an `InEdgeIterator` pointing to the first in-coming edge.  \r\n获取指向第一个入边的`InEdgeIterator`。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n返回  \r\nThe `InEdgeIterator`.  \r\n返回`InEdgeIterator`。\r\n\r\n```cpp\r\nInEdgeIterator GetInEdgeIterator(const EdgeUid &euid, bool nearest = false) const\r\n```\n\n该块内容位于文档中的“lgraph_vertex_iterator”类部分，主要描述了`VertexIterator`类的方法，包括获取出边和入边迭代器的功能，以及处理这些迭代器时可能抛出的异常。这些方法用于在图数据库中遍历和操作顶点之间的边。"
            },
            {
                "content": "The out edge iterator.  \r\n出边迭代器。\r\n\r\n```cpp\r\nInEdgeIterator GetInEdgeIterator() const\r\n```\r\nGets an `InEdgeIterator` pointing to the first in-coming edge.  \r\n获取指向第一个入边的`InEdgeIterator`。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n返回  \r\nThe `InEdgeIterator`.  \r\n返回`InEdgeIterator`。\r\n\r\n```cpp\r\nInEdgeIterator GetInEdgeIterator(const EdgeUid &euid, bool nearest = false) const\r\n```\r\nReturns an `InEdgeIterator` pointing to the edge specified by `euid`. If there is no such edge and `nearest==false`, an invalid iterator is returned. If the specified edge does not exist and `nearest==true`, get the edge that sorts right after it.  \r\n返回指向由`euid`指定的边的`InEdgeIterator`。如果没有这样的边并且`nearest==false`，则返回无效迭代器。如果指定的边不存在并且`nearest==true`，则获取排序在其后面的边。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出\n\n该代码块位于文档中关于TuGraph图数据库的边迭代器部分，特别是与入边迭代器相关的内容。它描述了如何获取指向第一个入边的迭代器以及通过唯一边标识符获取指定入边的迭代器，同时指出了在无效事务或迭代器无效时可能抛出的异常。"
            },
            {
                "content": "```\r\nReturns an `InEdgeIterator` pointing to the edge specified by `euid`. If there is no such edge and `nearest==false`, an invalid iterator is returned. If the specified edge does not exist and `nearest==true`, get the edge that sorts right after it.  \r\n返回指向由`euid`指定的边的`InEdgeIterator`。如果没有这样的边并且`nearest==false`，则返回无效迭代器。如果指定的边不存在并且`nearest==true`，则获取排序在其后面的边。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n参数  \r\n`euid` – The Edge Unique Id.  // 边的唯一ID  \r\n`nearest` – (Optional) If set to true and the specified edge does not exist, get the edge that sorts right after it.  // （可选）如果设置为true且指定边不存在，则获取排序在其后面的边。\r\n\r\n返回  \r\nThe `InEdgeIterator`.  \r\n返回`InEdgeIterator`。\r\n\r\n```cpp\r\nbool IsValid() const\r\n```\r\nQuery if this iterator is valid.  \r\n查询此迭代器是否有效。\r\n\r\n返回  \r\nTrue if valid, false if not.  \r\n如果有效，则返回True；否则返回false。\r\n\r\n```cpp\r\nconst std::string &GetLabel() const\r\n```\n\n该段落位于文档中关于“`InEdgeIterator`”类的部分，描述了如何通过唯一边标识符（`euid`）获取指向指定边的入边迭代器，以及该迭代器的有效性检查和相关异常处理。"
            },
            {
                "content": "参数  \r\n`euid` – The Edge Unique Id.  // 边的唯一ID  \r\n`nearest` – (Optional) If set to true and the specified edge does not exist, get the edge that sorts right after it.  // （可选）如果设置为true且指定边不存在，则获取排序在其后面的边。\r\n\r\n返回  \r\nThe `InEdgeIterator`.  \r\n返回`InEdgeIterator`。\r\n\r\n```cpp\r\nbool IsValid() const\r\n```\r\nQuery if this iterator is valid.  \r\n查询此迭代器是否有效。\r\n\r\n返回  \r\nTrue if valid, false if not.  \r\n如果有效，则返回True；否则返回false。\r\n\r\n```cpp\r\nconst std::string &GetLabel() const\r\n```\r\nGets the label of this vertex.  \r\n获取此顶点的标签。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n返回  \r\nThe label.  \r\n标签。\r\n\r\n```cpp\r\nsize_t GetLabelId() const\r\n```\r\nGets label id of this vertex.  \r\n获取此顶点的标签ID。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n返回  \r\nThe label identifier.  \r\n标签标识符。\r\n\r\n```cpp\n\n该块内容位于文档关于图数据库操作的部分，具体涉及`Transaction`类中的方法和属性，用于获取边的相关信息，如边的唯一 ID、有效性检查、标签和标签 ID 的获取。这为用户在执行图数据库操作时提供了必要的接口与信息。"
            },
            {
                "content": "抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n返回  \r\nThe label.  \r\n标签。\r\n\r\n```cpp\r\nsize_t GetLabelId() const\r\n```\r\nGets label id of this vertex.  \r\n获取此顶点的标签ID。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出\r\n\r\n返回  \r\nThe label identifier.  \r\n标签标识符。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_names) const\r\n```\r\nGets the fields specified.  \r\n获取指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  // 对于其他输入错误（字段不存在等）抛出\r\n\r\n参数  \r\n`field_names` – List of names of the fields.  // 字段名称列表\r\n\r\n返回  \r\nThe fields.  \r\n字段。\r\n\r\n```cpp\n\n该文本块位于描述 `VertexIterator` 类的部分，具体介绍了如何获取顶点的标签ID和字段，以及相关的异常抛出机制。该类用于遍历图中的顶点，其方法包括验证迭代器的有效性和获取指定字段的信息。"
            },
            {
                "content": "标签标识符。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_names) const\r\n```\r\nGets the fields specified.  \r\n获取指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  // 对于其他输入错误（字段不存在等）抛出\r\n\r\n参数  \r\n`field_names` – List of names of the fields.  // 字段名称列表\r\n\r\n返回  \r\nThe fields.  \r\n字段。\r\n\r\n```cpp\r\nFieldData GetField(const std::string &field_name) const\r\n```\r\nGets the field specified.  \r\n获取指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  // 对于其他输入错误（字段不存在等）抛出\r\n\r\n参数  \r\n`field_name` – Field name.  // 字段名称\r\n\r\n返回  \r\nField value.  \r\n字段值。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_ids) const\r\n```\n\n该片段位于文档中的“lgraph_vertex_iterator”类部分，主要描述了获取字段信息的方法，包括通过字段名称和字段ID获取特定字段的过程。这些方法涉及异常处理和参数说明，是理解如何操作图数据库中顶点数据的关键部分。"
            },
            {
                "content": "```\r\nGets the field specified.  \r\n获取指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  // 对于其他输入错误（字段不存在等）抛出\r\n\r\n参数  \r\n`field_name` – Field name.  // 字段名称\r\n\r\n返回  \r\nField value.  \r\n字段值。\r\n\r\n```cpp\r\nstd::vector GetFields(const std::vector &field_ids) const\r\n```\r\nGets the fields specified.  \r\n获取指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  // 对于其他输入错误（字段不存在等）抛出\r\n\r\n参数  \r\n`field_ids` – List of ids for the fields.  // 字段ID列表\r\n\r\n返回  \r\nThe fields.  \r\n字段。\r\n\r\n```cpp\r\nFieldData GetField(size_t field_id) const\r\n```\r\nGets the field specified.  \r\n获取指定的字段。\r\n\r\n抛出\n\n该内容位于文档中关于 `VertexIterator` 类的部分，具体描述了该类中获取指定字段和字段列表的方法及其参数、返回值和可能抛出的异常。通过这些方法，用户可以提取与特定顶点相关的字段信息。"
            },
            {
                "content": "```\r\nGets the fields specified.  \r\n获取指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  // 对于其他输入错误（字段不存在等）抛出\r\n\r\n参数  \r\n`field_ids` – List of ids for the fields.  // 字段ID列表\r\n\r\n返回  \r\nThe fields.  \r\n字段。\r\n\r\n```cpp\r\nFieldData GetField(size_t field_id) const\r\n```\r\nGets the field specified.  \r\n获取指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  // 对于其他输入错误（字段不存在等）抛出\r\n\r\n参数  \r\n`field_id` – Field ID.  // 字段ID\r\n\r\n返回  \r\nField value.  \r\n字段值。\r\n\r\n```cpp\r\ninline FieldData operator[](const std::string &field_name) const\r\n```\r\nGet field identified by `field_name`.  \r\n通过 `field_name` 获取指定的字段。\r\n\r\n抛出\n\n该块内容位于文档的 `lgraph_vertex_iterator` 类部分，描述了如何获取指定字段的相关信息，包括根据字段 ID 和字段名称获取字段值的函数及其对应的异常处理。在这部分中，用户可以了解如何通过迭代器访问图数据库中的不同字段及其值。"
            },
            {
                "content": "获取指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  // 当在无效事务中调用时抛出  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  // 当当前迭代器无效时抛出  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  // 对于其他输入错误（字段不存在等）抛出\r\n\r\n参数  \r\n`field_id` – Field ID.  // 字段ID\r\n\r\n返回  \r\nField value.  \r\n字段值。\r\n\r\n```cpp\r\ninline FieldData operator[](const std::string &field_name) const\r\n```\r\nGet field identified by `field_name`.  \r\n通过 `field_name` 获取指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`field_name` – Filename of the file.  \r\n字段的名称。\r\n\r\n返回  \r\nThe indexed value.  \r\n索引值。\r\n\r\n```cpp\r\ninline FieldData operator[](size_t fid) const\r\n```\r\nGet field identified by field id.  \r\n通过字段 ID 获取指定的字段。\r\n\r\n抛出\n\n该片段位于文档中关于`VertexIterator`类的部分，具体描述了如何获取指定字段的值，包括潜在的异常处理和方法参数。"
            },
            {
                "content": "通过 `field_name` 获取指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`field_name` – Filename of the file.  \r\n字段的名称。\r\n\r\n返回  \r\nThe indexed value.  \r\n索引值。\r\n\r\n```cpp\r\ninline FieldData operator[](size_t fid) const\r\n```\r\nGet field identified by field id.  \r\n通过字段 ID 获取指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`fid` – The field id.  \r\n字段 ID。\r\n\r\n返回  \r\nThe indexed value.  \r\n索引值。\r\n\r\n```cpp\r\nstd::map GetAllFields() const\r\n```\r\nGets all fields of the current vertex.  \r\n获取当前顶点的所有字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.\n\n该块内容位于文档的“lgraph_vertex_iterator”部分，主要描述了通过字段名称和字段 ID 获取指定字段的函数及其相关的异常处理、参数和返回值。这一部分提供了对顶点数据访问的具体实现细节，适用于图数据库中的字段操作。"
            },
            {
                "content": "当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`fid` – The field id.  \r\n字段 ID。\r\n\r\n返回  \r\nThe indexed value.  \r\n索引值。\r\n\r\n```cpp\r\nstd::map GetAllFields() const\r\n```\r\nGets all fields of the current vertex.  \r\n获取当前顶点的所有字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n返回  \r\nAll fields.  \r\n所有字段。\r\n\r\n```cpp\r\nvoid SetField(const std::string &field_name, const FieldData &field_value)\r\n```\r\nSets the specified field.  \r\n设置指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`WriteNotAllowed` – Thrown when called in a read-only transaction.  \r\n在只读事务中调用时抛出。\n\n该块内容位于文档中有关`VertexIterator`类的部分，详细描述了`VertexIterator`的成员函数及其抛出的异常，包括获取字段、设置字段和处理异常的逻辑，适用于对图中顶点进行遍历和操作的上下文。"
            },
            {
                "content": "`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n返回  \r\nAll fields.  \r\n所有字段。\r\n\r\n```cpp\r\nvoid SetField(const std::string &field_name, const FieldData &field_value)\r\n```\r\nSets the specified field.  \r\n设置指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`WriteNotAllowed` – Thrown when called in a read-only transaction.  \r\n在只读事务中调用时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`field_name` – Field name.  \r\n字段名。  \r\n`field_value` – Field value.  \r\n字段值。\r\n\r\n```cpp\r\nvoid SetField(size_t field_id, const FieldData &field_value)\r\n```\r\nSets the specified field.  \r\n设置指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。\n\n该块内容位于文档的“lgraph_vertex_iterator”类部分，描述了在无效事务或迭代器调用中可能抛出的异常，以及设置字段的功能。在这里，主要介绍了如何通过指定字段名称和字段值来设置字段，以及相关的异常处理机制。"
            },
            {
                "content": "在只读事务中调用时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`field_name` – Field name.  \r\n字段名。  \r\n`field_value` – Field value.  \r\n字段值。\r\n\r\n```cpp\r\nvoid SetField(size_t field_id, const FieldData &field_value)\r\n```\r\nSets the specified field.  \r\n设置指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`WriteNotAllowed` – Thrown when called in a read-only transaction.  \r\n在只读事务中调用时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`field_id` – Field id.  \r\n字段 ID。  \r\n`field_value` – Field value.  \r\n字段值。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_names, const std::vector &field_value_strings)\r\n```\r\nSets the fields specified.  \r\n设置指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。\n\n该块内容位于文档的“lgraph_vertex_iterator”类部分，具体描述了如何设置指定字段的方法，包括设置单个字段和多个字段的操作，以及在各种情况下可能抛出的异常。这部分内容是关于图数据库中对顶点的操作和错误处理的说明。"
            },
            {
                "content": "`WriteNotAllowed` – Thrown when called in a read-only transaction.  \r\n在只读事务中调用时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`field_id` – Field id.  \r\n字段 ID。  \r\n`field_value` – Field value.  \r\n字段值。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_names, const std::vector &field_value_strings)\r\n```\r\nSets the fields specified.  \r\n设置指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`WriteNotAllowed` – Thrown when called in a read-only transaction.  \r\n在只读事务中调用时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`field_names` – List of names of the fields.  \r\n字段名称列表。  \r\n`field_value_strings` – The field value strings.  \r\n字段值字符串。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_names, const std::vector &field_values)\r\n```\r\nSets the fields specified.  \r\n设置指定的字段。\n\n该代码块位于文档的“lgraph_txn”部分，描述了在事务处理中设置字段的函数及其抛出异常的情形，包括无效事务、无效迭代器、只读事务及输入错误。这部分主要讲解了如何在图数据库的事务中操作字段及相关的错误处理。"
            },
            {
                "content": "当当前迭代器无效时抛出。  \r\n`WriteNotAllowed` – Thrown when called in a read-only transaction.  \r\n在只读事务中调用时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`field_names` – List of names of the fields.  \r\n字段名称列表。  \r\n`field_value_strings` – The field value strings.  \r\n字段值字符串。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_names, const std::vector &field_values)\r\n```\r\nSets the fields specified.  \r\n设置指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`WriteNotAllowed` – Thrown when called in a read-only transaction.  \r\n在只读事务中调用时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`field_names` – List of names of the fields.  \r\n字段名称列表。  \r\n`field_values` – The field values.  \r\n字段值。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_ids, const std::vector &field_values)\r\n```\n\n该段落位于文档的“lgraph_vertex_iterator”类部分，具体描述了一些公共函数，包括`SetFields`方法的功能、参数以及可能抛出的异常。这些函数涉及对图数据库中顶点字段的设置和管理，是使用TuGraph时的重要操作方法。"
            },
            {
                "content": "当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`WriteNotAllowed` – Thrown when called in a read-only transaction.  \r\n在只读事务中调用时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`field_names` – List of names of the fields.  \r\n字段名称列表。  \r\n`field_values` – The field values.  \r\n字段值。\r\n\r\n```cpp\r\nvoid SetFields(const std::vector &field_ids, const std::vector &field_values)\r\n```\r\nSets the fields specified.  \r\n设置指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`WriteNotAllowed` – Thrown when called in a read-only transaction.  \r\n在只读事务中调用时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`field_ids` – List of identifiers for the fields.  \r\n字段的标识符列表。  \r\n`field_values` – The field values.  \r\n字段值。\r\n\r\n```cpp\n\n此代码段位于关于 `VertexIterator` 类的部分，详细描述了该类的方法，包括如何设置字段和处理异常情况。这些方法中的异常处理适用于在无效事务或无效迭代器调用时的响应，同时还涉及字段参数的处理。此处强调了事务和迭代器的有效性，对于确保正确操作至关重要。"
            },
            {
                "content": "设置指定的字段。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`WriteNotAllowed` – Thrown when called in a read-only transaction.  \r\n在只读事务中调用时抛出。  \r\n`InputError` – Thrown on other input errors (field not exist, etc.).  \r\n在其他输入错误（字段不存在等）时抛出。\r\n\r\n参数  \r\n`field_ids` – List of identifiers for the fields.  \r\n字段的标识符列表。  \r\n`field_values` – The field values.  \r\n字段值。\r\n\r\n```cpp\r\nstd::vector ListSrcVids(size_t n_limit = std::numeric_limits::max(), bool *more_to_go = nullptr)\r\n```\r\nList source vids. Each source vid is stored only once in the result.  \r\n列出源 vid。每个源 vid 在结果中只存储一次。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n参数  \r\n`n_limit` – (Optional) The limit on the number of vids to return.  \r\n（可选）返回的 vid 数量限制。\n\n该片段位于文档中关于`VertexIterator`类的方法描述部分，主要涉及设置字段和列出源顶点 ID（vid）的功能。这些功能允许用户在图数据库中操作和访问顶点数据。具体包括字段的设置方法及相关异常处理，以及获取源顶点 ID 的方法和参数说明。"
            },
            {
                "content": "字段值。\r\n\r\n```cpp\r\nstd::vector ListSrcVids(size_t n_limit = std::numeric_limits::max(), bool *more_to_go = nullptr)\r\n```\r\nList source vids. Each source vid is stored only once in the result.  \r\n列出源 vid。每个源 vid 在结果中只存储一次。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n参数  \r\n`n_limit` – (Optional) The limit on the number of vids to return.  \r\n（可选）返回的 vid 数量限制。  \r\n`more_to_go` – [out] (Optional) If non-null, returns whether the limit is exceeded.  \r\n[输出]（可选）如果不为 null，返回是否超出限制。\r\n\r\n返回  \r\nList of source vids.  \r\n源 vid 列表。\r\n\r\n```cpp\r\nstd::vector ListDstVids(size_t n_limit = std::numeric_limits::max(), bool *more_to_go = nullptr)\r\n```\r\nList destination vids. Each vid is stored only once in the result.  \r\n列出目标 vid。每个 vid 在结果中只存储一次。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.\n\n该块内容位于文档中关于 TuGraph 的 `VertexIterator` 类的部分，主要描述了获取源顶点和目标顶点 ID 的相关函数。这些函数允许用户列出图中的源和目标顶点 ID，并提供了抛出异常的条件及参数说明。整体文档涉及 TuGraph 数据库、图遍历算法及其相关接口和异常处理等内容。"
            },
            {
                "content": "[输出]（可选）如果不为 null，返回是否超出限制。\r\n\r\n返回  \r\nList of source vids.  \r\n源 vid 列表。\r\n\r\n```cpp\r\nstd::vector ListDstVids(size_t n_limit = std::numeric_limits::max(), bool *more_to_go = nullptr)\r\n```\r\nList destination vids. Each vid is stored only once in the result.  \r\n列出目标 vid。每个 vid 在结果中只存储一次。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n参数  \r\n`n_limit` – (Optional) The limit of the number of vids to return.  \r\n（可选）返回的 vid 数量限制。  \r\n`more_to_go` – [out] (Optional) If non-null, returns whether the limit is exceeded.  \r\n[输出]（可选）如果不为 null，返回是否超出限制。\r\n\r\n返回  \r\nList of destination vids.  \r\n目标 vid 列表。\r\n\r\n```cpp\r\nsize_t GetNumInEdges(size_t n_limit = std::numeric_limits::max(), bool *more_to_go = nullptr)\r\n```\r\nGets number of incoming edges, stopping on limit. This function can come in handy if we need to filter on large vertexes.  \r\n获取传入边的数量，在限制时停止。如果我们需要对大型顶点进行过滤，这个函数可能会很有用。\r\n\r\n抛出\n\n该块内容位于文档中关于TuGraph图数据库操作的部分，具体讲述了如何使用`VertexIterator`类获取顶点的源和目标ID列表，以及在获取边的入度和出度时的一些相关函数和注意事项。"
            },
            {
                "content": "（可选）返回的 vid 数量限制。  \r\n`more_to_go` – [out] (Optional) If non-null, returns whether the limit is exceeded.  \r\n[输出]（可选）如果不为 null，返回是否超出限制。\r\n\r\n返回  \r\nList of destination vids.  \r\n目标 vid 列表。\r\n\r\n```cpp\r\nsize_t GetNumInEdges(size_t n_limit = std::numeric_limits::max(), bool *more_to_go = nullptr)\r\n```\r\nGets number of incoming edges, stopping on limit. This function can come in handy if we need to filter on large vertexes.  \r\n获取传入边的数量，在限制时停止。如果我们需要对大型顶点进行过滤，这个函数可能会很有用。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n参数  \r\n`n_limit` – (Optional) The limit on the number of in-coming edges to count. When the limit is reached, `n_limit` is returned.  \r\n（可选）要计算的传入边的数量限制。当达到限制时，返回 `n_limit`。  \r\n`more_to_go` – [out] (Optional) If non-null, return whether the limit is exceeded.  \r\n[输出]（可选）如果不为 null，返回是否超出限制。\r\n\r\n返回  \r\nNumber of incoming edges.  \r\n传入边的数量。\r\n\r\n```cpp\n\n该片段位于文档中关于`VertexIterator`类的部分，具体描述了获取传入边数量的方法`GetNumInEdges`，包括函数签名、参数说明、抛出的异常及返回值，这些信息对于理解如何在图数据库中操作顶点和边的关系至关重要。"
            },
            {
                "content": "`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n参数  \r\n`n_limit` – (Optional) The limit on the number of in-coming edges to count. When the limit is reached, `n_limit` is returned.  \r\n（可选）要计算的传入边的数量限制。当达到限制时，返回 `n_limit`。  \r\n`more_to_go` – [out] (Optional) If non-null, return whether the limit is exceeded.  \r\n[输出]（可选）如果不为 null，返回是否超出限制。\r\n\r\n返回  \r\nNumber of incoming edges.  \r\n传入边的数量。\r\n\r\n```cpp\r\nsize_t GetNumOutEdges(size_t n_limit = std::numeric_limits::max(), bool *more_to_go = nullptr)\r\n```\r\nGets number of out-going edges, stopping on limit. This function can come in handy if we need to filter on large vertexes.  \r\n获取传出边的数量，在限制时停止。如果我们需要对大型顶点进行过滤，这个函数可能会很有用。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n参数\n\n该块内容位于文档中与事务处理和迭代器相关的部分，特别是在讨论如何获取图中的入边和出边数量时。它详细描述了在调用这些函数时可能抛出的异常类型，以及参数说明和返回值的定义，帮助用户理解如何安全有效地使用图数据库的迭代器和事务。"
            },
            {
                "content": "返回  \r\nNumber of incoming edges.  \r\n传入边的数量。\r\n\r\n```cpp\r\nsize_t GetNumOutEdges(size_t n_limit = std::numeric_limits::max(), bool *more_to_go = nullptr)\r\n```\r\nGets number of out-going edges, stopping on limit. This function can come in handy if we need to filter on large vertexes.  \r\n获取传出边的数量，在限制时停止。如果我们需要对大型顶点进行过滤，这个函数可能会很有用。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。\r\n\r\n参数  \r\n`n_limit` – (Optional) The limit on the number of out-going edges to count. When the limit is reached, `n_limit` is returned and `limit_exceeded` is set to true.  \r\n（可选）要计算的传出边的数量限制。当达到限制时，返回 `n_limit`，并将 `limit_exceeded` 设置为 true。  \r\n`more_to_go` – [out] (Optional) If non-null, return whether the limit is exceeded.  \r\n[输出]（可选）如果不为 null，返回是否超出限制。\r\n\r\n返回  \r\nNumber of out-going edges.  \r\n传出边的数量。\r\n\r\n```cpp\r\nvoid Delete(size_t *n_in_edges = nullptr, size_t *n_out_edges = nullptr)\r\n```\n\n该块内容位于文档的\"lgraph_vertex_iterator\"类部分，主要描述了如何获取顶点的入边和出边数量，以及删除顶点的相关函数。这些函数帮助用户在图数据库操作中有效管理顶点及其边的关系。"
            },
            {
                "content": "当当前迭代器无效时抛出。\r\n\r\n参数  \r\n`n_limit` – (Optional) The limit on the number of out-going edges to count. When the limit is reached, `n_limit` is returned and `limit_exceeded` is set to true.  \r\n（可选）要计算的传出边的数量限制。当达到限制时，返回 `n_limit`，并将 `limit_exceeded` 设置为 true。  \r\n`more_to_go` – [out] (Optional) If non-null, return whether the limit is exceeded.  \r\n[输出]（可选）如果不为 null，返回是否超出限制。\r\n\r\n返回  \r\nNumber of out-going edges.  \r\n传出边的数量。\r\n\r\n```cpp\r\nvoid Delete(size_t *n_in_edges = nullptr, size_t *n_out_edges = nullptr)\r\n```\r\nDeletes this vertex, also deletes all incoming and outgoing edges of this vertex. The iterator will point to the next vertex by vid if there is any.  \r\n删除该顶点，同时删除该顶点的所有传入和传出边。如果有下一个顶点，迭代器将指向其 vid。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`WriteNotAllowed` – Thrown when called in a read-only transaction.  \r\n在只读事务中调用时抛出。\r\n\r\n参数\n\n该段落位于文档中的“lgraph_vertex_iterator”类部分，主要描述了在遍历图形时处理顶点的删除操作和相关的异常处理。它强调了在无效事务或无效迭代器调用的情况下可能抛出的异常，以及在删除顶点时如何更新与之相关的入边和出边的数量。"
            },
            {
                "content": "```\r\nDeletes this vertex, also deletes all incoming and outgoing edges of this vertex. The iterator will point to the next vertex by vid if there is any.  \r\n删除该顶点，同时删除该顶点的所有传入和传出边。如果有下一个顶点，迭代器将指向其 vid。\r\n\r\n抛出  \r\n`InvalidTxn` – Thrown when called inside an invalid transaction.  \r\n当在无效事务中调用时抛出。  \r\n`InvalidIterator` – Thrown when current iterator is invalid.  \r\n当当前迭代器无效时抛出。  \r\n`WriteNotAllowed` – Thrown when called in a read-only transaction.  \r\n在只读事务中调用时抛出。\r\n\r\n参数  \r\n`n_in_edges` – [out] (Optional) If non-null, the number of in edges the vertex had.  \r\n[输出]（可选）如果不为 null，该顶点的传入边数量。  \r\n`n_out_edges` – [out] (Optional) If non-null, the number of out edges the vertex had.  \r\n[输出]（可选）如果不为 null，该顶点的传出边数量。\r\n\r\n```cpp\r\nstd::string ToString() const\r\n```\r\nGet the string representation of this vertex.  \r\n获取该顶点的字符串表示。\r\n\r\n#### Private Functions\r\n```cpp\r\nVertexIterator(lgraph::graph::VertexIterator&&, const std::shared_ptr&)\r\n```\r\n\r\n```cpp\r\nVertexIterator(const VertexIterator&) = delete\r\n```\r\n\r\n```cpp\n\n该块内容位于文档的 `lgraph_vertex_iterator` 类部分，具体描述了删除顶点及其相关的入边和出边操作，以及在执行该操作时可能抛出的异常和相关参数的说明。"
            },
            {
                "content": "[输出]（可选）如果不为 null，该顶点的传入边数量。  \r\n`n_out_edges` – [out] (Optional) If non-null, the number of out edges the vertex had.  \r\n[输出]（可选）如果不为 null，该顶点的传出边数量。\r\n\r\n```cpp\r\nstd::string ToString() const\r\n```\r\nGet the string representation of this vertex.  \r\n获取该顶点的字符串表示。\r\n\r\n#### Private Functions\r\n```cpp\r\nVertexIterator(lgraph::graph::VertexIterator&&, const std::shared_ptr&)\r\n```\r\n\r\n```cpp\r\nVertexIterator(const VertexIterator&) = delete\r\n```\r\n\r\n```cpp\r\nVertexIterator &operator=(const VertexIterator&) = delete\r\n```\r\n\r\n#### Private Members\r\n```cpp\r\nstd::unique_ptr it_\r\n```\r\n\r\n```cpp\r\nstd::shared_ptr txn_\r\n```\r\n\r\n#### Friends\r\nfriend class Transaction\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## olap_base\r\n\r\n这是TuGraph图分析引擎的实现。图分析引擎是一个通用的处理引擎，适用于实现各种图分析算法，例如PageRank、ShortestPath等。\r\n\r\n### Defines\r\n- **THREAD_WORKING**  \r\n  - 线程工作模式。\r\n  \r\n- **THREAD_STEALING**  \r\n  - 线程窃取模式。\r\n\r\n- **VERTEX_BATCH_SIZE**  \r\n  - 顶点批处理大小。\r\n\r\n- **WORD_OFFSET(i)**  \r\n  - 字的偏移量宏定义。\r\n\r\n- **BIT_OFFSET(i)**  \r\n  - 位的偏移量宏定义。\r\n\r\n### Functions\n\n该块内容位于文档中关于`VertexIterator`类的描述部分之后，介绍了`VertexIterator`的公共函数、私有函数和私有成员，以及其友元类。同时，该内容也引出了后续的`olap_base`部分，讨论了TuGraph图分析引擎的实现及其相关定义和功能。"
            },
            {
                "content": "```\r\n\r\n#### Private Members\r\n```cpp\r\nstd::unique_ptr it_\r\n```\r\n\r\n```cpp\r\nstd::shared_ptr txn_\r\n```\r\n\r\n#### Friends\r\nfriend class Transaction\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## olap_base\r\n\r\n这是TuGraph图分析引擎的实现。图分析引擎是一个通用的处理引擎，适用于实现各种图分析算法，例如PageRank、ShortestPath等。\r\n\r\n### Defines\r\n- **THREAD_WORKING**  \r\n  - 线程工作模式。\r\n  \r\n- **THREAD_STEALING**  \r\n  - 线程窃取模式。\r\n\r\n- **VERTEX_BATCH_SIZE**  \r\n  - 顶点批处理大小。\r\n\r\n- **WORD_OFFSET(i)**  \r\n  - 字的偏移量宏定义。\r\n\r\n- **BIT_OFFSET(i)**  \r\n  - 位的偏移量宏定义。\r\n\r\n### Functions\r\n- union @5 `__attribute__ ((packed))`  \r\n  - 定义一个打包的联合体。\r\n\r\n### Variables\r\n- `size_t neighbour`  \r\n  - 邻居的数量或标识符。\r\n\r\n- `EdgeData edge_data`  \r\n  - 边的数据。\r\n\r\n- `size_t src`  \r\n  - 边的源顶点标识符。\r\n\r\n- `size_t dst`  \r\n  - 边的目的顶点标识符。\r\n\r\n### Namespaces\r\n- `namespace lgraph_api`  \r\n  - 图形API的命名空间。\r\n\r\n- `namespace olap`  \r\n  - OLAP的命名空间。\r\n\r\n#### Enums\r\n- **enum EdgeDirectionPolicy**  \r\n  定义图的边方向策略。该策略确定图的对称性和无向特性。\r\n\r\n  **Values:**\r\n  - **enumerator DUAL_DIRECTION**  \r\n    图是非对称的。输入文件中的边是出边。反向边形成入边。\n\n该块内容位于文档中关于 TuGraph 图分析引擎的实现部分，具体描述了 olap_base 的相关定义、功能以及数据结构，包括线程管理、边的数据表示以及命名空间的定义。这些内容是为图分析算法如 PageRank 和 ShortestPath 提供支持的重要组成部分。"
            },
            {
                "content": "### Functions\r\n- union @5 `__attribute__ ((packed))`  \r\n  - 定义一个打包的联合体。\r\n\r\n### Variables\r\n- `size_t neighbour`  \r\n  - 邻居的数量或标识符。\r\n\r\n- `EdgeData edge_data`  \r\n  - 边的数据。\r\n\r\n- `size_t src`  \r\n  - 边的源顶点标识符。\r\n\r\n- `size_t dst`  \r\n  - 边的目的顶点标识符。\r\n\r\n### Namespaces\r\n- `namespace lgraph_api`  \r\n  - 图形API的命名空间。\r\n\r\n- `namespace olap`  \r\n  - OLAP的命名空间。\r\n\r\n#### Enums\r\n- **enum EdgeDirectionPolicy**  \r\n  定义图的边方向策略。该策略确定图的对称性和无向特性。\r\n\r\n  **Values:**\r\n  - **enumerator DUAL_DIRECTION**  \r\n    图是非对称的。输入文件中的边是出边。反向边形成入边。\r\n  \r\n  - **enumerator MAKE_SYMMETRIC**  \r\n    图是对称的，但输入文件是非对称的。出边和入边是相同的。\r\n  \r\n  - **enumerator INPUT_SYMMETRIC**  \r\n    图和输入文件都是对称的。出边和入边是相同的。\r\n\r\n#### Functions\r\n- **template struct lgraph_api::olap::AdjUnit `__attribute__ ((packed))`**  \r\n  - 定义相邻边的结构，使用EdgeData作为权重类型。\r\n\r\n- **template<> struct lgraph_api::olap::AdjUnit< Empty > `__attribute__ ((packed))`**  \r\n  - 对于无权图的特化AdjUnit结构定义。\r\n\r\n- **template static ReducedSum reduce_plus(ReducedSum a, ReducedSum b)**  \r\n  默认的归约函数，使用加法运算符。\n\n该块内容位于文档的“olap_base”部分，主要介绍与图的边方向策略和相邻边结构相关的函数、变量和命名空间定义。这些内容对于实现图分析算法和操作具有重要意义，尤其是在处理边的连接性及其属性时。"
            },
            {
                "content": "- **enumerator MAKE_SYMMETRIC**  \r\n    图是对称的，但输入文件是非对称的。出边和入边是相同的。\r\n  \r\n  - **enumerator INPUT_SYMMETRIC**  \r\n    图和输入文件都是对称的。出边和入边是相同的。\r\n\r\n#### Functions\r\n- **template struct lgraph_api::olap::AdjUnit `__attribute__ ((packed))`**  \r\n  - 定义相邻边的结构，使用EdgeData作为权重类型。\r\n\r\n- **template<> struct lgraph_api::olap::AdjUnit< Empty > `__attribute__ ((packed))`**  \r\n  - 对于无权图的特化AdjUnit结构定义。\r\n\r\n- **template static ReducedSum reduce_plus(ReducedSum a, ReducedSum b)**  \r\n  默认的归约函数，使用加法运算符。\r\n\r\n- **template T ForEachVertex(GraphDB &db, Transaction &txn, std::vector &workers, const std::vector &vertices, std::function work, std::function reduce, size_t parallel_factor = 8)**  \r\n  遍历每个顶点并执行指定的工作。\r\n\r\n- **template std::vector ForEachVertex(GraphDB &db, Transaction &txn, std::vector &workers, const std::vector &vertices, std::function work, size_t parallel_factor = 8)**  \r\n  遍历每个顶点并生成结果向量。\r\n\r\n#### Variables\r\n- **struct lgraph_api::olap::EdgeStringUnit `__attribute__`**  \r\n  - 表示一个带有字符串类型顶点的边的结构。\n\n该块内容位于文档的\"olap_base\"部分，讨论了图分析引擎中的边约束和邻接单位的定义，以及如何遍历图中的顶点和边。具体涵盖了不同的图对称性选项及相关的函数和数据结构声明，旨在提供并行处理图数据的方法。"
            },
            {
                "content": "- **template T ForEachVertex(GraphDB &db, Transaction &txn, std::vector &workers, const std::vector &vertices, std::function work, std::function reduce, size_t parallel_factor = 8)**  \r\n  遍历每个顶点并执行指定的工作。\r\n\r\n- **template std::vector ForEachVertex(GraphDB &db, Transaction &txn, std::vector &workers, const std::vector &vertices, std::function work, size_t parallel_factor = 8)**  \r\n  遍历每个顶点并生成结果向量。\r\n\r\n#### Variables\r\n- **struct lgraph_api::olap::EdgeStringUnit `__attribute__`**  \r\n  - 表示一个带有字符串类型顶点的边的结构。\r\n\r\n- **static constexpr size_t MAX_NUM_EDGES = 1ul << 36**  \r\n  最大边数。如果需要，可以更改此值。\r\n\r\n- **template class AdjList**  \r\n  ```cpp\r\n  #include \r\n  ```\r\n  - 表示一个邻接列表的类。\r\n\r\n##### Public Functions\r\n- **inline AdjList()**  \r\n  - 默认构造函数。\r\n\r\n- **inline AdjUnit *begin()**  \r\n  - 获取邻接列表的开始迭代器。\r\n\r\n- **inline AdjUnit *end()**  \r\n  - 获取邻接列表的结束迭代器。\r\n\r\n- **inline AdjUnit &operator[](size_t i)**  \r\n  - 通过索引获取邻接单位。\r\n\r\n##### Private Functions\r\n- **inline AdjList(AdjUnit *begin, AdjUnit *end)**  \r\n  - 私有构造函数，用于初始化邻接列表。\n\n这个块包含了关于TuGraph图分析引擎中遍历顶点的函数模板`ForEachVertex`的定义，以及邻接列表的类`AdjList`的构造和成员函数。这些内容属于文档的`lgraph_traversal`和`olap_base`部分，主要涉及图的操作和结构信息，用于实现并行化的图分析算法。"
            },
            {
                "content": "- **static constexpr size_t MAX_NUM_EDGES = 1ul << 36**  \r\n  最大边数。如果需要，可以更改此值。\r\n\r\n- **template class AdjList**  \r\n  ```cpp\r\n  #include \r\n  ```\r\n  - 表示一个邻接列表的类。\r\n\r\n##### Public Functions\r\n- **inline AdjList()**  \r\n  - 默认构造函数。\r\n\r\n- **inline AdjUnit *begin()**  \r\n  - 获取邻接列表的开始迭代器。\r\n\r\n- **inline AdjUnit *end()**  \r\n  - 获取邻接列表的结束迭代器。\r\n\r\n- **inline AdjUnit &operator[](size_t i)**  \r\n  - 通过索引获取邻接单位。\r\n\r\n##### Private Functions\r\n- **inline AdjList(AdjUnit *begin, AdjUnit *end)**  \r\n  - 私有构造函数，用于初始化邻接列表。\r\n\r\n##### Private Members\r\n- `AdjUnit *begin_`  \r\n  - 邻接列表的开始指针。\r\n\r\n- `AdjUnit *end_`  \r\n  - 邻接列表的结束指针。\r\n\r\n##### Friends\r\n- **friend class OlapBase< EdgeData >**  \r\n  - 允许OlapBase作为朋友类访问内部成员。\r\n\r\n- **template struct AdjUnit**  \r\n```cpp\r\n#include \r\n```\r\nAdjUnit表示一个带有EdgeData作为权重类型的相邻边。\r\n\r\n**模板参数**  \r\nEdgeData – 边数据的类型。\r\n\r\n#### Public Members\r\n- `size_t neighbour`  \r\n  - 邻居的数量或标识符。\r\n\r\n- `EdgeData edge_data`  \r\n  - 边的数据。\r\n\r\n- **template<> struct AdjUnit**  \r\n```cpp\r\n#include \r\n```\r\n#### Public Functions\n\n该块内容位于文档的“olap_base”部分，主要介绍了邻接列表（AdjList）类及其相关功能和成员。其重点是描述如何管理和操作图中的边，尤其是与边的权重（EdgeData）相关的邻接单位（AdjUnit）。"
            },
            {
                "content": "##### Private Members\r\n- `AdjUnit *begin_`  \r\n  - 邻接列表的开始指针。\r\n\r\n- `AdjUnit *end_`  \r\n  - 邻接列表的结束指针。\r\n\r\n##### Friends\r\n- **friend class OlapBase< EdgeData >**  \r\n  - 允许OlapBase作为朋友类访问内部成员。\r\n\r\n- **template struct AdjUnit**  \r\n```cpp\r\n#include \r\n```\r\nAdjUnit表示一个带有EdgeData作为权重类型的相邻边。\r\n\r\n**模板参数**  \r\nEdgeData – 边数据的类型。\r\n\r\n#### Public Members\r\n- `size_t neighbour`  \r\n  - 邻居的数量或标识符。\r\n\r\n- `EdgeData edge_data`  \r\n  - 边的数据。\r\n\r\n- **template<> struct AdjUnit**  \r\n```cpp\r\n#include \r\n```\r\n#### Public Functions\r\n- **template<> union lgraph_api::olap::AdjUnit< Empty >::@4 `__attribute__ ((packed))`**  \r\n  - 对无权连接单位的定义。\r\n\r\n#### Public Members\r\n- `size_t neighbour`  \r\n  - 邻居的数量或标识符。\r\n\r\n- `Empty edge_data`  \r\n  - 无权边数据。\r\n\r\n- **template struct EdgeStringUnit**  \r\n```cpp\r\n#include \r\n```\r\nEdgeStringUnit表示一个带有EdgeData作为权重类型的边，顶点为字符串类型。\r\n\r\n**模板参数**  \r\nEdgeData – 边数据的类型。\r\n\r\n#### Public Members\r\n- `std::string src`  \r\n  - 源顶点的字符串形式。\r\n\r\n- `std::string dst`  \r\n  - 目标顶点的字符串形式。\r\n\r\n- `EdgeData edge_data`  \r\n  - 边的数据。\n\n该段落位于文档的“olap_base”部分，具体描述了与图的邻接列表相关的数据结构和成员，包括`AdjUnit`、`EdgeStringUnit`以及它们的公共成员和函数。此部分主要聚焦于图分析引擎的实现细节，特别是无权图和带权图的边关系数据管理。"
            },
            {
                "content": "- **template<> union lgraph_api::olap::AdjUnit< Empty >::@4 `__attribute__ ((packed))`**  \r\n  - 对无权连接单位的定义。\r\n\r\n#### Public Members\r\n- `size_t neighbour`  \r\n  - 邻居的数量或标识符。\r\n\r\n- `Empty edge_data`  \r\n  - 无权边数据。\r\n\r\n- **template struct EdgeStringUnit**  \r\n```cpp\r\n#include \r\n```\r\nEdgeStringUnit表示一个带有EdgeData作为权重类型的边，顶点为字符串类型。\r\n\r\n**模板参数**  \r\nEdgeData – 边数据的类型。\r\n\r\n#### Public Members\r\n- `std::string src`  \r\n  - 源顶点的字符串形式。\r\n\r\n- `std::string dst`  \r\n  - 目标顶点的字符串形式。\r\n\r\n- `EdgeData edge_data`  \r\n  - 边的数据。\r\n\r\n- **template struct EdgeUnit**  \r\n```cpp\r\n#include \r\n```\r\nEdgeUnit表示一个带有EdgeData作为权重类型的边。\r\n\r\n**模板参数**  \r\nEdgeData – 边数据的类型。\r\n\r\n#### Public Members\r\n- `size_t src`  \r\n  - 源顶点的标识符。\r\n\r\n- `size_t dst`  \r\n  - 目标顶点的标识符。\r\n\r\n- `EdgeData edge_data`  \r\n  - 边的数据。\r\n\r\n- **template<> struct EdgeUnit**  \r\n```cpp\r\n#include \r\n```\r\n#### Public Functions\r\n- **template<> union lgraph_api::olap::EdgeUnit< Empty >::@6 `__attribute__ ((packed))`**  \r\n  - 对于无权图的连接单位的联合定义。\r\n\r\n#### Public Members\r\n- `size_t src`  \r\n  - 源顶点的标识符。\n\n该块内容位于文档的“olap_base”部分，主要描述了与边的数据结构相关的各种定义和成员，包括无权边的连接单位和边的字符串单位。此部分详细介绍了这些结构的公共成员和功能，涉及到图的边数据处理和管理。"
            },
            {
                "content": "- **template struct EdgeUnit**  \r\n```cpp\r\n#include \r\n```\r\nEdgeUnit表示一个带有EdgeData作为权重类型的边。\r\n\r\n**模板参数**  \r\nEdgeData – 边数据的类型。\r\n\r\n#### Public Members\r\n- `size_t src`  \r\n  - 源顶点的标识符。\r\n\r\n- `size_t dst`  \r\n  - 目标顶点的标识符。\r\n\r\n- `EdgeData edge_data`  \r\n  - 边的数据。\r\n\r\n- **template<> struct EdgeUnit**  \r\n```cpp\r\n#include \r\n```\r\n#### Public Functions\r\n- **template<> union lgraph_api::olap::EdgeUnit< Empty >::@6 `__attribute__ ((packed))`**  \r\n  - 对于无权图的连接单位的联合定义。\r\n\r\n#### Public Members\r\n- `size_t src`  \r\n  - 源顶点的标识符。\r\n\r\n- `size_t dst`  \r\n  - 目标顶点的标识符。\r\n\r\n- `Empty edge_data`  \r\n  - 无权边数据。\r\n\r\n- **struct Empty**  \r\n```cpp\r\n#include \r\n```\r\nEmpty用于表示无权图。\r\n\r\n- **template class OlapBase**  \r\n```cpp\r\n#include \r\n```\r\nAdjList允许对AdjUnit进行基于范围的循环。\r\n\r\n**Graph**\r\n\r\nEdgeData用于表示边的权重（默认类型是Empty，表示无权图）。\r\n\r\n**模板参数**  \r\nEdgeData – 边数据的类型。\r\n\r\nEdgeData – 图实例表示从txt文件加载的静态（子）图。内部组织使用压缩稀疏矩阵格式，优化了只读访问。\r\n\r\n**EdgeData** – 边数据的类型。\r\n\r\n**Subclassed by** OlapOnDB< EdgeData >\r\n\r\n#### Public Functions\r\n\r\n- **inline OlapBase()**  \r\n  - 图的构造函数。\n\n该段内容位于文档的“olap_base”部分，主要介绍了与边相关的数据结构和类，如 `EdgeUnit` 和 `EdgeData`。它定义了表示具有权重的边的结构，并描述了如何使用这些结构进行图的遍历与分析，特别是在 TuGraph 的 OLAP 接口下。"
            },
            {
                "content": "- `size_t dst`  \r\n  - 目标顶点的标识符。\r\n\r\n- `Empty edge_data`  \r\n  - 无权边数据。\r\n\r\n- **struct Empty**  \r\n```cpp\r\n#include \r\n```\r\nEmpty用于表示无权图。\r\n\r\n- **template class OlapBase**  \r\n```cpp\r\n#include \r\n```\r\nAdjList允许对AdjUnit进行基于范围的循环。\r\n\r\n**Graph**\r\n\r\nEdgeData用于表示边的权重（默认类型是Empty，表示无权图）。\r\n\r\n**模板参数**  \r\nEdgeData – 边数据的类型。\r\n\r\nEdgeData – 图实例表示从txt文件加载的静态（子）图。内部组织使用压缩稀疏矩阵格式，优化了只读访问。\r\n\r\n**EdgeData** – 边数据的类型。\r\n\r\n**Subclassed by** OlapOnDB< EdgeData >\r\n\r\n#### Public Functions\r\n\r\n- **inline OlapBase()**  \r\n  - 图的构造函数。\r\n\r\n- **inline virtual bool CheckKillThisTask()**  \r\n  - 检查是否需要终止此任务。\r\n\r\n- **inline size_t OutDegree(size_t vid)**  \r\n  - 访问某个顶点的出度。\r\n  \r\n  **参数**  \r\n  vid – 要访问的顶点ID（在图中）。\r\n\r\n  **返回**  \r\n  指定顶点在图中的出度。\r\n\r\n- **inline size_t InDegree(size_t vid)**  \r\n  - 访问某个顶点的入度。\r\n\r\n  **参数**  \r\n  vid – 要访问的顶点ID（在图中）。\r\n\r\n  **返回**  \r\n  指定顶点在图中的入度。\r\n\r\n- **inline AdjList OutEdges(size_t vid)**  \r\n  - 访问某个顶点的出边。\r\n\r\n  **参数**  \r\n  vid – 要访问的顶点ID（在图中）。\r\n\r\n  **返回**  \r\n  指定顶点在图中的出边。\r\n\r\n- **inline AdjList InEdges(size_t vid)**\n\n该段落位于有关TuGraph图分析引擎的文档中，具体描述了与无权图相关的结构体和类的定义，包括 `EdgeData` 和 `OlapBase`类的构造函数及其公共函数。这里强调了处理顶点的入度和出度的功能，以及如何访问和操作与边相关的数据。这部分内容对于理解引擎如何处理无权边的结构和行为非常重要。"
            },
            {
                "content": "- **inline virtual bool CheckKillThisTask()**  \r\n  - 检查是否需要终止此任务。\r\n\r\n- **inline size_t OutDegree(size_t vid)**  \r\n  - 访问某个顶点的出度。\r\n  \r\n  **参数**  \r\n  vid – 要访问的顶点ID（在图中）。\r\n\r\n  **返回**  \r\n  指定顶点在图中的出度。\r\n\r\n- **inline size_t InDegree(size_t vid)**  \r\n  - 访问某个顶点的入度。\r\n\r\n  **参数**  \r\n  vid – 要访问的顶点ID（在图中）。\r\n\r\n  **返回**  \r\n  指定顶点在图中的入度。\r\n\r\n- **inline AdjList OutEdges(size_t vid)**  \r\n  - 访问某个顶点的出边。\r\n\r\n  **参数**  \r\n  vid – 要访问的顶点ID（在图中）。\r\n\r\n  **返回**  \r\n  指定顶点在图中的出边。\r\n\r\n- **inline AdjList InEdges(size_t vid)**  \r\n  - 访问某个顶点的入边。\r\n\r\n  **参数**  \r\n  vid – 要访问的顶点ID（在图中）。\r\n\r\n  **返回**  \r\n  指定顶点在图中的入边。\r\n\r\n- **inline void Transpose()**  \r\n  - 转置图。\r\n\r\n- **inline size_t NumVertices()**  \r\n  - 获取图中顶点的数量。\r\n\r\n  **返回**  \r\n  图中顶点的数量。\r\n\r\n- **inline size_t NumEdges()**  \r\n  - 获取图中边的数量。\r\n\r\n  **返回**  \r\n  图中边的数量。\r\n\r\n- **template inline ParallelVector AllocVertexArray()**  \r\n  - 分配一个类型为VertexData的顶点数组。\r\n\r\n  **模板参数**  \r\n  VertexData – 顶点数据的类型。\r\n\r\n  **返回**  \r\n  返回一个类型为VertexData的ParallelVector。\n\n该部分内容位于文档的“olap_base”部分，描述了在TuGraph图分析引擎中用于图遍历的功能，具体包含了对顶点的出度和入度的访问、邻接边的访问、图的转置及顶点和边的数量获取等操作。这些函数是实现图算法所需的基本操作，为用户提供了对图结构的直接操作接口。"
            },
            {
                "content": "- 访问某个顶点的入边。\r\n\r\n  **参数**  \r\n  vid – 要访问的顶点ID（在图中）。\r\n\r\n  **返回**  \r\n  指定顶点在图中的入边。\r\n\r\n- **inline void Transpose()**  \r\n  - 转置图。\r\n\r\n- **inline size_t NumVertices()**  \r\n  - 获取图中顶点的数量。\r\n\r\n  **返回**  \r\n  图中顶点的数量。\r\n\r\n- **inline size_t NumEdges()**  \r\n  - 获取图中边的数量。\r\n\r\n  **返回**  \r\n  图中边的数量。\r\n\r\n- **template inline ParallelVector AllocVertexArray()**  \r\n  - 分配一个类型为VertexData的顶点数组。\r\n\r\n  **模板参数**  \r\n  VertexData – 顶点数据的类型。\r\n\r\n  **返回**  \r\n  返回一个类型为VertexData的ParallelVector。\r\n\r\n- **inline ParallelBitset AllocVertexSubset()**  \r\n  - 分配一个由ParallelBitset表示的顶点子集。\r\n\r\n  **返回**  \r\n  返回大小为|V|的图的ParallelBitset。\r\n\r\n- **inline void AcquireVertexLock(size_t vid)**  \r\n  - 锁定某个顶点以确保并发更新的正确性。\r\n\r\n  **参数**  \r\n  vid – 要锁定的顶点ID（在图中）。\r\n\r\n- **inline void ReleaseVertexLock(size_t vid)**\r\n  - Unlock some vertex to ensure correct concurrent updates.  // 解锁某个顶点以确保正确的并发更新。\r\n\r\n  **参数**  \r\n  vid – The vertex id (in the Graph) to unlock.  // 要解锁的顶点ID（在图中）。\r\n\r\n- **inline VertexLockGuard GuardVertexLock(size_t vid)**\n\n该块内容主要涉及 TuGraph 的图操作，包括访问某个顶点的入边、获取图中顶点和边的数量、分配顶点数组和顶点子集的函数，以及用于确保并发更新正确性的锁定相关函数。这些函数和操作是图分析和遍历过程中不可或缺的部分，尤其是在多线程环境中。"
            },
            {
                "content": "- 分配一个由ParallelBitset表示的顶点子集。\r\n\r\n  **返回**  \r\n  返回大小为|V|的图的ParallelBitset。\r\n\r\n- **inline void AcquireVertexLock(size_t vid)**  \r\n  - 锁定某个顶点以确保并发更新的正确性。\r\n\r\n  **参数**  \r\n  vid – 要锁定的顶点ID（在图中）。\r\n\r\n- **inline void ReleaseVertexLock(size_t vid)**\r\n  - Unlock some vertex to ensure correct concurrent updates.  // 解锁某个顶点以确保正确的并发更新。\r\n\r\n  **参数**  \r\n  vid – The vertex id (in the Graph) to unlock.  // 要解锁的顶点ID（在图中）。\r\n\r\n- **inline VertexLockGuard GuardVertexLock(size_t vid)**\r\n  - Get a VertexLockGuard of some vertex.  // 获取某个顶点的 VertexLockGuard。\r\n\r\n  **参数**  \r\n  vid – The vertex id (in the Graph) to lock/unlock.  // 要锁定/解锁的顶点ID（在图中）。\r\n\r\n  **返回**  \r\n  A VertexLockGuard corresponding to the specified vertex.  // 与指定顶点对应的 VertexLockGuard。\r\n\r\n- **inline bool IfSparse(ParallelBitset &active_vertices)**\r\n  - Judging whether it is sparse mode or dense mode according to the number of vertices.  // 根据顶点的数量判断是稀疏模式还是密集模式。\r\n\r\n  **参数**  \r\n  active_vertices – The ParallelBitset of active_vertices.  // 活动顶点的 ParallelBitset。\n\n这段内容位于文档的`olap_base`部分，主要涉及并发控制和顶点锁定机制，包括如何分配顶点子集、锁定和解锁顶点以确保并发更新的正确性，以及判断图的稀疏性。"
            },
            {
                "content": "**参数**  \r\n  vid – The vertex id (in the Graph) to lock/unlock.  // 要锁定/解锁的顶点ID（在图中）。\r\n\r\n  **返回**  \r\n  A VertexLockGuard corresponding to the specified vertex.  // 与指定顶点对应的 VertexLockGuard。\r\n\r\n- **inline bool IfSparse(ParallelBitset &active_vertices)**\r\n  - Judging whether it is sparse mode or dense mode according to the number of vertices.  // 根据顶点的数量判断是稀疏模式还是密集模式。\r\n\r\n  **参数**  \r\n  active_vertices – The ParallelBitset of active_vertices.  // 活动顶点的 ParallelBitset。\r\n\r\n- **inline void set_num_vertices(size_t vertices)**\r\n  - Assign vertices to the first loaded graph.  // 将顶点分配给第一个加载的图形。\r\n\r\n  **参数**  \r\n  vertices – The vertex id (in the Graph) to lock/unlock.  // 要锁定/解锁的顶点ID（在图中）。\r\n\r\n- **inline void LoadFromArray(char *edge_array, size_t input_vertices, size_t input_edges, EdgeDirectionPolicy edge_direction_policy)**\r\n  - Load graph data from edge_array.  // 从 edge_array 加载图形数据。\r\n\r\n  **参数**  \r\n  edge_array – [in] The data in this array is read into the graph.  // [输入] 此数组中的数据将读取到图形中。\n\n该块内容位于文档的关于图数据库操作的部分，具体涉及到锁定顶点、判断图的稀疏或密集模式，以及从数组加载图数据的函数声明和参数说明。这些内容属于 `OlapBase` 类和图形操作的实现细节，旨在对图形数据的管理和操作提供功能支持。"
            },
            {
                "content": "- Assign vertices to the first loaded graph.  // 将顶点分配给第一个加载的图形。\r\n\r\n  **参数**  \r\n  vertices – The vertex id (in the Graph) to lock/unlock.  // 要锁定/解锁的顶点ID（在图中）。\r\n\r\n- **inline void LoadFromArray(char *edge_array, size_t input_vertices, size_t input_edges, EdgeDirectionPolicy edge_direction_policy)**\r\n  - Load graph data from edge_array.  // 从 edge_array 加载图形数据。\r\n\r\n  **参数**  \r\n  edge_array – [in] The data in this array is read into the graph.  // [输入] 此数组中的数据将读取到图形中。  \r\n  input_vertices – The number of vertices in the input graph data.  // 输入图形数据中的顶点数量。  \r\n  input_edges – The number of edges in the input graph data.  // 输入图形数据中的边缘数量。  \r\n  edge_direction_policy – Graph data loading method.  // 图形数据加载方法。\r\n\r\n- **template inline ReducedSum ProcessVertexInRange(std::function work, size_t lower, size_t upper, ReducedSum zero = 0, std::function reduce = reduce_plus)**\r\n  - Execute a parallel-for loop in the range [lower, upper).  // 在区间 [lower, upper) 执行并行 for 循环。\r\n\r\n  **抛出**\n\n该片段位于文档中与 `OlapOnDB` 类相关的章节，主要描述图数据加载和顶点分配的函数及其参数。这些功能用于在TuGraph图分析引擎中实现从数组加载图数据和处理顶点的算法。"
            },
            {
                "content": "input_vertices – The number of vertices in the input graph data.  // 输入图形数据中的顶点数量。  \r\n  input_edges – The number of edges in the input graph data.  // 输入图形数据中的边缘数量。  \r\n  edge_direction_policy – Graph data loading method.  // 图形数据加载方法。\r\n\r\n- **template inline ReducedSum ProcessVertexInRange(std::function work, size_t lower, size_t upper, ReducedSum zero = 0, std::function reduce = reduce_plus)**\r\n  - Execute a parallel-for loop in the range [lower, upper).  // 在区间 [lower, upper) 执行并行 for 循环。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 当发生运行时错误条件时引发。\r\n\r\n  **模板参数**  \r\n  ReducedSum – Type of the reduced sum.  // 减少总和的类型。\r\n\r\n  **参数**  \r\n  work – The function describing the work.  // 描述工作的函数。  \r\n  lower – The lower bound of the range (inclusive).  // 范围的下界（包含）。  \r\n  upper – The upper bound of the range (exclusive).  // 范围的上界（不包含）。  \r\n  zero – (Optional) The initial value for reduction.  // （可选）用于缩减的初始值。\n\n该片段位于关于 TuGraph 数据加载和并行处理的部分，主要涉及从输入图形数据中获取顶点和边的数量，并介绍了如何在给定范围内执行并行计算的函数模板。这一部分旨在帮助用户理解如何有效管理图的边和顶点，并利用并行化技术提升性能。"
            },
            {
                "content": "**抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 当发生运行时错误条件时引发。\r\n\r\n  **模板参数**  \r\n  ReducedSum – Type of the reduced sum.  // 减少总和的类型。\r\n\r\n  **参数**  \r\n  work – The function describing the work.  // 描述工作的函数。  \r\n  lower – The lower bound of the range (inclusive).  // 范围的下界（包含）。  \r\n  upper – The upper bound of the range (exclusive).  // 范围的上界（不包含）。  \r\n  zero – (Optional) The initial value for reduction.  // （可选）用于缩减的初始值。  \r\n  reduce – (Optional) The function describing the reduction logic.  // （可选）描述减少逻辑的函数。\r\n\r\n  **返回**  \r\n  A reduction value.  // 一个减少值。\r\n\r\n- **template inline ReducedSum ProcessVertexInRange(std::function work, size_t lower, size_t upper, Algorithm algorithm, ReducedSum zero = 0, std::function reduce = reduce_plus)**\r\n\r\n- **template inline ReducedSum ProcessVertexActive(std::function work, ParallelBitset &active_vertices, ReducedSum zero = 0, std::function reduce = reduce_plus)**\r\n  - Process a set of active vertices in parallel.  // 并行处理一组活动顶点。\n\n该块内容位于文档的 **olap_base** 部分，主要描述了在图分析中并行处理顶点的相关函数，具体包括对顶点进行遍历和操作的模板函数，以及参数的详细说明和返回值的解释。这些信息对于实现高效的并行图计算算法至关重要。"
            },
            {
                "content": "**返回**  \r\n  A reduction value.  // 一个减少值。\r\n\r\n- **template inline ReducedSum ProcessVertexInRange(std::function work, size_t lower, size_t upper, Algorithm algorithm, ReducedSum zero = 0, std::function reduce = reduce_plus)**\r\n\r\n- **template inline ReducedSum ProcessVertexActive(std::function work, ParallelBitset &active_vertices, ReducedSum zero = 0, std::function reduce = reduce_plus)**\r\n  - Process a set of active vertices in parallel.  // 并行处理一组活动顶点。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 当发生运行时错误条件时引发。\r\n\r\n  **模板参数**  \r\n  ReducedSum – Type of the reduced sum.  // 减少总和的类型。\r\n\r\n  **参数**  \r\n  work – The function describing each vertex’s work.  // 描述每个顶点工作的函数。  \r\n  active_vertices – [inout] The active vertex set.  // [输入输出] 活动顶点集。  \r\n  zero – (Optional) The initial value for reduction.  // （可选）用于缩减的初始值。  \r\n  reduce – (Optional) The function describing the reduction logic.  // （可选）描述减少逻辑的函数。\r\n\r\n  **返回**  \r\n  A reduction value.  // 一个减少值。\n\n该块内容位于文档中与图分析引擎的并行处理相关部分，具体涉及如何在图遍历中利用 `ProcessVertexInRange` 和 `ProcessVertexActive` 函数处理活动顶点。这些函数支持并行计算并处理图中的顶点数据，主要用于提高算法效率。"
            },
            {
                "content": "**模板参数**  \r\n  ReducedSum – Type of the reduced sum.  // 减少总和的类型。\r\n\r\n  **参数**  \r\n  work – The function describing each vertex’s work.  // 描述每个顶点工作的函数。  \r\n  active_vertices – [inout] The active vertex set.  // [输入输出] 活动顶点集。  \r\n  zero – (Optional) The initial value for reduction.  // （可选）用于缩减的初始值。  \r\n  reduce – (Optional) The function describing the reduction logic.  // （可选）描述减少逻辑的函数。\r\n\r\n  **返回**  \r\n  A reduction value.  // 一个减少值。\r\n\r\n- **template inline ReducedSum ProcessVertexActive(std::function work, ParallelBitset &active_vertices, Algorithm algorithm, ReducedSum zero = 0, std::function reduce = reduce_plus)**\r\n\r\n#### Protected Functions\r\n\r\n- **inline virtual void Construct()**  // 构造函数。\r\n\r\n#### Protected Attributes\r\n\r\n- `size_t num_vertices_`  // 顶点数量。\r\n- `size_t num_edges_`  // 边的数量。\r\n- `size_t edge_data_size_`  // 边数据大小。\r\n- `size_t adj_unit_size_`  // 邻接单元大小。\r\n- `size_t edge_unit_size_`  // 边单元大小。\r\n- `EdgeDirectionPolicy edge_direction_policy_`  // 边方向策略。\r\n- `EdgeUnit *edge_list_`  // 边列表。\n\n该块内容位于文档中关于图分析引擎的部分，具体涉及TuGraph中的OLAP接口以及并行处理顶点的函数。它描述了如何使用`ProcessVertexActive`函数处理活动顶点，并涉及参数定义和返回值的说明。此信息旨在帮助用户实现并行图计算与分析。"
            },
            {
                "content": "#### Protected Functions\r\n\r\n- **inline virtual void Construct()**  // 构造函数。\r\n\r\n#### Protected Attributes\r\n\r\n- `size_t num_vertices_`  // 顶点数量。\r\n- `size_t num_edges_`  // 边的数量。\r\n- `size_t edge_data_size_`  // 边数据大小。\r\n- `size_t adj_unit_size_`  // 邻接单元大小。\r\n- `size_t edge_unit_size_`  // 边单元大小。\r\n- `EdgeDirectionPolicy edge_direction_policy_`  // 边方向策略。\r\n- `EdgeUnit *edge_list_`  // 边列表。\r\n- `ParallelVector out_degree_`  // 出度。\r\n- `ParallelVector in_degree_`  // 入度。\r\n- `ParallelVector out_index_`  // 出索引。\r\n- `ParallelVector in_index_`  // 入索引。\r\n- `ParallelVector> out_edges_`  // 出边。\r\n- `ParallelVector> in_edges_`  // 入边。\r\n- `ParallelVector lock_array_`  // 锁数组。\r\n\r\n#### class ParallelBitset\r\n\r\n```cpp\r\n#include \r\n```\r\nParallelBitset implements the concurrent bitset data structure, which is usually used to represent active vertex sets.  // ParallelBitset 实现了并发位集数据结构，通常用于表示活动顶点集。\r\n\r\n##### Public Functions\r\n\r\n- **explicit ParallelBitset(size_t size)**\r\n  - Construct a ParallelBitset.  // 构造一个 ParallelBitset。\n\n该段落位于文档中关于TuGraph图分析引擎的实现部分，主要介绍OlapBase类的保护函数和属性，以及ParallelBitset类的定义和公共函数。这些内容涉及图的构建、遍历及内存管理，是图分析和操作的重要组成部分。"
            },
            {
                "content": "- `ParallelVector in_index_`  // 入索引。\r\n- `ParallelVector> out_edges_`  // 出边。\r\n- `ParallelVector> in_edges_`  // 入边。\r\n- `ParallelVector lock_array_`  // 锁数组。\r\n\r\n#### class ParallelBitset\r\n\r\n```cpp\r\n#include \r\n```\r\nParallelBitset implements the concurrent bitset data structure, which is usually used to represent active vertex sets.  // ParallelBitset 实现了并发位集数据结构，通常用于表示活动顶点集。\r\n\r\n##### Public Functions\r\n\r\n- **explicit ParallelBitset(size_t size)**\r\n  - Construct a ParallelBitset.  // 构造一个 ParallelBitset。\r\n\r\n  **参数**  \r\n  size – The size of the bitset (i.e. the number of bits).  // 位集的大小（即位数）。\r\n\r\n- **ParallelBitset(const ParallelBitset &rhs) = delete**  // 禁止复制构造函数。\r\n\r\n- **inline ParallelBitset &operator=(ParallelBitset &&rhs)**  // 移动赋值运算符。\r\n\r\n- **inline ParallelBitset(ParallelBitset &&rhs)**  // 移动构造函数。\r\n\r\n- **inline ParallelBitset()**  // 默认构造函数。\r\n\r\n- **~ParallelBitset()**  // 析构函数。\r\n\r\n- **void Clear()**\r\n  - Clear the bitset.  // 清除位集。\r\n\r\n- **void Fill()**\r\n  - Fill the bitset.  // 填充位集。\n\n该块内容位于文档中关于TuGraph OLAP接口的部分，特别是描述了邻接列表和存储结构的实现，随后介绍了并发位集数据结构`ParallelBitset`的定义和相关公共函数，强调了如何构造并操作活动顶点集。"
            },
            {
                "content": "**参数**  \r\n  size – The size of the bitset (i.e. the number of bits).  // 位集的大小（即位数）。\r\n\r\n- **ParallelBitset(const ParallelBitset &rhs) = delete**  // 禁止复制构造函数。\r\n\r\n- **inline ParallelBitset &operator=(ParallelBitset &&rhs)**  // 移动赋值运算符。\r\n\r\n- **inline ParallelBitset(ParallelBitset &&rhs)**  // 移动构造函数。\r\n\r\n- **inline ParallelBitset()**  // 默认构造函数。\r\n\r\n- **~ParallelBitset()**  // 析构函数。\r\n\r\n- **void Clear()**\r\n  - Clear the bitset.  // 清除位集。\r\n\r\n- **void Fill()**\r\n  - Fill the bitset.  // 填充位集。\r\n\r\n- **bool Has(size_t i)**\r\n  - Test a specified bit.  // 测试指定的位。\r\n\r\n  **参数**  \r\n  i – The bit to test.  // 要测试的位。\r\n\r\n  **返回**  \r\n  Whether the bit is set or not.  // 位是否被设置。\r\n\r\n- **bool Add(size_t i)**\r\n  - Set a specified bit.  // 设置指定的位。\r\n\r\n  **参数**  \r\n  i – The bit to set.  // 要设置的位。\r\n\r\n  **返回**  \r\n  Whether the operation is a true addition or not.  // 操作是否是真正的添加。\r\n\r\n- **void Swap(ParallelBitset &other)**\r\n  - Swap the current bitset with another one.  // 将当前位集与另一个位集交换。\r\n\r\n  **参数**\n\n该内容位于文档的 `lgraph_vertex_iterator` 部分，介绍了 `ParallelBitset` 类的构造函数、成员函数和操作，主要用于处理并行计算中的位集，尤其是在图遍历和图分析过程中。"
            },
            {
                "content": "- **bool Has(size_t i)**\r\n  - Test a specified bit.  // 测试指定的位。\r\n\r\n  **参数**  \r\n  i – The bit to test.  // 要测试的位。\r\n\r\n  **返回**  \r\n  Whether the bit is set or not.  // 位是否被设置。\r\n\r\n- **bool Add(size_t i)**\r\n  - Set a specified bit.  // 设置指定的位。\r\n\r\n  **参数**  \r\n  i – The bit to set.  // 要设置的位。\r\n\r\n  **返回**  \r\n  Whether the operation is a true addition or not.  // 操作是否是真正的添加。\r\n\r\n- **void Swap(ParallelBitset &other)**\r\n  - Swap the current bitset with another one.  // 将当前位集与另一个位集交换。\r\n\r\n  **参数**  \r\n  other – [inout] The other bitset to swap with.  // [输入输出] 另一个待交换的位集。\r\n\r\n- **inline uint64_t *Data()**  // 获取数据指针。\r\n\r\n- **inline size_t Size()**  // 获取当前大小。\r\n\r\n##### Private Members\r\n\r\n- `uint64_t *data_`  // 数据指针。\r\n- `size_t size_`  // 大小。\r\n\r\n---\r\n\r\n#### template class ParallelVector\r\n\r\n```cpp\r\n#include \r\n```\r\nParallelVector aims to mimic std::vector. Note that the deletions other than clearing are not supported.  // ParallelVector 旨在模拟 std::vector。请注意，除了清除外，不支持其他删除操作。\r\n\r\n##### Public Functions\n\n该块位于文档的“lgraph_utils”部分，具体介绍了 `ParallelBitset` 类的公共函数和私有成员。`ParallelBitset` 负责实现并发位集数据结构，常用于表示活动顶点集，相关函数包括测试和设置位的方法，以及获取数据指针和大小的函数。该部分内容为图形数据处理的并发操作提供了基础。"
            },
            {
                "content": "other – [inout] The other bitset to swap with.  // [输入输出] 另一个待交换的位集。\r\n\r\n- **inline uint64_t *Data()**  // 获取数据指针。\r\n\r\n- **inline size_t Size()**  // 获取当前大小。\r\n\r\n##### Private Members\r\n\r\n- `uint64_t *data_`  // 数据指针。\r\n- `size_t size_`  // 大小。\r\n\r\n---\r\n\r\n#### template class ParallelVector\r\n\r\n```cpp\r\n#include \r\n```\r\nParallelVector aims to mimic std::vector. Note that the deletions other than clearing are not supported.  // ParallelVector 旨在模拟 std::vector。请注意，除了清除外，不支持其他删除操作。\r\n\r\n##### Public Functions\r\n\r\n- **inline explicit ParallelVector(size_t capacity)**\r\n  - Construct a ParallelVector.  // 构造一个 ParallelVector。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 当发生运行时错误条件时引发。\r\n\r\n  **参数**  \r\n  capacity – The capacity of the vector.  // 向量的容量。\r\n\r\n- **inline explicit ParallelVector(size_t capacity, size_t size)**\r\n  - Construct a ParallelVector.  // 构造一个 ParallelVector。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 当发生运行时错误条件时引发。\n\n该代码块位于文档的 \"lgraph_utils\" 部分，具体描述了 `ParallelBitset` 类的详细实现，其中包括公有函数、私有成员和用于模拟 std::vector 的 `ParallelVector` 类的构造函数以及相关错误处理。这部分内容主要关注并发位集数据结构的操作和内存管理。"
            },
            {
                "content": "- Construct a ParallelVector.  // 构造一个 ParallelVector。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 当发生运行时错误条件时引发。\r\n\r\n  **参数**  \r\n  capacity – The capacity of the vector.  // 向量的容量。\r\n\r\n- **inline explicit ParallelVector(size_t capacity, size_t size)**\r\n  - Construct a ParallelVector.  // 构造一个 ParallelVector。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 当发生运行时错误条件时引发。\r\n\r\n  **参数**  \r\n  capacity – The capacity of the vector.  // 向量的容量。  \r\n  size – The initial size of the vector.  // 向量的初始大小。\r\n\r\n- **inline ParallelVector(T *data, size_t size)**\r\n  - Construct a ParallelVector.  // 构造一个 ParallelVector。\r\n\r\n  **参数**  \r\n  data – The initial data of the vector.  // 向量的初始数据。  \r\n  size – The initial size of the vector. And the initial capacity equals initial size.  // 向量的初始大小，初始容量等于初始大小。\r\n\r\n- **ParallelVector(const ParallelVector &rhs) = delete**  // 禁止复制构造函数。\r\n\r\n- **inline ParallelVector(ParallelVector &&rhs)**  // 移动构造函数。\n\n该块内容位于文档的 \"olap_base\" 部分，具体描述了 `ParallelVector` 类的构造函数，包括不同构造函数的参数、返回值以及异常处理。这些构造函数用于初始化一个并行向量，以支持并行计算和图分析。"
            },
            {
                "content": "size – The initial size of the vector.  // 向量的初始大小。\r\n\r\n- **inline ParallelVector(T *data, size_t size)**\r\n  - Construct a ParallelVector.  // 构造一个 ParallelVector。\r\n\r\n  **参数**  \r\n  data – The initial data of the vector.  // 向量的初始数据。  \r\n  size – The initial size of the vector. And the initial capacity equals initial size.  // 向量的初始大小，初始容量等于初始大小。\r\n\r\n- **ParallelVector(const ParallelVector &rhs) = delete**  // 禁止复制构造函数。\r\n\r\n- **inline ParallelVector(ParallelVector &&rhs)**  // 移动构造函数。\r\n\r\n- **inline ParallelVector &operator=(ParallelVector &&rhs)**  // 移动赋值运算符。\r\n\r\n- **inline ParallelVector()**\r\n  - Default constructor of ParallelVector.  // ParallelVector 的默认构造函数。\r\n\r\n- **inline void Destroy()**\r\n  - Destroy ParallelVector.  // 销毁 ParallelVector。\r\n\r\n- **inline ~ParallelVector()**  // 析构函数。\r\n\r\n- **inline T &operator[](size_t i)**  // 重载下标运算符。\r\n\r\n- **inline T *begin()**  // 返回开始迭代器。\r\n\r\n- **inline T *end()**  // 返回结束迭代器。\r\n\r\n- **inline T &Back()**  // 返回最后一个元素。\r\n\r\n- **inline T *Data()**  // 返回数据指针。\n\n该块内容属于文档中的数据结构部分，详细描述了`ParallelVector`类的构造函数、成员函数以及相关参数。`ParallelVector`类用于实现并发向量，支持扩展和操作，以便于处理图形数据的存储和访问。在此上下文中，它强调了如何创建和管理动态大小的向量，以支持在图分析中存储和操作多个数据元素。"
            },
            {
                "content": "- **inline ParallelVector()**\r\n  - Default constructor of ParallelVector.  // ParallelVector 的默认构造函数。\r\n\r\n- **inline void Destroy()**\r\n  - Destroy ParallelVector.  // 销毁 ParallelVector。\r\n\r\n- **inline ~ParallelVector()**  // 析构函数。\r\n\r\n- **inline T &operator[](size_t i)**  // 重载下标运算符。\r\n\r\n- **inline T *begin()**  // 返回开始迭代器。\r\n\r\n- **inline T *end()**  // 返回结束迭代器。\r\n\r\n- **inline T &Back()**  // 返回最后一个元素。\r\n\r\n- **inline T *Data()**  // 返回数据指针。\r\n\r\n- **inline size_t Size()**  // 返回当前大小。\r\n\r\n- **inline size_t Capacity()**  // 返回容量。\r\n\r\n- **inline bool Destroyed()**  // 检查是否被销毁。\r\n\r\n- **inline void Resize(size_t size)**\r\n  - Change ParallelVector size. Note the new size should be larger than or equal to elder size.  // 改变 ParallelVector 的大小。注意新大小应大于或等于旧大小。\r\n\r\n  **参数**  \r\n  size – Value of new size.  // 新大小的值。\r\n\r\n- **inline void Resize(size_t size, const T &elem)**\r\n  - Change ParallelVector size and initialize the new element with elem. Note the new size should be larger than or equal to elder size.\n\n该代码块位于文档中与 `ParallelVector` 类相关的部分，描述其构造函数、析构函数、属性访问器、重载操作符和大小管理方法。`ParallelVector` 类用于实现并发的动态数组，能够处理大型图数据结构中的活跃顶点集合，支持高效的内存管理和元素操作。"
            },
            {
                "content": "- **inline bool Destroyed()**  // 检查是否被销毁。\r\n\r\n- **inline void Resize(size_t size)**\r\n  - Change ParallelVector size. Note the new size should be larger than or equal to elder size.  // 改变 ParallelVector 的大小。注意新大小应大于或等于旧大小。\r\n\r\n  **参数**  \r\n  size – Value of new size.  // 新大小的值。\r\n\r\n- **inline void Resize(size_t size, const T &elem)**\r\n  - Change ParallelVector size and initialize the new element with elem. Note the new size should be larger than or equal to elder size.  \r\n  - 改变 ParallelVector 的大小，并用 elem 初始化新元素。注意新大小应该大于或等于旧大小。\r\n\r\n  **参数**  \r\n  size – Value of new size.  // 新大小的值  \r\n  elem – Initial value of new-added element.  // 新添加元素的初始值\r\n\r\n- **inline void Clear()**\r\n  - Clear all data and change size to 0.  \r\n  - 清除所有数据并将大小设置为 0。\r\n\r\n- **inline void ReAlloc(size_t capacity)**\r\n  - Destroy elder data and allocate with new capacity.  \r\n  - 销毁旧数据并分配新的容量。\r\n\r\n  **参数**  \r\n  capacity – New capacity value.  // 新的容量值\r\n\r\n- **inline void Fill(T elem)**\r\n  - Assign the vector’s elements with a common value.\n\n此代码块位于文档的“ParallelVector”类中，该类旨在实现并发的向量数据结构，通常用于高效管理和操作动态数组。代码块具体描述了该类的一些成员函数，包括大小调整、数据清除和内存重新分配等功能。这些操作是确保向量在处理数据时能够灵活和高效的重要部分。"
            },
            {
                "content": "**参数**  \r\n  size – Value of new size.  // 新大小的值  \r\n  elem – Initial value of new-added element.  // 新添加元素的初始值\r\n\r\n- **inline void Clear()**\r\n  - Clear all data and change size to 0.  \r\n  - 清除所有数据并将大小设置为 0。\r\n\r\n- **inline void ReAlloc(size_t capacity)**\r\n  - Destroy elder data and allocate with new capacity.  \r\n  - 销毁旧数据并分配新的容量。\r\n\r\n  **参数**  \r\n  capacity – New capacity value.  // 新的容量值\r\n\r\n- **inline void Fill(T elem)**\r\n  - Assign the vector’s elements with a common value.  \r\n  - 将向量的元素赋值为一个公共值。\r\n\r\n  **参数**  \r\n  elem – The common value.  // 公共值\r\n\r\n  This action is performed in parallel, so you should not call it inside another parallel region (via Worker::Delegate).  \r\n  - 该操作是并行执行的，因此您不应在另一个并行区域内部调用它（通过 Worker::Delegate）。\r\n\r\n- **inline void Append(const T &elem, bool atomic = true)**\r\n  - Append an element to the vector.  \r\n  - 将一个元素附加到向量中。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 在发生运行时错误条件时引发。\r\n\r\n  **参数**  \r\n  elem – The element.  // 元素\n\n此块内容位于文档的 `ParallelVector` 类定义部分，描述了该类的公共函数，包括构造函数、清除、重新分配、填充和追加元素等操作。这些函数用于管理并行向量的数据结构，适用于图形数据库相关的多线程并行计算。"
            },
            {
                "content": "**参数**  \r\n  elem – The common value.  // 公共值\r\n\r\n  This action is performed in parallel, so you should not call it inside another parallel region (via Worker::Delegate).  \r\n  - 该操作是并行执行的，因此您不应在另一个并行区域内部调用它（通过 Worker::Delegate）。\r\n\r\n- **inline void Append(const T &elem, bool atomic = true)**\r\n  - Append an element to the vector.  \r\n  - 将一个元素附加到向量中。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 在发生运行时错误条件时引发。\r\n\r\n  **参数**  \r\n  elem – The element.  // 元素  \r\n  atomic – (Optional) Whether atomic instructions should be used or not.  // （可选）是否使用原子指令。\r\n\r\n- **inline void Append(T *buf, size_t count, bool atomic = true)**\r\n  - Append an array of elements to the vector.  \r\n  - 将一组元素附加到向量中。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 在发生运行时错误条件时引发。\r\n\r\n  **参数**  \r\n  buf – [inout] The array pointer.  // [输入输出] 数组指针  \r\n  count – The array length.  // 数组长度  \r\n  atomic – (Optional) True to atomic.  // （可选）是否为真以使用原子操作。\n\n该块内容位于文档的“olap_base”部分，具体描述了 `ParallelVector` 类的公共函数，包括用于向向量中添加单个元素和数组的 `Append` 方法，其中提到并行处理和相关参数的使用。这些方法可用于图形数据库中处理边和顶点数据的过程。"
            },
            {
                "content": "atomic – (Optional) Whether atomic instructions should be used or not.  // （可选）是否使用原子指令。\r\n\r\n- **inline void Append(T *buf, size_t count, bool atomic = true)**\r\n  - Append an array of elements to the vector.  \r\n  - 将一组元素附加到向量中。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 在发生运行时错误条件时引发。\r\n\r\n  **参数**  \r\n  buf – [inout] The array pointer.  // [输入输出] 数组指针  \r\n  count – The array length.  // 数组长度  \r\n  atomic – (Optional) True to atomic.  // （可选）是否为真以使用原子操作。\r\n\r\n- **inline void Append(ParallelVector &other, bool atomic = true)**\r\n  - Append another vector of elements to this.  \r\n  - 将另一个元素向量附加到此向量。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 在发生运行时错误条件时引发。\r\n\r\n  **参数**  \r\n  other – [inout] The other vector.  // [输入输出] 另一个向量  \r\n  atomic – (Optional) True to atomic.  // （可选）是否为真以使用原子操作。\r\n\r\n- **inline void Swap(ParallelVector &other)**\r\n  - Swap the current vector with another one.  \r\n  - 将当前向量与另一个向量交换。\r\n\r\n  **参数**\n\n该块内容位于文档的 **olap_base** 部分，主要描述了并行向量（ParallelVector）类的公共函数，包括向向量追加元素的功能和与其他向量交换的操作。这些函数支持在高性能计算中高效管理和操作元素，适用于图分析等应用。"
            },
            {
                "content": "- **inline void Append(ParallelVector &other, bool atomic = true)**\r\n  - Append another vector of elements to this.  \r\n  - 将另一个元素向量附加到此向量。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.  // 在发生运行时错误条件时引发。\r\n\r\n  **参数**  \r\n  other – [inout] The other vector.  // [输入输出] 另一个向量  \r\n  atomic – (Optional) True to atomic.  // （可选）是否为真以使用原子操作。\r\n\r\n- **inline void Swap(ParallelVector &other)**\r\n  - Swap the current vector with another one.  \r\n  - 将当前向量与另一个向量交换。\r\n\r\n  **参数**  \r\n  other – [inout] The other vector to swap with.  // [输入输出] 要交换的另一个向量\r\n\r\n- **inline ParallelVector Copy()**\r\n  - Copy the current vector.  \r\n  - 复制当前向量。\r\n\r\n  **返回**  \r\n  A new vector with the same copied content.  // 一个新的向量，具有相同的复制内容。\r\n\r\n##### Private Members\r\n\r\n- `bool destroyed_`\r\n- `size_t capacity_`\r\n- `T *data_`\r\n- `size_t size_`\r\n\r\n---\r\n\r\n#### struct ThreadState\r\n\r\n```cpp\r\n#include \r\n```\r\n\r\n##### Public Members\r\n\r\n- `size_t curr`\r\n- `size_t end`\r\n- `int state`\r\n\r\n---\r\n\r\n#### class VertexLockGuard\n\n该代码块位于文档的 `olap_on_db` 部分，涉及 `ParallelVector` 类的公共函数和私有成员。`ParallelVector` 类用于实现一个并行向量数据结构，支持向量元素的添加、交换和复制等操作，适用于在图分析中处理大规模数据。这一部分突出了向量操作的基本功能和内存管理，关键功能包括元素附加和并行性能优化。"
            },
            {
                "content": "other – [inout] The other vector to swap with.  // [输入输出] 要交换的另一个向量\r\n\r\n- **inline ParallelVector Copy()**\r\n  - Copy the current vector.  \r\n  - 复制当前向量。\r\n\r\n  **返回**  \r\n  A new vector with the same copied content.  // 一个新的向量，具有相同的复制内容。\r\n\r\n##### Private Members\r\n\r\n- `bool destroyed_`\r\n- `size_t capacity_`\r\n- `T *data_`\r\n- `size_t size_`\r\n\r\n---\r\n\r\n#### struct ThreadState\r\n\r\n```cpp\r\n#include \r\n```\r\n\r\n##### Public Members\r\n\r\n- `size_t curr`\r\n- `size_t end`\r\n- `int state`\r\n\r\n---\r\n\r\n#### class VertexLockGuard\r\n\r\n```cpp\r\n#include \r\n```\r\nThe VertexLockGuard automatically acquires the lock on construction and releases the lock on destruction.  \r\n- VertexLockGuard是一个机制，用于控制程序对点数据的访存权限。\r\n\r\n##### Public Functions\r\n\r\n- **explicit VertexLockGuard(volatile bool *lock)**\r\n\r\n- **VertexLockGuard(const VertexLockGuard &rhs) = delete**\r\n\r\n- **VertexLockGuard(VertexLockGuard &&rhs) = default**\r\n\r\n- **~VertexLockGuard()**\r\n\r\n##### Private Members\r\n\r\n- `bool *lock_`\r\n\r\n---\r\n\r\n#### class Worker\r\n\r\n```cpp\r\n#include \r\n```\n\n此片段位于文档的 `olap_on_db` 部分，涉及 `ParallelVector` 类的定义及其相关功能，包括构造函数、复制方法、私有成员和 `VertexLockGuard` 类的相关内容。此部分讨论了图数据分析过程中的向量管理和线程安全问题。"
            },
            {
                "content": "```cpp\r\n#include \r\n```\r\nThe VertexLockGuard automatically acquires the lock on construction and releases the lock on destruction.  \r\n- VertexLockGuard是一个机制，用于控制程序对点数据的访存权限。\r\n\r\n##### Public Functions\r\n\r\n- **explicit VertexLockGuard(volatile bool *lock)**\r\n\r\n- **VertexLockGuard(const VertexLockGuard &rhs) = delete**\r\n\r\n- **VertexLockGuard(VertexLockGuard &&rhs) = default**\r\n\r\n- **~VertexLockGuard()**\r\n\r\n##### Private Members\r\n\r\n- `bool *lock_`\r\n\r\n---\r\n\r\n#### class Worker\r\n\r\n```cpp\r\n#include \r\n```\r\nAll the parallel tasks should be delegated through Worker to prevent a huge number of threads being populated via OpenMP.  \r\n- 所有并行任务应通过 Worker 委托，以防止通过 OpenMP 创建大量线程。\r\n\r\n##### Public Functions\r\n\r\n- **Worker()**\r\n\r\n- **~Worker()**\r\n\r\n- **void Delegate(const std::function &work)**\r\n  - Send some work to the Worker instance.  \r\n  - 向 Worker 实例发送一些工作。\r\n\r\n  **参数**  \r\n  work – The function describing the work.  // 描述工作的函数\n\n该文本块位于文档的“lgraph”命名空间下，主要介绍了`VertexLockGuard`和`Worker`类。这些类用于管理并发访问和任务分配，确保在图数据库中的操作安全且高效。`VertexLockGuard`负责控制对顶点数据的访问权限，而`Worker`则用于处理并行任务，以避免创建过多线程。"
            },
            {
                "content": "- `bool *lock_`\r\n\r\n---\r\n\r\n#### class Worker\r\n\r\n```cpp\r\n#include \r\n```\r\nAll the parallel tasks should be delegated through Worker to prevent a huge number of threads being populated via OpenMP.  \r\n- 所有并行任务应通过 Worker 委托，以防止通过 OpenMP 创建大量线程。\r\n\r\n##### Public Functions\r\n\r\n- **Worker()**\r\n\r\n- **~Worker()**\r\n\r\n- **void Delegate(const std::function &work)**\r\n  - Send some work to the Worker instance.  \r\n  - 向 Worker 实例发送一些工作。\r\n\r\n  **参数**  \r\n  work – The function describing the work.  // 描述工作的函数\r\n\r\n  Exceptions can be thrown in the work function if necessary. Note that Delegate cannot be nested.  \r\n  - 如果需要，可以在工作函数中抛出异常。请注意，Delegate 不能嵌套。\r\n\r\n- **template inline void DelegateCompute(const std::function &work, Compute &compute)**\r\n\r\n##### Public Static Functions\r\n\r\n- **static std::shared_ptr &SharedWorker()**\r\n  - Get the global (shared) worker.  \r\n  - 获取全局（共享） Worker。\r\n\r\n  **返回**  \r\n  A shared pointer to the global Worker instance.  // 指向全局 Worker 实例的共享指针。\r\n\r\n##### Private Members\r\n\r\n- `bool stopping_`\n\n该内容位于文档的 \"lgraph\" 部分，其中详细介绍了TuGraph的并行任务处理机制。具体包含了Worker类的定义，Worker类用于管理并发任务并避免通过OpenMP创建大量线程。此段落强调了Worker的公共函数以及私有成员，讲解了如何将任务委托给Worker实例。"
            },
            {
                "content": "- 如果需要，可以在工作函数中抛出异常。请注意，Delegate 不能嵌套。\r\n\r\n- **template inline void DelegateCompute(const std::function &work, Compute &compute)**\r\n\r\n##### Public Static Functions\r\n\r\n- **static std::shared_ptr &SharedWorker()**\r\n  - Get the global (shared) worker.  \r\n  - 获取全局（共享） Worker。\r\n\r\n  **返回**  \r\n  A shared pointer to the global Worker instance.  // 指向全局 Worker 实例的共享指针。\r\n\r\n##### Private Members\r\n\r\n- `bool stopping_`\r\n- `bool has_work_`\r\n- `std::mutex mutex_`\r\n- `std::condition_variable cv_`\r\n- `std::shared_ptr> task_`\r\n- `std::thread worker_`\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## olap_on_db\r\n\r\nTuGraph OLAP interface. To implement a plugin that performs graph analytics on TuGraph, users can load a Snapshot from the database and then use the Gather-Apply-Scatter style interface to do the computation.\r\n\r\nTuGraph OLAP 接口。要实现一个在 TuGraph 上执行图分析的插件，用户可以从数据库加载一个快照，然后使用 Gather-Apply-Scatter 风格的接口进行计算。\r\n\r\n```cpp\r\nnamespace lgraph_api\r\nnamespace olap\r\n```\r\n\r\n### Variables\r\n\r\n- **static constexpr size_t SNAPSHOT_PARALLEL = 1ul << 0**\n\n该块内容位于文档的 \"olap_on_db\" 部分，主要讨论了 TuGraph OLAP 接口及插件的实现，特别是如何在数据分析过程中使用全局工作者和线程管理。它涉及到 Delegate 方法的使用，以及如何处理并行任务和内存管理。"
            },
            {
                "content": "- `std::thread worker_`\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## olap_on_db\r\n\r\nTuGraph OLAP interface. To implement a plugin that performs graph analytics on TuGraph, users can load a Snapshot from the database and then use the Gather-Apply-Scatter style interface to do the computation.\r\n\r\nTuGraph OLAP 接口。要实现一个在 TuGraph 上执行图分析的插件，用户可以从数据库加载一个快照，然后使用 Gather-Apply-Scatter 风格的接口进行计算。\r\n\r\n```cpp\r\nnamespace lgraph_api\r\nnamespace olap\r\n```\r\n\r\n### Variables\r\n\r\n- **static constexpr size_t SNAPSHOT_PARALLEL = 1ul << 0**\r\n  - The available options for (graph construction) flags.\r\n  # （图构建）标志的可用选项。\r\n\r\n- **static constexpr size_t SNAPSHOT_UNDIRECTED = 1ul << 1**\r\n  # 无向图的标志。\r\n\r\n- **static constexpr size_t SNAPSHOT_IDMAPPING = 1ul << 2**\r\n  # ID映射的标志。\r\n\r\n- **static constexpr size_t SNAPSHOT_OUT_DEGREE = 1ul << 3**\r\n  - The following options are not implemented yet.\r\n  # 以下选项尚未实现。\r\n\r\n- **static constexpr size_t SNAPSHOT_IN_DEGREE = 1ul << 4**\r\n  # 入度的标志。\r\n\r\n- **static constexpr size_t SNAPSHOT_OUT_EDGES = 1ul << 5**\r\n  # 出边的标志。\n\n该块内容位于文档中关于TuGraph OLAP接口的部分，介绍了用于实现图分析插件的功能，特别是加载快照和图构建的标志选项。此部分包含了静态常量变量，用于配置图的构建方式和属性，如并行处理、无向图和ID映射等。在文档的整体结构中，这一段属于TuGraph数据库操作界面的描述和实现细节。"
            },
            {
                "content": "# （图构建）标志的可用选项。\r\n\r\n- **static constexpr size_t SNAPSHOT_UNDIRECTED = 1ul << 1**\r\n  # 无向图的标志。\r\n\r\n- **static constexpr size_t SNAPSHOT_IDMAPPING = 1ul << 2**\r\n  # ID映射的标志。\r\n\r\n- **static constexpr size_t SNAPSHOT_OUT_DEGREE = 1ul << 3**\r\n  - The following options are not implemented yet.\r\n  # 以下选项尚未实现。\r\n\r\n- **static constexpr size_t SNAPSHOT_IN_DEGREE = 1ul << 4**\r\n  # 入度的标志。\r\n\r\n- **static constexpr size_t SNAPSHOT_OUT_EDGES = 1ul << 5**\r\n  # 出边的标志。\r\n\r\n- **static constexpr size_t SNAPSHOT_IN_EDGES = 1ul << 6**\r\n  # 入边的标志。\r\n\r\n- **template std::function edge_convert_default = [](OutEdgeIterator &eit, EdgeData &edge_data) -> bool { edge_data= 1;return true;}**\r\n  - Default Parser for weighted edges for graph.\r\n  # 图的加权边的默认解析器。\r\n\r\n  **Return**  \r\n  Edge is converted into graph or not.\r\n  # 边是否被转换为图。\r\n\r\n- **template std::function edge_convert_weight = [](OutEdgeIterator &eit, EdgeData &edge_data) -> bool { edge_data= eit.GetField(\"weight\").real();return true;}**\n\n该块内容位于文档的“olap_base”部分，具体描述了构建图时可用的标志选项和默认解析器，主要涉及图的结构特性、边的处理方式以及如何在图构建过程中应用这些标志和解析器。"
            },
            {
                "content": "# 入边的标志。\r\n\r\n- **template std::function edge_convert_default = [](OutEdgeIterator &eit, EdgeData &edge_data) -> bool { edge_data= 1;return true;}**\r\n  - Default Parser for weighted edges for graph.\r\n  # 图的加权边的默认解析器。\r\n\r\n  **Return**  \r\n  Edge is converted into graph or not.\r\n  # 边是否被转换为图。\r\n\r\n- **template std::function edge_convert_weight = [](OutEdgeIterator &eit, EdgeData &edge_data) -> bool { edge_data= eit.GetField(\"weight\").real();return true;}**\r\n  - Example parser for extracting from edge property “weight”\r\n  # 用于从边属性“权重”中提取的示例解析器。\r\n\r\n  **Return**  \r\n  Edge is converted into graph or not.\r\n  # 边是否被转换为图。\r\n\r\n- **template class OlapOnDB : public lgraph_api::olap::OlapBase**\r\n  \r\n  ```cpp\r\n  #include \r\n  ```\r\n\r\n  Snapshot is a derived class of Graph. Snapshot instances represent static (sub)graphs exported from LightningGraph. The internal organization uses compressed sparse matrix formats which are optimized for read-only accesses.\n\n该块内容位于文档中关于TuGraph OLAP接口的部分，主要描述了与边的处理相关的默认解析器和示例解析器，并引入了OlapOnDB类，解释了如何使用这些解析器来处理有权边的数据。这部分内容是理解图数据处理和转换的重要组成部分。"
            },
            {
                "content": "- Example parser for extracting from edge property “weight”\r\n  # 用于从边属性“权重”中提取的示例解析器。\r\n\r\n  **Return**  \r\n  Edge is converted into graph or not.\r\n  # 边是否被转换为图。\r\n\r\n- **template class OlapOnDB : public lgraph_api::olap::OlapBase**\r\n  \r\n  ```cpp\r\n  #include \r\n  ```\r\n\r\n  Snapshot is a derived class of Graph. Snapshot instances represent static (sub)graphs exported from LightningGraph. The internal organization uses compressed sparse matrix formats which are optimized for read-only accesses.\r\n  # Snapshot 是图的派生类。 Snapshot 实例表示从 LightningGraph 导出的静态（子）图。内部组织使用针对只读访问优化的压缩稀疏矩阵格式。\r\n\r\n  EdgeData is used for representing edge weights (the default type is Empty which is used for unweighted graphs).\r\n  # EdgeData 用于表示边权重（默认类型是 Empty，适用于无权图）。\r\n\r\n  **模板参数**  \r\n  EdgeData – Type of the edge data.\r\n  # EdgeData – 边数据的类型。\r\n\r\n### Public Functions\r\n\r\n- **inline OlapOnDB(GraphDB *db, Transaction &txn, size_t flags = 0, std::function vertex_filter = nullptr, std::function out_edge_filter = nullptr)**\n\n该块内容位于文档的 \"olap_on_db\" 部分，主要介绍了 TuGraph OLAP 接口中的图分析引擎实现，包括如何处理边属性的示例解析器，以及快照类的构造和使用，强调了图的派生和优化的内部数据组织结构。"
            },
            {
                "content": "# Snapshot 是图的派生类。 Snapshot 实例表示从 LightningGraph 导出的静态（子）图。内部组织使用针对只读访问优化的压缩稀疏矩阵格式。\r\n\r\n  EdgeData is used for representing edge weights (the default type is Empty which is used for unweighted graphs).\r\n  # EdgeData 用于表示边权重（默认类型是 Empty，适用于无权图）。\r\n\r\n  **模板参数**  \r\n  EdgeData – Type of the edge data.\r\n  # EdgeData – 边数据的类型。\r\n\r\n### Public Functions\r\n\r\n- **inline OlapOnDB(GraphDB *db, Transaction &txn, size_t flags = 0, std::function vertex_filter = nullptr, std::function out_edge_filter = nullptr)**\r\n  - Generate a graph with LightningGraph. For V1/V2 Procedures\r\n  # 使用 LightningGraph 生成图。用于 V1/V2 过程。\r\n\r\n- **inline OlapOnDB(GraphDB &db, Transaction &txn, size_t flags = 0, std::function vertex_filter = nullptr, std::function out_edge_filter = nullptr)**\r\n  - Generate a graph with LightningGraph. For V1 Procedures\r\n  # 使用 LightningGraph 生成图。用于 V1 过程。\n\n该块内容位于文档的“olap_on_db”部分，描述了Snapshot类及其功能，重点介绍了如何使用LightningGraph生成图形的构造函数，适用于V1/V2过程。同时，提到了EdgeData在无权图中的默认使用方式。"
            },
            {
                "content": "- **inline OlapOnDB(GraphDB *db, Transaction &txn, size_t flags = 0, std::function vertex_filter = nullptr, std::function out_edge_filter = nullptr)**\r\n  - Generate a graph with LightningGraph. For V1/V2 Procedures\r\n  # 使用 LightningGraph 生成图。用于 V1/V2 过程。\r\n\r\n- **inline OlapOnDB(GraphDB &db, Transaction &txn, size_t flags = 0, std::function vertex_filter = nullptr, std::function out_edge_filter = nullptr)**\r\n  - Generate a graph with LightningGraph. For V1 Procedures\r\n  # 使用 LightningGraph 生成图。用于 V1 过程。\r\n\r\n  **Note**: Read-write transactions are not recommended here for safety, e.g., some vertices might be removed causing inconsistencies in the analysis, and vertex data extraction may not work for deleted vertices. The constructed graph should contain all vertices whose vertex_filter calls return true and all edges sourced from these vertices whose out_edge_filter calls return true. If SNAPSHOT_UNDIRECTED is specified, the graph will be made symmetric (i.e., reversed edges are also added to the graph).\n\n该块内容位于文档中关于 TuGraph OLAP 接口的部分，具体描述了如何使用 LightningGraph 生成图形。它特别指出了构造图形时的注意事项，包括对读写事务的建议和如何处理顶点及边的过滤器。"
            },
            {
                "content": "**Note**: Read-write transactions are not recommended here for safety, e.g., some vertices might be removed causing inconsistencies in the analysis, and vertex data extraction may not work for deleted vertices. The constructed graph should contain all vertices whose vertex_filter calls return true and all edges sourced from these vertices whose out_edge_filter calls return true. If SNAPSHOT_UNDIRECTED is specified, the graph will be made symmetric (i.e., reversed edges are also added to the graph).\r\n  # 注意：这里不推荐使用读写事务以确保安全，例如，某些顶点可能会被删除，从而导致分析中的不一致性，并且顶点数据提取可能无法处理已删除的顶点。构建的图应该包含所有 vertex_filter 调用返回 true 的顶点，以及所有出自这些顶点的 out_edge_filter 调用返回 true 的边。如果指定了 SNAPSHOT_UNDIRECTED，则图将变为对称（即反向边也将被添加到图中）。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.\r\n  # std::runtime_error – 当发生运行时错误条件时抛出。\r\n\r\n  **参数**  \r\n  db – [inout] The GraphDB instance.  \r\n  txn – [inout] The transaction.  \r\n  flags – (Optional) The generation flags.\n\n该段落位于文档中关于TuGraph OLAP接口的部分，具体描述了在使用图数据库进行图构建时，不建议使用读写事务以确保数据的一致性和安全性，并对如何构建图进行详细说明。"
            },
            {
                "content": "# 注意：这里不推荐使用读写事务以确保安全，例如，某些顶点可能会被删除，从而导致分析中的不一致性，并且顶点数据提取可能无法处理已删除的顶点。构建的图应该包含所有 vertex_filter 调用返回 true 的顶点，以及所有出自这些顶点的 out_edge_filter 调用返回 true 的边。如果指定了 SNAPSHOT_UNDIRECTED，则图将变为对称（即反向边也将被添加到图中）。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.\r\n  # std::runtime_error – 当发生运行时错误条件时抛出。\r\n\r\n  **参数**  \r\n  db – [inout] The GraphDB instance.  \r\n  txn – [inout] The transaction.  \r\n  flags – (Optional) The generation flags.  \r\n  vertex_filter – [inout] (Optional) A function filtering vertices.  \r\n  out_edge_filter – [inout] (Optional) A function filtering out edges.\r\n\r\n- **inline OlapOnDB(GraphDB &db, Transaction &txn, std::vector> label_list, size_t flags = 0)**\r\n\r\n- **inline OlapOnDB(Transaction &txn, size_t flags = 0, std::function vertex_filter = nullptr, std::function out_edge_filter = nullptr)**\r\n  - Generate a graph without LightningGraph. For V2 Procedures\r\n  # 在没有 LightningGraph 的情况下生成图。用于 V2 过程。\r\n\r\n  **抛出**\n\n这段文本位于文档中关于TuGraph OLAP接口的部分，主要讨论在构建图时的事务管理和确保数据一致性的注意事项，特别是关于读写事务的使用、过滤函数的定义，以及如何构建对称图的相关信息。"
            },
            {
                "content": "vertex_filter – [inout] (Optional) A function filtering vertices.  \r\n  out_edge_filter – [inout] (Optional) A function filtering out edges.\r\n\r\n- **inline OlapOnDB(GraphDB &db, Transaction &txn, std::vector> label_list, size_t flags = 0)**\r\n\r\n- **inline OlapOnDB(Transaction &txn, size_t flags = 0, std::function vertex_filter = nullptr, std::function out_edge_filter = nullptr)**\r\n  - Generate a graph without LightningGraph. For V2 Procedures\r\n  # 在没有 LightningGraph 的情况下生成图。用于 V2 过程。\r\n\r\n  **抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.\r\n  # std::runtime_error – 当发生运行时错误条件时抛出。\r\n\r\n  **参数**  \r\n  txn – [inout] The transaction.  \r\n  flags – (Optional) The generation flags.  \r\n  vertex_filter – [inout] (Optional) A function filtering vertices.  \r\n  out_edge_filter – [inout] (Optional) A function filtering out edges.\r\n\r\n- **OlapOnDB() = delete**\r\n\r\n- **OlapOnDB(const OlapOnDB &rhs) = delete**\r\n\r\n- **OlapOnDB(OlapOnDB &&rhs) = default**\n\n该代码块位于文档中关于TuGraph OLAP接口的部分，主要描述了用于生成图的功能，包括在没有LightningGraph的情况下生成图的构造函数，以及与图相关的过滤器函数。这些功能允许用户在执行图分析时对顶点和边进行筛选。"
            },
            {
                "content": "**抛出**  \r\n  std::runtime_error – Raised when a runtime error condition occurs.\r\n  # std::runtime_error – 当发生运行时错误条件时抛出。\r\n\r\n  **参数**  \r\n  txn – [inout] The transaction.  \r\n  flags – (Optional) The generation flags.  \r\n  vertex_filter – [inout] (Optional) A function filtering vertices.  \r\n  out_edge_filter – [inout] (Optional) A function filtering out edges.\r\n\r\n- **OlapOnDB() = delete**\r\n\r\n- **OlapOnDB(const OlapOnDB &rhs) = delete**\r\n\r\n- **OlapOnDB(OlapOnDB &&rhs) = default**\r\n\r\n- **inline OlapOnDB &operator=(OlapOnDB &&rhs)**\r\n\r\n- **inline virtual ~OlapOnDB()**\r\n\r\n- **template inline ParallelVector ExtractVertexData(std::function extract)**\r\n  - Extract a vertex array from the graph.\r\n  # 从图中提取顶点数组。\r\n\r\n  **参数**  \r\n  extract – The function describing the extraction logic.\r\n  # extract – 描述提取逻辑的函数。\r\n\r\n  **返回**  \r\n  A ParallelVector containing each vertex’s extracted data.\r\n  # 一个包含每个顶点提取数据的 ParallelVector。\n\n该块内容位于文档中关于TuGraph OLAP接口的实现部分，主要描述了构造函数、析构函数、成员函数和参数等细节，涉及图数据库操作过程中的错误处理和顶点数据提取功能。"
            },
            {
                "content": "- **OlapOnDB(OlapOnDB &&rhs) = default**\r\n\r\n- **inline OlapOnDB &operator=(OlapOnDB &&rhs)**\r\n\r\n- **inline virtual ~OlapOnDB()**\r\n\r\n- **template inline ParallelVector ExtractVertexData(std::function extract)**\r\n  - Extract a vertex array from the graph.\r\n  # 从图中提取顶点数组。\r\n\r\n  **参数**  \r\n  extract – The function describing the extraction logic.\r\n  # extract – 描述提取逻辑的函数。\r\n\r\n  **返回**  \r\n  A ParallelVector containing each vertex’s extracted data.\r\n  # 一个包含每个顶点提取数据的 ParallelVector。\r\n\r\n- **template inline void WriteToFile(ParallelVector &vertex_data, const std::string &output_file, std::function output_filter = nullptr)**\r\n  - Write vertex data to a file.\r\n  # 将顶点数据写入文件。\r\n\r\n  **参数**  \r\n  vertex_data – The parallel vector storing the vertex data.  \r\n  output_file – The path to the output file.\r\n  # vertex_data – 存储顶点数据的并行向量。  \r\n  # output_file – 输出文件的路径。\r\n\r\n- **template inline void WriteToFile(bool detail_output, ParallelVector &vertex_data, const std::string &output_file, std::function output_filter = nullptr)**\n\n该chunk位于文档中的“olap_on_db”部分，描述了一些关于图的分析和操作的功能，包括OlapOnDB类的构造函数、移动构造函数、析构函数及其方法，用于提取顶点数据和将其写入文件。这些操作是图数据分析中至关重要的部分，便于用户从数据库中提取和处理图数据。"
            },
            {
                "content": "- Write vertex data to a file.\r\n  # 将顶点数据写入文件。\r\n\r\n  **参数**  \r\n  vertex_data – The parallel vector storing the vertex data.  \r\n  output_file – The path to the output file.\r\n  # vertex_data – 存储顶点数据的并行向量。  \r\n  # output_file – 输出文件的路径。\r\n\r\n- **template inline void WriteToFile(bool detail_output, ParallelVector &vertex_data, const std::string &output_file, std::function output_filter = nullptr)**\r\n  - Write vertex data (include label, primary_field, field_data) to a file.\r\n  # 将顶点数据（包括标签、主字段、字段数据）写入文件。\r\n\r\n  **参数**  \r\n  detail_output – always true  \r\n  vertex_data – The parallel vector storing the vertex data.  \r\n  output_file – The path to the output file.\r\n  # detail_output – 始终为 true  \r\n  # vertex_data – 存储顶点数据的并行向量。  \r\n  # output_file – 输出文件的路径。\r\n\r\n- **template inline void WriteToGraphDB(ParallelVector &vertex_data, const std::string &vertex_field)**\r\n  - Write vertex data to the graph database.\r\n  # 将顶点数据写入图数据库。\r\n\r\n  **参数**  \r\n  vertex_data – [inout] The parallel vector storing the vertex data.\n\n该块内容位于文档的\"olap_on_db\"部分，具体涉及TuGraph OLAP接口中的方法，用于将顶点数据写入文件和图数据库。这些方法包括写入顶点数据的参数说明以及使用场景，适用于图分析插件开发。"
            },
            {
                "content": "**参数**  \r\n  detail_output – always true  \r\n  vertex_data – The parallel vector storing the vertex data.  \r\n  output_file – The path to the output file.\r\n  # detail_output – 始终为 true  \r\n  # vertex_data – 存储顶点数据的并行向量。  \r\n  # output_file – 输出文件的路径。\r\n\r\n- **template inline void WriteToGraphDB(ParallelVector &vertex_data, const std::string &vertex_field)**\r\n  - Write vertex data to the graph database.\r\n  # 将顶点数据写入图数据库。\r\n\r\n  **参数**  \r\n  vertex_data – [inout] The parallel vector storing the vertex data.  \r\n  vertex_field – [in] The name of the vertex field.\r\n  # vertex_data – [inout] 存储顶点数据的并行向量。  \r\n  # vertex_field – [in] 顶点字段的名称。\r\n\r\n- **inline int64_t OriginalVid(size_t vid)**\r\n  - Get the original vertex id (in LightningGraph) of some vertex.\r\n  # 获取某个顶点的原始顶点 ID（在 LightningGraph 中）。\r\n\r\n  **参数**  \r\n  vid – The vertex id (in the graph) to access.\r\n  # vid – 要访问的顶点 ID（在图中）。\r\n\r\n  **返回**  \r\n  The original id of the specified vertex in the graph.\r\n  # 指定顶点在图中的原始 ID。\n\n该片段位于文档中的**olap_on_db**部分，描述了图形数据库的构建和数据写入操作，具体涉及将顶点数据写入图数据库的函数及其参数说明。此部分内容主要是关于如何在TuGraph中操作并管理顶点数据，包括相关参数的详细解释。"
            },
            {
                "content": "vertex_field – [in] The name of the vertex field.\r\n  # vertex_data – [inout] 存储顶点数据的并行向量。  \r\n  # vertex_field – [in] 顶点字段的名称。\r\n\r\n- **inline int64_t OriginalVid(size_t vid)**\r\n  - Get the original vertex id (in LightningGraph) of some vertex.\r\n  # 获取某个顶点的原始顶点 ID（在 LightningGraph 中）。\r\n\r\n  **参数**  \r\n  vid – The vertex id (in the graph) to access.\r\n  # vid – 要访问的顶点 ID（在图中）。\r\n\r\n  **返回**  \r\n  The original id of the specified vertex in the graph.\r\n  # 指定顶点在图中的原始 ID。\r\n\r\n- **inline size_t MappedVid(size_t original_vid)**\r\n  - Get the mapped vertex id (in the graph) of some vertex.\r\n  # 获取某个顶点的映射顶点 ID（在图中）。\r\n\r\n  **参数**  \r\n  original_vid – The original vertex id (in LightningGraph) to access.\r\n  # original_vid – 要访问的原始顶点 ID（在 LightningGraph 中）。\r\n\r\n  **返回**  \r\n  The mapped id of the specified vertex (in LightningGraph).\r\n  # 指定顶点（在 LightningGraph 中）的映射 ID。\r\n\r\n- **inline Transaction &GetTransaction()**\r\n\r\n### Private Functions\r\n\r\n- **inline void Init(size_t num_vertices)**\n\n该块内容位于文档的 \"lgraph_txn\" 部分，主要描述了与事务相关的函数和参数，例如获取原始顶点 ID 和映射顶点 ID 的函数。这些函数用于在 TuGraph 数据库中管理和访问顶点的信息，确保事务的有效性并提供顶点数据的操作接口。"
            },
            {
                "content": "- **inline size_t MappedVid(size_t original_vid)**\r\n  - Get the mapped vertex id (in the graph) of some vertex.\r\n  # 获取某个顶点的映射顶点 ID（在图中）。\r\n\r\n  **参数**  \r\n  original_vid – The original vertex id (in LightningGraph) to access.\r\n  # original_vid – 要访问的原始顶点 ID（在 LightningGraph 中）。\r\n\r\n  **返回**  \r\n  The mapped id of the specified vertex (in LightningGraph).\r\n  # 指定顶点（在 LightningGraph 中）的映射 ID。\r\n\r\n- **inline Transaction &GetTransaction()**\r\n\r\n### Private Functions\r\n\r\n- **inline void Init(size_t num_vertices)**\r\n\r\n- **inline virtual bool CheckKillThisTask()**\r\n  - This decision formula is used to determine whether to stop the algorithm running in OlapOnDB.\r\n  # 此决策公式用于确定是否停止在 OlapOnDB 中运行的算法。\r\n\r\n- **inline virtual void Construct()**\r\n\r\n- **inline void ConstructWithVid()**\r\n\r\n- **inline void ConstructWithDegree()**\r\n\r\n### Private Members\r\n\r\n- `GraphDB *db_`\r\n- `Transaction &txn_`\r\n- `ParallelVector original_vids_`\r\n- `cuckoohash_map vid_map_`\r\n- `size_t flags_`\r\n- `std::function vertex_filter_`\n\n该块内容位于文档的OlapOnDB类部分，详细说明了如何获取顶点的映射ID以及相关的私有函数和成员。这些函数和成员用于处理图形分析中的顶点管理和事务控制，是TuGraph OLAP接口的关键组成部分。"
            },
            {
                "content": "- **inline virtual bool CheckKillThisTask()**\r\n  - This decision formula is used to determine whether to stop the algorithm running in OlapOnDB.\r\n  # 此决策公式用于确定是否停止在 OlapOnDB 中运行的算法。\r\n\r\n- **inline virtual void Construct()**\r\n\r\n- **inline void ConstructWithVid()**\r\n\r\n- **inline void ConstructWithDegree()**\r\n\r\n### Private Members\r\n\r\n- `GraphDB *db_`\r\n- `Transaction &txn_`\r\n- `ParallelVector original_vids_`\r\n- `cuckoohash_map vid_map_`\r\n- `size_t flags_`\r\n- `std::function vertex_filter_`\r\n- `std::function out_edge_filter_`\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## olap_profile\r\n\r\n```cpp\r\nnamespace lgraph_api\r\nnamespace olap\r\n```\r\n在这里定义了 `lgraph_api` 和 `olap` 命名空间，便于对相应的功能进行组织和管理。\r\n\r\n### class MemUsage\r\n\r\n```cpp\r\n#include \r\n```\r\n该行包含了 `olap_profile.h` 头文件，这通常包含了 `MemUsage` 类的声明和其他相关的定义。\r\n\r\n### Public Functions\r\n\r\n- **inline MemUsage()**\r\n  - 构造函数，用于初始化 `MemUsage` 类的实例。\r\n\r\n- **inline int64_t getMaxMemUsage()**\r\n  - 获取最大的内存使用量，返回类型为64位整数。\r\n\r\n- **void reset()**\r\n  - 重置内存使用记录，将已记录的内存信息清零。\n\n此代码块位于文档中关于 TuGraph 图分析引擎的 OLAP 接口实现部分，具体讲述了相关算法在 OlapOnDB 中运行时的决策公式和构造函数。此外，还提到了与内存使用记录相关的 `MemUsage` 类的定义和功能，旨在提供内存监控和管理功能，以优化图处理性能。"
            },
            {
                "content": "- `std::function out_edge_filter_`\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## olap_profile\r\n\r\n```cpp\r\nnamespace lgraph_api\r\nnamespace olap\r\n```\r\n在这里定义了 `lgraph_api` 和 `olap` 命名空间，便于对相应的功能进行组织和管理。\r\n\r\n### class MemUsage\r\n\r\n```cpp\r\n#include \r\n```\r\n该行包含了 `olap_profile.h` 头文件，这通常包含了 `MemUsage` 类的声明和其他相关的定义。\r\n\r\n### Public Functions\r\n\r\n- **inline MemUsage()**\r\n  - 构造函数，用于初始化 `MemUsage` 类的实例。\r\n\r\n- **inline int64_t getMaxMemUsage()**\r\n  - 获取最大的内存使用量，返回类型为64位整数。\r\n\r\n- **void reset()**\r\n  - 重置内存使用记录，将已记录的内存信息清零。\r\n\r\n- **void startMemRecord(unsigned int interval = 1000)**\r\n  - 开始内存使用记录，接受一个参数 `interval`（默认1000毫秒），用来指定记录频率。\r\n\r\n- **void print()**\r\n  - 打印内存使用记录的详细信息，方便用户查看内存情况。\r\n\r\n### Private Functions\r\n\r\n- **int parseMemLine(char *line)**\r\n  - 解析内存使用的文本行，返回解析得到的内存值，通常用于将字符串转换为数字。\r\n\r\n### Private Members\r\n\r\n- `size_t maxMemUsage`\r\n  - 私有成员变量，用于存储最大的内存使用量，类型为 `size_t`，通常用于表示存储大小。\n\n该块内容位于文档的“olap_profile”部分，详细描述了内存使用情况的监控类 `MemUsage`，包括其公共函数和私有成员，主要涉及内存记录、获取最大内存使用量和重置功能等。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_59.md",
        "chunks": [
            {
                "content": "# 场景：三体（基于tugraph-db的产品内置场景上手体验）\n\n> 此文档主要介绍 三体 demo的使用方法。\n\n## 1.Demo场景设计\nDemo背景基于三体1、三体2、三体3的故事背景进行设计。\n\n根据三体故事的设定，我们设计了4类点和6类边，点包括“人物”、“组织”、“计划”、“时间线”，边包括“人物-人物关系”、“人物-计划关系”、“人物-组织关系”、“组织-计划关系”、“组织-组织关系”。\n根据剧情准备了对应Schema的数据，准备了一些query，提出一些关于剧情的问题。\n\n## 2.使用说明\n\n前置条件：TuGraph已安装。\n\n## 3.数据导入\n\n- 手动导入\n    - 数据存放目录：https://github.com/TuGraph-family/tugraph-db-demo （该项目汇集了TuGraph的Demo，每个文件夹为一个能够单独运行的demo，可以在tugraph-db中快速使用。）\n    - 根据数据存放目录对应修改import.json里面的DATA_PATH。\n    - 启动TuGraph服务后，访问${HOST_IP}:7070，打开web页面，确认数据是否导入成功。\n- 自动创建\n    - 点击`新建图项目`，选择三体数据，填写图项目配置，系统会自动完成三体场景图项目创建。\n\n## 4.Cypher查询\n\n参考TuGraph文档，在TuGraph的Web页面前端输入Cypher进行查询。\n\n## 5.使用展示\n\n### 5.1.数据导入的展示\n\n## 6.查询展示\n\n### 6.1.人物关系查询\n三体一剧情中，一开始全世界各地发生了大量科学家自杀事件，引起了警方重视，查案过程根据人物关系线索一步步排查，就如上面的图所示，随着线索越来越多，背后的真相逐步浮出水面。史强和汪淼发现大多数人都和叶文洁有着直接或者间接的联系，并派汪淼卧底，最终发现叶文洁的最终统帅身份。在图中也可以看出，叶文洁顶点周围有很多边关系（一度或二度邻居很多）。\n\n```cypher\nMATCH (n)-[e:person_person]-(m) RETURN n,e,m\n```\n\n该块内容处于文档的开头部分，主要介绍三体demo的背景设计、使用说明、数据导入方法以及Cypher查询的基础知识，为后续的具体查询示例和使用展示做铺垫。"
            },
            {
                "content": "## 4.Cypher查询\n\n参考TuGraph文档，在TuGraph的Web页面前端输入Cypher进行查询。\n\n## 5.使用展示\n\n### 5.1.数据导入的展示\n\n## 6.查询展示\n\n### 6.1.人物关系查询\n三体一剧情中，一开始全世界各地发生了大量科学家自杀事件，引起了警方重视，查案过程根据人物关系线索一步步排查，就如上面的图所示，随着线索越来越多，背后的真相逐步浮出水面。史强和汪淼发现大多数人都和叶文洁有着直接或者间接的联系，并派汪淼卧底，最终发现叶文洁的最终统帅身份。在图中也可以看出，叶文洁顶点周围有很多边关系（一度或二度邻居很多）。\n\n```cypher\nMATCH (n)-[e:person_person]-(m) RETURN n,e,m\n```\n\n### 6.2.邻域顶点分析\n三体中的各种计划比较多，有的时候可能会被绕晕，这时候我们可以通过图的邻居顶点查询来查看该计划的相关人物和组织等。如\"面壁计划\"中,我们可以看到有四位人物与之相关，这四位也是被世人所寄予厚望的“面壁者”。\n\n```cypher\nMATCH (p:plan {name: \"面壁计划\"})-[e]-(neighbor:person)\nRETURN neighbor,p,e\n```\n\n### 6.3.查询a节点和b节点的共同邻居\n我们往往希望知道两个人物之间的共同关联的人物都有谁，这样就能很快的掌握这两个人物之间的关系，在大数据量的情况下，使用cypher进行图关系分析就很方便！\n\n```cypher\nMATCH (a:person {name: \"叶文洁\"})-[e1:person_person]->(n)<-[e2:person_person]-(b:person {name: \"汪淼\"})\nRETURN a,b,n,e1,e2\n```\n\n### 6.4.设置/更改属性\n随着剧情推进，我们逐步了解了\"叶文洁\"身上的多个标签，那么我们也可以将这些标签更新至“叶文洁”节点上：\n\n```cypher\nMATCH (p:person {name: \"叶文洁\"})\nSET p.introduce = \"清华大学教授、ETO精神领袖、首位和三体人交流的人\"\nRETURN p\n```\n\n### 6.5.增加/删除节点\n后续我们了解到了罗辑、程心等等人物和PIA、星环集团等组织，希望把这些作为节点添加至图中：\n\n该部分主要介绍了在三体场景中使用Cypher进行查询的具体方法和示例，包括人物关系查询、邻域顶点分析、共同邻居查询、属性设置和节点增删操作，旨在帮助用户更好地理解和运用TuGraph数据库中的数据。"
            },
            {
                "content": "### 6.3.查询a节点和b节点的共同邻居\n我们往往希望知道两个人物之间的共同关联的人物都有谁，这样就能很快的掌握这两个人物之间的关系，在大数据量的情况下，使用cypher进行图关系分析就很方便！\n\n```cypher\nMATCH (a:person {name: \"叶文洁\"})-[e1:person_person]->(n)<-[e2:person_person]-(b:person {name: \"汪淼\"})\nRETURN a,b,n,e1,e2\n```\n\n### 6.4.设置/更改属性\n随着剧情推进，我们逐步了解了\"叶文洁\"身上的多个标签，那么我们也可以将这些标签更新至“叶文洁”节点上：\n\n```cypher\nMATCH (p:person {name: \"叶文洁\"})\nSET p.introduce = \"清华大学教授、ETO精神领袖、首位和三体人交流的人\"\nRETURN p\n```\n\n### 6.5.增加/删除节点\n后续我们了解到了罗辑、程心等等人物和PIA、星环集团等组织，希望把这些作为节点添加至图中：\n\n```cypher\nCREATE (a:person {introduce: \"物理学教授\", name: \"bbb\"})\nRETURN a\n```\n\n该块内容位于文档的第6节，专注于使用Cypher进行图数据库查询，包括查询两个人物的共同邻居、更新人物属性以及增加/删除节点的示例。这部分展示了在三体场景中如何通过图关系分析获取信息和构建数据。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_60.md",
        "chunks": [
            {
                "content": "# Select \n\n## Syntax\n\n```sql\nSELECT [ DISTINCT ]\n{ * | expr (, expr )* }\nFROM { Table | SubQuery | Match }\n[ WHERE boolExpr ]\n[ Group By expr (',' expr)* ]\n[ HAVING boolExpr ]\n[ ORDER BY (expr [ASC|DESC]) (',' expr [ASC|DESC])* ]\n[ LIMIT number ]\n```\n\n## Example\n### Select\n```sql\nSELECT id, name, age FROM user;\n\nSELECT DISTINCT id, name, age FROM user;\n\nSELECT price * 10 FROM trade;\n```\n\n### From\n#### From Table\n```sql\nSELECT id, name, age FROM user where id > 10\n```\n#### From SubQuery\n```sql\nSELECT id, name, age \nFROM (\n\tSELECT * FROM user where id > 10\n)\n```\n#### From Match\n```sql\nSELECT\n\ta_id,\n\tweight,\n\tb_id\nFROM (\n  MATCH (a) -[e:knows]->(b:person where b.id != 1)\n  RETURN a.id as a_id, e.weight as weight, b.id as b_id\n)\n```\nMore information about match, please see the Match Syntax.\n\n### Where\n```sql\nSELECT id, name, age FROM user where id > 10;\n\nSELECT DISTINCT id, name, age FROM user where id > 10;\n\n该块内容属于SQL查询语句的选取部分，包含了SELECT语法的详细描述、例子以及如何从不同来源（表、子查询、匹配）进行数据选择。同时，展示了使用WHERE子句进行条件过滤的示例。"
            },
            {
                "content": "### Where\n```sql\nSELECT id, name, age FROM user where id > 10;\n\nSELECT DISTINCT id, name, age FROM user where id > 10;\n\nSELECT price * 10 FROM trade where price > 20;\n```\n### Group By\n```sql\nSELECT age, count(id) as cnt FROM user GROUP BY age;\n\nSELECT type, max(age), min(age), avg(age) FROM user GROUP BY type;\n```\n### Having\n```sql\nSELECT age, count(id) as cnt FROM user GROUP BY age Having count(id) > 10;\n```\n### Order By\n```sql\nSELECT * from user order by age;\n\nSELECT age, count(id) as cnt FROM user GROUP BY age Having count(id) > 10 Order by cnt;\n```\n### Limit\n```sql\nSELECT * from user order by age limit 10;\n\nSELECT * from user limit 10;\n```\n\n该块内容主要涵盖了SQL查询语句中的“Where”、“Group By”、“Having”、“Order By”和“Limit”子句的使用示例和语法，属于文档的查询条件及结果排序部分。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_61.md",
        "chunks": [
            {
                "content": "# Round The World Demo（基于tugraph-db的产品内置场景上手体验）\n\n> 此文档主要介绍了基于tugraph-db开发的环球旅行（Round The World）demo的使用方法\n\n\n## 1. 简介\n\n基于\"80天环游世界\"的虚拟背景，基于部分公开历史航班数据，帮助用户设计多个城市的最优航班规划。\n- demo设计了自定义网站服务\n- 数据来源为国外某开源网站，不包含大陆城市航班数据\n- 数据中航班价格为模拟数据，不代表真实价格\n\n## 2. 目录结构\n\n- download：下载目录，下载脚本和后续下载的文件位于该文件夹\n- images：图片目录，文档使用的图片位于该文件夹\n- plugin：算法目录，代码文件和编译加载所需要的脚本均位于该文件夹\n- raw_data：源数据目录，数据处理脚本、城市文件、下载后的航班数据、处理后的点边数据、导入配置文件均位于该目录\n- server：自定义网站服务的文件夹\n- control.sh：自动化部署脚本\n\n## 数据说明\n\n### 航班数据\n\n- 数据来源：https://zenodo.org/record/7923702\n- 时间范围：2019.1-2022.12\n- 航班总数量：117258215\n- 关键字段：\n  - callsign：航班号，可直接使用\n  - typecode：航班类型，可直接使用\n  - origin/destination：出发/到达机场的icao24编号，可映射为出发/到达城市\n  - firstseen/lastseen：出发/到达时间\n  - latitude/longitude：出发和到达地点的经纬度\n\n### 机场数据\n\n航班数据中的起始和达到地点提供的是机场信息，而路径规划和前端展示以城市为单元，因此需要将航班数据中的机场信息映射为城市信息。映射数据来源：https://github.com/jpatokal/openflights/blob/master/data/airports-extended.dat\n\n关键信息：\n- 第二列：机场名称\n- 第三列：城市名称\n- 第四列：国家名称\n- 第六列：机场icao24编号\n\n### 数据转换\n\n该文档介绍了基于tugraph-db开发的环球旅行demo的使用方法，包含项目简介、目录结构及数据说明，尤其详细阐述了航班数据和机场数据的来源、转换过程及其重要性，以便用户更好地设计城市间的最优航班规划。"
            },
            {
                "content": "## 数据说明\n\n### 航班数据\n\n- 数据来源：https://zenodo.org/record/7923702\n- 时间范围：2019.1-2022.12\n- 航班总数量：117258215\n- 关键字段：\n  - callsign：航班号，可直接使用\n  - typecode：航班类型，可直接使用\n  - origin/destination：出发/到达机场的icao24编号，可映射为出发/到达城市\n  - firstseen/lastseen：出发/到达时间\n  - latitude/longitude：出发和到达地点的经纬度\n\n### 机场数据\n\n航班数据中的起始和达到地点提供的是机场信息，而路径规划和前端展示以城市为单元，因此需要将航班数据中的机场信息映射为城市信息。映射数据来源：https://github.com/jpatokal/openflights/blob/master/data/airports-extended.dat\n\n关键信息：\n- 第二列：机场名称\n- 第三列：城市名称\n- 第四列：国家名称\n- 第六列：机场icao24编号\n\n### 数据转换\n\n- 根据机场映射信息筛选航班数据，并进行航班-城市映射处理，给出航班的出发和终点城市\n- 根据航班出发和结束时间计算时间开销\n- 根据经纬度计算距离，再乘以[0.5, 1.5)的随机数模拟机票开销\n- 将航班出发和结束时间转换为seconds_from_epoc，添加对应属性\n\n### 图数据\n\n以城市为顶点，以航班为边进行数据导入。设置航班属性start_time_seconds为primary，按照起飞时间进行排序，以减少计算时的排序开销。\n\n## 算法设计\n\n### 输入\n\n- cities：给定城市列表\n- interval：航班间隔，乘客在每个城市停留时间，单位为小时\n- start_day：开始时间，所选航班时间需要大于该时间\n- end_day：结束时间，所选航班时间需要小于该时间\n\n### 输出\n\n- num_flights：航班总数\n- num_paths：计算出的路径数量\n- total_time：计算时间\n- time_first_data：按照时间开销从小到大排序的前十条路径\n- cost_first_data：按照机票开销从小到大排序的前十条路径\n\n### 计算流程\n\n该段落主要介绍了航班数据和机场数据的来源、关键字段及其映射关系，以及数据转换和图数据的结构。它还概述了算法设计的输入输出参数和计算流程，属于文档中关于数据说明和算法设计的部分，为读者理解后续内容提供了基础。"
            },
            {
                "content": "- 根据机场映射信息筛选航班数据，并进行航班-城市映射处理，给出航班的出发和终点城市\n- 根据航班出发和结束时间计算时间开销\n- 根据经纬度计算距离，再乘以[0.5, 1.5)的随机数模拟机票开销\n- 将航班出发和结束时间转换为seconds_from_epoc，添加对应属性\n\n### 图数据\n\n以城市为顶点，以航班为边进行数据导入。设置航班属性start_time_seconds为primary，按照起飞时间进行排序，以减少计算时的排序开销。\n\n## 算法设计\n\n### 输入\n\n- cities：给定城市列表\n- interval：航班间隔，乘客在每个城市停留时间，单位为小时\n- start_day：开始时间，所选航班时间需要大于该时间\n- end_day：结束时间，所选航班时间需要小于该时间\n\n### 输出\n\n- num_flights：航班总数\n- num_paths：计算出的路径数量\n- total_time：计算时间\n- time_first_data：按照时间开销从小到大排序的前十条路径\n- cost_first_data：按照机票开销从小到大排序的前十条路径\n\n### 计算流程\n\n1. 根据给定城市列表筛选这些城市之间的航班数据；\n2. 根据所有筛选航班数据，每条航班对应初始化一条路线，将所有路线压入栈S\n3. 从S中出栈路线path，若path已包含所有城市，将path写入到结果result\n4. 若path未包含所有城市，根据path遍历的最后一个城市，选择合适航班，将path+新航班作为new_path压入栈S\n5. 重复步骤3、4，直到S为空\n6. 返回result\n\n## 一键部署\n\n### compile镜像或本地安装\n\n将脚本control.sh中的 TUGRAPH_BIN_PATH改为tugraph-db编译后可执行文件地址，将脚本plugin/make-demo.sh中TUGRAPH_PATH改为tugraph-db目录。\n若按照文档默认装方式将tugraph-db安装到用户主目录，则无需修改。\n\n然后执行\n```bash\n    bash control.sh\n```\n即可部署服务。运行时间较长，执行期间不要中断脚本。\n\n执行完成后，即可在 localhost:8000 或者 {HOST_IP}:8000 页面进行查看。\n\n### runtime镜像\n\n本节主要介绍了基于航班数据的处理方法和算法设计，包括数据筛选、时间与费用计算以及数据导入的结构，最后概述了一键部署的步骤，以便用户能够快速搭建和使用环球旅行demo。"
            },
            {
                "content": "1. 根据给定城市列表筛选这些城市之间的航班数据；\n2. 根据所有筛选航班数据，每条航班对应初始化一条路线，将所有路线压入栈S\n3. 从S中出栈路线path，若path已包含所有城市，将path写入到结果result\n4. 若path未包含所有城市，根据path遍历的最后一个城市，选择合适航班，将path+新航班作为new_path压入栈S\n5. 重复步骤3、4，直到S为空\n6. 返回result\n\n## 一键部署\n\n### compile镜像或本地安装\n\n将脚本control.sh中的 TUGRAPH_BIN_PATH改为tugraph-db编译后可执行文件地址，将脚本plugin/make-demo.sh中TUGRAPH_PATH改为tugraph-db目录。\n若按照文档默认装方式将tugraph-db安装到用户主目录，则无需修改。\n\n然后执行\n```bash\n    bash control.sh\n```\n即可部署服务。运行时间较长，执行期间不要中断脚本。\n\n执行完成后，即可在 localhost:8000 或者 {HOST_IP}:8000 页面进行查看。\n\n### runtime镜像\n\n若使用runtime镜像，执行\n```bash\n    bash control.sh start_all runtime\n```\n即可在localhost:8000 或者 {HOST_IP}:8000页面进行查看。\n\n## 网页示例\n\n### 登录页面\n\n### 查询页面\n\n在登录页面点击后进入查询页面\n\n### 查询示例\n\n在左下角的城市列表中选择不超过8个城市，可返回推荐的航班规划，在满足前后航班间隔在2-6小时的要求下，返回费用最低和飞行时间最短的10条路径规划。\n\n## 详细部署流程\n\n前置条件：\n- TuGraph已安装，版本推荐4.0.0。（部署测试版本为4.0.0）\n- 使用tugraph docker镜像时，需要指定docker 7071和8000端口与本机一致\n- 若使用tugraph compile docker镜像时，需要安装编译好tugraph-db（建议按照教程安装到用户主目录）\n\n### 数据下载\n\n在download目录中调用download.sh，下载单月数据或多线程下载所有数据。\n\n```bash\n    bash download.sh [mode]\n```\n\n该部分内容主要介绍了航班路径规划的具体计算流程和一键部署的方法，包括如何筛选航班数据、初始化航线、路径的生成以及如何通过脚本进行系统的快速部署和查看。"
            },
            {
                "content": "若使用runtime镜像，执行\n```bash\n    bash control.sh start_all runtime\n```\n即可在localhost:8000 或者 {HOST_IP}:8000页面进行查看。\n\n## 网页示例\n\n### 登录页面\n\n### 查询页面\n\n在登录页面点击后进入查询页面\n\n### 查询示例\n\n在左下角的城市列表中选择不超过8个城市，可返回推荐的航班规划，在满足前后航班间隔在2-6小时的要求下，返回费用最低和飞行时间最短的10条路径规划。\n\n## 详细部署流程\n\n前置条件：\n- TuGraph已安装，版本推荐4.0.0。（部署测试版本为4.0.0）\n- 使用tugraph docker镜像时，需要指定docker 7071和8000端口与本机一致\n- 若使用tugraph compile docker镜像时，需要安装编译好tugraph-db（建议按照教程安装到用户主目录）\n\n### 数据下载\n\n在download目录中调用download.sh，下载单月数据或多线程下载所有数据。\n\n```bash\n    bash download.sh [mode]\n```\n\n参数：\n- mode：值为small或all，分别为下载2019.1月份数据和下载2019-2022全部数据。默认值为small\n\n下载后的数据会进行解压，压缩文件和解压后的文件均在download目录。脚本会将所有解压后的文件合并到../raw_data/flightlist.csv文件中。\n\n### 数据预处理\n\n将机场文件和下载处理后的航班文件进行预处理，转换成导入所需要的点边格式。在raw_data目录下执行\n```bash\n    python3 convert.py\n```\n即可进行预处理过程。convert.py的使用说明如下：\n\n```bash\n$ python3 convert.py -h\nusage: convert.py [-h] [-a AIRPORT_FILE] [-f FLIGHT_FILE] [-v VERTEX_FILE]\n                  [-e EDGE_FILE]\n\nflight demo convert manager\n\n此块内容位于文档的详细部署流程部分，介绍了使用runtime镜像启动服务的命令及部署的前置条件，同时涵盖了数据下载和数据预处理的具体步骤与命令，更全面地描述了环球旅行demo的部署过程。"
            },
            {
                "content": "```bash\n    bash download.sh [mode]\n```\n\n参数：\n- mode：值为small或all，分别为下载2019.1月份数据和下载2019-2022全部数据。默认值为small\n\n下载后的数据会进行解压，压缩文件和解压后的文件均在download目录。脚本会将所有解压后的文件合并到../raw_data/flightlist.csv文件中。\n\n### 数据预处理\n\n将机场文件和下载处理后的航班文件进行预处理，转换成导入所需要的点边格式。在raw_data目录下执行\n```bash\n    python3 convert.py\n```\n即可进行预处理过程。convert.py的使用说明如下：\n\n```bash\n$ python3 convert.py -h\nusage: convert.py [-h] [-a AIRPORT_FILE] [-f FLIGHT_FILE] [-v VERTEX_FILE]\n                  [-e EDGE_FILE]\n\nflight demo convert manager\n\noptional arguments:\n  -h, --help       show this help message and exit\n  -a AIRPORT_FILE  airport file path (default: airports-extended.dat)\n  -f FLIGHT_FILE   flight file path (default:\n                   flightlist.csv)\n  -v VERTEX_FILE   output vertex file (default: ./vertex_list)\n  -e EDGE_FILE     output edge file (default: ./edge_list)\n```\n\n### 数据导入\n\n该部分内容位于文档的“详细部署流程”章节，主要介绍数据下载和预处理的具体操作，包括执行下载脚本的命令和参数说明，以及如何预处理机场文件和航班数据以转换为导入所需的点边格式。"
            },
            {
                "content": "flight demo convert manager\n\noptional arguments:\n  -h, --help       show this help message and exit\n  -a AIRPORT_FILE  airport file path (default: airports-extended.dat)\n  -f FLIGHT_FILE   flight file path (default:\n                   flightlist.csv)\n  -v VERTEX_FILE   output vertex file (default: ./vertex_list)\n  -e EDGE_FILE     output edge file (default: ./edge_list)\n```\n\n### 数据导入\n\n使用lgraph_import将图数据加载到数据库。`[lgraph_import]`为lgraph_import路径。执行以下命令：\n```bash\n    [lgraph_import] -c ./raw_data/import.json -d ./lgraph_db --overwrite true --v3 0\n```\n将图数据导入到lgraph_db目录中。\n\n### 数据库服务启动\n\n使用lgraph_server启动图数据库。`[lgraph_server]`为lgraph_server路径。执行以下命令：\n```bash\n    [lgraph_server] -c ./raw_data/lgraph_standalone.json -d start --unlimited_token 1\n```\n启动服务。可通过本机7071端口访问确认导入是否成功。\n\n### 编译算法\n\n在plugin目录下，修改make_demo.sh文件：\n#### compile镜像或本地安装\n\n在plugin目录下，将make_demo.sh文件中的 TUGRAPH_PATH改为tugraph-db目录，执行\n```bash\n    bash make_demo.sh\n    python3 reload.sh\n```\n即可编译并加载demo算法。在reload.sh中可更改要加载算法的服务器的ip和端口。\n\n#### runtime镜像\n\n该块内容位于文档的“数据预处理”部分，主要介绍了使用`convert.py`脚本进行航班数据转换的命令行参数及其功能，同时接着详细说明了如何将转换后的图数据导入到数据库并启动图数据库服务的步骤。这些操作是为实现环球旅行demo的核心数据处理和算法编译做准备。"
            },
            {
                "content": "### 数据库服务启动\n\n使用lgraph_server启动图数据库。`[lgraph_server]`为lgraph_server路径。执行以下命令：\n```bash\n    [lgraph_server] -c ./raw_data/lgraph_standalone.json -d start --unlimited_token 1\n```\n启动服务。可通过本机7071端口访问确认导入是否成功。\n\n### 编译算法\n\n在plugin目录下，修改make_demo.sh文件：\n#### compile镜像或本地安装\n\n在plugin目录下，将make_demo.sh文件中的 TUGRAPH_PATH改为tugraph-db目录，执行\n```bash\n    bash make_demo.sh\n    python3 reload.sh\n```\n即可编译并加载demo算法。在reload.sh中可更改要加载算法的服务器的ip和端口。\n\n#### runtime镜像\n\n在plugin目录下，执行\n\n```bash\n    bash make_demo.sh runtime\n    python3 reload.sh\n```\n即可编译并加载demo算法。\n\n### 航班网站服务启动\n\n在server目录下执行\n```bash\n    npm install\n    npm start\n```\n即可启动航班网站服务。启动后可在 localhost:8000 或者 {HOST_IP}:8000 页面进行查看。详细命令可参考server/READMe.md文件。\n\n## Q&A\n\n- server npm安装失败\n答：可能为npm版本过低问题，执行\n```bash\n    npm install -g npm@latest\n```\n命令升级npm版本，重新执行命令即可。\n\n该文本块位于文档的“详细部署流程”部分，主要介绍了如何启动图数据库服务、编译算法以及启动航班网站服务的步骤和相关命令。同时，还提供了关于npm安装失败的解决方案。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_62.md",
        "chunks": [
            {
                "content": "# 单元测试\n\n> 该文档是TuGraph的单元测试文档\n\n## 1.简介\n\nTuGraph单元测试采用gtest框架，可以选择一次跑全部test或者制定某些test。\n\n该文档概述了TuGraph的单元测试相关内容，包括使用gtest框架的测试方法和选项。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_63.md",
        "chunks": [
            {
                "content": "# String\n\nGeaFlow支持以下字符串函数:\n* ascii2str\n* base64_decode\n* base64_encode\n* concat\n* concat_ws\n* hash\n* index_of\n* instr\n* isBlank\n* length\n* like\n* lower\n* ltrim\n* regexp\n* regexp_count\n* regexp_extract\n* repeat\n* replace\n* reverse\n* rtrim\n* space\n* split_ex\n* substr\n* trim\n* upper\n* urldecode\n* urlencode\n\n## ascii2str\n**Syntax**\n\n```sql\nstring ascii2str(int ascii)\nstring ascii2str(long ascii)\n```\n**Description**\n将数字转换为相应的ASCII字符。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nascii2str(66) = 'B'\nascii2str(48) = '0'\n```\n\n## base64_decode\n**Syntax**\n\n```sql\nstring base64_decode(string s)\n```\n**Description**\n将Base64编码的字符串解码。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nbase64_decode('YWJjIA==') = 'abc '\nbase64_decode('dGVzdF9zdHJpbmc=') = 'test_string'\nbase64_decode(null) = null\n```\n\n## base64_encode\n**Syntax**\n\n```sql\nstring base64_encode(string s)\n```\n**Description**\n将字符串编码为Base64格式。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nbase64_encode('abc ') = 'YWJjIA=='\nbase64_encode('test_string') = 'dGVzdF9zdHJpbmc='\n```\n\n## concat\n**Syntax**\n\n该段落概述了GeaFlow支持的各种字符串函数，包括它们的语法、描述和示例。这些函数涵盖了字符串的编码、解码、连接、查找、替换、格式化等操作，为用户提供了处理字符串的工具与方法。"
            },
            {
                "content": "## base64_decode\n**Syntax**\n\n```sql\nstring base64_decode(string s)\n```\n**Description**\n将Base64编码的字符串解码。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nbase64_decode('YWJjIA==') = 'abc '\nbase64_decode('dGVzdF9zdHJpbmc=') = 'test_string'\nbase64_decode(null) = null\n```\n\n## base64_encode\n**Syntax**\n\n```sql\nstring base64_encode(string s)\n```\n**Description**\n将字符串编码为Base64格式。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nbase64_encode('abc ') = 'YWJjIA=='\nbase64_encode('test_string') = 'dGVzdF9zdHJpbmc='\n```\n\n## concat\n**Syntax**\n\n```sql\nstring concat(string... args)\n```\n**Description**\n将按顺序传递的字符串连接成一个字符串。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nconcat('1',null,'2') = '12'\nconcat('1','2',null) = '12'\nconcat(null) = null;\n```\n\n## concat_ws\n**Syntax**\n\n```sql\nstring concat_ws(string separator, string... args)\n```\n**Description**\n将所有的参数字符串用指定的分隔符连接起来。如果输入的分隔符为null，则使用空字符串作为分隔符。\n\n**Example**\n\n该块内容位于GeaFlow支持的字符串函数部分，主要介绍了Base64解码和编码功能，以及字符串连接函数concat和concat_ws的用法和示例。"
            },
            {
                "content": "**Example**\n\n```sql\nbase64_encode('abc ') = 'YWJjIA=='\nbase64_encode('test_string') = 'dGVzdF9zdHJpbmc='\n```\n\n## concat\n**Syntax**\n\n```sql\nstring concat(string... args)\n```\n**Description**\n将按顺序传递的字符串连接成一个字符串。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nconcat('1',null,'2') = '12'\nconcat('1','2',null) = '12'\nconcat(null) = null;\n```\n\n## concat_ws\n**Syntax**\n\n```sql\nstring concat_ws(string separator, string... args)\n```\n**Description**\n将所有的参数字符串用指定的分隔符连接起来。如果输入的分隔符为null，则使用空字符串作为分隔符。\n\n**Example**\n\n```sql\nconcat_ws(',','a','b','c')= 'a,b,c'\nconcat_ws(',','1','2','ant') = '1,2,ant'\nconcat_ws(',','1',null,'c') = '1,,c'\nconcat_ws(null, 'a','b','c') = 'abc'\n```\n\n## hash\n**Syntax**\n\n```sql\nint hash(object s)\n```\n**Description**\n返回输入对象的哈希码。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nhash('1') = 49\nhash(2) = 2\n```\n\n## index_of\n**Syntax**\n\n```sql\nint index_of(string str, string target, int index)\nint index_of(string str, string target)\n```\n**Description**\n返回从索引位置开始，目标字符串在输入字符串中第一次出现的位置。如果未指定索引，则默认值为0。第一个字母的索引为0。如果任何输入为null，则返回-1。\n\n该块包含关于GeaFlow字符串函数的示例，具体涉及到`base64_encode`、`concat`、`concat_ws`、`hash`和`index_of`函数的定义和用法示例，位于文档中字符串函数部分的详细说明之后。"
            },
            {
                "content": "## hash\n**Syntax**\n\n```sql\nint hash(object s)\n```\n**Description**\n返回输入对象的哈希码。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nhash('1') = 49\nhash(2) = 2\n```\n\n## index_of\n**Syntax**\n\n```sql\nint index_of(string str, string target, int index)\nint index_of(string str, string target)\n```\n**Description**\n返回从索引位置开始，目标字符串在输入字符串中第一次出现的位置。如果未指定索引，则默认值为0。第一个字母的索引为0。如果任何输入为null，则返回-1。\n\n**Example**\n\n```sql\nindex_of('a test string', 'string', 3) = 7\nindex_of('a test string', 'test') = 2\nindex_of(null, 'test') = -1\n```\n\n## instr\n**Syntax**\n\n```sql\nbigint instr(string str, string target)\nbigint instr(string str, string target, bigint index, bigint nth)\n```\n**Description**\n如果函数有两个输入参数，则返回目标字符串在字符串中第一次出现的位置（从1开始计数），从位置1开始查找。\n如果函数有四个输入参数，则返回目标字符串在字符串中第nth次出现的位置（从1开始计数），从位置index开始查找。\n如果任何输入为null，则返回Null。如果index < 1或nth < 1，则返回null。\n如果目标字符串没有出现在字符串中，则返回0。\n\n**Example**\n\n```sql\ninstr('abc', 'a') = 1\ninstr('a test string', 'string', 3, 1) = 8\ninstr('abc', 'a', 3, -1) = null\ninstr('abc', null) = null\n```\n\n## isBlank\n**Syntax**\n\n该块内容位于GeaFlow支持的字符串函数部分，其中详细介绍了三个函数：hash、index_of和instr，及其语法、描述和示例。"
            },
            {
                "content": "## instr\n**Syntax**\n\n```sql\nbigint instr(string str, string target)\nbigint instr(string str, string target, bigint index, bigint nth)\n```\n**Description**\n如果函数有两个输入参数，则返回目标字符串在字符串中第一次出现的位置（从1开始计数），从位置1开始查找。\n如果函数有四个输入参数，则返回目标字符串在字符串中第nth次出现的位置（从1开始计数），从位置index开始查找。\n如果任何输入为null，则返回Null。如果index < 1或nth < 1，则返回null。\n如果目标字符串没有出现在字符串中，则返回0。\n\n**Example**\n\n```sql\ninstr('abc', 'a') = 1\ninstr('a test string', 'string', 3, 1) = 8\ninstr('abc', 'a', 3, -1) = null\ninstr('abc', null) = null\n```\n\n## isBlank\n**Syntax**\n\n```sql\nboolean isBlank(string str)\n```\n**Description**\n返回输入字符串是否为空白。如果输入为空，则返回true。\n\n**Example**\n\n```sql\nisBlank('test') = false\nisBlank(' ') = true\n```\n\n## length\n**Syntax**\n\n```sql\nbigint length(string str)\n```\n**Description**\n返回输入字符串的长度。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nlength('abc') = 3\nlength('abc  ') = 5\n```\n\n## like\n**Syntax**\n\n```sql\nboolean like(string str, string likePattern)\n```\n**Description**\n返回字符串是否与模式匹配。如果任何一个输入为空，则返回Null。\n\n**Example**\n\n该块内容包含了GeaFlow的字符串函数中关于`instr`、`isBlank`、`length`和`like`的详细描述及示例。这些函数用于处理字符串操作，包括查找子字符串位置、检查字符串是否为空白、获取字符串长度以及匹配模式的功能。"
            },
            {
                "content": "## isBlank\n**Syntax**\n\n```sql\nboolean isBlank(string str)\n```\n**Description**\n返回输入字符串是否为空白。如果输入为空，则返回true。\n\n**Example**\n\n```sql\nisBlank('test') = false\nisBlank(' ') = true\n```\n\n## length\n**Syntax**\n\n```sql\nbigint length(string str)\n```\n**Description**\n返回输入字符串的长度。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nlength('abc') = 3\nlength('abc  ') = 5\n```\n\n## like\n**Syntax**\n\n```sql\nboolean like(string str, string likePattern)\n```\n**Description**\n返回字符串是否与模式匹配。如果任何一个输入为空，则返回Null。\n\n**Example**\n\n```sql\nlike('abc', '%abc') = true\nlike('test', 'abc\\\\%') = false\nlike('abc', 'a%bc') = true\n```\n\n## lower\n**Syntax**\n\n```sql\nstring lower(string str)\n```\n**Description**\n将字符串中的所有字符转换为小写字母并返回。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nlower('ABC') = 'abc'\nlower(null) = null\n```\n\n## ltrim\n**Syntax**\n\n```sql\nstring ltrim(string str)\n```\n**Description**\n从输入字符串中删除前导空格字符并返回。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nltrim('    abc    ') = 'abc    '\nltrim('   test') = 'test'\n```\n\n## regexp\n**Syntax**\n\n该块内容位于文档中关于字符串函数的部分，具体介绍了有关字符串处理的多种函数，包括判断字符串是否为空白、获取字符串长度、模式匹配、转换为小写、去除前导空格以及正则表达式匹配等功能。"
            },
            {
                "content": "**Example**\n\n```sql\nlike('abc', '%abc') = true\nlike('test', 'abc\\\\%') = false\nlike('abc', 'a%bc') = true\n```\n\n## lower\n**Syntax**\n\n```sql\nstring lower(string str)\n```\n**Description**\n将字符串中的所有字符转换为小写字母并返回。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nlower('ABC') = 'abc'\nlower(null) = null\n```\n\n## ltrim\n**Syntax**\n\n```sql\nstring ltrim(string str)\n```\n**Description**\n从输入字符串中删除前导空格字符并返回。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nltrim('    abc    ') = 'abc    '\nltrim('   test') = 'test'\n```\n\n## regexp\n**Syntax**\n\n```sql\nboolean regexp(string str, string pattern)\n```\n**Description**\n如果输入字符串与模式匹配，则返回true。如果任何一个输入为空，则返回Null。\n\n**Example**\n\n```sql\nregexp('a.b.c.d.e.f', '.') = true\nregexp('a.b.c.d.e.f', '.d%') = false\nregexp('a.b.c.d.e.f', null) = null\n```\n\n## regexp_count\n**Syntax**\n\n```sql\nbigint regexp(string str, string pattern)\nbigint regexp(string str, string pattern, bigint startPos)\n```\n**Description**\n返回与模式匹配的子字符串的数量。如果未指定startPos，则从位置0开始。如果任何输入为空，则返回Null。\n\n**Example**\n\n该块内容位于文档中字符串函数部分，涵盖了字符串匹配（like）、字符串转换为小写（lower）、去除前导空格（ltrim）以及正则表达式匹配（regexp和regexp_count）相关的函数语法、描述和示例。"
            },
            {
                "content": "## regexp\n**Syntax**\n\n```sql\nboolean regexp(string str, string pattern)\n```\n**Description**\n如果输入字符串与模式匹配，则返回true。如果任何一个输入为空，则返回Null。\n\n**Example**\n\n```sql\nregexp('a.b.c.d.e.f', '.') = true\nregexp('a.b.c.d.e.f', '.d%') = false\nregexp('a.b.c.d.e.f', null) = null\n```\n\n## regexp_count\n**Syntax**\n\n```sql\nbigint regexp(string str, string pattern)\nbigint regexp(string str, string pattern, bigint startPos)\n```\n**Description**\n返回与模式匹配的子字符串的数量。如果未指定startPos，则从位置0开始。如果任何输入为空，则返回Null。\n\n**Example**\n\n```sql\nregexp('ab1d2d3dsss', '[0-9]d', 0) = 3\nregexp('ab1d2d3dsss', '[0-9]d', 8) = 0\nregexp('ab1d2d3dsss', '.b') = 1\n```\n\n## regexp_extract\n**Syntax**\n\n```sql\nstring regexp_extract(string str, string pattern)\nstring regexp_extract(string str, string pattern, bigint extractIndex)\n```\n**Description**\n使用模式提取字符串并返回。如果未指定extractIndex，则从1开始。第一个字母的索引为1。如果任何输入为空，则返回Null。\n\n**Example**\n\n```sql\nregexp_extract('abchebar', 'abc(.*?)(bar)', 1) = 'he'\nregexp_extract('100-200', '(\\d+)-(\\d+)') = '100'\n```\n\n## regexp_replace\n**Syntax**\n\n该部分包含了GeaFlow支持的正则表达式相关字符串函数，包括`regexp`、`regexp_count`、`regexp_extract`和`regexp_replace`的语法、描述和示例，用于处理和匹配字符串中的模式。"
            },
            {
                "content": "## regexp_extract\n**Syntax**\n\n```sql\nstring regexp_extract(string str, string pattern)\nstring regexp_extract(string str, string pattern, bigint extractIndex)\n```\n**Description**\n使用模式提取字符串并返回。如果未指定extractIndex，则从1开始。第一个字母的索引为1。如果任何输入为空，则返回Null。\n\n**Example**\n\n```sql\nregexp_extract('abchebar', 'abc(.*?)(bar)', 1) = 'he'\nregexp_extract('100-200', '(\\d+)-(\\d+)') = '100'\n```\n\n## regexp_replace\n**Syntax**\n\n```sql\nstring regexp_replace(string str, string pattern, string replacement)\n```\n**Description**\n替换所有与模式匹配的子字符串。如果任何输入为空，则返回Null。\n\n**Example**\n\n```sql\nregexp_replace('100-200', '(\\\\d+)', 'num') = 'num-num'\nregexp_replace('(adfafa', '\\\\(', '') = 'adfafa'\nregexp_replace('adfabadfasdf', '[a]', '3') = '3df3b3df3sdf'\n```\n\n\n## repeat\n**Syntax**\n\n```sql\nstring repeat(string str, int n)\n```\n**Description**\n返回重复n次连接字符串str的结果。如果任何输入为空，则返回Null。\n\n**Example**\n\n```sql\nrepeat('abc', 3) = 'abcabcabc'\nrepeat(null, 4) = null\n```\n\n## replace\n**Syntax**\n\n该块内容位于GeaFlow支持的字符串函数部分，主要介绍了正则表达式提取和替换功能，以及字符串重复和替换的功能，这些函数用于处理和转换字符串数据。"
            },
            {
                "content": "**Example**\n\n```sql\nregexp_replace('100-200', '(\\\\d+)', 'num') = 'num-num'\nregexp_replace('(adfafa', '\\\\(', '') = 'adfafa'\nregexp_replace('adfabadfasdf', '[a]', '3') = '3df3b3df3sdf'\n```\n\n\n## repeat\n**Syntax**\n\n```sql\nstring repeat(string str, int n)\n```\n**Description**\n返回重复n次连接字符串str的结果。如果任何输入为空，则返回Null。\n\n**Example**\n\n```sql\nrepeat('abc', 3) = 'abcabcabc'\nrepeat(null, 4) = null\n```\n\n## replace\n**Syntax**\n\n```sql\nstring replace(string str, string oldString, string newString)\n```\n**Description**\n将字符串str中的所有旧子字符串替换为新的子字符串。如果任何一个输入为空，则返回Null。\n\n**Example**\n\n```sql\nreplace('test test', 'test', 'c') = 'c c'\nreplace('test test', 'test', '') = ' '\n```\n\n## reverse\n**Syntax**\n\n```sql\nstring reverse(string str)\n```\n**Description**\n返回反转后的字符串。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nreverse('abc') = 'cba'\nreverse(null) = null\n```\n\n## rtrim\n**Syntax**\n\n```sql\nstring rtrim(string str)\n```\n**Description**\n从str中删除尾随空格字符。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nrtrim('    abc    ') = '    abc'\nrtrim('test') = 'test'\n```\n\n该文本块位于文档中关于字符串函数的部分，具体描述了`regexp_replace`、`repeat`、`replace`、`reverse`和`rtrim`这几个字符串处理函数的语法、描述和示例。"
            },
            {
                "content": "**Example**\n\n```sql\nreplace('test test', 'test', 'c') = 'c c'\nreplace('test test', 'test', '') = ' '\n```\n\n## reverse\n**Syntax**\n\n```sql\nstring reverse(string str)\n```\n**Description**\n返回反转后的字符串。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nreverse('abc') = 'cba'\nreverse(null) = null\n```\n\n## rtrim\n**Syntax**\n\n```sql\nstring rtrim(string str)\n```\n**Description**\n从str中删除尾随空格字符。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nrtrim('    abc    ') = '    abc'\nrtrim('test') = 'test'\n```\n\n## space\n**Syntax**\n\n```sql\nstring space(bigint n)\n```\n**Description**\n返回n个空格的字符串。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nspace(5) = '     '\nspace(null) = null\n```\n\n## split_ex\n**Syntax**\n\n```sql\nstring split_ex(string str, string separator, int nth)\n```\n**Description**\n按分隔符separator拆分字符串str并返回第n个子字符串。如果任何一个输入为空或者nth < 0，则返回Null。\n\n**Example**\n\n```sql\nsplit_ex('a.b.c.d.e', '.', 5) = null\nsplit_ex('a.b.c.d.e', '.', 1) = 'b'\nsplit_ex('a.b.c.d.e', '.', -1) = null\n```\n\n\n## substr\n**Syntax**\n\n该片段位于文档中关于字符串操作的函数部分，具体涵盖了`replace`、`reverse`、`rtrim`、`space`、`split_ex`和`substr`等字符串处理函数的示例及其用法。这些函数提供了字符串的替换、反转、去除空格、生成空格字符串、字符串拆分以及获取子字符串等功能。"
            },
            {
                "content": "## space\n**Syntax**\n\n```sql\nstring space(bigint n)\n```\n**Description**\n返回n个空格的字符串。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nspace(5) = '     '\nspace(null) = null\n```\n\n## split_ex\n**Syntax**\n\n```sql\nstring split_ex(string str, string separator, int nth)\n```\n**Description**\n按分隔符separator拆分字符串str并返回第n个子字符串。如果任何一个输入为空或者nth < 0，则返回Null。\n\n**Example**\n\n```sql\nsplit_ex('a.b.c.d.e', '.', 5) = null\nsplit_ex('a.b.c.d.e', '.', 1) = 'b'\nsplit_ex('a.b.c.d.e', '.', -1) = null\n```\n\n\n## substr\n**Syntax**\n\n```sql\nstring substr(string str, int pos)\nstring substr(string str, int pos, int len)\n```\n**Description**\n从pos开始并具有长度为len的字符串的一部分。第一个字母的索引为1。如果未指定长度，则默认值为无穷大。如果任何输入为空，则返回Null。\n\n**Example**\n\n```sql\nsubstr('testString', 5, 10) = 'String'\nsubstr('testString', -6) = 'String'\n```\n\n## trim\n**Syntax**\n\n```sql\nstring trim(string str)\n```\n**Description**\n删除字符串str中的前导和尾随空格字符。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\ntrim('    abc    ') = 'abc'\ntrim('abc') = 'abc'\n```\n\n## upper\n**Syntax**\n\n该块内容位于文档中关于字符串函数的部分，主要包含字符串处理函数的定义、语法、描述和示例，特别关注于空格处理、字符串拆分、子字符串提取、去除空格和大写转换等功能。"
            },
            {
                "content": "## substr\n**Syntax**\n\n```sql\nstring substr(string str, int pos)\nstring substr(string str, int pos, int len)\n```\n**Description**\n从pos开始并具有长度为len的字符串的一部分。第一个字母的索引为1。如果未指定长度，则默认值为无穷大。如果任何输入为空，则返回Null。\n\n**Example**\n\n```sql\nsubstr('testString', 5, 10) = 'String'\nsubstr('testString', -6) = 'String'\n```\n\n## trim\n**Syntax**\n\n```sql\nstring trim(string str)\n```\n**Description**\n删除字符串str中的前导和尾随空格字符。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\ntrim('    abc    ') = 'abc'\ntrim('abc') = 'abc'\n```\n\n## upper\n**Syntax**\n\n```sql\nstring upper(string str)\n```\n**Description**\n将字符串str中的所有字符转换为大写。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nupper('abc') = 'ABC'\nupper(null) = null\n```\n\n## urldecode\n**Syntax**\n\n```sql\nstring urldecode(string str)\n```\n**Description**\n使用UTF-8解码URL。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nurldecode('a%3d0%26c%3d1') = 'a=0&c=1'\nurldecode('a%3D2') = 'a=2'\n```\n\n## urlencode\n**Syntax**\n\n```sql\nstring urlencode(string str)\n```\n**Description**\n使用UTF-8编码URL。如果输入为空，则返回Null。\n\n**Example**\n\n该块包含了GeaFlow字符串函数文档中的几个重要函数的详细信息，包括`substr`、`trim`、`upper`、`urldecode`和`urlencode`，它们用于字符串操作和URL编码解码，位于整个字符串函数列表的后部。"
            },
            {
                "content": "## upper\n**Syntax**\n\n```sql\nstring upper(string str)\n```\n**Description**\n将字符串str中的所有字符转换为大写。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nupper('abc') = 'ABC'\nupper(null) = null\n```\n\n## urldecode\n**Syntax**\n\n```sql\nstring urldecode(string str)\n```\n**Description**\n使用UTF-8解码URL。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nurldecode('a%3d0%26c%3d1') = 'a=0&c=1'\nurldecode('a%3D2') = 'a=2'\n```\n\n## urlencode\n**Syntax**\n\n```sql\nstring urlencode(string str)\n```\n**Description**\n使用UTF-8编码URL。如果输入为空，则返回Null。\n\n**Example**\n\n```sql\nurlencode('a=0&c=1') = 'a%3d0%26c%3d1'\nurlencode('a=2') = 'a%3D2'\n```\n\n该块内容位于文档末尾，涵盖了三个字符串处理函数：`upper`（转换为大写）、`urldecode`（解码URL）和`urlencode`（编码URL）。这些函数是GeaFlow支持的字符串函数中的一部分，提供了对字符串的格式化和编码操作。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_64.md",
        "chunks": [
            {
                "content": "# 环境准备\n\n> 此文档主要介绍 TuGraph 部署时所需的软硬件环境。\n\n## 1.硬件环境\n\n### 1.1. CPU\nTuGraph 无论是物理、虚拟还是容器化环境，均支持 X86_64 和 ARM64 架构的硬件平台，测试认证过的硬件平台包括 Intel、AMD、Kunpeng、Hygon、飞腾等。\n\n### 1.2. 内存\n\n我们建议内存容量不小于实际的数据大小。如果最求极致的性能，把所有的数据缓存到内存里是最理想的。在数据访问的局部性上，图数据库的局部性要比关系型数据库差，因此如果数据在内存中放不下，通常会频繁地换入换出。\n\n### 1.3. 外存\n我们强烈建议用户使用 NVMe SSD 作为外存，数据库有大量的写操作需要同步的外存，通常为随机写，外存的读写性能很容易成为整体数据库运行的性能瓶颈。因此，高IOPS、低延迟的 NVMe SSD 是最优的选择。\n\n如果现实条件只能使用 SATA接口的SSD，或者云上的网盘，性能虽然会受到影响，但 TuGraph 依然能正确的运行。\n\n外存大小建议为实际数据大小的4倍，比如数据为1TB，则准备4TB的硬盘会比较稳妥。\n\n## 2.软件环境\n\n### 2.1. 操作系统\n\nTuGraph 能够兼容主流操作系统，包括Ubuntu、CentOS、SUSE、银河麒麟、 中标麒麟、UOS等，均通过测试认证。\n\n其中最稳定使用的系统版本是 Ubuntu 18.04、CentOS 7、CentOS 8。\n\n### 2.2. 系统库\n\n编译环境和运行环境对系统库的要求不一样。针对三种环境，除去TuGraph的运行包，所需要的系统库如下：\n* 编译环境，包括gcc、python、java等编译器，也包含antlr4、pybind11等，具体参见tugraph-db源码目录 ci/images/tugraph-compile-*-Dockerfile。\n* 运行环境，主要由存储过程引入，包括gcc、boost、cmake等，具体参见tugraph-db源码目录 ci/images/tugraph-runtime-*-Dockerfile。\n* 精简运行环境，无，可以参见tugraph-db源码目录 ci/images/ tugraph-mini-runtime-*-Dockerfile。\n\n## 3.典型配置推荐\n\n该文档主要介绍 TuGraph 部署所需的软硬件环境，分为硬件环境和软件环境两大部分，具体阐述了关于CPU、内存、外存、操作系统及系统库的要求，并在最后提供了典型配置推荐，以帮助用户选择合适的资源配置。"
            },
            {
                "content": "## 2.软件环境\n\n### 2.1. 操作系统\n\nTuGraph 能够兼容主流操作系统，包括Ubuntu、CentOS、SUSE、银河麒麟、 中标麒麟、UOS等，均通过测试认证。\n\n其中最稳定使用的系统版本是 Ubuntu 18.04、CentOS 7、CentOS 8。\n\n### 2.2. 系统库\n\n编译环境和运行环境对系统库的要求不一样。针对三种环境，除去TuGraph的运行包，所需要的系统库如下：\n* 编译环境，包括gcc、python、java等编译器，也包含antlr4、pybind11等，具体参见tugraph-db源码目录 ci/images/tugraph-compile-*-Dockerfile。\n* 运行环境，主要由存储过程引入，包括gcc、boost、cmake等，具体参见tugraph-db源码目录 ci/images/tugraph-runtime-*-Dockerfile。\n* 精简运行环境，无，可以参见tugraph-db源码目录 ci/images/ tugraph-mini-runtime-*-Dockerfile。\n\n## 3.典型配置推荐\n\n| 硬件      | 最低配置   | 建议配置                   |\n| -------- | --------- | ------------------------ |\n| CPU      | 4 Cores   | 64 Cores                 |\n| 内存      | 4GB       | 512GB                    |\n| 外存      | 100GB     | 2TB NVMe SSD             |\n| OS       | Linux 4.9 | CentOS 7.3               |\n表格内容描述: \n\n该表格包含三个列名：硬件、最低配置和建议配置。\n\n逐行描述表格中的数据内容：\n1. 在CPU一栏，最低配置要求为4个核心，而建议配置为64个核心。\n2. 在内存一栏，最低配置要求为4GB，建议配置为512GB。\n3. 在外存一栏，最低配置要求为100GB，建议配置为2TB NVMe SSD。\n4. 在操作系统一栏，最低配置要求为Linux 4.9，建议使用CentOS 7.3。\n\n该文档主要介绍 TuGraph 部署所需的软硬件环境，其中包含硬件环境的详细要求，以及软件环境的操作系统和系统库的配置要求。在软件环境部分，具体说明了兼容的操作系统、系统库的需求，以及推荐的典型配置，帮助用户进行系统准备以确保良好的性能和稳定性。"
            },
            {
                "content": "| 硬件      | 最低配置   | 建议配置                   |\n| -------- | --------- | ------------------------ |\n| CPU      | 4 Cores   | 64 Cores                 |\n| 内存      | 4GB       | 512GB                    |\n| 外存      | 100GB     | 2TB NVMe SSD             |\n| OS       | Linux 4.9 | CentOS 7.3               |\n表格内容描述: \n\n该表格包含三个列名：硬件、最低配置和建议配置。\n\n逐行描述表格中的数据内容：\n1. 在CPU一栏，最低配置要求为4个核心，而建议配置为64个核心。\n2. 在内存一栏，最低配置要求为4GB，建议配置为512GB。\n3. 在外存一栏，最低配置要求为100GB，建议配置为2TB NVMe SSD。\n4. 在操作系统一栏，最低配置要求为Linux 4.9，建议使用CentOS 7.3。\n\n概要总结：该表格展示了某系统在硬件方面的最低和建议配置要求，强调了CPU核心数、内存和外存容量以及操作系统版本的差异，建议配置显著高于最低配置，以满足更高的性能需求。\n\n该块内容位于文档的\"典型配置推荐\"部分，详细列出了TuGraph在硬件方面的最低和建议配置要求，包括CPU、内存、外存和操作系统的具体规格，以帮助用户选择合适的硬件环境从而提升系统性能。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_65.md",
        "chunks": [
            {
                "content": "# TuGraph-Explorer\n\n> TuGraph Explorer 已经合并到 TuGraph Browser\n\n该文档主要介绍了TuGraph相关工具的合并情况，其中提到TuGraph-Explorer已经与TuGraph Browser合并。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_66.md",
        "chunks": [
            {
                "content": "# Math\n\nGeaflow 支持以下数学运算。\n\n本文档介绍了Geaflow支持的各种数学运算，包括基本算术运算、三角函数、对数和随机数生成等，提供详细的操作说明和使用示例。"
            },
            {
                "content": "| 操作 | 说明 |\n| :--- | :--- |\n| + numeric | 返回 numeric 的正值 |\n| - numeric | 返回 numeric 的负值 |\n| numeric1 + numeric2 | 返回 numeric1 加上 numeric2 的结果 |\n| numeric1 - numeric2 | 返回 numeric1 减去 numeric2 的结果 |\n| numeric1 * numeric2 | 返回 numeric1 乘以 numeric2 的结果 |\n| numeric1 / numeric2 | 将numeric1除以numeric2并返回结果。如果numeric1和numeric2都是整数，则它们会被平均分配。例如，3/2 = 1，3/2.0 = 1.5 |\n| POWER(numeric1, numeric2) | 返回numeric1的numeric2次方的结果 |\n| ABS(numeric) | 返回numeric的绝对值 |\n| MOD(numeric1, numeric2) | 返回numeric1除以numeric2的余数 |\n| SQRT(numeric) | 返回numeric的平方根 |\n| LN(numeric) | 返回numeric以自然对数e为底的对数 |\n| LOG10(numeric) | 返回numeric以10为底的对数 |\n| EXP(numeric) | 返回e的numeric次幂的结果 |\n| CEIL(numeric) | 返回大于或等于numeric的最小整数值 |\n| FLOOR(numeric) | 返回小于或等于numeric的最大整数值 |\n| SIN(numeric) | 返回numeric的正弦值 |\n| COS(numeric) | 返回numeric的余弦值 |\n| TAN(numeric) | 返回numeric的正切值 |\n| COT(numeric) | 返回numeric的余切值 |\n| ASIN(numeric) | 返回numeric的反正弦值 |\n| ACOS(numeric) | 返回numeric的反余弦值 |\n| ATAN(numeric) | 返回numeric的反正切值 |\n| DEGREES(numeric) | 将弧度转换为度数，返回numeric的度数值 |\n\n该块内容为Geaflow支持的数学运算功能的详细描述，包括基本算术运算、三角函数、对数等操作及其说明，位于整个文档的数学运算部分。"
            },
            {
                "content": "| LN(numeric) | 返回numeric以自然对数e为底的对数 |\n| LOG10(numeric) | 返回numeric以10为底的对数 |\n| EXP(numeric) | 返回e的numeric次幂的结果 |\n| CEIL(numeric) | 返回大于或等于numeric的最小整数值 |\n| FLOOR(numeric) | 返回小于或等于numeric的最大整数值 |\n| SIN(numeric) | 返回numeric的正弦值 |\n| COS(numeric) | 返回numeric的余弦值 |\n| TAN(numeric) | 返回numeric的正切值 |\n| COT(numeric) | 返回numeric的余切值 |\n| ASIN(numeric) | 返回numeric的反正弦值 |\n| ACOS(numeric) | 返回numeric的反余弦值 |\n| ATAN(numeric) | 返回numeric的反正切值 |\n| DEGREES(numeric) | 将弧度转换为度数，返回numeric的度数值 |\n| RADIANS(numeric) | 将度数转换为弧度，返回numeric的弧度值 |\n| SIGN(numeric) | 返回numeric的符号，1表示正数，-1表示负数，0表示0 |\n| PI | 返回常量值 `PI` |\n| E() | 返回常量值 `e` |\n| RAND() | 返回0-1之间的随机双精度浮点数 |\n| RAND(seed s) | 使用初始种子返回伪随机double值，介于0.0（含）和1.0（不含）之间。如果两个RAND函数具有相同的初始种子，则两个RAND函数将返回相同的数字序列 |\n| RAND_INTEGER(bound numeric) | 返回介于0-numeric之间的随机整数 |\n| RAND_INTEGER(seed s, bound numeric) | 使用初始种子返回介于0（含）和numeric（不含）之间的伪随机整数值。如果两个RAND_INTEGER函数具有相同的初始种子，则两个RAND_INTEGER函数将返回相同的数字序列 |\n| ROUND(numeric1, numeric2) | 将numeric1四舍五入为numeric2位小数的结果 |\n表格内容描述:\n\n该块内容包括多种数学函数及其说明，主要涉及对数函数、三角函数、随机数生成以及常量的计算。这些内容位于文档的数学运算部分，旨在为用户提供数学运算及其应用的详细指导。"
            },
            {
                "content": "该表格包含两列，分别为“操作”和“说明”。\n\n该文档主要介绍Geaflow支持的各种数学运算及其说明，其中包括对表格内容的详细描述。此处的“该表格包含两列，分别为‘操作’和‘说明’。”是对文档中数学运算表格结构的概括，帮助读者了解表格内容。"
            },
            {
                "content": "逐行描述如下：\n1. “+ numeric”表示返回numeric的正值。\n2. “- numeric”表示返回numeric的负值。\n3. “numeric1 + numeric2”表示返回numeric1与numeric2的和。\n4. “numeric1 - numeric2”表示返回numeric1减去numeric2的结果。\n5. “numeric1 * numeric2”表示返回numeric1与numeric2的积。\n6. “numeric1 / numeric2”表示将numeric1除以numeric2并返回结果。如果numeric1和numeric2都是整数，则会进行整数除法，例如3/2=1，而3/2.0=1.5。\n7. “POWER(numeric1, numeric2)”表示返回numeric1的numeric2次方结果。\n8. “ABS(numeric)”表示返回numeric的绝对值。\n9. “MOD(numeric1, numeric2)”表示返回numeric1除以numeric2的余数。\n10. “SQRT(numeric)”表示返回numeric的平方根。\n11. “LN(numeric)”表示返回以自然对数e为底的对数。\n12. “LOG10(numeric)”表示返回以10为底的对数。\n13. “EXP(numeric)”表示返回e的numeric次幂结果。\n14. “CEIL(numeric)”表示返回大于或等于numeric的最小整数。\n15. “FLOOR(numeric)”表示返回小于或等于numeric的最大整数。\n16. “SIN(numeric)”表示返回numeric的正弦值。\n17. “COS(numeric)”表示返回numeric的余弦值。\n18. “TAN(numeric)”表示返回numeric的正切值。\n19. “COT(numeric)”表示返回numeric的余切值。\n20. “ASIN(numeric)”表示返回numeric的反正弦值。\n21. “ACOS(numeric)”表示返回numeric的反余弦值。\n22. “ATAN(numeric)”表示返回numeric的反正切值。\n23. “DEGREES(numeric)”表示将弧度转换为度数，返回numeric的度数值。\n\n该片段详细描述了Geaflow支持的各种数学运算的逐行说明，具体阐释了每种运算的功能和结果，属于文档中数学操作说明部分的具体内容。"
            },
            {
                "content": "11. “LN(numeric)”表示返回以自然对数e为底的对数。\n12. “LOG10(numeric)”表示返回以10为底的对数。\n13. “EXP(numeric)”表示返回e的numeric次幂结果。\n14. “CEIL(numeric)”表示返回大于或等于numeric的最小整数。\n15. “FLOOR(numeric)”表示返回小于或等于numeric的最大整数。\n16. “SIN(numeric)”表示返回numeric的正弦值。\n17. “COS(numeric)”表示返回numeric的余弦值。\n18. “TAN(numeric)”表示返回numeric的正切值。\n19. “COT(numeric)”表示返回numeric的余切值。\n20. “ASIN(numeric)”表示返回numeric的反正弦值。\n21. “ACOS(numeric)”表示返回numeric的反余弦值。\n22. “ATAN(numeric)”表示返回numeric的反正切值。\n23. “DEGREES(numeric)”表示将弧度转换为度数，返回numeric的度数值。\n24. “RADIANS(numeric)”表示将度数转换为弧度，返回numeric的弧度值。\n25. “SIGN(numeric)”表示返回numeric的符号，其中1表示正数，-1表示负数，0表示零。\n26. “PI”表示返回常量值π。\n27. “E()”表示返回常量值e。\n28. “RAND()”表示返回一个介于0和1之间的随机双精度浮点数。\n29. “RAND(seed s)”表示使用初始种子返回介于0.0（含）和1.0（不含）之间的伪随机双精度值。\n30. “RAND_INTEGER(bound numeric)”表示返回介于0和numeric之间的随机整数。\n31. “RAND_INTEGER(seed s, bound numeric)”表示使用初始种子返回介于0（含）和numeric（不含）之间的伪随机整数。\n32. “ROUND(numeric1, numeric2)”表示将numeric1四舍五入为numeric2位小数的结果。\n\n该段落包含了Geaflow支持的数学运算的具体功能描述，涵盖了对数、三角函数、常量及随机数生成等高级数学操作，属于文档中介绍数学操作功能的一部分。"
            },
            {
                "content": "概要总结: \n该表格列举了多种数学操作及其对应的说明，包括基本的数学运算、三角函数、对数、随机数生成等，提供了对数字进行多种处理和运算的函数描述，适用于需要进行数学计算和随机数生成的场景。\n| log2(numeric) | 返回numeric以2为底的对数 |\n\n该文档详细列出了Geaflow支持的多种数学运算，包括基本算术运算、三角函数、对数、随机数生成等，并分别给出了每种运算的具体说明。此处的概要总结对整个表格的内容进行了概括，并补充了以2为底的对数运算操作。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_67.md",
        "chunks": [
            {
                "content": "# Table\n\nTABLE 函数对每个输入返回若干行数据。\n\n**Table Function Syntax**\n\n```\nSELECT expr (, expr)*\nFROM (Table | SubQuery),\nLATERAL TABLE '('TableFunctionRef')' AS Identifier '(' Identifier (,Identifier)* ')'\n```\n\n## split\n**Syntax**\n\n```sql\n\tsplit(string text)\n\tsplit(string text, string separator)\n```\n**Description**\n将文本按分隔符拆分为字符串列表。默认分隔符为英文逗号','。\n\n**Example**\n\n```sql\nSELECT t.id, u.name FROM users u, LATERAL table(split(u.ids)) as t(id);\nSELECT t.id, u.name FROM users u, LATERAL table(split(u.ids, ',')) as t(id);\n```\n\n该文档介绍了TABLE函数及其语法，包括具体的分隔函数(split)及其用法示例，旨在帮助用户理解如何在SQL查询中使用这些函数进行数据处理。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_68.md",
        "chunks": [
            {
                "content": "# 应用场景（图与图数据库可以做什么）\n\n> 此文档主要介绍图数据库适用的应用场景。\n\n## 1. 金融领域\n\n金融领域的实体主要涉及人、公司、账户、产品等，它们之间的关系包括交易关系、登录关系、股权关系、雇佣关系等。这些实体构成了一张金融图数据网络。应用图数据库，我们可以从金融图数据网络里发掘出大量有用信息，帮助我们做出更准确的金融决策。\n\n| **场景**         | **描述**               |\n|-----------------| -----------------------|\n|贷款审核|通过分析申请人的关联关系、交易情况等辅助判断申请人的偿还能力和偿还意愿，可应用于零售贷款审核、小微贷款审核、供应链金融等。此方法可与传统的基于申请人自身信息的审核机制互补，在个体信息录覆盖较低的小微贷款审核中尤其有用。|\n|贷后管理|通过分析借款人交易情况，辅助分析借款人是否有逾期风险。相比于传统只在贷款资金流向特定用户的情况下发出警报的方式不同，该方法可以给每个账户赋予一个风险值，并在贷款流向高风险账户时给出预警。|\n|失联修复|通过分析失联贷款人的社交和购物数据，找出其它联系方式。该方法可以大幅改进失联修复率。|\n|担保环检测|可在担保关系图中找出环状、链式、家族式、交叉等特殊担保结构，揭露潜在风险。相比于关系型数据库的JOIN方法，基于图算法的方案更高效，可以检测出任意长的担保环，且可以实现更复杂限定条件的检测。|\n|信用卡团伙欺诈检测|构建信用卡申请信息中的地址、联系方式等关系网络，在申请关系网络中运行社区发现算法，可以检测出疑似欺诈的团伙，从而拒绝涉嫌欺诈的申请件，减少经济损失。|\n|反洗钱|通过交易网络和介质网络，找出疑似洗钱的行为和链路。洗钱是一个复杂的多方参与的过程，通过在交易和社交网络中进行图分析，我们可以更精准的检测出洗钱行为。|\n|车险反欺诈|针对有修理厂参与的骗保行为，通过分析被保人、案件地点和修理厂之间的关系，可以更精准的识别出骗保行为，减少经济损失。|\n表格内容描述:\n该表格包含两列，分别为“场景”和“描述”。每一行对应不同的金融场景及其相关的描述内容。\n\n该文档介绍了图数据库的多种应用场景，包括金融、工业、智慧城市、社会治理和互联网等领域。第一部分聚焦于金融领域，详细描述了使用图数据库处理贷款审核、贷后管理、失联修复等金融场景，提高风险识别和管理的能力。"
            },
            {
                "content": "1. 在“贷款审核”场景中，描述提到通过分析申请人的关系和交易情况来判断其偿还能力和意愿，这种方法适用于各类贷款审核，并可与传统方法互补。\n2. 对于“贷后管理”，通过分析借款人的交易情况来评估逾期风险，并根据风险值为每个账户提供预警，与传统放贷方式不同。\n3. “失联修复”中，通过分析失联贷款人的社交和购物数据来寻找其他联系方式，显著提高失联修复率。\n4. 在“担保环检测”中，该方法能识别复杂的担保结构和潜在风险，比关系型数据库的方法效率更高，能够检测任意长的担保环。\n5. “信用卡团伙欺诈检测”通过构建申请信息的关系网络，并运用社区发现算法来识别疑似欺诈团伙，帮助拒绝涉嫌欺诈的申请。\n6. 在“反洗钱”场景中，利用交易网络和社交网络进行图分析，能更准确地识别洗钱行为，揭示复杂的参与链路。\n7. 最后，“车险反欺诈”通过分析相关方的关系来精准识别骗保行为，减少可能的经济损失。\n\n总体总结：该表格展示了多种金融场景下的风险识别和管理方法，强调通过数据分析、图算法和网络关系的应用，提高金融操作的安全性和效率，有效防范和减少潜在的金融风险。\n\n## 2. 工业领域\n\n在生产和制造过程中会产生大量异构数据，如何有效的组织和管理这些数据是工业大数据中最重要的问题之一。这些数据包括设计文档、设备数据、仿真方案和结果、实验结果、经验文档等，关系错综复杂。传统的数据管理系统只能累积数据，而查找相关材料则往往力不从心。使用图模型，将这些不同类型的数据组织成一张网络，就可以方便地浏览和查找数据。\n\n该段落位于文档的第一部分，主要探讨图数据库在金融领域的应用场景，具体描述了贷款审核、贷后管理、失联修复等多个场景及相应的风险识别和管理方法。通过数据分析和网络关系的应用，强调了提高金融操作安全性和效率的重要性。"
            },
            {
                "content": "总体总结：该表格展示了多种金融场景下的风险识别和管理方法，强调通过数据分析、图算法和网络关系的应用，提高金融操作的安全性和效率，有效防范和减少潜在的金融风险。\n\n## 2. 工业领域\n\n在生产和制造过程中会产生大量异构数据，如何有效的组织和管理这些数据是工业大数据中最重要的问题之一。这些数据包括设计文档、设备数据、仿真方案和结果、实验结果、经验文档等，关系错综复杂。传统的数据管理系统只能累积数据，而查找相关材料则往往力不从心。使用图模型，将这些不同类型的数据组织成一张网络，就可以方便地浏览和查找数据。\n\n| **场景**         | **描述**               |\n|-----------------| -----------------------|\n|供应链管理|供应链数据主要关心产品—部件—零件的对应关系、零件与供应商的对应关系、零件中的敏感成分等。相比于传统的物料管理（BOM）系统，使用图数据库的方案可以更方便地维护多个部件层次、多个供应商级别的复杂网络，从而为穿透式供应链提供基础支持。|\n|文档管理|使用图数据库可以将不同类型的文档按不同关系有机地组织在一起。例如将部件设计文档、部件—零件关系、部件测试文档、相关经验文档等组织起来，在需要查找时就可以方便获取该部件的所有相关信息。|\n|研发过程管理|产品研发和验证过程中需要进行大量仿真、试验和测试，每一个测试流程都会涉及大量不同的步骤。步骤之间的连接关系、每个步骤中使用的数据版本、算法版本等就构成了一张复杂的关系网络。使用图数据库可以更好管理这个关系网络，从而为研发过程中的数据复用、流程改进提供良好基础。|\n|设备信息管理|制造业需要管理大量设备，设备之间又互相关联（供电关系、供料关系、空间关系），从而形成了一张复杂的网络。传统的数据库很难体现这种复杂关系。而使用图数据库则可以便捷表示这些关系，从而更好的管理设备信息。|\n表格内容描述: 此表格包含两列，分别是“场景”和“描述”。\n\n1. 供应链管理：该场景关注供应链数据中产品、部件与零件的关系，以及零件与供应商的对应关系和零件中敏感成分的管理。相较于传统的物料管理系统，图数据库能够更方便地维护复杂的多层次部件和供应商网络，为实现全面的供应链管理提供支持。\n\n该块内容位于文档的第二部分，讨论了“工业领域”的应用场景，重点介绍了图数据库在供应链管理、文档管理、研发过程管理和设备信息管理中的具体应用和优势。同时，该块之前的总结强调了图数据库在金融领域的风险识别和管理方法。这段内容为整体论述图数据库在不同领域的应用提供了案例支持。"
            },
            {
                "content": "1. 供应链管理：该场景关注供应链数据中产品、部件与零件的关系，以及零件与供应商的对应关系和零件中敏感成分的管理。相较于传统的物料管理系统，图数据库能够更方便地维护复杂的多层次部件和供应商网络，为实现全面的供应链管理提供支持。\n\n2. 文档管理：在此场景中，图数据库可以将不同类型的文档通过多种关系有机组织。例如，将部件设计文档、部件与零件的关系文档、部件测试文档和相关经验文档等进行整理，以便在需要时迅速获取某部件的所有相关信息。\n\n3. 研发过程管理：在产品研发和验证过程中，会涉及多个仿真、试验和测试环节。每个测试环节之间的连接关系、所用的数据和算法版本等，构成了一张复杂的关系网络。图数据库能有效管理这种关系网络，从而促进研发过程中的数据复用和流程优化。\n\n4. 设备信息管理：制造业需管理大量设备，设备之间存在供电、供料及空间等多种相互关系，形成复杂的网络。传统数据库难以体现这些复杂关系，而通过图数据库则能简洁明了地表示和管理设备信息。\n\n整体总结：此表格阐述了不同领域（供应链管理、文档管理、研发过程管理、设备信息管理）中图数据库的应用及其优势。图数据库在处理复杂关系网络方面表现出色，能够提升信息管理的效率和便利性。\n\n## 3. 智慧城市\n\n随着科技的发展，城市的智能化管理已成为一个大趋势。智能化管理需要建立在良好的信息管理平台之上，因此需要强大的系统软件做支撑。在智能化城市管理系统中，智能化决策系统需要基于大量不同信息做出决策，这些信息包括各种拓扑信息（道路、管线），供求信息（电力输送、饮用水供应、污水排放），环境信息（温度、湿度、雨量）等。要将这些复杂的异构数据有机管理起来，并基于它们做出决策，就需要一个成熟的系统。传统的数据管理系统基于关系数据模型，并不适合管理这种复杂异构数据。而使用图模型就可以很好的解决这一问题。如果我们将这些不同的数据利用图数据库进行管理，就可以实现很多复杂的智能管理场景。\n\n该段落位于文档中的“工业领域”部分，介绍了图数据库在供应链管理、文档管理、研发过程管理和设备信息管理等方面的应用场景及其优势，强调其在处理复杂关系网络和提升信息管理效率中的重要性。"
            },
            {
                "content": "4. 设备信息管理：制造业需管理大量设备，设备之间存在供电、供料及空间等多种相互关系，形成复杂的网络。传统数据库难以体现这些复杂关系，而通过图数据库则能简洁明了地表示和管理设备信息。\n\n整体总结：此表格阐述了不同领域（供应链管理、文档管理、研发过程管理、设备信息管理）中图数据库的应用及其优势。图数据库在处理复杂关系网络方面表现出色，能够提升信息管理的效率和便利性。\n\n## 3. 智慧城市\n\n随着科技的发展，城市的智能化管理已成为一个大趋势。智能化管理需要建立在良好的信息管理平台之上，因此需要强大的系统软件做支撑。在智能化城市管理系统中，智能化决策系统需要基于大量不同信息做出决策，这些信息包括各种拓扑信息（道路、管线），供求信息（电力输送、饮用水供应、污水排放），环境信息（温度、湿度、雨量）等。要将这些复杂的异构数据有机管理起来，并基于它们做出决策，就需要一个成熟的系统。传统的数据管理系统基于关系数据模型，并不适合管理这种复杂异构数据。而使用图模型就可以很好的解决这一问题。如果我们将这些不同的数据利用图数据库进行管理，就可以实现很多复杂的智能管理场景。\n\n| **场景**         | **描述**               |\n|-----------------| -----------------------|\n|智能交通|基于道路拓扑、道路容量及当前流量，可以进行智能信号灯调度，从而提高通行效率。|\n|智能排水|基于排水系统信息及当前雨量，可以对排水系统进行调度，从而减少内涝的产生。|\n|管线管理|将管线的生产、安装、拓扑信息，以及历史状态信息有机组织起来，可以帮助我们对管线进行全周期管理，包括故障排查、寿命评估等。|\n|人群疏散|大量人群需要疏散时，需要考虑公交、地铁、出租车、共享单车等多种交通方式，同时还需要考虑道路承载量。使用图数据库将这些信息有机整合在一起，可以帮助我们更好的做出决策，以便为大型公共活动提供更好的支持。|\n表格内容描述: \n\n该表格包含两个列名：**场景**和**描述**，分别代表不同的应用场景及其对应的详细描述。\n\n该内容片段位于文档的“工业领域”部分，其中讨论了图数据库在设备信息管理方面的应用和优势。接下来，文档将进一步探讨“智慧城市”领域，强调图数据库在城市智能管理中的价值和应用场景。"
            },
            {
                "content": "| **场景**         | **描述**               |\n|-----------------| -----------------------|\n|智能交通|基于道路拓扑、道路容量及当前流量，可以进行智能信号灯调度，从而提高通行效率。|\n|智能排水|基于排水系统信息及当前雨量，可以对排水系统进行调度，从而减少内涝的产生。|\n|管线管理|将管线的生产、安装、拓扑信息，以及历史状态信息有机组织起来，可以帮助我们对管线进行全周期管理，包括故障排查、寿命评估等。|\n|人群疏散|大量人群需要疏散时，需要考虑公交、地铁、出租车、共享单车等多种交通方式，同时还需要考虑道路承载量。使用图数据库将这些信息有机整合在一起，可以帮助我们更好的做出决策，以便为大型公共活动提供更好的支持。|\n表格内容描述: \n\n该表格包含两个列名：**场景**和**描述**，分别代表不同的应用场景及其对应的详细描述。\n\n1. **智能交通**：该场景利用道路拓扑、道路容量及当前流量信息，通过智能信号灯的调度，提高道路通行效率。\n   \n2. **智能排水**：在此场景中，基于排水系统的运行信息和当前降雨量，能够对排水系统进行有效调度，从而减少内涝现象的发生。\n   \n3. **管线管理**：该场景整合了管线的生产、安装、拓扑及历史状态信息，全面提升管线的全生命周期管理，包括故障排查和寿命评估等方面。\n   \n4. **人群疏散**：当大量人群需要疏散时，该场景考虑了公交、地铁、出租车及共享单车等多种交通方式，并结合道路承载量，利用图数据库整合这些信息，以便做出更优决策，从而为大型公共活动提供更全面的支持。\n\n整体总结：该表格描述了四个不同的智能管理场景，涵盖了交通、排水、管线及人群疏散等领域，表明了通过整合相关信息和技术，能够有效提升各领域的管理效率与安全性。\n\n## 4. 社会治理\n\n社会治理包括公共安全、法律事务、舆论、网络安全等多方面。社会治理是一个综合性的、多系统联动问题。它需要综合大量数据、全局考量才能做出更好的决策。在这种多维度复杂数据问题上，图数据模型可以提供更好的适应性，从而为智能化的社会治理决策平台提供坚实的基础。\n\n该块内容位于文档的第三部分“智慧城市”，专注于图数据库在智能交通、排水、管线管理和人群疏散等场景中的应用，强调如何通过整合相关信息提升城市管理的效率与安全性。"
            },
            {
                "content": "整体总结：该表格描述了四个不同的智能管理场景，涵盖了交通、排水、管线及人群疏散等领域，表明了通过整合相关信息和技术，能够有效提升各领域的管理效率与安全性。\n\n## 4. 社会治理\n\n社会治理包括公共安全、法律事务、舆论、网络安全等多方面。社会治理是一个综合性的、多系统联动问题。它需要综合大量数据、全局考量才能做出更好的决策。在这种多维度复杂数据问题上，图数据模型可以提供更好的适应性，从而为智能化的社会治理决策平台提供坚实的基础。\n\n| **场景**         | **描述**               |\n|-----------------| -----------------------|\n|犯罪团伙发现|合谋团伙必然会通过某些方式产生联系，这种联系包括面谈（出现在同一地点）、电话联系、或者互联网联系，他们还可能有经济往来。如果我们将这些数据统一存放在一张图中，我们就可以通过图分析算法查找出联系紧密的群体，从而发现和识别整个犯罪团伙。|\n|涉众案件调查|涉众案件，特别是涉众经济案件往往涉及大量的人员和要素（货币、地点、事件等）。如何有效的组织这些资料，从而为办案提供证据支持是涉众案件调查的一个难点。使用图数据库来存储和分析这些资料，可以让我们快速定位资料、分析人员构成、为案件调查提供更好的技术支持。|\n|违法网站甄别|违法网站、钓鱼网站、黄色网站等往往通过使用不同的域名和IP来避免被封杀。基于黑名单的过滤方法只能封禁已知的违法网站，无法对新出现的域名和IP进行有效甄别。基于IP—域名网络的映射关系，我们可以建立一张图，然后通过图计算建立起域名和IP的“可信度”模型，利用该模型来判断网站是否属于违法网站。|\n|法院卷宗管理|卷宗往往错综复杂，不同的案件之间可能通过当事人产生联系，也可能通过案发地、案件性质、审判人员等产生联系。这些联系构成了一张复杂的网络。使用图数据库我们可以更方便的管理这些复杂关系，提高办案和查询效率。|\n表格内容描述: 该表格包含两列，分别是“场景”和“描述”， detailing four different scenarios related to crime and investigation.\n\n第一行描述的是“犯罪团伙发现”。合谋团伙通过面谈、电话联系或互联网联系相互联系，并可能存在经济往来。通过将数据统一存放在图中，并运用图分析算法，可以发现和识别整个犯罪团伙。\n\n该段落位于文档的第四部分“社会治理”，讨论了社会治理相关的应用场景，重点在于如何通过图数据库和图分析技术提高在公共安全、法律事务和网络安全等领域的决策效率，具体包括犯罪团伙发现、涉众案件调查、违法网站甄别和法院卷宗管理等场景。"
            },
            {
                "content": "第一行描述的是“犯罪团伙发现”。合谋团伙通过面谈、电话联系或互联网联系相互联系，并可能存在经济往来。通过将数据统一存放在图中，并运用图分析算法，可以发现和识别整个犯罪团伙。\n\n第二行描述的是“涉众案件调查”。涉众案件，特别是经济案件涵盖大量人员及要素（如货币、地点和事件）。组织这些资料并为办案提供证据支持是其难点。利用图数据库进行存储和分析，可以快速定位资料、掌握人员构成，从而为案件调查提供技术支持。\n\n第三行描述的是“违法网站甄别”。违法网站通常通过不同的域名和IP避免被封锁。传统的黑名单过滤方法对新出现的网站无效。通过构建IP与域名的映射关系图，建立“可信度”模型以判断网站是否合法，可以更有效地区别违法网站。\n\n第四行描述的是“法院卷宗管理”。法院卷宗复杂，各案件可能通过当事人、案发地、性质等相互关联。应用图数据库能够更便捷地管理这些复杂关系，提高办案和查询效率。\n\n总体总结：此表格探讨了通过图数据库和图分析技术在犯罪侦查、涉众案件调查、违法网站甄别和法院卷宗管理等多个场景下所能带来的效率提升和数据处理能力，展示了图技术在处理复杂关系网中的实用价值。\n\n## 5. 互联网\n\n人—人关系的社交网络、人—商品的购买关系都能构成图。通过分析这些网络数据，我们可以为用户提供更优质的服务，包括相关推荐、用户信息归集、重要用户识别、垃圾用户识别等。\n\n| **场景**         | **描述**               |\n|-----------------| -----------------------|\n|ID映射|图数据库可以将用户相关的所有信息，包括用户之间的关系统一存储在一个数据库中，同时还能通过这些关系来找出疑似单人多号和多人一号的情况，从而为后期的风控、推荐等业务提供决策支持。|\n|好友推荐|基于分析社交网络，我们可以提供“好友的好友”，“共同好友”等好友推荐。|\n|商品推荐|基于用户—商品关系图，我们可以找出兴趣爱好类似的用户，向他们推荐类似用户选择的其他商品。|\n表格内容描述: \n\n该表格包含两列，分别是“场景”和“描述”。 \n\n在“ID映射”行中，描述指出图数据库能够将用户的所有相关信息以及用户之间的关系统一存储，这样可以帮助识别出疑似的单人多号和多人一号的情况，从而为后续的风控和推荐提供决策支持。\n\n该段落位于文档的第四部分，探讨了社会治理中的几个应用场景，包括犯罪团伙发现、涉众案件调查、违法网站甄别和法院卷宗管理，强调了图数据库在处理复杂数据关系中的重要性和实用性。接着，文档转向第五部分，讨论了互联网领域的人际关系和商品关系，通过图数据库技术提供个性化服务的应用案例。"
            },
            {
                "content": "## 5. 互联网\n\n人—人关系的社交网络、人—商品的购买关系都能构成图。通过分析这些网络数据，我们可以为用户提供更优质的服务，包括相关推荐、用户信息归集、重要用户识别、垃圾用户识别等。\n\n| **场景**         | **描述**               |\n|-----------------| -----------------------|\n|ID映射|图数据库可以将用户相关的所有信息，包括用户之间的关系统一存储在一个数据库中，同时还能通过这些关系来找出疑似单人多号和多人一号的情况，从而为后期的风控、推荐等业务提供决策支持。|\n|好友推荐|基于分析社交网络，我们可以提供“好友的好友”，“共同好友”等好友推荐。|\n|商品推荐|基于用户—商品关系图，我们可以找出兴趣爱好类似的用户，向他们推荐类似用户选择的其他商品。|\n表格内容描述: \n\n该表格包含两列，分别是“场景”和“描述”。 \n\n在“ID映射”行中，描述指出图数据库能够将用户的所有相关信息以及用户之间的关系统一存储，这样可以帮助识别出疑似的单人多号和多人一号的情况，从而为后续的风控和推荐提供决策支持。\n\n在“好友推荐”行中，介绍了基于社交网络分析，可以提供“好友的好友”和“共同好友”等推荐功能，帮助用户扩大社交圈。\n\n在“商品推荐”行中，说明通过分析用户与商品之间的关系图，能够发现兴趣爱好相似的用户，并向他们推荐类似用户选择的其他商品。\n\n总体来看，该表格展示了通过图数据库技术在用户管理、社交推荐和商品推荐等场景中，可以如何有效地利用用户数据，为用户提供个性化和精准的推荐服务。\n|垃圾用户识别|传统的垃圾用户识别主要基于用户账号本身的信息，如注册信息、发帖信息等，但是这些信息都比较容易伪造。而基于网络的信息则不存在这个问题：它们很难被伪造。因此基于网络信息的垃圾用户识别可以更加精准和高效。|\n\n该段落位于文档的第五部分，讨论了图数据库在互联网领域的应用，包括社交网络分析和商品推荐。具体阐述了如何通过用户之间的关系和购买行为来提供个性化服务，例如ID映射、好友推荐和商品推荐，同时强调了垃圾用户识别的高效性。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_69.md",
        "chunks": [
            {
                "content": "# TuGraph-OGM\n\n## 1.简介\n\n> TuGraph-OGM 项目在其他仓库开源。\n\nTuGraph-OGM(Object Graph Mapping)为面向 TuGraph 的图对象映射工具，支持将 JAVA 对象（POJO）映射到 TuGraph 中，JAVA 中的类映射为图中的节点、类中的集合映射为边、类的属性映射为图对象的属性，并提供了对应的函数操作图数据库，因此 JAVA 开发人员可以在熟悉的生态中轻松地使用 TuGraph 数据库。同时 TuGraph-OGM 兼容 Neo4j-OGM，Neo4j 生态用户可以无缝迁移到 TuGraph 数据库上。\n\n### 1.1.TuGraph-OGM 功能\n\nTuGraph-OGM 提供以下函数操作 TuGraph：\n\n该文档介绍了TuGraph-OGM，一个用于将JAVA对象映射到TuGraph图数据库的工具，并列出了其主要功能和操作方法。该工具支持JAVA开发人员在熟悉的环境中进行图数据库操作，并与Neo4j-OGM兼容。文中详细描述了TuGraph-OGM的功能、编译方法、使用示例及如何与TuGraph建立连接。"
            },
            {
                "content": "| 功能                            | 用法                                                                             |\n| ------------------------------- | -------------------------------------------------------------------------------- |\n| 插入单个节点\\边                 | void session.save(T object)                                                      |\n| 批量插入节点\\边                 | void session.save(T object)                                                      |\n| 删除节点与对应边                | void session.delete(T object)                                                    |\n| 删除指定 label 的全部节点       | void session.deleteAll(Class\\ type)                                           |\n| 清空数据库                      | void purgeDatabase()                                                             |\n| 更新节点                        | void session.save(T newObject)                                                   |\n| 根据 id 查询单个节点            | T load(Class type, ID id)                                                     |\n\n该块内容位于文档的第二部分，详细列出了 TuGraph-OGM 提供的功能及其对应的使用方法，包括节点和边的插入、删除、更新和查询等基本操作，为开发人员在使用 TuGraph 数据库时提供了参考。"
            },
            {
                "content": "| 删除指定 label 的全部节点       | void session.deleteAll(Class\\ type)                                           |\n| 清空数据库                      | void purgeDatabase()                                                             |\n| 更新节点                        | void session.save(T newObject)                                                   |\n| 根据 id 查询单个节点            | T load(Class type, ID id)                                                     |\n| 根据 ids 查询多个节点           | Collection\\ loadAll(Class\\ type, Collection ids)                       |\n| 根据 label 查询全部节点         | Collection\\ loadAll(Class\\ type)                                           |\n| 条件查询                        | Collection\\ loadAll(Class\\ type, Filters filters)                          |\n| Cypher 查询（指定返回结果类型） | T queryForObject(Class\\ objectType, String cypher, Map parameters) |\n| Cypher 查询                     | Result query(String cypher, Map parameters)                           |\n表格内容描述:\n\n该块内容位于文档第二部分的功能描述中，详细列出了TuGraph-OGM提供的各种数据库操作功能及其对应的用法，包括删除节点、清空数据库、更新节点、查询节点和执行Cypher查询等基本操作。"
            },
            {
                "content": "该表格列出了不同的功能及其对应的用法。具体列名为“功能”和“用法”。\n\n1. 插入单个节点或边的功能使用`void session.save(T object)`方法。\n2. 批量插入节点或边采用与单个插入相同的方法，即`void session.save(T object)`。\n3. 删除节点及其对应边的功能可以通过`void session.delete(T object)`实现。\n4. 如果需要删除指定label的全部节点，可使用`void session.deleteAll(Class type)`方法。\n5. 清空数据库的操作使用`void purgeDatabase()`方法。\n6. 更新节点的功能可通过`void session.save(T newObject)`实现。\n7. 查询单个节点根据id使用`T load(Class type, ID id)`方法。\n8. 根据一组ids查询多个节点，可使用`Collection loadAll(Class type, Collection ids)`。\n9. 查询所有指定label的节点，使用`Collection loadAll(Class type)`。\n10. 条件查询功能通过`Collection loadAll(Class type, Filters filters)`来实现。\n11. 使用Cypher查询时，可以指定返回的结果类型，通过`T queryForObject(Class objectType, String cypher, Map parameters)`。\n12. 进行通用的Cypher查询，则使用`Result query(String cypher, Map parameters)`。\n\n综上所述，该表格提供了一系列与数据库操作相关的功能及其具体实现方法，涵盖了节点和边的插入、删除、更新、查询等基本操作，适用于开发人员在使用数据库时的参考。\n\n## 2.编译 TuGraph-OGM\n\n```shell\ncd tugraph-ogm\nmvn clean install -DskipTests -Denforcer.skip=true\n```\n\n## 3.使用 TuGraph-OGM\n\n详细示例请参考 demo 文件夹下的 TuGraphOGMDemo ###在`pom.xml`中引入依赖\n\n```\n\n该块内容位于文档的功能描述部分，具体介绍了TuGraph-OGM提供的各种数据库操作功能及其对应的用法，旨在为开发人员提供操作指南和参考。"
            },
            {
                "content": "综上所述，该表格提供了一系列与数据库操作相关的功能及其具体实现方法，涵盖了节点和边的插入、删除、更新、查询等基本操作，适用于开发人员在使用数据库时的参考。\n\n## 2.编译 TuGraph-OGM\n\n```shell\ncd tugraph-ogm\nmvn clean install -DskipTests -Denforcer.skip=true\n```\n\n## 3.使用 TuGraph-OGM\n\n详细示例请参考 demo 文件夹下的 TuGraphOGMDemo ###在`pom.xml`中引入依赖\n\n```\n\norg.neo4j\nneo4j-ogm-api\n0.1.0-SNAPSHOT\n\n\norg.neo4j\nneo4j-ogm-core\n0.1.0-SNAPSHOT\n\n\norg.neo4j\ntugraph-rpc-driver\n0.1.0-SNAPSHOT\n\n```\n\n### 3.1.构建图对象\n\n```java\n@NodeEntity\npublic class Movie {      // 构建Movie节点\n    @Id\n    private Long id;      // Movie节点的id\n    private String title; // title属性\n    private int released; // released属性\n\n    // 构建边ACTS_IN    (actor)-[:ACTS_IN]->(movie)\n    @Relationship(type = \"ACTS_IN\", direction = Relationship.Direction.INCOMING)\n    Set actors = new HashSet<>();\n\n    public Movie(String title, int year) {\n        this.title = title;\n        this.released = year;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public void setReleased(int released) {\n        this.released = released;\n    }\n}\n\n该段落主要介绍了 TuGraph-OGM 的基本功能和使用方法，包括编译步骤、如何在 `pom.xml` 中引入依赖、构建图对象的示例，以及针对图数据库的操作示例。这部分内容是文档中关于 TuGraph-OGM 使用指南的关键组成部分，有助于用户在实际应用中参考和实现图数据库的相关操作。"
            },
            {
                "content": "// 构建边ACTS_IN    (actor)-[:ACTS_IN]->(movie)\n    @Relationship(type = \"ACTS_IN\", direction = Relationship.Direction.INCOMING)\n    Set actors = new HashSet<>();\n\n    public Movie(String title, int year) {\n        this.title = title;\n        this.released = year;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public void setReleased(int released) {\n        this.released = released;\n    }\n}\n\n@NodeEntity\npublic class Actor {      // 构建Actor节点\n    @Id\n    private Long id;\n    private String name;\n\n    @Relationship(type = \"ACTS_IN\", direction = Relationship.Direction.OUTGOING)\n    private Set movies = new HashSet<>();\n\n    public Actor(String name) {\n        this.name = name;\n    }\n\n    public void actsIn(Movie movie) {\n        movies.add(movie);\n        movie.getActors().add(this);\n    }\n}\n```\n\n### 3.2.与TuGraph建立连接\n\n该代码块位于文档的3.1节“构建图对象”下，展示了如何定义电影（Movie）和演员（Actor）两个节点实体及其之间的关系（边）“ACTS_IN”。通过这些定义，开发者可以创建具有相互关系的图数据结构，为后续的数据库操作做好准备。"
            },
            {
                "content": "@Relationship(type = \"ACTS_IN\", direction = Relationship.Direction.OUTGOING)\n    private Set movies = new HashSet<>();\n\n    public Actor(String name) {\n        this.name = name;\n    }\n\n    public void actsIn(Movie movie) {\n        movies.add(movie);\n        movie.getActors().add(this);\n    }\n}\n```\n\n### 3.2.与TuGraph建立连接\n\n```java\n// 配置\nString databaseUri = \"list://ip:port\";\nString username = \"admin\";\nString password = \"73@TuGraph\";\n//启动driver\nDriver driver = new RpcDriver();\nConfiguration.Builder baseConfigurationBuilder = new Configuration.Builder()\n                            .uri(databaseUri)\n                            .verifyConnection(true)\n                            .credentials(username, password);\n                            driver.configure(baseConfigurationBuilder.build());\ndriver.configure(baseConfigurationBuilder.build());\n// 开启session\nSessionFactory sessionFactory = new SessionFactory(driver, \"entity_path\");\nSession session = sessionFactory.openSession();\n```\n\n### 3.3.通过OGM进行增删改查\n\n该段代码位于文档的第3.1节“构建图对象”中，具体展示了Actor节点的定义及其与Movie节点的关系构建方法。在此之后，文档进入第3.2节“与TuGraph建立连接”，介绍如何配置与TuGraph数据库的连接。"
            },
            {
                "content": "### 3.3.通过OGM进行增删改查\n\n```java\n// 增\nMovie jokes = new Movie(\"Jokes\", 1990);  // 新建Movie节点jokes\nsession.save(jokes);                     // 将jokes存储在TuGraph中\n\nMovie speed = new Movie(\"Speed\", 2019);\nActor alice = new Actor(\"Alice Neeves\");\nalice.actsIn(speed);                    // 将speed节点与alice节点通过ACTS_IN进行连接\nsession.save(speed);                    // 存储两个节点与一条边\n\n// 删\nsession.delete(alice);                  // 删除alice节点以及相连的边\nMovie m = session.load(Movie.class, jokes.getId());   // 根据jokes节点的id获取jokes节点\nsession.delete(m);                                    // 删除jokes节点\n\n// 改\nspeed.setReleased(2018);\nsession.save(speed);                   // 更新speed节点属性\n\n// 查\nCollection movies = session.loadAll(Movie.class);  // 获取所有Movie节点\nCollection moviesFilter = session.loadAll(Movie.class,\n        new Filter(\"released\", ComparisonOperator.LESS_THAN, 1995));  // 查询所有小于1995年发布的电影\n\n该段落位于文档的第3节，专门介绍如何通过TuGraph-OGM工具进行增、删、改、查（CRUD）操作，提供了具体的代码示例以展示如何在Java中处理图数据库中的节点和边。"
            },
            {
                "content": "// 改\nspeed.setReleased(2018);\nsession.save(speed);                   // 更新speed节点属性\n\n// 查\nCollection movies = session.loadAll(Movie.class);  // 获取所有Movie节点\nCollection moviesFilter = session.loadAll(Movie.class,\n        new Filter(\"released\", ComparisonOperator.LESS_THAN, 1995));  // 查询所有小于1995年发布的电影\n\n// 调用Cypher\nHashMap parameters = new HashMap<>();\nparameters.put(\"Speed\", 2018);\nMovie cm = session.queryForObject(Movie.class,\n        \"MATCH (cm:Movie{Speed: $Speed}) RETURN *\", parameters);      // 查询Speed为2018的Movie\n\n该片段位于文档的“3.3.通过OGM进行增删改查”部分，具体描述了如何使用TuGraph-OGM工具对图数据库中的节点进行更新（修改节点属性）和查询（获取所有节点及按条件过滤节点），并展示了如何使用Cypher进行查询。这部分是使用TuGraph-OGM进行数据库操作的重要示例。"
            },
            {
                "content": "// 调用Cypher\nHashMap parameters = new HashMap<>();\nparameters.put(\"Speed\", 2018);\nMovie cm = session.queryForObject(Movie.class,\n        \"MATCH (cm:Movie{Speed: $Speed}) RETURN *\", parameters);      // 查询Speed为2018的Movie\n\nsession.query(\"CALL db.createVertexLabel('Director', 'name', 'name',\" +\n        \"STRING, false, 'age', INT16, true)\", emptyMap());            // 创建节点Label Director\nsession.query(\"CALL db.createEdgeLabel('DIRECT', '[]')\", emptyMap()); // 创建边Label DIRECT\nResult createResult = session.query(\n        \"CREATE (n:Movie{title:\\\"The Shawshank Redemption\\\", released:1994})\" +\n        \"<-[r:DIRECT]-\" +\n        \"(n2:Director{name:\\\"Frank Darabont\\\", age:63})\",\n        emptyMap());\nQueryStatistics statistics = createResult.queryStatistics();          // 获取create结果\nSystem.out.println(\"created \" + statistics.getNodesCreated() + \" vertices\");    // 查看创建节点数目\nSystem.out.println(\"created \" + statistics.getRelationshipsCreated() + \" edges\");  //查看创建边数目\n\n该代码块位于文档的“3.3.通过OGM进行增删改查”部分，展示了如何使用TuGraph-OGM进行Cypher查询和图形数据的操作，包括查询特定电影、创建节点和边的标签以及创建新节点和边的示例。"
            },
            {
                "content": "// 清空数据库\nsession.deleteAll(Movie.class);        // 删除所有Movie节点\nsession.purgeDatabase();               // 删除全部数据\n```\n\n这段代码位于文档的“3.3.通过OGM进行增删改查”部分，主要介绍如何使用 TuGraph-OGM 进行数据库的基本操作，包括插入、删除、更新和查询。在此代码块中，展示了如何清空数据库中所有 Movie 节点及其他数据的操作。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_70.md",
        "chunks": [
            {
                "content": "# UDTF介绍\nUDTF（User Defined Table Function）将输入扩展为多行。\n## 接口\n\n```java\npublic abstract class UserDefinedFunction implements Serializable {\n\n   /**\n     * Init method for the user defined function.\n     */\n    public void open(FunctionContext context) {\n    }\n\n    /**\n     * Close method for the user defined function.\n     */\n    public void close() {\n    }\n}\n\npublic abstract class UDTF extends UserDefinedFunction {\n\n    protected List collector;\n\n    public UDTF() {\n        this.collector = Lists.newArrayList();\n    }\n\t\n\t/**\n     * Collect the result.\n     */\n    protected void collect(Object[] output) {\n        \n    }\n\t\n\t/**\n     * Returns type output types for the function.\n     * @param paramTypes The parameter types of the function.\n     * @param outFieldNames The output fields of the function in the sql.\n     */\n    public abstract List> getReturnType(List> paramTypes, \n\t\t\t\t\t\t\t\t\t\t\t\t List outFieldNames);\n}\n\n```\n每个UDTF都应该有一个或多个**eval**方法。\n\n## 示例\n\n```java\npublic class Split extends UDTF {\n\n本文档介绍了用户定义的表函数（UDTF），包括其接口及实现示例。UDTF允许将输入扩展为多行，并详细阐述了如何实现该功能及相关方法。该块内容包括UDTF的基本结构和接口定义，以及一个具体的UDTF实现示例。"
            },
            {
                "content": "```\n每个UDTF都应该有一个或多个**eval**方法。\n\n## 示例\n\n```java\npublic class Split extends UDTF {\n\n    private String splitChar = \",\";\n\n    public void eval(String text) {\n        evalInternal(text);\n    }\n\n    public void eval(String text, String separator) {\n        evalInternal(text, separator);\n    }\n\n    private void evalInternal(String... args) {\n        if (args != null && (args.length == 1 || args.length == 2)) {\n            if (args.length == 2 && StringUtils.isNotEmpty(args[1])) {\n                splitChar = args[1];\n            }\n            String[] lines = StringUtils.split(args[0], splitChar);\n            for (String line : lines) {\n                collect(new Object[]{line});\n            }\n        }\n    }\n\n    @Override\n    public List> getReturnType(List> paramTypes, \n\t\t\t\t\t\t\t\t\t\tList outputFields) {\n        return Collections.singletonList(String.class);\n    }\n}\n```\n\n```sql\nCREATE Function my_split AS 'com.antgroup.geaflow.dsl.udf.Split';\n\n该块内容介绍了UDTF（用户定义表函数）的示例实现，具体为一个名为`Split`的类，该类包含多个`eval`方法用于处理字符串的分割，并演示了如何在SQL中使用该自定义函数。"
            },
            {
                "content": "@Override\n    public List> getReturnType(List> paramTypes, \n\t\t\t\t\t\t\t\t\t\tList outputFields) {\n        return Collections.singletonList(String.class);\n    }\n}\n```\n\n```sql\nCREATE Function my_split AS 'com.antgroup.geaflow.dsl.udf.Split';\n\nSELECT t.id, u.name FROM users u, LATERAL table(my_split(u.ids)) as t(id);\n```\n\n该块包含了UDTF示例类`Split`的`getReturnType`方法实现，以及如何在SQL中创建和使用该自定义函数的示例查询。这部分主要展示了如何定义UDTF的输出类型和使用场景。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_71.md",
        "chunks": [
            {
                "content": "# TuGraph图模型说明\n## 1. 数据模型\n\n### 1.1. 图模型\n\nTuGraph是一个具备多图能力的强类型、有向属性图数据库。\n\n- 图项目：每个数据库服务可以承载多个图项目（多图），每个图项目可以有自己的访问控制配置，数据库管理员可以创建或删除指定图项目。\n- 点：指实体，一般用于表达现实中的实体对象，如一部电影、一个演员。\n    - 主键：用户自定义的点数据主键，默认唯一索引，在对应的点类型中唯一。\n    - VID：点在存储层自动分配图项目中的唯一ID，用户不可修改。\n    - 上限：每个图项目存储最多2^(40)个点数据。\n- 边：用于表达点与点之间的关系，如演员出演电影。\n    - 有向边：边为有向边。若要模拟无向边，用户可以创建两个方向相反的边。\n    - 多条边：两个点数据之间可以有多条边数据。当前TuGraph支持重复边，如要确保边边唯一，需要通过业务策略实现。\n    - 上限：两个点数据之间存储最多2^(32)条边数据。\n- 属性图：点和边可以具有与其关联的属性，每个属性可以有不同的类型。\n- 强类型：每个点和边有且仅有一个标签，创建标签后，修改属性数量及类型有代价。\n    - 指定边的起/终点类型：可限制边的起点和终点点类型，支持同类型边的起点和终点的点类型不同，如个人转账给公司、公司转账给公司；当指定边的起/终点类型后，可增加多组起/终点类型，不可删除已限制的起/终点类型。\n    - 无限制模式：支持不指定边的起点和终点的点类型，任意两个点类型间均可创建该类型的边数据。注：当指定边的起/终点类型后无法再采用无限制模式。\n\n### 1.2. 数据类型\n\nTuGraph支持多种可用于属性的数据类型。具体支持的数据类型如下：\n\n该内容为TuGraph图模型说明的第一部分，主要介绍了数据模型，包括图模型、点和边的定义、属性图的概念及其强类型特性，以及支持的数据类型。这部分为了解TuGraph数据库的基本结构和功能提供了基础信息。"
            },
            {
                "content": "| **数据类型** | **最小值**          | **最大值**          | **描述**                            |\n| ------------ | ------------------- | ------------------- | ----------------------------------- |\n| BOOL         | false               | true                | 布尔值                              |\n| INT8         | -128                | 127                 | 8位整型                          |\n| INT16        | -32768              | 32767               | 16位整型                         |\n| INT32        | - 2^31              | 2^31 - 1            | 32位整型                         |\n| INT64        | - 2^63              | 2^63 - 1            | 64位整型                         |\n| DATE         | 0000-00-00          | 9999-12-31          | \"YYYY-MM-DD\" 格式的日期             |\n| DATETIME     | 0000-00-00 00:00:00.000000 | 9999-12-31 23:59:59.999999 | \"YYYY-MM-DD HH:mm:ss[.ffffff]\" 格式的日期时间 |\n| FLOAT        |                     |                     | 32位浮点数                       |\n\n该内容位于文档的“1.2. 数据类型”部分，详细列出了TuGraph支持的各种数据类型及其最小值、最大值和描述，涵盖布尔值、整型、日期、时间和浮点数等。"
            },
            {
                "content": "| INT32        | - 2^31              | 2^31 - 1            | 32位整型                         |\n| INT64        | - 2^63              | 2^63 - 1            | 64位整型                         |\n| DATE         | 0000-00-00          | 9999-12-31          | \"YYYY-MM-DD\" 格式的日期             |\n| DATETIME     | 0000-00-00 00:00:00.000000 | 9999-12-31 23:59:59.999999 | \"YYYY-MM-DD HH:mm:ss[.ffffff]\" 格式的日期时间 |\n| FLOAT        |                     |                     | 32位浮点数                       |\n| DOUBLE       |                     |                     | 64位浮点数                       |\n| STRING       |                     |                     | 不定长度的字符串                    |\n| BLOB         |                     |                     | 二进制数据（在输入输出时使用Base64编码） |\n| POINT        |                     |                     | EWKB格式数据，表示点              |\n| LINESTRING   |                     |                     | EWKB格式数据，表示线              |\n| POLYGON      |                     |                     | EWKB格式数据，表示面(多边形)       |\n\n该chunk位于TuGraph图模型说明的\"数据类型\"部分，具体列出了支持的多种属性数据类型及其最小值、最大值和描述，包括整型、浮点数、字符串和空间数据类型等。这一部分为用户提供了在图数据库中使用的各种数据类型的详细信息，有助于理解和选择适合的数据格式。"
            },
            {
                "content": "| STRING       |                     |                     | 不定长度的字符串                    |\n| BLOB         |                     |                     | 二进制数据（在输入输出时使用Base64编码） |\n| POINT        |                     |                     | EWKB格式数据，表示点              |\n| LINESTRING   |                     |                     | EWKB格式数据，表示线              |\n| POLYGON      |                     |                     | EWKB格式数据，表示面(多边形)       |\n| FLOAT_VECTOR |                     |                     | 包含32位浮点数的动态向量               |\n表格内容描述: 本表格包含了多种数据类型的相关信息，列名包括“数据类型”、“最小值”、“最大值”和“描述”。\n\n该内容位于TuGraph图模型说明的“1.2. 数据类型”部分，详细列出了支持的多种数据类型及其描述，包括不定长度字符串、二进制数据、空间数据类型等，旨在帮助用户了解可用于图数据库属性的数据类型及特性。"
            },
            {
                "content": "逐行描述数据内容如下：\n1. BOOL：最小值为false，最大值为true，表示布尔值类型。\n2. INT8：最小值为-128，最大值为127，表示8位整型。\n3. INT16：最小值为-32768，最大值为32767，表示16位整型。\n4. INT32：最小值为-2^31，最大值为2^31 - 1，表示32位整型。\n5. INT64：最小值为-2^63，最大值为2^63 - 1，表示64位整型。\n6. DATE：最小值为0000-00-00，最大值为9999-12-31，格式为\"YYYY-MM-DD\"的日期。\n7. DATETIME：最小值为0000-00-00 00:00:00.000000，最大值为9999-12-31 23:59:59.999999，格式为\"YYYY-MM-DD HH:mm:ss[.ffffff]\"的日期时间。\n8. FLOAT：表示32位浮点数，未设定最小值和最大值。\n9. DOUBLE：表示64位浮点数，未设定最小值和最大值。\n10. STRING：表示不定长度的字符串，未设定最小值和最大值。\n11. BLOB：表示二进制数据，输入输出时使用Base64编码，未设定最小值和最大值。\n12. POINT：表示点的EWKB格式数据，未设定最小值和最大值。\n13. LINESTRING：表示线的EWKB格式数据，未设定最小值和最大值。\n14. POLYGON：表示面的EWKB格式数据（多边形），未设定最小值和最大值。\n15. FLOAT_VECTOR：表示包含32位浮点数的动态向量，未设定最小值和最大值。\n\n总体总结：该表格详细列出了多种数据类型及其取值范围，涵盖了布尔值、整型、日期、时间、浮点数、字符串、二进制数据以及空间数据类型等。对于一些数据类型，如浮点数、字符串、BLOB及空间数据类型，虽然未设定具体的最小或最大值，但它们各自的使用特性已在描述中说明。\n\n### 1.3. 索引\n\nTuGraph支持对点或边的属性创建索引，以提升查询效率。其特点如下：\n- 索引包括普通索引和组合索引，普通索引基于一个点或边的一个属性创建，而组合索引基于一个点或边的多个属性创建（不超过16个），可以对同一点或边的多个（组）属性创建索引。\n- 如果为点标签创建了唯一索引，在修改该标签的点时，会先执行数据完整性检查，以确保该索引的唯一性。\n- BLOB类型的属性不能建立索引。\n\n该内容位于文档的“数据模型”部分，具体介绍了TuGraph中支持的数据类型及其相关属性，包括各数据类型的最小值、最大值及其描述，同时总结了数据类型的总体特征。接下来部分则讲述了索引的相关信息。"
            },
            {
                "content": "总体总结：该表格详细列出了多种数据类型及其取值范围，涵盖了布尔值、整型、日期、时间、浮点数、字符串、二进制数据以及空间数据类型等。对于一些数据类型，如浮点数、字符串、BLOB及空间数据类型，虽然未设定具体的最小或最大值，但它们各自的使用特性已在描述中说明。\n\n### 1.3. 索引\n\nTuGraph支持对点或边的属性创建索引，以提升查询效率。其特点如下：\n- 索引包括普通索引和组合索引，普通索引基于一个点或边的一个属性创建，而组合索引基于一个点或边的多个属性创建（不超过16个），可以对同一点或边的多个（组）属性创建索引。\n- 如果为点标签创建了唯一索引，在修改该标签的点时，会先执行数据完整性检查，以确保该索引的唯一性。\n- BLOB类型的属性不能建立索引。\n\nTuGraph的点边均有多种索引类型，不同的索引类型的功能和限制不同，具体如下：\n\n#### 1.3.1 普通索引\n##### 1.3.1.1 点索引\n###### 1.3.1.1.1 unique索引\n\n点的unique索引指的是全局唯一的索引，即若一个属性设置了unique索引，在同一个图中，相同label的点的该属性不会存在相同的值，\nunique索引key的最大长度是480bytes，**超过480bytes的属性不能建立unique索引**。\nprimary作为特殊的unique索引，因此最大key的长度也是480bytes。\n\n###### 1.3.1.1.2 non_unique索引\n\n点的non_unique索引指的是非全局唯一的索引，即若一个属性设置了non_unique索引，\n在同一个图中，相同label的点的该属性可以存在相同的值。\n由于non_unique索引一个key可能映射到多个值，为了加速查找和写入，\n在用户指定的key后面加上了索引key相同的一组vid的最大值。\n每个vid是5bytes长度，因此non_unique索引key最大长度是475bytes。\n但是，不同于unique索引，超过475bytes也可以建立non_unique索引。\n只不过在对这样的属性建立索引时会只截取**前475bytes**作为索引key（属性本身存储的值不受影响）。\n并且，在通过迭代器遍历时，也是先自动截取查询值的前475bytes再进行遍历，\n所以结果可能和预期不一致，需要用户再过滤。\n\n##### 1.3.1.2 边索引\n\n该chunk位于TuGraph文档的第1.2节和第1.3节之间，主要总结了TuGraph支持的数据类型及其特性，并介绍了如何为点或边的属性创建索引以提升查询效率，涵盖了普通索引和组合索引的详细说明。"
            },
            {
                "content": "###### 1.3.1.1.2 non_unique索引\n\n点的non_unique索引指的是非全局唯一的索引，即若一个属性设置了non_unique索引，\n在同一个图中，相同label的点的该属性可以存在相同的值。\n由于non_unique索引一个key可能映射到多个值，为了加速查找和写入，\n在用户指定的key后面加上了索引key相同的一组vid的最大值。\n每个vid是5bytes长度，因此non_unique索引key最大长度是475bytes。\n但是，不同于unique索引，超过475bytes也可以建立non_unique索引。\n只不过在对这样的属性建立索引时会只截取**前475bytes**作为索引key（属性本身存储的值不受影响）。\n并且，在通过迭代器遍历时，也是先自动截取查询值的前475bytes再进行遍历，\n所以结果可能和预期不一致，需要用户再过滤。\n\n##### 1.3.1.2 边索引\n\n###### 1.3.1.2.1 unique索引\n\n和点类似，边的unique索引指的是全局唯一的索引，即若一个属性设置了unique索引，在同一个图中，相同label的边的该属性不会存在相同的值，\nunique索引key的最大长度是480bytes，**超过480bytes的属性不能建立unique索引**。\n\n###### 1.3.1.2.2 pair_unique索引\n\npair_unique索引指的是两点间的唯一索引，即若一个属性设置了unique索引，在同一个图的同一组起点和终点之间，\n相同label的边的该属性不会存在相同的值。为了保证pair_unique索引key在同一组起点和终点之间不重复，\n索引在用户指定的key后面加上了起点和终点的vid，每个vid是5bytes长度。\n因此最大key的长度是470bytes，**超过470bytes的属性不能建立pair_unique索引**。\n\n###### 1.3.1.2.3 non_unique索引\n\n该段落位于TuGraph图模型说明的索引部分，具体讨论了点和边的非唯一索引及其特性，包括non_unique索引、unique索引和pair_unique索引的定义、限制和使用细则。"
            },
            {
                "content": "##### 1.3.1.2 边索引\n\n###### 1.3.1.2.1 unique索引\n\n和点类似，边的unique索引指的是全局唯一的索引，即若一个属性设置了unique索引，在同一个图中，相同label的边的该属性不会存在相同的值，\nunique索引key的最大长度是480bytes，**超过480bytes的属性不能建立unique索引**。\n\n###### 1.3.1.2.2 pair_unique索引\n\npair_unique索引指的是两点间的唯一索引，即若一个属性设置了unique索引，在同一个图的同一组起点和终点之间，\n相同label的边的该属性不会存在相同的值。为了保证pair_unique索引key在同一组起点和终点之间不重复，\n索引在用户指定的key后面加上了起点和终点的vid，每个vid是5bytes长度。\n因此最大key的长度是470bytes，**超过470bytes的属性不能建立pair_unique索引**。\n\n###### 1.3.1.2.3 non_unique索引\n\n和点类似，边的non_unique索引指的是非全局唯一的索引，即若一个属性设置了non_unique索引，\n在同一个图中，相同label的边的该属性可以存在相同的值。\n由于non_unique索引一个key可能映射到多个值，为了加速查找和写入，\n在用户指定的key后面加上了索引key相同的一组eid的最大值。\n每个eid是24bytes长度，因此non_unique索引key最大长度是456bytes。\n但是，不同于unique索引，超过456bytes也可以建立non_unique索引。\n只不过在对这样的属性建立索引时会只截取**前456bytes**作为索引key（属性本身存储的值不受影响）。\n并且，在通过迭代器遍历时，也是先自动截取查询值的前456bytes再进行遍历，\n所以结果可能和预期不一致，需要用户再过滤。\n\n#### 1.3.2 组合索引\n\n目前只支持对点的多个属性建立组合索引，不支持对边的属性建立组合索引。组合索引支持唯一索引和非唯一索引两种类型，建立索引的要求如下：\n1. 建立组合索引的属性个数在2到16个之间（含）\n2. 唯一组合索引的属性长度之和不能超过480-2*(属性个数-1)字节，非唯一组合索引的属性长度之和不能超过475-2*(属性个数-1)字节\n\n该段落位于TuGraph图模型说明的索引部分，具体描述了边索引的类型，包括唯一索引、成对唯一索引和非唯一索引的定义、规则及限制。此外，还提到组合索引的相关要求和限制，提供关于如何高效管理边属性索引的信息。"
            },
            {
                "content": "#### 1.3.2 组合索引\n\n目前只支持对点的多个属性建立组合索引，不支持对边的属性建立组合索引。组合索引支持唯一索引和非唯一索引两种类型，建立索引的要求如下：\n1. 建立组合索引的属性个数在2到16个之间（含）\n2. 唯一组合索引的属性长度之和不能超过480-2*(属性个数-1)字节，非唯一组合索引的属性长度之和不能超过475-2*(属性个数-1)字节\n\n##### 1.3.2.1 唯一索引\n\n和点的普通唯一索引类似，点的组合唯一索引指的是全局唯一的索引，即若一组属性设置了unique索引，\n在同一个图中，相同label的点的该组属性不会存在相同的值。\n由于底层存储设计，组合索引key需要保存属性的长度，因此，\n组合唯一索引key的最大长度是480-2*(属性个数-1) bytes，**超过的属性不能建立唯一索引**。\n\n##### 1.3.2.2 非唯一索引\n\n和点的普通非唯一索引类似，点的非唯一索引指的是非全局唯一的索引，即若一组属性设置了非唯一索引，\n在同一个图中，相同label的点的该组属性可以存在相同的值。\n由于非唯一索引一个key可能映射到多个值，为了加速查找和写入，\n在用户指定的key后面加上了索引key相同的一组vid的最大值。\n每个vid是5bytes长度，因此non_unique索引key最大长度是475-2*(属性个数-1) bytes，\n**超过的属性不能建立非唯一索引**。\n\n## 2. 图项目、点、边、属性命名规则和建议\n\n### 2.1 命名规则\n图项目、点、边和属性是识别符。该节描述了在TuGraph中识别符的允许的语法。\n下面的表描述了每类识别符的最大长度和允许的字符。\n\n|**识别符** |**长度** |**允许的字符**|\n|---------  |---------  |---------  |\n|用户、角色、图项目\t|1-64字符\t|允许中文、字母、数字、下划线，且首字符不为数字|\n|点类型、边类型、属性\t|1~256字符\t|允许中文、字母、数字、下划线，且首字符不为数字|\n表格内容描述: 该表格包含三列，分别是“识别符”、“长度”和“允许的字符”。\n\n该内容块位于TuGraph图模型说明文档中，具体介绍了组合索引的相关信息，包括组合索引的类型、建立要求及其具体特性，后面紧接着是对图项目及点、边、属性的命名规则和建议的说明。"
            },
            {
                "content": "## 2. 图项目、点、边、属性命名规则和建议\n\n### 2.1 命名规则\n图项目、点、边和属性是识别符。该节描述了在TuGraph中识别符的允许的语法。\n下面的表描述了每类识别符的最大长度和允许的字符。\n\n|**识别符** |**长度** |**允许的字符**|\n|---------  |---------  |---------  |\n|用户、角色、图项目\t|1-64字符\t|允许中文、字母、数字、下划线，且首字符不为数字|\n|点类型、边类型、属性\t|1~256字符\t|允许中文、字母、数字、下划线，且首字符不为数字|\n表格内容描述: 该表格包含三列，分别是“识别符”、“长度”和“允许的字符”。 \n\n- 第一行数据为“用户、角色、图项目”，其长度为“1-64字符”，允许的字符包括中文、字母、数字和下划线，但首字符不能为数字。 \n- 第二行数据为“点类型、边类型、属性”，其长度为“1~256字符”，同样允许的字符包括中文、字母、数字和下划线，首字符也不能为数字。 \n\n总体而言，该表格对不同类型的识别符进行了描述，规定了它们的长度范围和允许使用的字符类型，以便于系统的规范管理和使用。\n\n### 2.2 使用限制\n\n|**描述**|\t**最大个数**|\n|-------- |--------- |\n|用户数、角色数\t|65536|\n|图项目的个数\t|4096|\n|每个图项目的点和边类型数量之和\t|4096|\n|每个点或边类型的属性数量\t|1024|\n表格内容描述: 该表格包含两列，分别为“描述”和“最大个数”。“描述”列列出了不同类型的数据限制，包括用户数、角色数、图项目的个数等，而“最大个数”列则给出了对应的最大值。\n\n逐行描述表格中的数据内容：\n- 用户数和角色数的最大个数为65536。\n- 图项目的个数的最大个数为4096。\n- 每个图项目的点和边类型数量之和的最大个数为4096。\n- 每个点或边类型的属性数量的最大个数为1024。\n\n表格整体内容的概要总结：该表格总结了若干关键数据类别的最大限制，涉及用户、角色、图项目及其类型和属性，提供了系统在这些维度上的容量上限。\n\n注：\n1、特殊字符和关键字说明：使用特殊字符或非保留关键字时，需要使用反单引号/backquote（``）进行引用；\n\n示例： ```match (`match`:match) return `match`.id limit 1```\n\n该章节主要介绍了TuGraph中的图项目、点、边及属性的命名规则和建议，包括识别符的长度、允许字符以及使用限制。它旨在帮助用户在定义这些元素时保持一致性和规范性，以便于系统管理和使用。"
            },
            {
                "content": "|**描述**|\t**最大个数**|\n|-------- |--------- |\n|用户数、角色数\t|65536|\n|图项目的个数\t|4096|\n|每个图项目的点和边类型数量之和\t|4096|\n|每个点或边类型的属性数量\t|1024|\n表格内容描述: 该表格包含两列，分别为“描述”和“最大个数”。“描述”列列出了不同类型的数据限制，包括用户数、角色数、图项目的个数等，而“最大个数”列则给出了对应的最大值。\n\n逐行描述表格中的数据内容：\n- 用户数和角色数的最大个数为65536。\n- 图项目的个数的最大个数为4096。\n- 每个图项目的点和边类型数量之和的最大个数为4096。\n- 每个点或边类型的属性数量的最大个数为1024。\n\n表格整体内容的概要总结：该表格总结了若干关键数据类别的最大限制，涉及用户、角色、图项目及其类型和属性，提供了系统在这些维度上的容量上限。\n\n注：\n1、特殊字符和关键字说明：使用特殊字符或非保留关键字时，需要使用反单引号/backquote（``）进行引用；\n\n示例： ```match (`match`:match) return `match`.id limit 1```\n\n2、大小写敏感性：TuGraph大小写敏感；\n\n3、图项目、点/边、属性名称之间可以重复使用，同一点或边下的属性名称不可以重复；\n\n4、属性名字保留关键字：SRC_ID / DST_ID / SKIP\n\n\n### 2.3 命名建议\n|**识别符**|**描述**|**建议**|\n|-------|-------|--------|\n|图项目\t|字母或中文开头\t|如graph123、project123等|\n|点/边类型\t|字母或中文开头，使用下划线区分单词\t|如person、act_in等|\n表格内容描述：\n该表格包含三列，分别为“识别符”、“描述”和“建议”。\n\n第一行数据的识别符为“图项目”，其描述是字母或中文开头，建议使用格式如“graph123”或“project123”等。  \n第二行数据的识别符为“点/边类型”，其描述也是字母或中文开头，并使用下划线区分单词，建议的示例包括“person”或“act_in”等。\n\n总体来说，此表格为用户提供了两种类型的命名规范，分别适用于图项目和点/边类型，以确保命名的一致性和可读性。\n|属性\t|字母或中文\t|如name、age等|\n\n该块内容位于TuGraph图模型说明的第二部分，主要描述图项目、点、边和属性的命名规则及建议，并列出了与用户数、角色数、图项目个数及属性数量相关的使用限制信息。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_72.md",
        "chunks": [
            {
                "content": "# 集成测试\n\n> 此文档主要介绍 TuGraph 的集成测试框架如何使用\n\n## 1.TuGraph集成测试的意义\n\n在单元测试与功能测试中，有部分用例直接开启galaxy或statemachine来进行测试，这并不是一个完整的流程。在完整的cs架构中，用户请求是通过客户端发往服务端，网络通信是必不可少的，为了避免单元测试不完整带来的bug，针对这种情况，使用集成测试框架进行全链路的完整测试。\n\n## 2.TuGraph集成测试框架\n\nTuGraph采用pytest框架作为自己的集成测试框架，pytest框架作为目前使用最广泛的cs端集成测试框架，以其灵活简单，容易上手，并且支持参数化的使用方式而著称，TuGraph基于pytest提供的功能，抽象出了不同的工具，通过参数来控制各个工具的处理逻辑，以方便大家进行高效的测试代码开发。\n\n更多pytest信息请参考官网: https://docs.pytest.org/en/7.2.x/getting-started.html\n\n### 2.1.组件描述\n\n该文档主要描述TuGraph的集成测试框架，首先介绍了集成测试的重要性，强调了在完整的客户端-服务器架构中进行全链路测试的必要性。接着，文档详细阐述了TuGraph集成测试框架的构建，特别是其基于pytest的实现，并列出了框架中的各种组件及其功能。"
            },
            {
                "content": "| 组件名称            | 组件功能                       | 实现方式                                  |\n|-----------------|----------------------------|---------------------------------------|\n| server          | TuGraph单机服务                | 开启子进程并在子进程中启动服务                       |\n| client          | TuGraph Rpc Client         | 当前进程中开启TuGraph Python Rpc Client发送请求  |\n| importor        | TuGraph Importor           | 开启子进程并在子进程中处理导入请求                     |\n| exportor        | TuGraph Exportor           | 开启子进程并在子进程中处理导出请求                     |\n| backup_binlog   | TuGraph Backup Binlog      | 开启子进程并在子进程中处理备份binlog的请求              |\n| backup_copy_dir | TuGraph Backup             | 开启子进程并在子进程中处理备份完整db的请求                |\n| build_so        | 编译c++动态连接库的组件              | 开启子进程并在子进程中处理gcc编译逻辑                  |\n| copy_snapshot   | TuGraph Copy Snapshot      | 当前进程中处理备份snapshot的请求                  |\n| copydir         | 文件夹拷贝                      | 当前进程中处理文件夹拷贝请求                        |\n\n该部分内容位于文档的“2.1.组件描述”小节，详细列出了TuGraph集成测试框架中各个组件的名称、功能及实现方式，旨在帮助用户理解不同组件在测试过程中的作用及其工作机制。"
            },
            {
                "content": "| backup_binlog   | TuGraph Backup Binlog      | 开启子进程并在子进程中处理备份binlog的请求              |\n| backup_copy_dir | TuGraph Backup             | 开启子进程并在子进程中处理备份完整db的请求                |\n| build_so        | 编译c++动态连接库的组件              | 开启子进程并在子进程中处理gcc编译逻辑                  |\n| copy_snapshot   | TuGraph Copy Snapshot      | 当前进程中处理备份snapshot的请求                  |\n| copydir         | 文件夹拷贝                      | 当前进程中处理文件夹拷贝请求                        |\n| exec            | 执行c++/java可执行文件            | 开启子进程并在子进程中启动C++可执行文件                 |\n| algo            | 执行算法                       | 开启子进程并在子进程中执行算法                       |\n| bash            | 执行bash命令                   | 开启子进程并在子进程中执行bash命令                   |\n| rest            | TuGraph Python Rest Client | 当前进程中开启TuGraph Python Rest Client发送请求 |\n表格内容描述：\n该表格列出了不同组件及其功能和实现方式。具体的列名包括“组件名称”、“组件功能”和“实现方式”。\n\n在文档第二部分中，TuGraph集成测试框架的组件描述中，该表格详细列出了各个组件的名称、功能以及实现方式，具体介绍了与数据备份、编译、文件操作、算法执行等相关的测试组件及其处理逻辑。"
            },
            {
                "content": "逐行描述如下：\n1. 组件名称为“server”，其功能是提供TuGraph单机服务，实施方式为开启子进程并在子进程中启动服务。\n2. 组件名称为“client”，其功能是TuGraph Rpc Client，实施方式为当前进程中开启TuGraph Python Rpc Client发送请求。\n3. 组件名称为“importor”，其功能是TuGraph Importor，实施方式为开启子进程并在子进程中处理导入请求。\n4. 组件名称为“exportor”，其功能是TuGraph Exportor，实施方式为开启子进程并在子进程中处理导出请求。\n5. 组件名称为“backup_binlog”，其功能是TuGraph Backup Binlog，实施方式为开启子进程并在子进程中处理备份binlog的请求。\n6. 组件名称为“backup_copy_dir”，其功能是TuGraph Backup，实施方式为开启子进程并在子进程中处理备份完整数据库的请求。\n7. 组件名称为“build_so”，其功能是编译C++动态连接库的组件，实施方式为开启子进程并在子进程中处理GCC编译逻辑。\n8. 组件名称为“copy_snapshot”，其功能是TuGraph Copy Snapshot，实施方式为当前进程中处理备份snapshot的请求。\n9. 组件名称为“copydir”，其功能是文件夹拷贝，实施方式为当前进程中处理文件夹拷贝请求。\n10. 组件名称为“exec”，其功能是执行C++/Java可执行文件，实施方式为开启子进程并在子进程中启动C++可执行文件。\n11. 组件名称为“algo”，其功能是执行算法，实施方式为开启子进程并在子进程中执行算法。\n12. 组件名称为“bash”，其功能是执行bash命令，实施方式为开启子进程并在子进程中执行bash命令。\n13. 组件名称为“rest”，其功能是TuGraph Python Rest Client，实施方式为当前进程中开启TuGraph Python Rest Client发送请求。\n\n总体总结：\n该表格提供了一系列TuGraph相关组件的功能和实现方式说明，涉及服务、客户端、数据导入导出、备份、编译、执行等多个方面，使用子进程或当前进程的方式来处理不同的任务，体现了系统设计中的多任务处理与服务分离的理念。\n\n### 2.2.组件用法\n\n该段落位于文档的“2.1.组件描述”部分，详细列出了TuGraph集成测试框架中各个组件的名称、功能及其实现方式，并提供了对这些组件的逐行说明和总体总结，有助于读者理解整个集成测试框架的结构与功能。"
            },
            {
                "content": "总体总结：\n该表格提供了一系列TuGraph相关组件的功能和实现方式说明，涉及服务、客户端、数据导入导出、备份、编译、执行等多个方面，使用子进程或当前进程的方式来处理不同的任务，体现了系统设计中的多任务处理与服务分离的理念。\n\n### 2.2.组件用法\n\n#### 2.2.1.server\n\n##### 2.2.1.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n+ cleanup_dir是执行完成后需要清理的目录，可以是多个，通过python列表传入\n\n```python\nSERVEROPT = {\"cmd\":\"./lgraph_server -c lgraph_standalone.json --directory ./testdb --license _FMA_IGNORE_LICENSE_CHECK_SALTED_ --port 7072 --rpc_port 9092\",\n             \"cleanup_dir\":[\"./testdb\"]}\n```\n\n##### 2.2.1.2.启动命令\n通过fixtures组件引入工具，并通过启动参数来控制不同的处理逻辑，函数开始执行前会启动server，函数执行完成后会停止server，并清理cleanup_dir指定的目录\n\n```python\n@pytest.mark.parametrize(\"server\", [SERVEROPT], indirect=True)\ndef test_server(self, server):\n    pass\n```\n\n#### 2.2.2.client\n\n##### 2.2.2.1.启动参数\n采用python字典传入\n+ host是TuGraph Server的ip和端口\n+ user是TuGraph Server的用户名\n+ password是TuGraph Server 中user对应的密码\n\n```python\nCLIENTOPT = {\"host\":\"127.0.0.1:9092\", \"user\":\"admin\", \"password\":\"73@TuGraph\"}\n```\n\n##### 2.2.2.2.启动命令\n通过fixtures组件引入工具，并通过启动参数来控制不同的处理逻辑，函数开始执行前会启动客户端，函数执行结束后会结束客户端\n\n该块内容位于文档的第二部分，主要介绍了TuGraph集成测试框架的组件用法，具体包括如何配置和启动server和client组件。通过描述启动参数和启动命令，提供了操作示例，便于用户理解和使用TuGraph的集成测试工具。"
            },
            {
                "content": "```python\n@pytest.mark.parametrize(\"server\", [SERVEROPT], indirect=True)\ndef test_server(self, server):\n    pass\n```\n\n#### 2.2.2.client\n\n##### 2.2.2.1.启动参数\n采用python字典传入\n+ host是TuGraph Server的ip和端口\n+ user是TuGraph Server的用户名\n+ password是TuGraph Server 中user对应的密码\n\n```python\nCLIENTOPT = {\"host\":\"127.0.0.1:9092\", \"user\":\"admin\", \"password\":\"73@TuGraph\"}\n```\n\n##### 2.2.2.2.启动命令\n通过fixtures组件引入工具，并通过启动参数来控制不同的处理逻辑，函数开始执行前会启动客户端，函数执行结束后会结束客户端\n\n```python\n@pytest.mark.parametrize(\"server\", [SERVEROPT], indirect=True)\n@pytest.mark.parametrize(\"client\", [CLIENTOPT], indirect=True)\ndef test_client(self, server, client):\n    ret = client.callCypher(\"CALL db.createEdgeLabel('followed', '[]', 'address', string, false, 'date', int32, false)\", \"default\")\n    assert ret[0]\n    ret = client.callCypher(\"CALL db.createEdgeLabel('followed', '[]', 'address', string, false, 'date', int32, false)\", \"default\")\n    assert ret[0] == False\n```\n\n#### 2.2.3.importor\n\n该片段位于文档的第2.2.2节\"client\"中，主要介绍TuGraph集成测试框架中客户端的启动参数和启动命令，包括如何通过pytest的参数化功能启动TuGraph客户端并进行相关操作。在此之前，文档先简要说明了测试服务器的启动逻辑，以便于理解整个测试流程的完整性。"
            },
            {
                "content": "```python\n@pytest.mark.parametrize(\"server\", [SERVEROPT], indirect=True)\n@pytest.mark.parametrize(\"client\", [CLIENTOPT], indirect=True)\ndef test_client(self, server, client):\n    ret = client.callCypher(\"CALL db.createEdgeLabel('followed', '[]', 'address', string, false, 'date', int32, false)\", \"default\")\n    assert ret[0]\n    ret = client.callCypher(\"CALL db.createEdgeLabel('followed', '[]', 'address', string, false, 'date', int32, false)\", \"default\")\n    assert ret[0] == False\n```\n\n#### 2.2.3.importor\n\n##### 2.2.3.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n+ cleanup_dir是执行完成后需要清理的目录，可以是多个，通过python列表传入\n\n```python\nIMPORTOPT = {\"cmd\":\"./lgraph_import --config_file ./data/yago/yago.conf --dir ./testdb --user admin --password 73@TuGraph --graph default --overwrite 1\",\n             \"cleanup_dir\":[\"./testdb\", \"./.import_tmp\"]}\n```\n\n##### 2.2.3.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来控制导入不同的数据，函数开始执行前会导入数据到指定的目录，函数执行完成后会清理cleanup_dir指定的目录\n\n该代码段位于文档的集成测试部分， specifically 在“client”组件的用法描述中。它展示了如何通过pytest框架对TuGraph的客户端进行集成测试，包括如何调用Cypher命令以创建边标签，并验证调用结果的有效性。紧接着，该代码块后面是关于“importor”组件的启动参数和命令的描述。"
            },
            {
                "content": "#### 2.2.3.importor\n\n##### 2.2.3.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n+ cleanup_dir是执行完成后需要清理的目录，可以是多个，通过python列表传入\n\n```python\nIMPORTOPT = {\"cmd\":\"./lgraph_import --config_file ./data/yago/yago.conf --dir ./testdb --user admin --password 73@TuGraph --graph default --overwrite 1\",\n             \"cleanup_dir\":[\"./testdb\", \"./.import_tmp\"]}\n```\n\n##### 2.2.3.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来控制导入不同的数据，函数开始执行前会导入数据到指定的目录，函数执行完成后会清理cleanup_dir指定的目录\n\n```python\n@pytest.mark.parametrize(\"importor\", [IMPORTOPT], indirect=True)\ndef test_importor(self, importor):\n    pass\n```\n\n#### 2.2.4.exportor\n\n##### 2.2.4.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n+ cleanup_dir是执行完成后需要清理的目录，可以是多个，通过python列表传入\n\n```python\nEXPORT_DEF_OPT = {\"cmd\":\"./lgraph_export -d ./testdb -e ./export/default -g default -u admin -p 73@TuGraph\",\n                  \"cleanup_dir\":[\"./export\"]}\n```\n\n##### 2.2.4.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来控制导出不同的数据，函数开始执行前会导出数据到指定的目录，函数执行完成后会清理cleanup_dir指定的目录\n\n该段落主要介绍了TuGraph集成测试框架中“导入器”和“导出器”组件的启动参数和使用方法。包括如何通过Python字典定义启动命令和清理目录，以及如何通过pytest的参数化功能来执行这些导入和导出操作。此部分紧接在“集成测试框架组件用法”的章节中，具体描述了如何实现数据的导入与导出流程。"
            },
            {
                "content": "```python\n@pytest.mark.parametrize(\"importor\", [IMPORTOPT], indirect=True)\ndef test_importor(self, importor):\n    pass\n```\n\n#### 2.2.4.exportor\n\n##### 2.2.4.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n+ cleanup_dir是执行完成后需要清理的目录，可以是多个，通过python列表传入\n\n```python\nEXPORT_DEF_OPT = {\"cmd\":\"./lgraph_export -d ./testdb -e ./export/default -g default -u admin -p 73@TuGraph\",\n                  \"cleanup_dir\":[\"./export\"]}\n```\n\n##### 2.2.4.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来控制导出不同的数据，函数开始执行前会导出数据到指定的目录，函数执行完成后会清理cleanup_dir指定的目录\n\n```python\n@pytest.mark.parametrize(\"exportor\", [EXPORT_DEF_OPT], indirect=True)\ndef test_exportor(self, exportor):\n    pass\n```\n\n#### 2.2.5.backup_binlog\n\n##### 2.2.5.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n+ cleanup_dir是执行完成后需要清理的目录，可以是多个，通过python列表传入\n\n```python\nBINLOGOPT = {\"cmd\" : \"./lgraph_binlog -a restore --host 127.0.0.1 --port 9093 -u admin -p 73@TuGraph -f ./testdb/binlog/*\",\n             \"cleanup_dir\":[]}\n```\n\n##### 2.2.5.2.启动命令\n\n该代码片段位于文档的2.2.3部分，描述了TuGraph集成测试框架中“importor”组件的使用方法，具体展示了如何通过参数化方式启动导入逻辑的测试函数。紧接着是2.2.4节，介绍了“exportor”组件的启动参数及相应的测试函数实现，涉及数据导出的功能。"
            },
            {
                "content": "```python\n@pytest.mark.parametrize(\"exportor\", [EXPORT_DEF_OPT], indirect=True)\ndef test_exportor(self, exportor):\n    pass\n```\n\n#### 2.2.5.backup_binlog\n\n##### 2.2.5.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n+ cleanup_dir是执行完成后需要清理的目录，可以是多个，通过python列表传入\n\n```python\nBINLOGOPT = {\"cmd\" : \"./lgraph_binlog -a restore --host 127.0.0.1 --port 9093 -u admin -p 73@TuGraph -f ./testdb/binlog/*\",\n             \"cleanup_dir\":[]}\n```\n\n##### 2.2.5.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来控制备份不同的binlog，函数开始执行前会拷贝binlog到指定的目录，函数执行完成后会清理cleanup_dir指定的目录\n\n```python\n@pytest.mark.parametrize(\"backup_binlog\", [BINLOGOPT], indirect=True)\ndef test_backup_binlog(self, backup_binlog):\n    pass\n```\n\n#### 2.2.6.backup_copy_dir\n\n##### 2.2.6.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n+ cleanup_dir是执行完成后需要清理的目录，可以是多个，通过python列表传入\n\n```python\nBACKUPOPT = {\"cmd\" : \"./lgraph_backup --src ./testdb -dst ./testdb1\",\n             \"cleanup_dir\":[]}\n```\n\n##### 2.2.6.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来控制备份不同的db，函数开始执行前会拷贝db到指定的目录，函数执行完成后会清理cleanup_dir指定的目录\n\n该代码块位于TuGraph集成测试框架的“备份和导出”部分，具体讨论了“备份binlog”和“备份目录”的功能及实现方式。在此之前，介绍了导出功能的启动参数和命令，接着说明了备份binlog和备份目录的启动参数与命令的具体实现。"
            },
            {
                "content": "```python\n@pytest.mark.parametrize(\"backup_binlog\", [BINLOGOPT], indirect=True)\ndef test_backup_binlog(self, backup_binlog):\n    pass\n```\n\n#### 2.2.6.backup_copy_dir\n\n##### 2.2.6.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n+ cleanup_dir是执行完成后需要清理的目录，可以是多个，通过python列表传入\n\n```python\nBACKUPOPT = {\"cmd\" : \"./lgraph_backup --src ./testdb -dst ./testdb1\",\n             \"cleanup_dir\":[]}\n```\n\n##### 2.2.6.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来控制备份不同的db，函数开始执行前会拷贝db到指定的目录，函数执行完成后会清理cleanup_dir指定的目录\n\n```python\n@pytest.mark.parametrize(\"backup_copy_dir\", [BACKUPOPT], indirect=True)\ndef test_backup_copy_dir(self, backup_copy_dir):\n\tpass\n```\n\n#### 2.2.7.build_so\n\n##### 2.2.7.1.启动参数\n采用python字典传入\n+ cmd是启动命令，采用python列表传入，可以一次编译多个so\n+ so_name是执行完成后需要清理的so，可以是多个，通过python列表传入\n\n该代码块位于文档的“2.2.5.backup_binlog”和“2.2.7.build_so”部分之间，主要介绍了TuGraph集成测试框架中关于备份binlog和备份数据库目录的测试用例及其实现方式。具体包含了`backup_binlog`和`backup_copy_dir`两个测试用例的启动参数和启动命令示例。"
            },
            {
                "content": "```python\nBACKUPOPT = {\"cmd\" : \"./lgraph_backup --src ./testdb -dst ./testdb1\",\n             \"cleanup_dir\":[]}\n```\n\n##### 2.2.6.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来控制备份不同的db，函数开始执行前会拷贝db到指定的目录，函数执行完成后会清理cleanup_dir指定的目录\n\n```python\n@pytest.mark.parametrize(\"backup_copy_dir\", [BACKUPOPT], indirect=True)\ndef test_backup_copy_dir(self, backup_copy_dir):\n\tpass\n```\n\n#### 2.2.7.build_so\n\n##### 2.2.7.1.启动参数\n采用python字典传入\n+ cmd是启动命令，采用python列表传入，可以一次编译多个so\n+ so_name是执行完成后需要清理的so，可以是多个，通过python列表传入\n\n```python\nBUILDOPT = {\"cmd\":[\"g++ -fno-gnu-unique -fPIC -g --std=c++17 -I ../../include -I ../../deps/install/include -rdynamic -O3 -fopenmp -DNDEBUG -o ./scan_graph.so ../../test/test_procedures/scan_graph.cpp ./liblgraph.so -shared\",\n                       \"g++ -fno-gnu-unique -fPIC -g --std=c++17 -I ../../include -I ../../deps/install/include -rdynamic -O3 -fopenmp -DNDEBUG -o ./sortstr.so ../../test/test_procedures/sortstr.cpp ./liblgraph.so -shared\"],\n                \"so_name\":[\"./scan_graph.so\", \"./sortstr.so\"]}\n```\n\n该块内容位于文档的第2.2.6节和第2.2.7节之间，主要介绍了TuGraph集成测试框架中关于备份数据库（backup_copy_dir）的启动参数和启动命令，以及编译C++动态连接库（build_so）的启动参数和命令。这部分内容详细描述了如何通过pytest框架为这两个功能设置参数及其使用示例。"
            },
            {
                "content": "##### 2.2.7.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来控制编译不同的so，函数开始执行前会生成so到指定的目录，函数执行完成后会清理so_name列表指定的动态库\n\n```python\n@pytest.mark.parametrize(\"build_so\", [BUILDOPT], indirect=True)\ndef test_build_so(self, build_so):\n    pass\n```\n\n#### 2.2.8.copy_snapshot\n\n##### 2.2.8.1.启动参数\n采用python字典传入\n+ src是原db\n+ dst是拷贝后的snapshot\n\n```python\nCOPYSNAPOPT = {\"src\" : \"./testdb\", \"dst\" : \"./testdb1\"}\n```\n\n##### 2.2.8.2.启动命令\n通过fixtures组件引入工具，并通过启动参数来控制拷贝不同的snapshot，函数开始执行前会拷贝src中的snapshot到dst指定的目录\n\n```python\n@pytest.mark.parametrize(\"copy_snapshot\", [COPYSNAPOPT], indirect=True)\ndef test_copy_snapshot(self, copy_snapshot):\n    pass\n```\n\n#### 2.2.9.copy_dir\n\n##### 2.2.9.1.启动参数\n采用python字典传入\n+ src是原db\n+ dst是拷贝后的snapshot\n\n```python\nCOPYSNAPOPT = {\"src\" : \"./testdb\", \"dst\" : \"./testdb1\"}\n```\n\n##### 2.2.9.2.启动命令\n通过fixtures组件引入工具，并通过启动参数来控制拷贝不同的目录，函数开始执行前会拷贝src到dst指定的目录\n\n```python\n@pytest.mark.parametrize(\"copy_dir\", [COPYDIR], indirect=True)\ndef test_copy_dir(self, copy_dir):\n    pass\n```\n\n#### 2.2.10.exec\n\n该块内容位于文档的集成测试框架部分，具体描述了TuGraph集成测试框架中\"build_so\"、\"copy_snapshot\"、\"copy_dir\"和\"exec\"组件的启动参数和启动命令，旨在指导用户如何通过pytest进行相关组件的测试和编译操作。"
            },
            {
                "content": "#### 2.2.9.copy_dir\n\n##### 2.2.9.1.启动参数\n采用python字典传入\n+ src是原db\n+ dst是拷贝后的snapshot\n\n```python\nCOPYSNAPOPT = {\"src\" : \"./testdb\", \"dst\" : \"./testdb1\"}\n```\n\n##### 2.2.9.2.启动命令\n通过fixtures组件引入工具，并通过启动参数来控制拷贝不同的目录，函数开始执行前会拷贝src到dst指定的目录\n\n```python\n@pytest.mark.parametrize(\"copy_dir\", [COPYDIR], indirect=True)\ndef test_copy_dir(self, copy_dir):\n    pass\n```\n\n#### 2.2.10.exec\n\n##### 2.2.10.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n\n```python\nEXECOPT = {\n        \"cmd\" : \"test_rpc_client/cpp/CppClientTest/build/clienttest\"\n    }\n```\n\n##### 2.2.10.2.启动命令\n通过fixtures组件引入工具，并通过启动参数来控制执行不同的逻辑，函数开始执行前会开启子进程执行通过cmd参数传入的命令\n\n```python\n@pytest.mark.parametrize(\"exec\", [EXECOPT], indirect=True)\ndef test_exec(self, exec):\n        pass\n```\n\n#### 2.2.11.algo\n\n##### 2.2.11.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n+ result是算法预期的执行结果，执行完成会通过实际结果与预期结果进行比较，不同则测试失败\n\n```python\nBFSEMBEDOPT = {\n        \"cmd\" : \"algo/bfs_embed ./testdb\",\n        \"result\" : [\"found_vertices = 3829\"]\n    }\n```\n\n该块内容位于TuGraph集成测试框架文档的组件用法部分，具体描述了`copy_dir`、`exec`和`algo`三个组件的启动参数和使用命令。这些组件涉及到目录拷贝、执行命令和算法运行的测试逻辑，帮助用户理解如何进行相关操作并进行集成测试。"
            },
            {
                "content": "##### 2.2.10.2.启动命令\n通过fixtures组件引入工具，并通过启动参数来控制执行不同的逻辑，函数开始执行前会开启子进程执行通过cmd参数传入的命令\n\n```python\n@pytest.mark.parametrize(\"exec\", [EXECOPT], indirect=True)\ndef test_exec(self, exec):\n        pass\n```\n\n#### 2.2.11.algo\n\n##### 2.2.11.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n+ result是算法预期的执行结果，执行完成会通过实际结果与预期结果进行比较，不同则测试失败\n\n```python\nBFSEMBEDOPT = {\n        \"cmd\" : \"algo/bfs_embed ./testdb\",\n        \"result\" : [\"found_vertices = 3829\"]\n    }\n```\n\n##### 2.2.11.2.启动命令\n通过fixtures组件引入工具，并通过启动参数来控制执行不同的算法逻辑，函数开始执行前会开启子进程执行通过cmd参数传入的算法，函数主体等待算法执行完成后对比结果\n\n```python\n@pytest.mark.parametrize(\"algo\", [BFSEMBEDOPT], indirect=True)\ndef test_exec_bfs_embed(self, algo):\n    pass\n```\n\n#### 2.2.12.bash\n\n##### 2.2.12.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n\n```python\nBASHOPT = {\n        \"cmd\" : \"sh ./test_rpc_client/cpp/CppClientTest/compile.sh\"\n    }\n```\n\n##### 2.2.12.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来控制执行不同的bash命令，函数开始执行前会开启子进程执行通过cmd参数传入的bash命令，函数主体等待算法执行完成\n\n该块内容位于文档的**2.2.10**到**2.2.12**节，主要介绍了TuGraph集成测试框架中关于**执行可执行文件**、**算法执行**和**bash命令执行**的组件用法及启动命令，包括其启动参数的定义、测试样例的编写以及如何通过pytest框架进行测试。这部分内容展示了如何使用pytest的参数化功能来灵活执行不同的测试逻辑。"
            },
            {
                "content": "##### 2.2.11.2.启动命令\n通过fixtures组件引入工具，并通过启动参数来控制执行不同的算法逻辑，函数开始执行前会开启子进程执行通过cmd参数传入的算法，函数主体等待算法执行完成后对比结果\n\n```python\n@pytest.mark.parametrize(\"algo\", [BFSEMBEDOPT], indirect=True)\ndef test_exec_bfs_embed(self, algo):\n    pass\n```\n\n#### 2.2.12.bash\n\n##### 2.2.12.1.启动参数\n采用python字典传入\n+ cmd是启动命令\n\n```python\nBASHOPT = {\n        \"cmd\" : \"sh ./test_rpc_client/cpp/CppClientTest/compile.sh\"\n    }\n```\n\n##### 2.2.12.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来控制执行不同的bash命令，函数开始执行前会开启子进程执行通过cmd参数传入的bash命令，函数主体等待算法执行完成\n\n```python\n@pytest.mark.parametrize(\"bash\", [BASHOPT], indirect=True)\ndef test_bash(self, bash):\n    pass\n```\n\n#### 2.2.13.rest\n\n##### 2.2.13.1.启动参数\n采用python字典传入\n+ port是TuGraph Server的端口\n+ user是TuGraph Server的用户名\n+ password是TuGraph Server 中user对应的密码\n\n\n```python\nRESTTOPT = {\"port\":\"7073\", \"user\":\"admin\", \"password\":\"73@TuGraph\"}\n```\n\n##### 2.2.13.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来链接不同的TuGraph Rest Server，函数开始执行前会启动客户端，函数执行结束后会结束客户端\n\n该部分主要介绍TuGraph集成测试框架中针对算法执行（`algo`）、Bash命令执行（`bash`）以及REST服务调用（`rest`）的组件用法和启动命令，包括它们的启动参数、执行逻辑和示例代码。这些内容属于集成测试的具体实现，说明如何通过pytest框架进行算法测试、执行Shell脚本和进行网络请求等操作。"
            },
            {
                "content": "```python\n@pytest.mark.parametrize(\"bash\", [BASHOPT], indirect=True)\ndef test_bash(self, bash):\n    pass\n```\n\n#### 2.2.13.rest\n\n##### 2.2.13.1.启动参数\n采用python字典传入\n+ port是TuGraph Server的端口\n+ user是TuGraph Server的用户名\n+ password是TuGraph Server 中user对应的密码\n\n\n```python\nRESTTOPT = {\"port\":\"7073\", \"user\":\"admin\", \"password\":\"73@TuGraph\"}\n```\n\n##### 2.2.13.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来链接不同的TuGraph Rest Server，函数开始执行前会启动客户端，函数执行结束后会结束客户端\n\n```python\n@pytest.mark.parametrize(\"rest\", [RESTTOPT], indirect=True)\ndef test_get_info(self, server, rest):\n\tpass\n```\n\n### 2.3.测试样例\n\n#### 2.3.1.rest\n\n样例代码中在test_get_info函数执行之前先启动server，server启动后启动了rest client，进入test_get_info函数后获取server的一些信息，并通过assert判断是否有获取到cpu的信息。\n\n该代码块位于文档的2.2.12节和2.2.13节之间，主要介绍了如何使用pytest框架中的bash命令和rest客户端组件进行集成测试，包括相关的启动参数和示例命令。此部分内容强调了测试不同组件的用法和示例，包括从参数化启动到测试用例的编写。"
            },
            {
                "content": "```python\nRESTTOPT = {\"port\":\"7073\", \"user\":\"admin\", \"password\":\"73@TuGraph\"}\n```\n\n##### 2.2.13.2.启动命令\n\n通过fixtures组件引入工具，并通过启动参数来链接不同的TuGraph Rest Server，函数开始执行前会启动客户端，函数执行结束后会结束客户端\n\n```python\n@pytest.mark.parametrize(\"rest\", [RESTTOPT], indirect=True)\ndef test_get_info(self, server, rest):\n\tpass\n```\n\n### 2.3.测试样例\n\n#### 2.3.1.rest\n\n样例代码中在test_get_info函数执行之前先启动server，server启动后启动了rest client，进入test_get_info函数后获取server的一些信息，并通过assert判断是否有获取到cpu的信息。\n\n```python\nSERVEROPT = {\"cmd\":\"./lgraph_server -c lgraph_standalone.json --directory ./testdb --license _FMA_IGNORE_LICENSE_CHECK_SALTED_ --port 7073 --rpc_port 9093\",\n               \"cleanup_dir\":[\"./testdb\"]}\nRESTTOPT = {\"port\":\"7073\", \"user\":\"admin\", \"password\":\"73@TuGraph\"}\n@pytest.mark.parametrize(\"server\", [SERVEROPT], indirect=True)\n@pytest.mark.parametrize(\"rest\", [RESTTOPT], indirect=True)\ndef test_get_info(self, server, rest):\n    res = rest.get_server_info()\n    log.info(\"res : %s\", res)\n    assert('cpu' in res)\n```\n\n#### 2.3.2.client\n\n该代码片段位于文档的集成测试框架部分，具体是在描述如何使用TuGraph的REST客户端组件进行测试时提供的。它包含了REST客户端的启动参数和相应的测试命令示例，展示了如何在启动服务器后获取服务器信息并进行断言检查。"
            },
            {
                "content": "#### 2.3.2.client\n\n样例代码中在test_flushdb函数执行之前先执行了数据离线导入逻辑，并启动server后，通过client创建链接，进入test_flushdb函数后，通过查询点的个数判断导入是否成功，导入成功后执行flushDB操作，再次通过assert判断是否能正常清空db\n\n```python\nSERVEROPT = {\"cmd\":\"./lgraph_server -c lgraph_standalone.json --directory ./testdb --license _FMA_IGNORE_LICENSE_CHECK_SALTED_ --port 7072 --rpc_port 9092\",\n             \"cleanup_dir\":[\"./testdb\"]}\n\nCLIENTOPT = {\"host\":\"127.0.0.1:9092\", \"user\":\"admin\", \"password\":\"73@TuGraph\"}\n\nIMPORTOPT = {\"cmd\":\"./lgraph_import --config_file ./data/yago/yago.conf --dir ./testdb --user admin --password 73@TuGraph --graph default --overwrite 1\",\n             \"cleanup_dir\":[\"./testdb\", \"./.import_tmp\"]}\n\n该部分内容位于文档的“测试样例”章节，具体是关于“客户端”组件的测试示例。在这个示例中，演示了如何在执行`test_flushdb`函数之前先导入数据并启动服务器，然后通过客户端连接进行数据库操作的验证，包括检查导入数据的成功与清空数据库的功能测试。"
            },
            {
                "content": "```python\nSERVEROPT = {\"cmd\":\"./lgraph_server -c lgraph_standalone.json --directory ./testdb --license _FMA_IGNORE_LICENSE_CHECK_SALTED_ --port 7072 --rpc_port 9092\",\n             \"cleanup_dir\":[\"./testdb\"]}\n\nCLIENTOPT = {\"host\":\"127.0.0.1:9092\", \"user\":\"admin\", \"password\":\"73@TuGraph\"}\n\nIMPORTOPT = {\"cmd\":\"./lgraph_import --config_file ./data/yago/yago.conf --dir ./testdb --user admin --password 73@TuGraph --graph default --overwrite 1\",\n             \"cleanup_dir\":[\"./testdb\", \"./.import_tmp\"]}\n\n@pytest.mark.parametrize(\"importor\", [IMPORTOPT], indirect=True)\n@pytest.mark.parametrize(\"server\", [SERVEROPT], indirect=True)\n@pytest.mark.parametrize(\"client\", [CLIENTOPT], indirect=True)\ndef test_flushdb(self, importor, server, client):\n    ret = client.callCypher(\"MATCH (n) RETURN n LIMIT 100\", \"default\")\n    assert ret[0]\n    res = json.loads(ret[1])\n    assert len(res) == 21\n    ret = client.callCypher(\"CALL db.flushDB()\", \"default\")\n    assert ret[0]\n    res = json.loads(ret[1])\n     assert res == None\n```\n\n该代码块位于文档的“2.3.2.client”测试样例部分，展示了如何在集成测试中设置服务器、客户端和数据导入器，以验证数据库的操作，包括查询节点数量和执行清空数据库的操作。"
            },
            {
                "content": "#### 2.3.3.exportor/importor\n\n样例代码中在test_export_default函数执行之前先执行了数据离线导入逻辑，导入成功后将当前db的数据导出，然后再次通过离线导入逻辑将exportor导出的数据导入到新的目录中，以新导入的数据启动db，并且创建链接。在test_export_default函数主体中判断导出后再次导入的数据是否与原始数据一致\n\n```python\nSERVEROPT = {\"cmd\":\"./lgraph_server -c lgraph_standalone.json --directory ./testdb1 --license _FMA_IGNORE_LICENSE_CHECK_SALTED_ --port 7073 --rpc_port 9093\",\n             \"cleanup_dir\":[\"./testdb1\"]}\n\nCLIENTOPT = {\"host\":\"127.0.0.1:9093\", \"user\":\"admin\", \"password\":\"73@TuGraph\"}\n\nIMPORT_YAGO_OPT = {\"cmd\":\"./lgraph_import --config_file ./data/yago/yago.conf --dir ./testdb --user admin --password 73@TuGraph --graph default --overwrite 1\",\n             \"cleanup_dir\":[\"./.import_tmp\", \"./testdb\"]}\n\nIMPORT_DEF_OPT = {\"cmd\":\"./lgraph_import -c ./export/default/import.config -d ./testdb1\",\n             \"cleanup_dir\":[\"./.import_tmp\", \"./testdb1\"]}\n\nEXPORT_DEF_OPT = {\"cmd\":\"./lgraph_export -d ./testdb -e ./export/default -g default -u admin -p 73@TuGraph\",\n                  \"cleanup_dir\":[\"./export\"]}\n\n该块内容位于文档的2.3节，具体描述了一个集成测试示例，重点是exportor和importor的使用。在test_export_default函数中，先执行数据的离线导入，随后导出数据库中的数据，并将其导入到新的目录中，最终验证导入的数据是否与原始数据一致。此示例展示了如何利用TuGraph的集成测试框架进行数据的导入导出操作测试。"
            },
            {
                "content": "IMPORT_DEF_OPT = {\"cmd\":\"./lgraph_import -c ./export/default/import.config -d ./testdb1\",\n             \"cleanup_dir\":[\"./.import_tmp\", \"./testdb1\"]}\n\nEXPORT_DEF_OPT = {\"cmd\":\"./lgraph_export -d ./testdb -e ./export/default -g default -u admin -p 73@TuGraph\",\n                  \"cleanup_dir\":[\"./export\"]}\n\n@pytest.mark.parametrize(\"importor\", [IMPORT_YAGO_OPT], indirect=True)\n@pytest.mark.parametrize(\"exportor\", [EXPORT_DEF_OPT], indirect=True)\n@pytest.mark.parametrize(\"importor_1\", [IMPORT_DEF_OPT], indirect=True)\n@pytest.mark.parametrize(\"server\", [SERVEROPT], indirect=True)\n@pytest.mark.parametrize(\"client\", [CLIENTOPT], indirect=True)\ndef test_export_default(self, importor, exportor, importor_1, server, client):\n    ret = client.callCypher(\"MATCH (n) RETURN n LIMIT 100\", \"default\")\n    assert ret[0]\n    res = json.loads(ret[1])\n    log.info(\"res : %s\", res)\n    assert len(res) == 21\n```\n\n#### 2.3.4.其他测试\n更多用例请参考集成测试代码 https://github.com/TuGraph-family/tugraph-db/tree/master/test/integration\n\n该代码块位于文档的集成测试部分，主要介绍如何配置和执行针对TuGraph数据库的导入导出操作的测试案例。在此块中，定义了导入和导出操作的启动参数，并通过pytest参数化机制实现测试函数，以验证数据库的导入导出功能是否正常。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_73.md",
        "chunks": [
            {
                "content": "# TuGraph-Analytics 图计算快速上手之 PageRank 算法\n\n## -TuGraph-Analytics 介绍-\n\nTuGraph-Analytics（下文简称GeaFlow）是蚂蚁集团开源的分布式实时图计算引擎，目前广泛应用于金融风控、社交网络、知识图谱以及数据应用等场景。GeaFlow的核心能力是流式图计算，流式图计算相比离线图计算提供了一种高时效性低延迟的图计算模式，更多详细内容参考GitHub介绍(https://github.com/TuGraph-family/tugraph-analytics).\n\nGeaFlow整体架构如下所示：\n\nGeaFlow整体架构从上往下包含以下几层：\n\n- **GeaFlow DSL**  \n  GeaFlow对用户提供图表融合分析语言，采用SQL + ISO/GQL方式。用户可以通过类似SQL编程的方式编写实时图计算任务。\n\n- **GraphView API**  \n  GeaFlow以GraphView为核心定义的一套图计算的编程接口,包含图构建、图计算以及Stream API接口。\n\n- **GeaFlow Runtime**  \n  GeaFlow运行时，包含GeaFlow图表算子、task调度、failover以及shuffle等核心功能。\n\n- **GeaFlow State**  \n  GeaFlow的图状态存储，用于存储图的点边数据。同时流式计算的状态如聚合状态也存放在State中。\n\n- **K8S Deployment**  \n  GeaFlow支持K8S的方式进行部署运行。\n\n- **GeaFlow Console**  \n  GeaFlow的管控平台，包含作业管理、元数据管理等功能。\n\n## -PageRank算法介绍-\n\nPageRank是图计算领域一个应用广泛的算法，由Google公司创始人之一拉里·佩奇与谢尔盖·布林在1998年发明，主要用于网页的排序。该算法基于网页之间相互引用的关系，将网页评分的思想引入到搜索引擎中，用于计算网页的重要度和排名。\n\nPageRank算法的核心思想是：一个网页的重要度是由其他网页对它的引用数量和质量决定的。如果一个网页被其他网页引用得多，那么它的重要度就越高。同时，如果一个网页的引用来源也很重要，那么它对被引用网页的贡献也会更大。\n\n本文件主要介绍TuGraph-Analytics图计算引擎的基本架构和核心功能，特别聚焦于PageRank算法的原理及其在GeaFlow中的实现和使用方式。该文本从引擎的介绍开始，详细讲解了PageRank算法的背景、核心思想，以及如何在GeaFlow中以编程方式实现该算法。"
            },
            {
                "content": "- **GeaFlow State**  \n  GeaFlow的图状态存储，用于存储图的点边数据。同时流式计算的状态如聚合状态也存放在State中。\n\n- **K8S Deployment**  \n  GeaFlow支持K8S的方式进行部署运行。\n\n- **GeaFlow Console**  \n  GeaFlow的管控平台，包含作业管理、元数据管理等功能。\n\n## -PageRank算法介绍-\n\nPageRank是图计算领域一个应用广泛的算法，由Google公司创始人之一拉里·佩奇与谢尔盖·布林在1998年发明，主要用于网页的排序。该算法基于网页之间相互引用的关系，将网页评分的思想引入到搜索引擎中，用于计算网页的重要度和排名。\n\nPageRank算法的核心思想是：一个网页的重要度是由其他网页对它的引用数量和质量决定的。如果一个网页被其他网页引用得多，那么它的重要度就越高。同时，如果一个网页的引用来源也很重要，那么它对被引用网页的贡献也会更大。\n\n实现PageRank算法的具体步骤包括：首先构建网页之间的链接关系图，然后对图进行迭代计算，直到收敛为止。在每一次迭代中，每个网页的得分都会被重新计算，并更新到下一次迭代中。最后，按照网页得分的大小对搜索结果进行排序，输出排名前几位的网页。如下有4个页面，A, B, C, D：\n\n以A点为例，其每一轮的PageRank值计算方法如下：\n\nPR(A) = d * (PR(D)/ 2 + PR(B)/1 + PR(C)/2) + (1- d)\n\n每一个点的PageRank值等于其入点的PageRank值除以入点出边数的加权和，其中d为0~1之间的修正系数。\n\nPageRank算法在搜索引擎中广泛应用，成为搜索引擎排名的重要算法之一。除此之外，PageRank算法的思想也在社交网络、推荐系统等领域得到了应用。\n\n## -TuGraph-Analytics 实现 PageRank-\n\n### 接口与实现\n\nTuGraph-Analytics支持在图查询里调用图算法，语法形式如下：\n\n```sql\nINSERT INTO tbl_result\nCALL page_rank() YIELD (vid, prValue)\nRETURN vid, prValue;\n```\n\n该文档介绍了TuGraph-Analytics图计算引擎的架构和功能，特别是流式图计算的能力。其中，在“PageRank算法介绍”部分详细阐述了PageRank算法的原理及其历史背景，随后进一步探讨了如何在TuGraph-Analytics中实现和调用PageRank算法的具体步骤和接口。这个chunk涵盖了GeaFlow的状态存储、K8S部署以及PageRank算法的核心思想和实现细节。"
            },
            {
                "content": "以A点为例，其每一轮的PageRank值计算方法如下：\n\nPR(A) = d * (PR(D)/ 2 + PR(B)/1 + PR(C)/2) + (1- d)\n\n每一个点的PageRank值等于其入点的PageRank值除以入点出边数的加权和，其中d为0~1之间的修正系数。\n\nPageRank算法在搜索引擎中广泛应用，成为搜索引擎排名的重要算法之一。除此之外，PageRank算法的思想也在社交网络、推荐系统等领域得到了应用。\n\n## -TuGraph-Analytics 实现 PageRank-\n\n### 接口与实现\n\nTuGraph-Analytics支持在图查询里调用图算法，语法形式如下：\n\n```sql\nINSERT INTO tbl_result\nCALL page_rank() YIELD (vid, prValue)\nRETURN vid, prValue;\n```\n\n我们通过CALL语句调用具体的算法，通过YIELD定义算法的返回字段，比如page_rank算法返回点id和page rank值两个字段，则可以通过YIELD(vid, prValue)来表示。\n\nDSL里面实现一个图算法需要实现`AlgorithmUserFunction`接口，其定义如下：\n\n```java\n/**\n * Interface for the User Defined Graph Algorithm.\n * \n * @param  The id type for vertex.\n * @param  The message type for message send between vertices.\n */\npublic interface AlgorithmUserFunction extends Serializable {\n    /**\n     * Init method for the function\n     * @param context The runtime context.\n     * @param params  The parameters for the function.\n     */\n    void init(AlgorithmRuntimeContext context, Object[] params);\n\n该段落主要介绍了PageRank算法的具体计算方法及其在TuGraph-Analytics中的实现，通过示例和代码说明了如何在图查询中调用PageRank算法，并详细阐述了实现算法所需遵循的接口和初始化方法，为读者理解实时图计算的应用提供了具体的技术细节。"
            },
            {
                "content": "DSL里面实现一个图算法需要实现`AlgorithmUserFunction`接口，其定义如下：\n\n```java\n/**\n * Interface for the User Defined Graph Algorithm.\n * \n * @param  The id type for vertex.\n * @param  The message type for message send between vertices.\n */\npublic interface AlgorithmUserFunction extends Serializable {\n    /**\n     * Init method for the function\n     * @param context The runtime context.\n     * @param params  The parameters for the function.\n     */\n    void init(AlgorithmRuntimeContext context, Object[] params);\n\n    /**\n     * Processing method for each vertex and the messages it received.\n     */\n    void process(RowVertex vertex, Iterator messages);\n\n    /**\n     * Returns the output type for the function.\n     */\n    StructType getOutputType();\n}\n```\n\n### init\n\n算法的初始化接口，主要完成算法的一些初始化操作. PageRank的init方法实现如下：\n\n该块内容位于文档中关于在TuGraph-Analytics中实现PageRank算法的部分，具体阐述了实现图算法所需的`AlgorithmUserFunction`接口及其方法定义，包括算法的初始化方法`init`，为后续介绍PageRank算法的初始化过程提供基础。"
            },
            {
                "content": "/**\n     * Returns the output type for the function.\n     */\n    StructType getOutputType();\n}\n```\n\n### init\n\n算法的初始化接口，主要完成算法的一些初始化操作. PageRank的init方法实现如下：\n\n```java\n@Override\npublic void init(AlgorithmRuntimeContext context, Object[] parameters) {\n    this.context = context;\n\t\n    if (parameters.length > 3) {\n        throw new IllegalArgumentException(\n            \"Only support zero or more arguments, false arguments \"\n                + \"usage: func([alpha, [convergence, [max_iteration]]])\");\n    }\n\t\n    // 修正系数，即前面介绍的参数d.\n    if (parameters.length > 0) {\n        alpha = Double.parseDouble(String.valueOf(parameters[0]));\n    }\n\t\n    // PR值更新阀值，当点的pr差值小于该值时，不再更新pr值.\n    if (parameters.length > 1) {\n        convergence = Double.parseDouble(String.valueOf(parameters[1]));\n    }\n\t\n    // 迭代次数\n    if (parameters.length > 2) {\n        iteration = Integer.parseInt(String.valueOf(parameters[2]));\n    }\n}\n```\n\n### process\n\n算法的主要处理逻辑，入参为当前Active点和要处理的消息，PageRank主要实现如下：\n\n本文的主要内容是关于TuGraph-Analytics实时图计算引擎及其实现的PageRank算法。在介绍PageRank算法的基本原理后，接着详细描述了算法的初始化、处理逻辑和返回类型的实现细节，以便用户理解如何在GeaFlow中使用该算法。"
            },
            {
                "content": "```java\n@Override\npublic void process(RowVertex vertex, Iterator messages) {\n    ....\n\t\n    if (context.getCurrentIterationId() == 1L) {\n        // 首轮迭代设置pr初始值,并发送给出边,同时更新当前点的pr值。\n        double initValue = 1.0;\n        sendMessageToNeighbors(outEdges, initValue / outEdges.size());\n        ...\n        context.updateVertexValue(ObjectRow.create(initValue));\n    } else if (context.getCurrentIterationId() < iteration) {\n        double sum = 0.0;\n        while (messages.hasNext()) {\n            double input = (double) messages.next();\n            input = input > 0 ? input : 0.0;\n            sum += input;\n        }\n\t\t\n        // 计算当前迭代的pr值\n        double pr = (1 - alpha) + (sum * alpha);\n        double currentPr = (double) vertex.getValue().getField(0, DoubleType.INSTANCE);\n\t\t\n        if (Math.abs(currentPr - pr) > convergence) {\n            // pr值发送给出边目标点.\n            sendMessageToNeighbors(outEdges, pr / outEdges.size());\n        } \n        context.updateVertexValue(ObjectRow.create(pr));\n\n该代码块位于关于PageRank算法实现的部分，具体描述了算法的主要处理逻辑，即如何在每轮迭代中更新每个节点的PageRank值并发送给相邻节点。此过程包括初始化值设置、消息接收与处理以及Pr值的计算与更新。"
            },
            {
                "content": "input = input > 0 ? input : 0.0;\n            sum += input;\n        }\n\t\t\n        // 计算当前迭代的pr值\n        double pr = (1 - alpha) + (sum * alpha);\n        double currentPr = (double) vertex.getValue().getField(0, DoubleType.INSTANCE);\n\t\t\n        if (Math.abs(currentPr - pr) > convergence) {\n            // pr值发送给出边目标点.\n            sendMessageToNeighbors(outEdges, pr / outEdges.size());\n        } \n        context.updateVertexValue(ObjectRow.create(pr));\n    } else { // 到达最大迭代次数，结束本轮迭代，take最终计算结果.\n        double currentPr = (double) vertex.getValue().getField(0, DoubleType.INSTANCE);\n        context.take(ObjectRow.create(vertex.getId(), currentPr));\n        return;\n    }\n}\n```\n\n该代码段位于TuGraph-Analytics中PageRank算法的实现部分，具体展示了算法在迭代过程中的PR值计算逻辑和发送消息给邻接点的操作，以及当达到最大迭代次数时如何结束迭代并返回最终计算结果。"
            },
            {
                "content": "### getOutputType\n\n定义算法返回类型，PageRank实现如下：\n\n```java\n@Override\npublic StructType getOutputType() {\n    return new StructType(\n        // id\n        new TableField(\"id\", LongType.INSTANCE, false),\n        // pr值\n        new TableField(\"pr\", DoubleType.INSTANCE, false)\n    );\n}\n```\n\n### 算法注册\n\n算法实现通过注解来定义算法名称，如下所示：\n\n```java\n@Description(name = \"page_rank\", description = \"built-in udga for PageRank\")\npublic class PageRank implements AlgorithmUserFunction {\n}\n```\n\n算法和UDF一样，需要注册或者创建后才能使用。DSL内置算法或者UDF在`BuildInSqlFunctionTable`中进行注册。对于非内置算法，可以通过`create function`语句来创建。\n\n```sql\nCreate function page_rank as 'com.antgroup.geaflow.dsl.udf.graph.PageRank';\n```\n\n## -总结-\n\n本文主要介绍实时图计算引擎GeaFlow的基本架构，然后介绍了图算法PageRank的基本原理以及在GeaFlow中的实现细节和使用方式。\n\n该段落位于文档的最后部分，介绍了PageRank算法在TuGraph-Analytics中的输出类型定义和算法注册过程，强调了算法的实现细节以及如何在DSL中进行注册，以便用户能够使用该算法进行图计算。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_74.md",
        "chunks": [
            {
                "content": "# 产品简介\n## GeaFlow起源\n\n早期的大数据分析主要以离线处理为主，以Hadoop为代表的技术栈很好的解决了大规模数据的分析问题。然而数据处理的时效性不足，\n很难满足高实时需求的场景。以Storm为代表的流式计算引擎的出现则很好的解决了数据实时处理的问题，提高了数据处理的时效性。\n然而，Storm本身不提供状态管理的能力， 对于聚合等有状态的计算显得无能为力。Flink\n的出现很好的弥补了这一短板，通过引入状态管理以及Checkpoint机制，实现了高效的有状态流计算能力。\n\n随着数据实时处理场景的丰富，尤其是在实时数仓场景下，实时关系运算(即Stream Join)\n越来越多的成为数据实时化的难点。Flink虽然具备优秀的状态管理能和出色的性能，然而在处理Join运算，尤其是3度以上Join时，\n性能瓶颈越来越明显。由于需要在Join两端存放各个输入的数据状态，当Join变多时，状态的数据量急剧扩大，性能也变的难以接受。\n产生这个问题的本质原因是Flink等流计算系统以表作为数据模型，而表模型本身是一个二维结构，不包含关系的定义和关系的存储，\n在处理关系运算时只能通过Join运算方式实现，成本很高。\n\n在蚂蚁的大数据应用场景中，尤其是金融风控、实时数仓等场景下，存在大量Join运算，如何提高Join\n的时效性和性能成为我们面临的重要挑战，为此我们引入了图模型。图模型是一种以点边结构描述实体关系的数据模型，在图模型里面，点代表实体，\n边代表关系，数据存储层面点边存放在一起。因此，图模型天然定义了数据的关系同时存储层面物化了点边关系。基于图模型，我们实现了新一代实时计算\n引擎GeaFlow，很好的解决了复杂关系运算实时化的问题。目前GeaFlow已广泛应用于数仓加速、金融风控、知识图谱以及社交网络等场景。\n\n## 技术架构\n\nGeaFlow整体架构如下所示：\n\n此段落为文档的介绍部分，重点阐述了GeaFlow的起源和技术背景，主要讨论了大数据分析的演变过程、流计算的挑战以及图模型的引入，最终导致GeaFlow实时计算引擎的开发与应用。该部分为理解后续的技术架构和应用场景奠定基础。"
            },
            {
                "content": "在蚂蚁的大数据应用场景中，尤其是金融风控、实时数仓等场景下，存在大量Join运算，如何提高Join\n的时效性和性能成为我们面临的重要挑战，为此我们引入了图模型。图模型是一种以点边结构描述实体关系的数据模型，在图模型里面，点代表实体，\n边代表关系，数据存储层面点边存放在一起。因此，图模型天然定义了数据的关系同时存储层面物化了点边关系。基于图模型，我们实现了新一代实时计算\n引擎GeaFlow，很好的解决了复杂关系运算实时化的问题。目前GeaFlow已广泛应用于数仓加速、金融风控、知识图谱以及社交网络等场景。\n\n## 技术架构\n\nGeaFlow整体架构如下所示：\n\n* DSL层：即语言层。GeaFlow设计了SQL+GQL的融合分析语言，支持对表模型和图模型统一处理。\n* Framework层：即框架层。GeaFlow设计了面向Graph和Stream的两套API支持流、批、图融合计算，并实现了基于Cycle的统一分布式调度模型。\n* State层：即存储层。GeaFlow设计了面向Graph和KV的两套API支持表数据和图数据的混合存储，整体采用了Sharing Nothing的设计，并支持将数据持久化到远程存储。\n* Console平台：GeaFlow提供了一站式图研发平台，实现了图数据的建模、加工、分析能力，并提供了图作业的运维管控支持。\n* **执行环境**：GeaFlow可以运行在多种异构执行环境，如K8S、Ray以及本地模式。\n\n## 应用场景\n\n### 实时数仓加速\n数仓场景存在大量Join运算，在DWD层往往需要将多张表展开成一张大宽表，以加速后续查询。当Join的表数量变多时，传统的实时计算引擎很难\n保证Join的时效性和性能，这也成为目前实时数仓领域一个棘手的问题。基于GeaFlow的实时图计算引擎，可以很好的解决这方面的问题。\nGeaFlow以图作为数据模型，替代DWD层的宽表，可以实现数据实时构图，同时在查询阶段利用图的点边物化特性，可以极大加速关系运算的查询。\n\n该块内容主要介绍了在蚂蚁的大数据应用场景中，针对金融风控和实时数仓等领域内大量Join运算带来的挑战，提出了引入图模型的必要性及其优势，继而引入新一代实时计算引擎GeaFlow的技术架构和应用场景，具体阐述了如何利用图模型提升关系运算的实时性与性能。"
            },
            {
                "content": "## 应用场景\n\n### 实时数仓加速\n数仓场景存在大量Join运算，在DWD层往往需要将多张表展开成一张大宽表，以加速后续查询。当Join的表数量变多时，传统的实时计算引擎很难\n保证Join的时效性和性能，这也成为目前实时数仓领域一个棘手的问题。基于GeaFlow的实时图计算引擎，可以很好的解决这方面的问题。\nGeaFlow以图作为数据模型，替代DWD层的宽表，可以实现数据实时构图，同时在查询阶段利用图的点边物化特性，可以极大加速关系运算的查询。\n\n### 实时归因分析\n在信息化的大背景下，对用户行为进行渠道归因和路径分析是流量分析领域中的核心所在。通过实时计算用户的有效行为路径，构建出完整的转化路径，能够快速帮助业务看清楚产品的价值，帮助运营及时调整运营思路。实时归因分析的核心要点是准确性和实效性。准确性要求在成本可控下保证用户行为路径分析的准确性;实效性则要求计算的实时性足够高，才能快速帮助业务决策。\n基于GeaFlow流图计算引擎的能力可以很好的满足归因分析的准确性和时效性要求。\n\nGeaFlow首先通过实时构图将用户行为日志转换成用户行为拓扑图，以用户作为图中的点，与其相关的每个行为构建成从该用户指向埋点页面的一条边.然后利用流图计算能力分析提前用户行为子图，在子图上基于归因路径匹配的规则进行匹配计算得出该成交行为相应用户的归因路径，并输出到下游系统。\n\n### 实时反套现\n在信贷风控的场景下，如何进行信用卡反套现是一个典型的风控诉求。基于现有的套现模式分析，可以看到套现是一个环路子图，如何快速，高效在大图中快速判定套现，将极大的增加风险的识别效率。以下图为例，通过将实时交易流、转账流等输入数据源转换成实时交易图，然后根据风控策略对用户交易行为做图特征分析，比如环路检查等特征计算，实时提供给决策和监控平台进行反套现行为判定。通过GeaFlow实时构图和实时图计算能力，可以快速发现套现等异常交易行为，极大降低平台风险。\n\n该chunk位于文档的“应用场景”部分，详细介绍了GeaFlow在实时数仓加速、实时归因分析和实时反套现等具体应用场景中的优势和实际应用，强调了其基于图模型的实时计算能力如何有效解决传统实时计算引擎面临的挑战。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_75.md",
        "chunks": [
            {
                "content": "# 备份恢复\n\n> 此文档主要介绍 TuGraph 的数据备份和恢复功能。\n\n## 1.数据备份\n\nTuGraph 可以通过 `lgraph_backup` 工具来进行数据备份。\n`lgraph_backup` 工具可以将一个 TuGraph 数据库中的数据备份到另一个目录下，它的用法如下：\n\n```bash\n$ lgraph_backup -s {source_dir} -d {destination_dir} -c {true/false}\n```\n\n其中：\n\n- `-s {source_dir}` 指定需要备份的数据库（源数据库）所在目录。\n- `-d {destination_dir}` 指定备份文件（目标数据库）所在目录。\n  如果目标数据库不为空，`lgraph_backup` 会提示是否覆盖该数据库。\n- `-c {true/false}` 指明是否在备份过程中进行 compaction。\n  compaction 能使产生的备份文件更紧凑，但备份时间也会变长。该选项默认为 `true`。\n\n## 2.数据恢复\n\n使用`lgraph_backup` 工具得到的目标数据库`{destination_dir}`备份了源数据库\n`{source_dir}`的所有子图，但不包含HA集群的raft信息，从而保证服务和集群能\n以备份数据库成功重启并与源数据库的数据一致。使用如下命令可以用备份数据库重启服务，\n在服务启动时会恢复所有子图的存储过程，保证备份服务和原服务完全一致。\n\n```bash\n$ lgraph_server -c lgraph.json --directory {destination_dir} -d start\n```\n\n其中：\n\n- `-d {destination_dir}` 指定备份文件（目标数据库）所在目录。\n\n该文档介绍了 TuGraph 的数据备份与恢复功能，包括备份工具 `lgraph_backup` 的使用方法，以及如何通过备份数据重启服务以保证一致性。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_76.md",
        "chunks": [
            {
                "content": "# Console平台介绍\n\nGeaFlow Console提供了一站式图研发、运维的平台能力，同时为引擎运行时提供元数据（Catalog）服务。\n\n### 平台架构\n\n* **标准化API**：平台提供了标准化的RESTful API和认证机制，同时支持了页面端和应用端的统一API服务能力。\n* **任务研发**：平台支持“关系-实体-属性”的图数据建模。基于字段映射配置，可以定义图数据传输任务，包括数据集成（Import）和数据分发（Export）。基于图表模型的图数据加工任务支持多样化的计算场景，如Traversal、Compute、Mining等。基于数据加速器的图数据服务，提供了多协议的实时分析能力，支持BI、可视化分析工具的接入集成。\n* **构建提交**：平台通过任务和作业的独立抽象，实现研发态与运维态的分离。任务开发完成后执行发布动作，会自动触发构建流水线（Release Builder），生成发布版本。任务提交器（Task Submitter）负责将发布版本的内容提交到执行环境，生成计算作业。\n* **作业运维**：作业属于任务的运行态，平台提供了作业的操纵（启停、重置）、监控（指标、告警、审计）、调优（诊断、伸缩、调参）、调度等运维能力。作业的运行时资源会由资源池统一分配和管理。\n* **元数据服务**：平台同时承载了引擎运行时的元数据服务能力，以实现研发与运维的自动化。元数据以实例维度进行隔离，实例内的研发资源可以根据名字直接访问，如点、边、图、表、视图、函数等。\n* **系统管理**：平台提供了多租户隔离机制、细粒度用户权限控制，以及系统资源的管理能力。\n\n## 部署架构\n\nGeaFlow支持多种异构环境执行，以常见的K8S部署环境为例，GeaFlow物理部署架构如下：\n\n在GeaFlow作业的全生命周期过程中，涉及的关键数据流程有：\n\n该段落介绍了GeaFlow Console平台的功能与架构，包括标准化API、任务研发、构建提交、作业运维、元数据服务和系统管理，同时概述了其在不同部署环境下的物理架构和作业生命周期中的关键数据流程。"
            },
            {
                "content": "## 部署架构\n\nGeaFlow支持多种异构环境执行，以常见的K8S部署环境为例，GeaFlow物理部署架构如下：\n\n在GeaFlow作业的全生命周期过程中，涉及的关键数据流程有：\n\n* **研发阶段**：Console平台提供了实例下所有的研发资源的管理，用户可以在创建任务前，提前准备所需的研发资源信息，并存储在Catalog。\n* **构建阶段**：任务创建完成后，通过发布动作触发构建流水线，用户的JAR包、任务的ZIP包等会上传到RemoteFileStore。\n* **提交阶段**：作业提交时，Console会根据作业的参数配置、运行时环境信息，以及远程文件地址等创建KubernetesJobClient，既而会拉起Client Pod，Client会拉起Master Pod，Master会拉起Container Pods和Driver Pod。所有的Pod拉起后，Client会把作业的Pipeline发送给Driver执行，Driver最终通过Cycle调度的Events与Containers交互。所有的Pod启动时都会从RemoteFileStore下载版本JAR包、用户JAR包、作业ZIP包等信息。Driver对DSL代码编译时，也需要通过Console提供的Catalog API操作Schema信息。\n* **运行阶段**：作业运行时，各个组件会上报不同的数据和信息。Master会上报作业的心跳汇总信息，Driver会上报作业的Pipeline/Cycle指标以及错误信息，Container会上报作业的Offset、指标定义以及错误信息等。RuntimeMetaStore存储作业的Pipeline/Cycle指标、Offset、心跳汇总、错误等信息。HAMetaStore存储各个运行组件的地址信息。DataStore存储State数据和作业FailOver时所需的元数据信息。MetricStore存储运行时指标信息。\n* **监控阶段**：Console会主要查询RuntimeMetaStore和MetricStore存储的信息用于作业的运行时监控。\n* **清理阶段**：作业重置/删除时，Console会对作业的RuntimeMeta、HAMeta以及部分Data做清理操作。\n\n该文本段落属于GeaFlow Console平台介绍的\"部署架构\"部分，详细描述了GeaFlow在K8S环境下的物理部署架构及作业全生命周期中的关键数据流程，包括研发、构建、提交、运行、监控和清理阶段。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_77.md",
        "chunks": [
            {
                "content": "# Source API介绍\nGeaFlow对外提供了Source API，在接口层面需要提供IWindow，用于构建相应的window source，用户可以通过实现SourceFunction来定义具体的源头读取逻辑。\n\n\n## 接口\n\n| API | 接口说明 | 入参说明 |\n| -------- | -------- | -------- |\n| PWindowSource build(IPipelineContext pipelineContext, SourceFunction sourceFunction, IWindow window)     | 构建window source     |SourceFunction：定义source读取逻辑，GeaFlow内部已经实现了几种类型的source function，例如Collection、File等；IWindow：当前支持SizeTumblingWindow和AllWindow两种类型，前者可以用于支持流式的读取窗口，后者是用于支持批量一次性读取完。   |\n表格内容描述：\n该表格包含三列，分别为“API”、“接口说明”和“入参说明”。\n\n第一行数据中，API为“PWindowSource build(IPipelineContext pipelineContext, SourceFunction sourceFunction, IWindow window)”，其接口说明为“构建window source”。在入参说明中，SourceFunction用于定义source的读取逻辑，GeaFlow内部已经实现了多种类型的source function，例如Collection和File等；IWindow目前支持SizeTumblingWindow和AllWindow两种类型，前者适用于流式读取窗口，后者则用于一次性批量读取完数据。\n\n总结：该表格详细描述了一个构建窗口源的API及其相关参数的说明，主要用于数据流处理的场景，支持不同类型的source函数和窗口选项。\n\n该文档主要介绍GeaFlow的Source API，重点在于构建窗口源（window source）的方法和所需参数，包含接口说明、示例代码以及不同类型的source函数和窗口选项的详细解释，以帮助用户实现数据流处理。"
            },
            {
                "content": "第一行数据中，API为“PWindowSource build(IPipelineContext pipelineContext, SourceFunction sourceFunction, IWindow window)”，其接口说明为“构建window source”。在入参说明中，SourceFunction用于定义source的读取逻辑，GeaFlow内部已经实现了多种类型的source function，例如Collection和File等；IWindow目前支持SizeTumblingWindow和AllWindow两种类型，前者适用于流式读取窗口，后者则用于一次性批量读取完数据。\n\n总结：该表格详细描述了一个构建窗口源的API及其相关参数的说明，主要用于数据流处理的场景，支持不同类型的source函数和窗口选项。\n\n\n\n为了构建window source，用户一般可以直接通过IPipelineTaskContext提供的buildSource接口来实现。\n```java\n\t// Interface.\n\t PWindowSource buildSource(SourceFunction sourceFunction, IWindow window);\n\n\t// Example: 构建window size为2的collection source.\n\tList words = Lists.newArrayList(\"hello\", \"world\", \"hello\", \"word\");\n\tPWindowSource source =\n        pipelineTaskCxt.buildSource(new CollectionSource(words) {},\n            SizeTumblingWindow.of(2));\n```\n\n## 示例\n```java\npublic class WindowStreamWordCount {\n\n    private static final Logger LOGGER =\n        LoggerFactory.getLogger(WindowStreamWordCount.class);\n\n该文档主要介绍了GeaFlow的Source API，包括如何构建窗口源的接口及其相关参数。茶在第一行数据中详细解释了构建窗口源的API及入参，接着提供了使用该接口的示例代码，展示如何通过内置的CollectionSource构建具有特定窗口类型的source。"
            },
            {
                "content": "## 示例\n```java\npublic class WindowStreamWordCount {\n\n    private static final Logger LOGGER =\n        LoggerFactory.getLogger(WindowStreamWordCount.class);\n\n    public static void main(String[] args) {\n        Environment environment = EnvironmentFactory.onLocalEnvironment();\n        Pipeline pipeline = PipelineFactory.buildPipeline(environment);\n        pipeline.submit(new PipelineTask() {\n            @Override\n            public void execute(IPipelineTaskContext pipelineTaskCxt) {\n                Configuration config = pipelineTaskCxt.getConfig();\n                List words = Lists.newArrayList(\"hello\", \"world\", \"hello\", \"word\");\n                // 通过内置的CollectionSource构建source，同时指定window类型为SizeTumblingWindow，window size为2。\n                PWindowSource source =\n                    pipelineTaskCxt.buildSource(new CollectionSource(words) {},\n                        SizeTumblingWindow.of(2));\n                source.sink(v -> LOGGER.info(\"result: {}\", v));\n            }\n        });\n\n该代码示例展示了如何使用GeaFlow框架中的API构建一个基于窗口的流处理程序。通过实现`IPipelineTaskContext`接口，用户能够创建一个集合源`CollectionSource`，并指定窗口类型为`SizeTumblingWindow`，窗口大小为2，以进行词语计数并输出结果。此示例位于文档的API介绍部分之后，用于演示API的具体应用。"
            },
            {
                "content": "IPipelineResult result = pipeline.execute();\n        // 等待执行完成\n        result.get();\n    }\n\n}\n```\n\n该代码段位于一个示例类`WindowStreamWordCount`的`main`方法中，展示了如何构建并执行一个数据流处理的管道。执行管道后，该段代码等待处理结果的返回，标志着数据流处理的完成。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_78.md",
        "chunks": [
            {
                "content": "# TuGraph 嵌入模式 Python API 文档概述（Python开发存储过程接口）\r\n\r\n## 介绍\r\n\r\nTuGraph 是一个图数据库，与 SQLite 和 Neo4j 类似，支持嵌入式模式。在嵌入式模式下，TuGraph 作为一个库运行，允许用户编写应用程序并调用库函数来创建、查询和修改图数据。数据交换在同一进程中进行，操作简单且高效。\r\n\r\n与 SQLite 和 Noe4j 类似，TuGraph 可以在嵌入式模式下工作。 在嵌入式模式下，它就像一个库。 您可以编写自己的应用程序并调用库函数来创建、查询和修改图。 在这种情况下，应用程序和图数据库之间的所有数据交换都在同一个进程中进行。 它非常简单高效。\r\n\r\n这是 TuGraph 嵌入模式的 python API 文档。 通过嵌入式API，用户可以打开或创建数据库，然后查询或修改数据库。\r\n\r\n## 接口\r\n\r\n以下是 TuGraph 嵌入模式的 Python API 类及其成员的详细介绍：\r\n\r\n### `liblgraph_python_api.AccessLevel`\r\n表示用户在图上的访问权限。  \r\n*Access that a user has on a graph.*\r\n\r\n- **成员 Members**:\r\n  - `NONE`: 无权限. *No access.*\r\n  - `READ`: 只读权限. *Read-only access.*\r\n  - `WRITE`: 写权限. *Write access.*\r\n  - `FULL`: 完全权限. *Full access.*\r\n- **属性 Property**:\r\n  - `name`: 访问级别名称. *Name of the access level.*\r\n\r\n\r\n### `liblgraph_python_api.EdgeUid`\r\n表示边的标识符。  \r\n*Edge identifier.*\r\n\r\n- **属性 Property**:\r\n  - `dst`: 目标顶点 ID. *Destination vertex ID.*\r\n  - `eid`: 边的 ID. *ID of the edge.*\r\n  - `lid`: 边的标签 ID. *Label ID of the edge.*\r\n  - `src`: 源顶点 ID. *Source vertex ID.*\n\n该文档是关于 TuGraph 嵌入模式的 Python API 的详细介绍，主要涵盖了其功能、接口和相关类的描述，包括用户访问权限、边的标识符等信息。提供了 API 的使用方法和成员属性，适用于开发图数据库应用程序。"
            },
            {
                "content": "- **成员 Members**:\r\n  - `NONE`: 无权限. *No access.*\r\n  - `READ`: 只读权限. *Read-only access.*\r\n  - `WRITE`: 写权限. *Write access.*\r\n  - `FULL`: 完全权限. *Full access.*\r\n- **属性 Property**:\r\n  - `name`: 访问级别名称. *Name of the access level.*\r\n\r\n\r\n### `liblgraph_python_api.EdgeUid`\r\n表示边的标识符。  \r\n*Edge identifier.*\r\n\r\n- **属性 Property**:\r\n  - `dst`: 目标顶点 ID. *Destination vertex ID.*\r\n  - `eid`: 边的 ID. *ID of the edge.*\r\n  - `lid`: 边的标签 ID. *Label ID of the edge.*\r\n  - `src`: 源顶点 ID. *Source vertex ID.*\r\n  - `tid`: 边的时间 ID. *Temporal ID of the edge.*\r\n\r\n  \r\n\r\n### `liblgraph_python_api.FieldData`\r\n表示字段值的数据类型。  \r\n*FieldData is the data type of field value.*\r\n\r\n- **方法 Methods**:\r\n  - `AsBlob(self: liblgraph_python_api.FieldData) → bytes`: 返回 BLOB 类型的值，如果类型不匹配则抛出异常.  \r\n    *Get value as BLOB, throws exception on type mismatch.*\r\n  - `AsBool(self: liblgraph_python_api.FieldData) → bool`: 返回布尔类型的值，如果类型不匹配则抛出异常.  \r\n    *Get value as bool, throws exception on type mismatch.*\n\n该段落位于 TuGraph 嵌入模式 Python API 文档中，介绍了访问权限级别和边的标识符的信息。在此之前，文档概述了 TuGraph 的基本功能和接口，接着详细列出了与图数据库操作相关的不同类及其成员，包括访问级别（`liblgraph_python_api.AccessLevel`）、边标识符（`liblgraph_python_api.EdgeUid`）以及字段值的数据类型（`liblgraph_python_api.FieldData`）。"
            },
            {
                "content": "- `tid`: 边的时间 ID. *Temporal ID of the edge.*\r\n\r\n  \r\n\r\n### `liblgraph_python_api.FieldData`\r\n表示字段值的数据类型。  \r\n*FieldData is the data type of field value.*\r\n\r\n- **方法 Methods**:\r\n  - `AsBlob(self: liblgraph_python_api.FieldData) → bytes`: 返回 BLOB 类型的值，如果类型不匹配则抛出异常.  \r\n    *Get value as BLOB, throws exception on type mismatch.*\r\n  - `AsBool(self: liblgraph_python_api.FieldData) → bool`: 返回布尔类型的值，如果类型不匹配则抛出异常.  \r\n    *Get value as bool, throws exception on type mismatch.*\r\n  - `AsDate(self: liblgraph_python_api.FieldData) → datetime.datetime`: 返回日期类型的值，如果类型不匹配则抛出异常.  \r\n    *Get value as date, throws exception on type mismatch.*\r\n  - `AsDateTime(self: liblgraph_python_api.FieldData) → datetime.datetime`: 返回日期时间类型的值，如果类型不匹配则抛出异常.  \r\n    *Get value as datetime, throws exception on type mismatch.*\r\n  - `AsDouble(self: liblgraph_python_api.FieldData) → float`: 返回双精度浮点数类型的值，如果类型不匹配则抛出异常.  \r\n    *Get value as double, throws exception on type mismatch.*\n\n该块内容位于 TuGraph 嵌入模式的 Python API 文档中，介绍了边的时间 ID (`tid`) 的属性，接着详细描述了 `FieldData` 类及其方法，主要用于处理字段值的数据类型和相关操作。"
            },
            {
                "content": "- `AsDate(self: liblgraph_python_api.FieldData) → datetime.datetime`: 返回日期类型的值，如果类型不匹配则抛出异常.  \r\n    *Get value as date, throws exception on type mismatch.*\r\n  - `AsDateTime(self: liblgraph_python_api.FieldData) → datetime.datetime`: 返回日期时间类型的值，如果类型不匹配则抛出异常.  \r\n    *Get value as datetime, throws exception on type mismatch.*\r\n  - `AsDouble(self: liblgraph_python_api.FieldData) → float`: 返回双精度浮点数类型的值，如果类型不匹配则抛出异常.  \r\n    *Get value as double, throws exception on type mismatch.*\r\n  - `AsFloat(self: liblgraph_python_api.FieldData) → float`: 返回单精度浮点数类型的值，如果类型不匹配则抛出异常.  \r\n    *Get value as float, throws exception on type mismatch.*\r\n  - `AsInt16(self: liblgraph_python_api.FieldData) → int`: 返回 16 位整型值，如果类型不匹配则抛出异常.  \r\n    *Get value as int16, throws exception on type mismatch.*\r\n  - `AsInt32(self: liblgraph_python_api.FieldData) → int`: 返回 32 位整型值，如果类型不匹配则抛出异常.  \r\n    *Get value as int32, throws exception on type mismatch.*\r\n  - `AsInt64(self: liblgraph_python_api.FieldData) → int`: 返回 64 位整型值，如果类型不匹配则抛出异常.\n\n该代码片段位于 TuGraph 嵌入模式 Python API 文档中，属于 `liblgraph_python_api.FieldData` 类的详细介绍部分，具体描述了该类的方法，以获取不同数据类型的字段值，包括日期、时间、浮点数和整型等，同时强调如果类型不匹配将抛出异常。这些方法为用户提供了访问和处理图数据库中字段数据的灵活性。"
            },
            {
                "content": "*Get value as float, throws exception on type mismatch.*\r\n  - `AsInt16(self: liblgraph_python_api.FieldData) → int`: 返回 16 位整型值，如果类型不匹配则抛出异常.  \r\n    *Get value as int16, throws exception on type mismatch.*\r\n  - `AsInt32(self: liblgraph_python_api.FieldData) → int`: 返回 32 位整型值，如果类型不匹配则抛出异常.  \r\n    *Get value as int32, throws exception on type mismatch.*\r\n  - `AsInt64(self: liblgraph_python_api.FieldData) → int`: 返回 64 位整型值，如果类型不匹配则抛出异常.  \r\n    *Get value as int64, throws exception on type mismatch.*\r\n  - `AsInt8(self: liblgraph_python_api.FieldData) → int`: 返回 8 位整型值，如果类型不匹配则抛出异常.  \r\n    *Get value as int8, throws exception on type mismatch.*\r\n  - `AsString(self: liblgraph_python_api.FieldData) → str`: 返回字符串值，如果类型不匹配则抛出异常.  \r\n    *Get value as string, throws exception on type mismatch.*\r\n    - `static Blob(arg0: bytes) → liblgraph_python_api.FieldData`: 创建 BLOB 值.  \r\n    *Make a BLOB value.*\r\n  - `static Bool(arg0: bool) → liblgraph_python_api.FieldData`: 创建布尔值.  \r\n    *Make a BOOL value.*\n\n该段落位于TuGraph嵌入模式Python API文档中的`liblgraph_python_api.FieldData`类的详细描述部分，主要介绍该类的方法，特别是用于获取不同数据类型字段值的方法及其异常处理机制。这些方法包括将字段值转换为浮点数、整型和字符串等。"
            },
            {
                "content": "- `AsInt8(self: liblgraph_python_api.FieldData) → int`: 返回 8 位整型值，如果类型不匹配则抛出异常.  \r\n    *Get value as int8, throws exception on type mismatch.*\r\n  - `AsString(self: liblgraph_python_api.FieldData) → str`: 返回字符串值，如果类型不匹配则抛出异常.  \r\n    *Get value as string, throws exception on type mismatch.*\r\n    - `static Blob(arg0: bytes) → liblgraph_python_api.FieldData`: 创建 BLOB 值.  \r\n    *Make a BLOB value.*\r\n  - `static Bool(arg0: bool) → liblgraph_python_api.FieldData`: 创建布尔值.  \r\n    *Make a BOOL value.*\r\n  - `static Date(*args, **kwargs)`: 重载函数.  \r\n    *Overloaded function.*\r\n    - `1.Date(arg0: str) → liblgraph_python_api.FieldData`: 创建日期值.  \r\n      *Make a DATE value.*\r\n    - `2.Date(arg0: datetime.datetime) → liblgraph_python_api.FieldData`: 创建日期值.  \r\n      *Make a DATE value.*\r\n  - `static DateTime(*args, **kwargs)`: 重载函数.  \r\n    *Overloaded function.*\r\n    - `1.DateTime(arg0: str) → liblgraph_python_api.FieldData`: 创建日期时间值.  \r\n      *Make a DATETIME value.*\n\n该区块位于 TuGraph 嵌入模式的 Python API 文档中，具体介绍了 `liblgraph_python_api.FieldData` 类的部分方法，包括如何获取不同数据类型的值以及创建特定类型的字段值静态方法。这些方法允许用户处理图数据库中的字段数据。"
            },
            {
                "content": "*Make a BOOL value.*\r\n  - `static Date(*args, **kwargs)`: 重载函数.  \r\n    *Overloaded function.*\r\n    - `1.Date(arg0: str) → liblgraph_python_api.FieldData`: 创建日期值.  \r\n      *Make a DATE value.*\r\n    - `2.Date(arg0: datetime.datetime) → liblgraph_python_api.FieldData`: 创建日期值.  \r\n      *Make a DATE value.*\r\n  - `static DateTime(*args, **kwargs)`: 重载函数.  \r\n    *Overloaded function.*\r\n    - `1.DateTime(arg0: str) → liblgraph_python_api.FieldData`: 创建日期时间值.  \r\n      *Make a DATETIME value.*\r\n    - `2.DateTime(arg0: datetime.datetime) → liblgraph_python_api.FieldData`: 创建日期时间值.  \r\n      *Make a DATETIME value.*\r\n  - `static Double(arg0: float) → liblgraph_python_api.FieldData`: 创建双精度浮点数值.  \r\n    *Make a DOUBLE value.*\r\n  - `static Float(arg0: float) → liblgraph_python_api.FieldData`: 创建单精度浮点数值.  \r\n    *Make a FLOAT value.*\r\n  - `static Int16(arg0: int) → liblgraph_python_api.FieldData`: 创建 16 位整型值.  \r\n    *Make a INT16 value.*\r\n  - `static Int32(arg0: int) → liblgraph_python_api.FieldData`: 创建 32 位整型值.\n\n该片段位于 TuGraph 嵌入模式 Python API 文档的 `liblgraph_python_api.FieldData` 类的具体方法部分，描述了如何创建不同数据类型的字段值，包括布尔值、日期、日期时间、双精度浮点数、单精度浮点数和整型值。"
            },
            {
                "content": "*Make a DATETIME value.*\r\n  - `static Double(arg0: float) → liblgraph_python_api.FieldData`: 创建双精度浮点数值.  \r\n    *Make a DOUBLE value.*\r\n  - `static Float(arg0: float) → liblgraph_python_api.FieldData`: 创建单精度浮点数值.  \r\n    *Make a FLOAT value.*\r\n  - `static Int16(arg0: int) → liblgraph_python_api.FieldData`: 创建 16 位整型值.  \r\n    *Make a INT16 value.*\r\n  - `static Int32(arg0: int) → liblgraph_python_api.FieldData`: 创建 32 位整型值.  \r\n    *Make a INT32 value.*\r\n  - `static Int64(arg0: int) → liblgraph_python_api.FieldData`: 创建 64 位整型值.  \r\n    *Make a INT64 value.*\r\n  - `static Int8(arg0: int) → liblgraph_python_api.FieldData`: 创建 8 位整型值.  \r\n    *Make a INT8 value.*\r\n  - `static String(arg0: str) → liblgraph_python_api.FieldData`: 创建字符串值.  \r\n    *Make a STRING value.*\r\n  - `ToPython(self: liblgraph_python_api.FieldData) → object`: 转换为相应的 Python 类型.  \r\n    *Convert to corresponding Python type.*\r\n  - `get(self: liblgraph_python_api.FieldData) → object`: 获取字段值.  \r\n    *Get the field value.*\n\n该块内容位于 TuGraph 嵌入模式的 Python API 文档中，具体涉及 `liblgraph_python_api.FieldData` 类的静态方法和实例方法，主要用于创建和转换多种数据类型的字段值，如日期、浮点数、整型和字符串，并提供获取和转换字段值的方法。这些方法对用户在操作图数据时非常重要。"
            },
            {
                "content": "*Make a INT64 value.*\r\n  - `static Int8(arg0: int) → liblgraph_python_api.FieldData`: 创建 8 位整型值.  \r\n    *Make a INT8 value.*\r\n  - `static String(arg0: str) → liblgraph_python_api.FieldData`: 创建字符串值.  \r\n    *Make a STRING value.*\r\n  - `ToPython(self: liblgraph_python_api.FieldData) → object`: 转换为相应的 Python 类型.  \r\n    *Convert to corresponding Python type.*\r\n  - `get(self: liblgraph_python_api.FieldData) → object`: 获取字段值.  \r\n    *Get the field value.*\r\n  - `isNull(self: liblgraph_python_api.FieldData) → bool`: 检查字段是否为 null.  \r\n    *Check if the field is null.*\r\n  - `set(self: liblgraph_python_api.FieldData, arg0: object) → None`: 设置字段值.  \r\n    *Set the field value.*\r\n\r\n  \r\n\r\n### `liblgraph_python_api.FieldSpec`\r\n表示字段的规格。  \r\n*Represents the specifications of a field.*\r\n\r\n- **属性 Property**:\r\n  - `name`: 字段名称. *Name of this field.*\r\n  - `nullable`: 字段是否可以为空. *Whether this field can be null.*\r\n  - `type`: 字段类型（例如 INT8, FLOAT, STRING）. *Type of this field, INT8, INT16, …, FLOAT, DOUBLE, STRING.*\n\n该块内容位于 TuGraph 嵌入模式 Python API 文档中，具体介绍了 `liblgraph_python_api.FieldData` 类的静态方法和实例方法，以及 `liblgraph_python_api.FieldSpec` 类的定义和属性。这部分内容主要涉及字段值的数据类型处理和字段规格的描述，属于API接口部分的详细信息，有助于用户理解如何操作和管理图数据库中的字段数据。"
            },
            {
                "content": "*Check if the field is null.*\r\n  - `set(self: liblgraph_python_api.FieldData, arg0: object) → None`: 设置字段值.  \r\n    *Set the field value.*\r\n\r\n  \r\n\r\n### `liblgraph_python_api.FieldSpec`\r\n表示字段的规格。  \r\n*Represents the specifications of a field.*\r\n\r\n- **属性 Property**:\r\n  - `name`: 字段名称. *Name of this field.*\r\n  - `nullable`: 字段是否可以为空. *Whether this field can be null.*\r\n  - `type`: 字段类型（例如 INT8, FLOAT, STRING）. *Type of this field, INT8, INT16, …, FLOAT, DOUBLE, STRING.*\r\n\r\n\r\n### `liblgraph_python_api.FieldType`\r\n表示 FieldData 的数据类型。  \r\n*Data type of FieldData.*\r\n\r\n- **成员 Members**:\r\n  - `NUL`: 空值类型.  \r\n    *Null type.*\r\n  - `BOOL`: 布尔类型.  \r\n    *Boolean type.*\r\n  - `INT8`: 8 位整型.  \r\n    *8-bit integer type.*\r\n  - `INT16`: 16 位整型.  \r\n    *16-bit integer type.*\r\n  - `INT32`: 32 位整型.  \r\n    *32-bit integer type.*\r\n  - `INT64`: 64 位整型.  \r\n    *64-bit integer type.*\r\n  - `FLOAT`: 单精度浮点数.  \r\n    *Float type.*\r\n  - `DOUBLE`: 双精度浮点数.  \r\n    *Double type.*\r\n  - `DATE`: 日期类型.  \r\n    *Date type.*\n\n该块内容位于 TuGraph 嵌入模式 Python API 文档中的字段相关部分，主要介绍了 `FieldData` 类中的方法和 `FieldSpec` 及 `FieldType` 的定义与说明。这部分内容旨在帮助用户理解如何操作字段值以及字段的规格和数据类型。"
            },
            {
                "content": "表示 FieldData 的数据类型。  \r\n*Data type of FieldData.*\r\n\r\n- **成员 Members**:\r\n  - `NUL`: 空值类型.  \r\n    *Null type.*\r\n  - `BOOL`: 布尔类型.  \r\n    *Boolean type.*\r\n  - `INT8`: 8 位整型.  \r\n    *8-bit integer type.*\r\n  - `INT16`: 16 位整型.  \r\n    *16-bit integer type.*\r\n  - `INT32`: 32 位整型.  \r\n    *32-bit integer type.*\r\n  - `INT64`: 64 位整型.  \r\n    *64-bit integer type.*\r\n  - `FLOAT`: 单精度浮点数.  \r\n    *Float type.*\r\n  - `DOUBLE`: 双精度浮点数.  \r\n    *Double type.*\r\n  - `DATE`: 日期类型.  \r\n    *Date type.*\r\n  - `DATETIME`: 日期时间类型.  \r\n    *DateTime type.*\r\n  - `STRING`: 字符串类型.  \r\n    *String type.*\r\n  - `BLOB`: 二进制大对象类型.  \r\n    *BLOB type.*\r\n\r\n- **属性 Property**:\r\n  - `name`: 数据类型名称.  \r\n    *Name of the data type.*\r\n\r\n\r\n\r\n\r\n### `liblgraph_python_api.Galaxy`\r\n一个银河是一个 TuGraph 实例，持有多个 GraphDB。银河存储在一个目录中，管理用户和 GraphDB。每个 (用户, GraphDB) 对可以具有不同的访问级别。您可以使用 `db = Galaxy.OpenGraph(graph)` 打开一个图。由于 Python 中的垃圾回收是自动的，完成后需要使用 `Galaxy.Close()` 关闭银河。\n\n该块内容位于 TuGraph 嵌入模式 Python API 文档中，具体介绍了 `liblgraph_python_api.FieldType` 类，定义了不同的数据类型及其属性。这些数据类型用于表示字段值的数据类型，为后续银河和图数据库操作提供基础。它紧接着介绍了 `liblgraph_python_api.Galaxy` 类，这是一个管理多个 GraphDB 的 TuGraph 实例。"
            },
            {
                "content": "*Double type.*\r\n  - `DATE`: 日期类型.  \r\n    *Date type.*\r\n  - `DATETIME`: 日期时间类型.  \r\n    *DateTime type.*\r\n  - `STRING`: 字符串类型.  \r\n    *String type.*\r\n  - `BLOB`: 二进制大对象类型.  \r\n    *BLOB type.*\r\n\r\n- **属性 Property**:\r\n  - `name`: 数据类型名称.  \r\n    *Name of the data type.*\r\n\r\n\r\n\r\n\r\n### `liblgraph_python_api.Galaxy`\r\n一个银河是一个 TuGraph 实例，持有多个 GraphDB。银河存储在一个目录中，管理用户和 GraphDB。每个 (用户, GraphDB) 对可以具有不同的访问级别。您可以使用 `db = Galaxy.OpenGraph(graph)` 打开一个图。由于 Python 中的垃圾回收是自动的，完成后需要使用 `Galaxy.Close()` 关闭银河。  \r\n*A galaxy is a TuGraph instance that holds multiple GraphDBs. A galaxy is stored in a directory and manages users and GraphDBs. Each (user, GraphDB) pair can have different access levels. You can use `db = Galaxy.OpenGraph(graph)` to open a graph. Since garbage collection in Python is automatic, you need to close the galaxy with `Galaxy.Close()` when you are done with it.*\r\n\r\n- **方法 Methods**:\r\n  - `Close(self: liblgraph_python_api.Galaxy) → None`: 关闭此银河.  \r\n    *Closes this galaxy.*\n\n该段落位于 TuGraph 嵌入模式 Python API 文档中，介于数据类型 `FieldType` 的成员列表和 `Galaxy` 类的介绍之间。这一部分涵盖了图数据库中的数据类型及其属性，随后转向了 `Galaxy` 的概念，它代表一个 TuGraph 实例，管理多个图数据库和用户。"
            },
            {
                "content": "*A galaxy is a TuGraph instance that holds multiple GraphDBs. A galaxy is stored in a directory and manages users and GraphDBs. Each (user, GraphDB) pair can have different access levels. You can use `db = Galaxy.OpenGraph(graph)` to open a graph. Since garbage collection in Python is automatic, you need to close the galaxy with `Galaxy.Close()` when you are done with it.*\r\n\r\n- **方法 Methods**:\r\n  - `Close(self: liblgraph_python_api.Galaxy) → None`: 关闭此银河.  \r\n    *Closes this galaxy.*\r\n  \r\n  - `CreateGraph(self: liblgraph_python_api.Galaxy, name: str, description: str = '', max_size: int = 4398046511104) → bool`: 创建一个图。  \r\n    `name`: 图的名称.  \r\n    `description`: 图的描述.  \r\n    `max_size`: 图的最大大小，默认 1TB.  \r\n    *Creates a graph. `name`: the name of the graph; `description`: description of the graph; `max_size`: maximum size of the graph, default 1TB.*\r\n  \r\n  - `CreateRole(self: liblgraph_python_api.Galaxy, name: str, desc: str) → bool`: 创建一个角色.  \r\n    `name`: 角色名称.  \r\n    `desc`: 角色描述.\n\n该块内容位于 TuGraph 嵌入模式 Python API 文档中的“liblgraph_python_api.Galaxy”部分，主要介绍了 Galaxy 类的功能，包括其定义、如何打开图数据库以及相关的方法，如关闭银河、创建图和角色等。这部分内容有助于用户理解如何管理和操作多个图数据库实例。"
            },
            {
                "content": "- `CreateGraph(self: liblgraph_python_api.Galaxy, name: str, description: str = '', max_size: int = 4398046511104) → bool`: 创建一个图。  \r\n    `name`: 图的名称.  \r\n    `description`: 图的描述.  \r\n    `max_size`: 图的最大大小，默认 1TB.  \r\n    *Creates a graph. `name`: the name of the graph; `description`: description of the graph; `max_size`: maximum size of the graph, default 1TB.*\r\n  \r\n  - `CreateRole(self: liblgraph_python_api.Galaxy, name: str, desc: str) → bool`: 创建一个角色.  \r\n    `name`: 角色名称.  \r\n    `desc`: 角色描述.  \r\n    *Create a role. `name`: name of the role; `desc`: description of the role.*\r\n  \r\n  - `CreateUser(self: liblgraph_python_api.Galaxy, name: str, password: str, desc: str) → bool`: 创建一个新用户账户.  \r\n    `name`: 用户名称.  \r\n    `password`: 用户密码.  \r\n    `desc`: 此用户的描述.  \r\n    *Creates a new user account. `name`: name of the user; `password`: password for the user; `desc`: description of this user.*\r\n  \r\n  - `DeleteGraph(self: liblgraph_python_api.Galaxy, arg0: str) → bool`: 删除一个图.  \r\n    *Deletes a graph.*\n\n该内容来自于 TuGraph 嵌入模式 Python API 文档中的 `liblgraph_python_api.Galaxy` 类，主要介绍了与图数据库相关的管理操作，包括创建图、角色和用户账户，以及删除图的功能。"
            },
            {
                "content": "*Create a role. `name`: name of the role; `desc`: description of the role.*\r\n  \r\n  - `CreateUser(self: liblgraph_python_api.Galaxy, name: str, password: str, desc: str) → bool`: 创建一个新用户账户.  \r\n    `name`: 用户名称.  \r\n    `password`: 用户密码.  \r\n    `desc`: 此用户的描述.  \r\n    *Creates a new user account. `name`: name of the user; `password`: password for the user; `desc`: description of this user.*\r\n  \r\n  - `DeleteGraph(self: liblgraph_python_api.Galaxy, arg0: str) → bool`: 删除一个图.  \r\n    *Deletes a graph.*\r\n  \r\n  - `DeleteRole(self: liblgraph_python_api.Galaxy, arg0: str) → bool`: 删除指定角色.  \r\n    *Deletes the specified role.*\r\n  \r\n  - `DeleteUser(self: liblgraph_python_api.Galaxy, arg0: str) → bool`: 删除用户账户.  \r\n    *Deletes a user account.*\r\n  \r\n  - `DisableUser(self: liblgraph_python_api.Galaxy, arg0: str) → bool`: 禁用用户.  \r\n    *Disables a user.*\r\n  \r\n  - `EnableUser(self: liblgraph_python_api.Galaxy, arg0: str) → bool`: 启用用户.  \r\n    *Enables a user.*\n\n该chunk位于TuGraph嵌入模式Python API文档的接口部分，具体介绍了在`liblgraph_python_api.Galaxy`类中与用户角色管理相关的方法，包括创建角色、创建用户账户、删除图形、删除角色和用户的功能。"
            },
            {
                "content": "*Deletes a graph.*\r\n  \r\n  - `DeleteRole(self: liblgraph_python_api.Galaxy, arg0: str) → bool`: 删除指定角色.  \r\n    *Deletes the specified role.*\r\n  \r\n  - `DeleteUser(self: liblgraph_python_api.Galaxy, arg0: str) → bool`: 删除用户账户.  \r\n    *Deletes a user account.*\r\n  \r\n  - `DisableUser(self: liblgraph_python_api.Galaxy, arg0: str) → bool`: 禁用用户.  \r\n    *Disables a user.*\r\n  \r\n  - `EnableUser(self: liblgraph_python_api.Galaxy, arg0: str) → bool`: 启用用户.  \r\n    *Enables a user.*\r\n  \r\n  - `GetUserInfo(self: liblgraph_python_api.Galaxy, arg0: str) → lgraph_api::UserInfo`: 获取指定用户的信息.  \r\n    *Get information of the specified user.*\r\n  \r\n  - `ListGraphs(self: liblgraph_python_api.Galaxy) → Dict[str, Tuple[str, int]]`: 列出图并返回字典 {名称:(描述, 最大大小)}.  \r\n    *Lists graphs and returns a dictionary of {name:(desc, max_size)}.*\r\n  \r\n  - `ListUsers(self: liblgraph_python_api.Galaxy) → Dict[str, lgraph_api::UserInfo]`: 列出所有用户及其是否为管理员.  \r\n    *Lists all users and whether they are admin.*\n\n该部分位于 TuGraph 嵌入模式的 Python API 文档中，具体介绍了 `liblgraph_python_api.Galaxy` 类的方法，包括用户和图的管理操作，如删除图、角色和用户，以及禁用和启用用户等功能。此上下文有助于理解如何通过 Galaxy 类管理图数据库的用户权限及相关操作。"
            },
            {
                "content": "- `GetUserInfo(self: liblgraph_python_api.Galaxy, arg0: str) → lgraph_api::UserInfo`: 获取指定用户的信息.  \r\n    *Get information of the specified user.*\r\n  \r\n  - `ListGraphs(self: liblgraph_python_api.Galaxy) → Dict[str, Tuple[str, int]]`: 列出图并返回字典 {名称:(描述, 最大大小)}.  \r\n    *Lists graphs and returns a dictionary of {name:(desc, max_size)}.*\r\n  \r\n  - `ListUsers(self: liblgraph_python_api.Galaxy) → Dict[str, lgraph_api::UserInfo]`: 列出所有用户及其是否为管理员.  \r\n    *Lists all users and whether they are admin.*\r\n  \r\n  - `ModGraph(self: liblgraph_python_api.Galaxy, graph_name: str, mod_desc: bool, description: str, mod_size: bool, new_max_size: int) → bool`: 修改图.  \r\n    `mod_size`: 是否修改最大图大小.  \r\n    `new_max_size`: 新的图的最大大小（以字节为单位）.  \r\n    *Modifies a graph. `mod_size`: whether to modify max graph size; `new_max_size`: new maximum size of the graph, in bytes.*\r\n  \r\n  - `OpenGraph(self: liblgraph_python_api.Galaxy, graph: str, read_only: bool = False) → lgraph_api::GraphDB`: 打开一个图并返回 GraphDB 实例.  \r\n    `graph`: 图的名称.\n\n该块内容位于 TuGraph 嵌入模式 Python API 文档的 `liblgraph_python_api.Galaxy` 类部分，主要描述了与图数据库相关的用户和图管理操作，涵盖获取用户信息、列出图和用户、修改图及打开图等方法。"
            },
            {
                "content": "- `ModGraph(self: liblgraph_python_api.Galaxy, graph_name: str, mod_desc: bool, description: str, mod_size: bool, new_max_size: int) → bool`: 修改图.  \r\n    `mod_size`: 是否修改最大图大小.  \r\n    `new_max_size`: 新的图的最大大小（以字节为单位）.  \r\n    *Modifies a graph. `mod_size`: whether to modify max graph size; `new_max_size`: new maximum size of the graph, in bytes.*\r\n  \r\n  - `OpenGraph(self: liblgraph_python_api.Galaxy, graph: str, read_only: bool = False) → lgraph_api::GraphDB`: 打开一个图并返回 GraphDB 实例.  \r\n    `graph`: 图的名称.  \r\n    `read_only`: 是否以只读模式打开图.  \r\n    *Opens a graph and returns a GraphDB instance. `graph`: name of the graph; `read_only`: whether to open the graph in read-only mode.*\r\n  \r\n  - `SetCurrentUser(self: liblgraph_python_api.Galaxy, user: str, password: str) → None`: 验证用户密码并设置当前用户.  \r\n    `user`: 用户名.  \r\n    `password`: 用户密码.  \r\n    *Validate user password and set current user. `user`: user name; `password`: password of the user.*\n\n该块内容位于 TuGraph 嵌入模式的 Python API 文档中，具体描述了 `liblgraph_python_api.Galaxy` 类的几个重要方法，包括修改图、打开图和设置当前用户的方法。这些方法涉及图数据库的管理和用户身份验证，是用户与图数据库交互的关键接口。"
            },
            {
                "content": "`graph`: 图的名称.  \r\n    `read_only`: 是否以只读模式打开图.  \r\n    *Opens a graph and returns a GraphDB instance. `graph`: name of the graph; `read_only`: whether to open the graph in read-only mode.*\r\n  \r\n  - `SetCurrentUser(self: liblgraph_python_api.Galaxy, user: str, password: str) → None`: 验证用户密码并设置当前用户.  \r\n    `user`: 用户名.  \r\n    `password`: 用户密码.  \r\n    *Validate user password and set current user. `user`: user name; `password`: password of the user.*\r\n  \r\n  - `SetRoleAccessRights(self: liblgraph_python_api.Galaxy, arg0: str, arg1: Dict[str, liblgraph_python_api.AccessLevel]) → bool`: 设置指定角色的访问权限.  \r\n    *Set access rights for the specified role.*\r\n  \r\n  - `SetRoleAccessRightsIncremental(self: liblgraph_python_api.Galaxy, arg0: str, arg1: Dict[str, liblgraph_python_api.AccessLevel]) → bool`: 为指定角色设置增量访问权限，仅影响指定图.  \r\n    *Set access rights for the specified role, only affects the specified graphs.*\r\n  \r\n  - `SetRoleDesc(self: liblgraph_python_api.Galaxy, name: str, desc: str) → bool`: 设置指定角色的描述.\n\n这段内容位于 TuGraph 嵌入模式 Python API 文档的接口部分，具体是在 `liblgraph_python_api.Galaxy` 类的描述中。该部分介绍了与银河相关的方法，包括打开图、设置当前用户和角色访问权限等功能。这为用户提供了管理图数据库的权限和操作接口。"
            },
            {
                "content": "*Set access rights for the specified role.*\r\n  \r\n  - `SetRoleAccessRightsIncremental(self: liblgraph_python_api.Galaxy, arg0: str, arg1: Dict[str, liblgraph_python_api.AccessLevel]) → bool`: 为指定角色设置增量访问权限，仅影响指定图.  \r\n    *Set access rights for the specified role, only affects the specified graphs.*\r\n  \r\n  - `SetRoleDesc(self: liblgraph_python_api.Galaxy, name: str, desc: str) → bool`: 设置指定角色的描述.  \r\n    `name`: 角色名称.  \r\n    `desc`: 角色描述.  \r\n    *Set description of the specified role. `name`: name of the role; `desc`: description of the role.*\r\n  \r\n  - `SetUser(self: liblgraph_python_api.Galaxy, user: str) → None`: 验证给定用户并设置当前用户.  \r\n    `user`: 用户名.  \r\n    *Validate the given user and set current user given in the user.*\r\n  \r\n  - `SetUserGraphAccess(self: liblgraph_python_api.Galaxy, user: str, graph: str, access: liblgraph_python_api.AccessLevel) → bool`: 设置指定用户在图上的访问级别.  \r\n    `user`: 用户名称.  \r\n    `graph`: 图的名称.  \r\n    `access`: 用户在该图上的访问级别.\n\n该块内容位于 TuGraph 嵌入模式 Python API 文档中的 \"接口\" 部分，主要涉及 `liblgraph_python_api.Galaxy` 类的相关方法，具体描述了如何为角色和用户设置访问权限和描述。此部分是关于权限管理功能的重要组成部分。"
            },
            {
                "content": "- `SetUser(self: liblgraph_python_api.Galaxy, user: str) → None`: 验证给定用户并设置当前用户.  \r\n    `user`: 用户名.  \r\n    *Validate the given user and set current user given in the user.*\r\n  \r\n  - `SetUserGraphAccess(self: liblgraph_python_api.Galaxy, user: str, graph: str, access: liblgraph_python_api.AccessLevel) → bool`: 设置指定用户在图上的访问级别.  \r\n    `user`: 用户名称.  \r\n    `graph`: 图的名称.  \r\n    `access`: 用户在该图上的访问级别.  \r\n    *Set the access level of the specified user on the graph. `user`: name of the user; `graph`: name of the graph; `access`: access level of the user on that graph.*\r\n  \r\n  - `SetUserPass(self: liblgraph_python_api.Galaxy, name: str, old_password: str = '', new_password: str) → bool`: 修改用户密码.  \r\n    `name`: 用户名称.  \r\n    `old_password`: 当前密码，在修改其他用户时不需要.  \r\n    `new_password`: 用户的新密码.  \r\n    *Modifies user password. `name`: name of the user; `old_password`: current password, not needed when modifying another user; `new_password`: new password for the user.*\n\n该段落位于TuGraph嵌入模式的Python API文档中，具体描述了`liblgraph_python_api.Galaxy`类的相关方法，主要涉及用户管理功能，包括验证用户、设置用户在图数据库上的访问级别以及修改用户密码等操作。这些方法对管理用户权限和安全性至关重要。"
            },
            {
                "content": "- `SetUserPass(self: liblgraph_python_api.Galaxy, name: str, old_password: str = '', new_password: str) → bool`: 修改用户密码.  \r\n    `name`: 用户名称.  \r\n    `old_password`: 当前密码，在修改其他用户时不需要.  \r\n    `new_password`: 用户的新密码.  \r\n    *Modifies user password. `name`: name of the user; `old_password`: current password, not needed when modifying another user; `new_password`: new password for the user.*\r\n  \r\n  - `SetUserRoles(self: liblgraph_python_api.Galaxy, name: str, roles: List[str]) → bool`: 为指定用户设置角色.  \r\n    `name`: 用户名称.  \r\n    `roles`: 该用户的角色列表.  \r\n    *Set the roles for the specified user. `name`: name of the user; `roles`: list of roles for this user.*\r\n\r\n\r\n\r\n\r\n### `liblgraph_python_api.GraphDB`\r\n图数据库类。GraphDB 存储图的数据，包括标签、顶点、边和索引。由于 Python 中的垃圾回收是自动的，您需要在生命周期结束时使用 `GraphDB.Close()` 关闭数据库。在关闭数据库之前，确保已提交或中止每个使用数据库的事务。\n\n该文本块位于 TuGraph 嵌入模式 Python API 文档中，具体涉及 `liblgraph_python_api.Galaxy` 类的方法，主要功能为修改用户密码和设置用户角色。紧接着，该块后面是关于 `liblgraph_python_api.GraphDB` 类的介绍，描述图数据库的基本功能和管理。"
            },
            {
                "content": "- `SetUserRoles(self: liblgraph_python_api.Galaxy, name: str, roles: List[str]) → bool`: 为指定用户设置角色.  \r\n    `name`: 用户名称.  \r\n    `roles`: 该用户的角色列表.  \r\n    *Set the roles for the specified user. `name`: name of the user; `roles`: list of roles for this user.*\r\n\r\n\r\n\r\n\r\n### `liblgraph_python_api.GraphDB`\r\n图数据库类。GraphDB 存储图的数据，包括标签、顶点、边和索引。由于 Python 中的垃圾回收是自动的，您需要在生命周期结束时使用 `GraphDB.Close()` 关闭数据库。在关闭数据库之前，确保已提交或中止每个使用数据库的事务。  \r\n*The graph database class. A GraphDB stores the data about the graph, including labels, vertices, edges, and indexes. Since garbage collection in Python is automatic, you need to close the DB with `GraphDB.Close()` at the end of its lifetime. Make sure you have either committed or aborted every transaction that is using the DB before you close the DB.*\r\n\r\n- **方法 Methods**:\r\n  - `AddEdgeLabel(self: liblgraph_python_api.GraphDB, label_name: str, field_specs: List[liblgraph_python_api.FieldSpec], temporal_field: str = '', constraints: List[Tuple[str, str]] = []) → bool`: 添加边标签.\n\n该块内容位于 TuGraph 嵌入模式 Python API 文档中，具体介绍了 `liblgraph_python_api.Galaxy` 类的方法 `SetUserRoles`，该方法用于为指定用户设置角色。其后续内容则开始介绍 `liblgraph_python_api.GraphDB` 类，该类负责存储图的数据，包括标签、顶点、边和索引。"
            },
            {
                "content": "- **方法 Methods**:\r\n  - `AddEdgeLabel(self: liblgraph_python_api.GraphDB, label_name: str, field_specs: List[liblgraph_python_api.FieldSpec], temporal_field: str = '', constraints: List[Tuple[str, str]] = []) → bool`: 添加边标签.  \r\n    *Adds an edge label.*\r\n  \r\n  - `AddVertexIndex(self: liblgraph_python_api.GraphDB, label_name: str, field_name: str, is_unique: bool) → bool`: 添加索引.  \r\n    *Adds an index.*\r\n  \r\n  - `AddVertexLabel(self: liblgraph_python_api.GraphDB, label_name: str, field_specs: List[liblgraph_python_api.FieldSpec], primary_field: str) → bool`: 添加顶点标签.  \r\n    *Add a vertex label.*\r\n  \r\n  - `AlterEdgeLabelAddFields(self: liblgraph_python_api.GraphDB, label: str, add_fields: List[liblgraph_python_api.FieldSpec], default_values: List[liblgraph_python_api.FieldData]) → int`: 向边标签添加字段.  \r\n    `label`: 标签名称.  \r\n    `add_fields`: 新添加字段的 FieldSpec 列表.  \r\n    `default_values`: 新添加字段的默认值.\n\n该块内容位于 TuGraph 嵌入模式 Python API 文档的 `liblgraph_python_api.GraphDB` 类部分，主要描述该类中的方法，用于添加和修改图数据库中的边标签、顶点标签和索引。"
            },
            {
                "content": "- `AddVertexLabel(self: liblgraph_python_api.GraphDB, label_name: str, field_specs: List[liblgraph_python_api.FieldSpec], primary_field: str) → bool`: 添加顶点标签.  \r\n    *Add a vertex label.*\r\n  \r\n  - `AlterEdgeLabelAddFields(self: liblgraph_python_api.GraphDB, label: str, add_fields: List[liblgraph_python_api.FieldSpec], default_values: List[liblgraph_python_api.FieldData]) → int`: 向边标签添加字段.  \r\n    `label`: 标签名称.  \r\n    `add_fields`: 新添加字段的 FieldSpec 列表.  \r\n    `default_values`: 新添加字段的默认值.  \r\n    *Add fields to an edge label. `label`: name of the label; `add_fields`: list of FieldSpec for the newly added fields; `default_values`: default values of the added fields.*\r\n  \r\n  - `AlterEdgeLabelDelFields(self: liblgraph_python_api.GraphDB, label: str, del_fields: List[str]) → int`: 从边标签中删除字段.  \r\n    `label`: 标签名称.  \r\n    `del_fields`: 字段名称列表.  \r\n    *Delete fields from an edge label. `label`: name of the label; `del_fields`: list of field names.*\n\n该块内容位于 TuGraph 嵌入模式的 Python API 文档中，具体描述了 `GraphDB` 类中的方法，这些方法用于添加和修改顶点标签及边标签的字段。这部分接口为用户提供了管理图数据库中标签和字段结构的能力，相关方法包括添加顶点标签、向边标签添加字段以及删除边标签中的字段。"
            },
            {
                "content": "`default_values`: 新添加字段的默认值.  \r\n    *Add fields to an edge label. `label`: name of the label; `add_fields`: list of FieldSpec for the newly added fields; `default_values`: default values of the added fields.*\r\n  \r\n  - `AlterEdgeLabelDelFields(self: liblgraph_python_api.GraphDB, label: str, del_fields: List[str]) → int`: 从边标签中删除字段.  \r\n    `label`: 标签名称.  \r\n    `del_fields`: 字段名称列表.  \r\n    *Delete fields from an edge label. `label`: name of the label; `del_fields`: list of field names.*\r\n  \r\n  - `AlterEdgeLabelModFields(self: liblgraph_python_api.GraphDB, label: str, mod_fields: List[liblgraph_python_api.FieldSpec]) → int`: 修改边标签中的字段.  \r\n    `label`: 标签名称.  \r\n    `mod_fields`: 修改字段的 FieldSpec 列表.  \r\n    *Modify fields in an edge label. `label`: name of the label; `mod_fields`: list of FieldSpec for the modified fields.*\r\n  \r\n  - `AlterEdgeLabelModifyConstraints(self: liblgraph_python_api.GraphDB, label_name: str, constraints: List[Tuple[str, str]]) → bool`: 修改边约束.  \r\n    *Modify edge constraints.*\n\n该块内容位于 TuGraph 嵌入模式 Python API 文档的 \"liblgraph_python_api.GraphDB\" 类部分，主要描述了与边标签相关的操作，包括添加、删除和修改字段的功能。这些方法用于管理图数据库中的边标签结构，帮助用户在图数据库中高效地进行边的属性管理。"
            },
            {
                "content": "`label`: 标签名称.  \r\n    `mod_fields`: 修改字段的 FieldSpec 列表.  \r\n    *Modify fields in an edge label. `label`: name of the label; `mod_fields`: list of FieldSpec for the modified fields.*\r\n  \r\n  - `AlterEdgeLabelModifyConstraints(self: liblgraph_python_api.GraphDB, label_name: str, constraints: List[Tuple[str, str]]) → bool`: 修改边约束.  \r\n    *Modify edge constraints.*\r\n  \r\n  - `AlterVertexLabelAddFields(self: liblgraph_python_api.GraphDB, label: str, add_fields: List[liblgraph_python_api.FieldSpec], default_values: List[liblgraph_python_api.FieldData]) → int`: 向顶点标签添加字段.  \r\n    `label`: 标签名称.  \r\n    `add_fields`: 新添加字段的 FieldSpec 列表.  \r\n    `default_values`: 新添加字段的默认值.  \r\n    *Add fields to a vertex label. `label`: name of the label; `add_fields`: list of FieldSpec for the newly added fields; `default_values`: default values of the added fields.*\r\n  \r\n  - `AlterVertexLabelDelFields(self: liblgraph_python_api.GraphDB, label: str, del_fields: List[str]) → int`: 从顶点标签中删除字段.  \r\n    `label`: 标签名称.\n\n该块内容位于 TuGraph 嵌入模式 Python API 文档的 \"GraphDB\" 类部分，具体涵盖了与修改边标签和顶点标签相关的方法，包括添加、删除字段以及修改约束的功能。这些方法旨在帮助用户管理和操作图数据库中的标签及其字段，以便进行灵活的数据建模和结构调整。"
            },
            {
                "content": "`label`: 标签名称.  \r\n    `add_fields`: 新添加字段的 FieldSpec 列表.  \r\n    `default_values`: 新添加字段的默认值.  \r\n    *Add fields to a vertex label. `label`: name of the label; `add_fields`: list of FieldSpec for the newly added fields; `default_values`: default values of the added fields.*\r\n  \r\n  - `AlterVertexLabelDelFields(self: liblgraph_python_api.GraphDB, label: str, del_fields: List[str]) → int`: 从顶点标签中删除字段.  \r\n    `label`: 标签名称.  \r\n    `del_fields`: 字段名称列表.  \r\n    *Delete fields from a vertex label. `label`: name of the label; `del_fields`: list of field names.*\r\n  \r\n  - `AlterVertexLabelModFields(self: liblgraph_python_api.GraphDB, label: str, mod_fields: List[liblgraph_python_api.FieldSpec]) → int`: 修改顶点标签中的字段.  \r\n    `label`: 标签名称.  \r\n    `mod_fields`: 修改字段的 FieldSpec 列表.  \r\n    *Modify fields in a vertex label. `label`: name of the label; `mod_fields`: list of FieldSpec for the modified fields.*\r\n  \r\n  - `Close(self: liblgraph_python_api.GraphDB) → None`: 关闭数据库.  \r\n    *Closes the DB.*\n\n该碎片位于文档的 `liblgraph_python_api.GraphDB` 类部分，具体描述了与顶点标签相关的操作，包括添加、删除和修改字段的方法。这部分内容是对图数据库操作的具体实现和方法调用的详细说明，属于接口部分的关键组成。"
            },
            {
                "content": "- `AlterVertexLabelModFields(self: liblgraph_python_api.GraphDB, label: str, mod_fields: List[liblgraph_python_api.FieldSpec]) → int`: 修改顶点标签中的字段.  \r\n    `label`: 标签名称.  \r\n    `mod_fields`: 修改字段的 FieldSpec 列表.  \r\n    *Modify fields in a vertex label. `label`: name of the label; `mod_fields`: list of FieldSpec for the modified fields.*\r\n  \r\n  - `Close(self: liblgraph_python_api.GraphDB) → None`: 关闭数据库.  \r\n    *Closes the DB.*\r\n  \r\n  - `CreateReadTxn(self: liblgraph_python_api.GraphDB) → lgraph_api::Transaction`: 创建读取事务.  \r\n    *Create a read transaction.*\r\n  \r\n  - `CreateWriteTxn(self: liblgraph_python_api.GraphDB, optimistic: bool = False) → lgraph_api::Transaction`: 创建写事务.  \r\n    *Create a write transaction.*\r\n  \r\n  - `DeleteEdgeLabel(self: liblgraph_python_api.GraphDB, label_name: str) → int`: 删除边标签.  \r\n    *Deletes an edge label.*\r\n  \r\n  - `DeleteVertexIndex(self: liblgraph_python_api.GraphDB, label_name: str, field_name: str) → bool`: 删除指定索引.  \r\n    *Deletes the specified index.*\n\n本段落位于 TuGraph 嵌入模式 Python API 文档的 `liblgraph_python_api.GraphDB` 类部分，主要介绍该类中的方法，包括修改顶点标签字段、关闭数据库、创建读取和写入事务，以及删除边标签和顶点索引的方法。这些方法对用户在使用图数据库时进行操作和管理字段、事务以及标签至关重要。"
            },
            {
                "content": "*Create a read transaction.*\r\n  \r\n  - `CreateWriteTxn(self: liblgraph_python_api.GraphDB, optimistic: bool = False) → lgraph_api::Transaction`: 创建写事务.  \r\n    *Create a write transaction.*\r\n  \r\n  - `DeleteEdgeLabel(self: liblgraph_python_api.GraphDB, label_name: str) → int`: 删除边标签.  \r\n    *Deletes an edge label.*\r\n  \r\n  - `DeleteVertexIndex(self: liblgraph_python_api.GraphDB, label_name: str, field_name: str) → bool`: 删除指定索引.  \r\n    *Deletes the specified index.*\r\n  \r\n  - `DeleteVertexLabel(self: liblgraph_python_api.GraphDB, label_name: str) → int`: 删除顶点标签.  \r\n    *Deletes a vertex label.*\r\n  \r\n  - `DropAllData(self: liblgraph_python_api.GraphDB) → None`: 删除数据库中的所有数据. 所有顶点、边、标签和索引将被删除.  \r\n    *Drop all the data in this DB. All vertices, edges, labels, and indexes will be dropped.*\r\n  \r\n  - `DropAllVertex(self: liblgraph_python_api.GraphDB) → None`: 删除数据库中的所有顶点和边. 标签和索引（尽管由于顶点的删除，索引内容将被清除）将被保留.\n\n此段落位于 TuGraph 嵌入模式 Python API 文档中的 `liblgraph_python_api.GraphDB` 类部分，详细描述了该类中与事务管理和图数据库操作相关的方法，包括创建读写事务、删除边标签和顶点标签、以及清除数据库中的所有数据。"
            },
            {
                "content": "*Deletes the specified index.*\r\n  \r\n  - `DeleteVertexLabel(self: liblgraph_python_api.GraphDB, label_name: str) → int`: 删除顶点标签.  \r\n    *Deletes a vertex label.*\r\n  \r\n  - `DropAllData(self: liblgraph_python_api.GraphDB) → None`: 删除数据库中的所有数据. 所有顶点、边、标签和索引将被删除.  \r\n    *Drop all the data in this DB. All vertices, edges, labels, and indexes will be dropped.*\r\n  \r\n  - `DropAllVertex(self: liblgraph_python_api.GraphDB) → None`: 删除数据库中的所有顶点和边. 标签和索引（尽管由于顶点的删除，索引内容将被清除）将被保留.  \r\n    *Drops all the vertices and edges in this DB. Labels and indexes (though index contents will be cleared due to deletion of vertices) will be preserved.*\r\n  \r\n  - `EstimateNumVertices(self: liblgraph_python_api.GraphDB) → int`: 获取顶点数量的估算值. 如果有顶点删除，这可能不准确.  \r\n    *Gets an estimation of the number of vertices. This can be inaccurate if there were vertex removals.*\r\n  \r\n  - `Flush(self: liblgraph_python_api.GraphDB) → None`: 刷新写入的数据到磁盘.  \r\n    *Flushes written data into disk.*\n\n该块内容位于 TuGraph 嵌入模式 Python API 文档中的 `liblgraph_python_api.GraphDB` 类部分，主要描述与图数据库相关的删除和清理操作，包括删除顶点标签、删除所有数据、删除所有顶点以及估算顶点数量和刷新数据到磁盘的方法。这些方法是图数据库管理和维护的重要功能。"
            },
            {
                "content": "*Drops all the vertices and edges in this DB. Labels and indexes (though index contents will be cleared due to deletion of vertices) will be preserved.*\r\n  \r\n  - `EstimateNumVertices(self: liblgraph_python_api.GraphDB) → int`: 获取顶点数量的估算值. 如果有顶点删除，这可能不准确.  \r\n    *Gets an estimation of the number of vertices. This can be inaccurate if there were vertex removals.*\r\n  \r\n  - `Flush(self: liblgraph_python_api.GraphDB) → None`: 刷新写入的数据到磁盘.  \r\n    *Flushes written data into disk.*\r\n  \r\n  - `GetDescription(self: liblgraph_python_api.GraphDB) → str`: 获取图的描述.  \r\n    *Gets description of the graph.*\r\n  \r\n  - `GetMaxSize(self: liblgraph_python_api.GraphDB) → int`: 获取图的最大大小.  \r\n    *Gets maximum size of the graph.*\r\n  \r\n  - `IsVertexIndexed(self: liblgraph_python_api.GraphDB, label_name: str, field_name: str) → bool`: 判断指定字段是否已索引.  \r\n    *Tells whether the specified field is indexed.*\r\n\r\n\r\n\r\n\r\n### `liblgraph_python_api.InEdgeIterator`\r\n`InEdgeIterator` 可用于迭代目标顶点的所有入边。入边按 (dst, label, src, eid) 的顺序排序。\n\n该段落位于 TuGraph 嵌入模式 Python API 文档的 `liblgraph_python_api.GraphDB` 类部分，主要描述了与图数据库操作相关的方法，包括删除所有顶点和边、获取顶点数量估算、刷新数据到磁盘以及获取图的描述和最大大小等功能。在此之后，文档转向介绍 `liblgraph_python_api.InEdgeIterator` 类。"
            },
            {
                "content": "*Gets description of the graph.*\r\n  \r\n  - `GetMaxSize(self: liblgraph_python_api.GraphDB) → int`: 获取图的最大大小.  \r\n    *Gets maximum size of the graph.*\r\n  \r\n  - `IsVertexIndexed(self: liblgraph_python_api.GraphDB, label_name: str, field_name: str) → bool`: 判断指定字段是否已索引.  \r\n    *Tells whether the specified field is indexed.*\r\n\r\n\r\n\r\n\r\n### `liblgraph_python_api.InEdgeIterator`\r\n`InEdgeIterator` 可用于迭代目标顶点的所有入边。入边按 (dst, label, src, eid) 的顺序排序。  \r\n*InEdgeIterator can be used to iterate through all the incoming edges of the destination vertex. Incoming edges are sorted in (dst, label, src, eid) order.*\r\n\r\n- **方法 Methods**:\r\n  - `Delete(self: liblgraph_python_api.InEdgeIterator) → None`: 删除当前边。如果有下一个出边，迭代器将指向下一个出边.  \r\n    *Deletes the current edge. The iterator will point to the next out edge if there is any.*\r\n  \r\n  - `GetAllFields(self: liblgraph_python_api.InEdgeIterator) → dict`: 获取所有字段值并返回为字典.  \r\n    *Gets all the field values and returns as a dict.*\n\n该片段位于TuGraph嵌入模式Python API文档中的“GraphDB”类部分，具体描述了获取图的最大大小以及判断顶点字段是否已被索引的方法，随后引入了“InEdgeIterator”类，涉及如何迭代目标顶点的入边及其相关操作。"
            },
            {
                "content": "- **方法 Methods**:\r\n  - `Delete(self: liblgraph_python_api.InEdgeIterator) → None`: 删除当前边。如果有下一个出边，迭代器将指向下一个出边.  \r\n    *Deletes the current edge. The iterator will point to the next out edge if there is any.*\r\n  \r\n  - `GetAllFields(self: liblgraph_python_api.InEdgeIterator) → dict`: 获取所有字段值并返回为字典.  \r\n    *Gets all the field values and returns as a dict.*\r\n  \r\n  - `GetDst(self: liblgraph_python_api.InEdgeIterator) → int`: 返回目标顶点的 ID.  \r\n    *Returns the id of the destination vertex.*\r\n  \r\n  - `GetEdgeId(self: liblgraph_python_api.InEdgeIterator) → int`: 返回当前边的 ID. 边 ID 在相同的 (src, dst) 集合中是唯一的.  \r\n    *Returns the id of the current edge. Edge id is unique across the same (src, dst) set.*\r\n  \r\n  - `GetField(*args, **kwargs)`: 重载函数.\r\n    1. `GetField(self: liblgraph_python_api.InEdgeIterator, field_name: str) → object`: 获取指定字段名称的字段值.  \r\n       *Gets the field value of the field specified by field_name.*\r\n    2. `GetField(self: liblgraph_python_api.InEdgeIterator, field_id: int) → object`: 获取指定字段 ID 的字段值.\n\n该块内容描述的是`liblgraph_python_api.InEdgeIterator`类的方法，主要用于迭代目标顶点的所有入边，包括删除边、获取边属性和字段值等操作。这部分位于TuGraph嵌入模式Python API文档的接口部分，具体为图数据库操作的一个关键组件。"
            },
            {
                "content": "*Returns the id of the current edge. Edge id is unique across the same (src, dst) set.*\r\n  \r\n  - `GetField(*args, **kwargs)`: 重载函数.\r\n    1. `GetField(self: liblgraph_python_api.InEdgeIterator, field_name: str) → object`: 获取指定字段名称的字段值.  \r\n       *Gets the field value of the field specified by field_name.*\r\n    2. `GetField(self: liblgraph_python_api.InEdgeIterator, field_id: int) → object`: 获取指定字段 ID 的字段值.  \r\n       *Gets the field value of the field specified by field_id.*\r\n\r\n  - `GetFields(*args, **kwargs)`: 重载函数.\r\n    1. `GetFields(self: liblgraph_python_api.InEdgeIterator, field_names: List[str]) → list`: 获取指定字段名称的字段值.  \r\n       *Gets field values of the fields specified by field_names.*\r\n    2. `GetFields(self: liblgraph_python_api.InEdgeIterator, field_ids: List[int]) → list`: 获取指定字段 ID 的字段值.  \r\n       *Gets field values of the fields specified by field_ids.*\r\n\r\n  - `GetLabel(self: liblgraph_python_api.InEdgeIterator) → str`: 返回边标签的名称.  \r\n    *Returns the name of the edge label.*\n\n该块内容来自于 TuGraph 嵌入模式的 Python API 文档，具体涉及 `liblgraph_python_api.InEdgeIterator` 类的方法说明，主要描述如何获取当前入边的 ID、字段值、边标签名称等。这些方法用于迭代目标顶点的所有入边，便于用户操作和查询图数据库中的结构。"
            },
            {
                "content": "1. `GetFields(self: liblgraph_python_api.InEdgeIterator, field_names: List[str]) → list`: 获取指定字段名称的字段值.  \r\n       *Gets field values of the fields specified by field_names.*\r\n    2. `GetFields(self: liblgraph_python_api.InEdgeIterator, field_ids: List[int]) → list`: 获取指定字段 ID 的字段值.  \r\n       *Gets field values of the fields specified by field_ids.*\r\n\r\n  - `GetLabel(self: liblgraph_python_api.InEdgeIterator) → str`: 返回边标签的名称.  \r\n    *Returns the name of the edge label.*\r\n  \r\n  - `GetLabelId(self: liblgraph_python_api.InEdgeIterator) → int`: 返回边标签的 ID.  \r\n    *Returns the id of the edge label.*\r\n  \r\n  - `GetSrc(self: liblgraph_python_api.InEdgeIterator) → int`: 返回源顶点的 ID.  \r\n    *Returns the id of the source vertex.*\r\n  \r\n  - `GetUid(self: liblgraph_python_api.InEdgeIterator) → liblgraph_python_api.EdgeUid`: 返回边的 EdgeUid.  \r\n    *Returns the EdgeUid of the edge.*\r\n  \r\n  - `Goto(self: liblgraph_python_api.InEdgeIterator, euid: liblgraph_python_api.EdgeUid, nearest: bool) → bool`: 转到由 euid 指定的入边.\n\n该块内容位于 TuGraph 嵌入模式 Python API 文档中的 `liblgraph_python_api.InEdgeIterator` 类部分，主要描述了该类的方法，包括获取字段值、边标签信息和源顶点 ID 的相关功能。这些方法用于迭代和操作输入边的详细数据，是图数据库操作的重要组成部分。"
            },
            {
                "content": "*Returns the id of the edge label.*\r\n  \r\n  - `GetSrc(self: liblgraph_python_api.InEdgeIterator) → int`: 返回源顶点的 ID.  \r\n    *Returns the id of the source vertex.*\r\n  \r\n  - `GetUid(self: liblgraph_python_api.InEdgeIterator) → liblgraph_python_api.EdgeUid`: 返回边的 EdgeUid.  \r\n    *Returns the EdgeUid of the edge.*\r\n  \r\n  - `Goto(self: liblgraph_python_api.InEdgeIterator, euid: liblgraph_python_api.EdgeUid, nearest: bool) → bool`: 转到由 euid 指定的入边.  \r\n    *Goes to the in edge specified by euid.*\r\n  \r\n  - `IsValid(self: liblgraph_python_api.InEdgeIterator) → bool`: 告诉迭代器是否有效.  \r\n    *Tells whether the iterator is valid.*\r\n  \r\n  - `Next(self: liblgraph_python_api.InEdgeIterator) → bool`: 转到当前目标顶点的下一个入边。如果没有更多的入边，迭代器将变得无效.  \r\n    *Goes to the next in edge to current destination vertex. If there are no more in edges left, the iterator becomes invalid.*\r\n  \r\n  - `SetField(self: liblgraph_python_api.InEdgeIterator, field_name: str, field_value_object: object) → None`: 设置指定字段.  \r\n    *Sets the specified field.*\n\n该部分内容位于 TuGraph 嵌入模式 Python API 文档中的 `liblgraph_python_api.InEdgeIterator` 类的详细描述中，具体介绍了该类的方法，包括如何获取源顶点 ID、边的 EdgeUid、验证迭代器的有效性以及设置字段等操作。这些方法用于处理图数据库中与入边相关的迭代和数据操作。"
            },
            {
                "content": "*Tells whether the iterator is valid.*\r\n  \r\n  - `Next(self: liblgraph_python_api.InEdgeIterator) → bool`: 转到当前目标顶点的下一个入边。如果没有更多的入边，迭代器将变得无效.  \r\n    *Goes to the next in edge to current destination vertex. If there are no more in edges left, the iterator becomes invalid.*\r\n  \r\n  - `SetField(self: liblgraph_python_api.InEdgeIterator, field_name: str, field_value_object: object) → None`: 设置指定字段.  \r\n    *Sets the specified field.*\r\n  \r\n  - `SetFields(*args, **kwargs)`: 重载函数.\r\n    1. `SetFields(self: liblgraph_python_api.InEdgeIterator, field_names: List[str], field_value_strings: List[str]) → None`: 使用字符串表示的字段值设置指定字段.  \r\n       *Sets the fields specified by field_names with field values in string representation.*\r\n    2. `SetFields(self: liblgraph_python_api.InEdgeIterator, field_names: List[str], field_values: List[liblgraph_python_api.FieldData]) → None`: 使用新值设置指定字段.  \r\n       *Sets the fields specified by field_names with new values.*\n\n该内容位于 `liblgraph_python_api.InEdgeIterator` 类的描述部分，主要介绍用于迭代目标顶点的入边的相关方法，包括判断迭代器有效性和操作边的字段设置。"
            },
            {
                "content": "1. `SetFields(self: liblgraph_python_api.InEdgeIterator, field_names: List[str], field_value_strings: List[str]) → None`: 使用字符串表示的字段值设置指定字段.  \r\n       *Sets the fields specified by field_names with field values in string representation.*\r\n    2. `SetFields(self: liblgraph_python_api.InEdgeIterator, field_names: List[str], field_values: List[liblgraph_python_api.FieldData]) → None`: 使用新值设置指定字段.  \r\n       *Sets the fields specified by field_names with new values.*\r\n    3. `SetFields(self: liblgraph_python_api.InEdgeIterator, value_dict: dict) → None`: 设置字段值，如 value_dict 中所示.  \r\n       *Sets the fields with values as specified in value_dict.*\r\n    4. `SetFields(self: liblgraph_python_api.InEdgeIterator, field_ids: List[int], field_values: List[liblgraph_python_api.FieldData]) → None`: 使用字段值设置指定字段 ID.  \r\n       *Sets the fields specified by field_ids with field values.*\r\n\r\n  - `ToString(self: liblgraph_python_api.InEdgeIterator) → str`: 返回当前边的字符串表示.\n\n该段落位于 TuGraph 嵌入模式 Python API 文档中的 `liblgraph_python_api.InEdgeIterator` 类的详细介绍部分，主要描述了 `SetFields` 方法的重载版本，用于设置特定入边的字段值，以及 `ToString` 方法用于获取当前边的字符串表示。"
            },
            {
                "content": "3. `SetFields(self: liblgraph_python_api.InEdgeIterator, value_dict: dict) → None`: 设置字段值，如 value_dict 中所示.  \r\n       *Sets the fields with values as specified in value_dict.*\r\n    4. `SetFields(self: liblgraph_python_api.InEdgeIterator, field_ids: List[int], field_values: List[liblgraph_python_api.FieldData]) → None`: 使用字段值设置指定字段 ID.  \r\n       *Sets the fields specified by field_ids with field values.*\r\n\r\n  - `ToString(self: liblgraph_python_api.InEdgeIterator) → str`: 返回当前边的字符串表示.  \r\n    *Returns the string representation of the current edge.*\r\n\r\n\r\n\r\n\r\n### `liblgraph_python_api.IndexSpec`\r\n`IndexSpec` 是索引规范。  \r\n*Index specification.*\r\n\r\n- **属性 Properties**:\r\n  - `field`: 字段的名称.  \r\n    *Name of the field.*\r\n  \r\n  - `label`: 标签的名称.  \r\n    *Name of the label.*\r\n  \r\n  - `unique`: 指示索引值是否唯一.  \r\n    *Whether the indexed values are unique.*\r\n\r\n\r\n\r\n### `liblgraph_python_api.LGraphType`\r\n`LGraphType` 表示图数据库中的数据类型。  \r\n*Data types in the graph database.*\r\n\r\n- **成员 Members**:\r\n  - `NUL`: 表示空值.  \r\n    *NUL*\n\n该块内容属于文档中的 `liblgraph_python_api.InEdgeIterator` 类部分，主要描述了该类的 `SetFields` 方法的重载版本，以及 `ToString` 方法，用于设置入边的字段值和获取当前边的字符串表示。该部分明确阐述了如何操作入边迭代器，以便用户理解如何在图数据库中处理入边数据。"
            },
            {
                "content": "### `liblgraph_python_api.IndexSpec`\r\n`IndexSpec` 是索引规范。  \r\n*Index specification.*\r\n\r\n- **属性 Properties**:\r\n  - `field`: 字段的名称.  \r\n    *Name of the field.*\r\n  \r\n  - `label`: 标签的名称.  \r\n    *Name of the label.*\r\n  \r\n  - `unique`: 指示索引值是否唯一.  \r\n    *Whether the indexed values are unique.*\r\n\r\n\r\n\r\n### `liblgraph_python_api.LGraphType`\r\n`LGraphType` 表示图数据库中的数据类型。  \r\n*Data types in the graph database.*\r\n\r\n- **成员 Members**:\r\n  - `NUL`: 表示空值.  \r\n    *NUL*\r\n  \r\n  - `INTEGER`: 整数类型.  \r\n    *INTEGER*\r\n  \r\n  - `FLOAT`: 浮点数类型.  \r\n    *FLOAT*\r\n  \r\n  - `DOUBLE`: 双精度浮点数类型.  \r\n    *DOUBLE*\r\n  \r\n  - `BOOLEAN`: 布尔类型.  \r\n    *BOOLEAN*\r\n  \r\n  - `STRING`: 字符串类型.  \r\n    *STRING*\r\n  \r\n  - `NODE`: 节点类型.  \r\n    *NODE*\r\n  \r\n  - `RELATIONSHIP`: 关系类型.  \r\n    *RELATIONSHIP*\r\n  \r\n  - `PATH`: 路径类型.  \r\n    *PATH*\r\n  \r\n  - `LIST`: 列表类型.  \r\n    *LIST*\r\n  \r\n  - `MAP`: 映射类型.  \r\n    *MAP*\r\n  \r\n  - `ANY`: 任意类型.  \r\n    *ANY*\r\n\r\n- **属性 Property**:\r\n  - `name`: 数据类型的名称.  \r\n    *Name of the data type.*\n\n该内容块位于 TuGraph 嵌入模式 Python API 文档中，介绍了与图数据库相关的索引规范 (`IndexSpec`) 和数据类型 (`LGraphType`)。这些概念对于理解图数据库的结构和如何处理索引及其数据类型至关重要，帮助开发者有效地管理和查询图数据。"
            },
            {
                "content": "*INTEGER*\r\n  \r\n  - `FLOAT`: 浮点数类型.  \r\n    *FLOAT*\r\n  \r\n  - `DOUBLE`: 双精度浮点数类型.  \r\n    *DOUBLE*\r\n  \r\n  - `BOOLEAN`: 布尔类型.  \r\n    *BOOLEAN*\r\n  \r\n  - `STRING`: 字符串类型.  \r\n    *STRING*\r\n  \r\n  - `NODE`: 节点类型.  \r\n    *NODE*\r\n  \r\n  - `RELATIONSHIP`: 关系类型.  \r\n    *RELATIONSHIP*\r\n  \r\n  - `PATH`: 路径类型.  \r\n    *PATH*\r\n  \r\n  - `LIST`: 列表类型.  \r\n    *LIST*\r\n  \r\n  - `MAP`: 映射类型.  \r\n    *MAP*\r\n  \r\n  - `ANY`: 任意类型.  \r\n    *ANY*\r\n\r\n- **属性 Property**:\r\n  - `name`: 数据类型的名称.  \r\n    *Name of the data type.*\r\n\r\n\r\n\r\n### `liblgraph_python_api.OutEdgeIterator`\r\n`OutEdgeIterator` 用于遍历源顶点的所有出边.  \r\n*Iterates through all the outgoing edges of the source vertex.*\r\n\r\n- **方法 Methods**:\r\n  - `Delete(self: liblgraph_python_api.OutEdgeIterator) → None`  \r\n    删除当前边. 如果还有其他出边，迭代器将指向下一个出边.  \r\n    *Deletes the current edge; the iterator points to the next outgoing edge if available.*\r\n\r\n  - `GetAllFields(self: liblgraph_python_api.OutEdgeIterator) → dict`  \r\n    获取所有字段值并返回为字典.  \r\n    *Gets all field values and returns them as a dict.*\n\n该块内容位于 TuGraph 嵌入模式 Python API 文档中，属于 `liblgraph_python_api.FieldType` 类的描述部分，列出了图数据库中可用的数据类型（如 INTEGER、FLOAT 等）及其说明，并紧接着介绍 `liblgraph_python_api.OutEdgeIterator` 类，用于遍历源顶点的出边。"
            },
            {
                "content": "`OutEdgeIterator` 用于遍历源顶点的所有出边.  \r\n*Iterates through all the outgoing edges of the source vertex.*\r\n\r\n- **方法 Methods**:\r\n  - `Delete(self: liblgraph_python_api.OutEdgeIterator) → None`  \r\n    删除当前边. 如果还有其他出边，迭代器将指向下一个出边.  \r\n    *Deletes the current edge; the iterator points to the next outgoing edge if available.*\r\n\r\n  - `GetAllFields(self: liblgraph_python_api.OutEdgeIterator) → dict`  \r\n    获取所有字段值并返回为字典.  \r\n    *Gets all field values and returns them as a dict.*\r\n\r\n  - `GetDst(self: liblgraph_python_api.OutEdgeIterator) → int`  \r\n    返回目标顶点的 ID.  \r\n    *Returns the id of the destination vertex.*\r\n\r\n  - `GetEdgeId(self: liblgraph_python_api.OutEdgeIterator) → int`  \r\n    返回当前边的 ID. 边 ID 在相同 (src, dst) 集合中是唯一的.  \r\n    *Returns the id of the current edge; edge id is unique across the same (src, dst) set.*\r\n\r\n  - `GetField(*args, **kwargs)`  \r\n    **重载函数 Overloaded function**:  \r\n    1. `GetField(self: liblgraph_python_api.OutEdgeIterator, field_name: str) → object`  \r\n       获取指定字段名的字段值.\n\n该文档是关于 TuGraph 嵌入模式的 Python API 文档，其中详细介绍了图数据库的不同类和接口。该片段具体描述了 `OutEdgeIterator` 类的功能和方法，旨在遍历源顶点的出边，并提供了与出边操作相关的多种方法。"
            },
            {
                "content": "返回目标顶点的 ID.  \r\n    *Returns the id of the destination vertex.*\r\n\r\n  - `GetEdgeId(self: liblgraph_python_api.OutEdgeIterator) → int`  \r\n    返回当前边的 ID. 边 ID 在相同 (src, dst) 集合中是唯一的.  \r\n    *Returns the id of the current edge; edge id is unique across the same (src, dst) set.*\r\n\r\n  - `GetField(*args, **kwargs)`  \r\n    **重载函数 Overloaded function**:  \r\n    1. `GetField(self: liblgraph_python_api.OutEdgeIterator, field_name: str) → object`  \r\n       获取指定字段名的字段值.  \r\n       *Gets the field value specified by field_name.*\r\n    2. `GetField(self: liblgraph_python_api.OutEdgeIterator, field_id: int) → object`  \r\n       获取指定字段 ID 的字段值.  \r\n       *Gets the field value specified by field_id.*\r\n\r\n  - `GetFields(*args, **kwargs)`  \r\n    **重载函数 Overloaded function**:  \r\n    1. `GetFields(self: liblgraph_python_api.OutEdgeIterator, field_names: List[str]) → list`  \r\n       获取指定字段名的字段值.  \r\n       *Gets field values for the specified field_names.*\n\n该块内容位于文档的 `liblgraph_python_api.OutEdgeIterator` 类部分，描述了该类的方法，包括获取目标顶点 ID、当前边 ID，以及字段值的方法。这部分提供了有关如何迭代源顶点的出边及其相关字段信息的细节。"
            },
            {
                "content": "获取指定字段名的字段值.  \r\n       *Gets the field value specified by field_name.*\r\n    2. `GetField(self: liblgraph_python_api.OutEdgeIterator, field_id: int) → object`  \r\n       获取指定字段 ID 的字段值.  \r\n       *Gets the field value specified by field_id.*\r\n\r\n  - `GetFields(*args, **kwargs)`  \r\n    **重载函数 Overloaded function**:  \r\n    1. `GetFields(self: liblgraph_python_api.OutEdgeIterator, field_names: List[str]) → list`  \r\n       获取指定字段名的字段值.  \r\n       *Gets field values for the specified field_names.*\r\n    2. `GetFields(self: liblgraph_python_api.OutEdgeIterator, field_ids: List[int]) → list`  \r\n       获取指定字段 ID 的字段值.  \r\n       *Gets field values for the specified field_ids.*\r\n\r\n  - `GetLabel(self: liblgraph_python_api.OutEdgeIterator) → str`  \r\n    返回边的标签名称.  \r\n    *Returns the name of the edge label.*\r\n\r\n  - `GetLabelId(self: liblgraph_python_api.OutEdgeIterator) → int`  \r\n    返回边标签的 ID.  \r\n    *Returns the id of the edge label.*\r\n\r\n  - `GetSrc(self: liblgraph_python_api.OutEdgeIterator) → int`\n\n该内容位于 TuGraph 嵌入模式 Python API 文档中，具体属于 `liblgraph_python_api.OutEdgeIterator` 类的部分，描述了如何获取出边的字段值、边标签名称和边标签 ID。这部分内容为用户提供了操作出边所需的相关方法的详细信息。"
            },
            {
                "content": "2. `GetFields(self: liblgraph_python_api.OutEdgeIterator, field_ids: List[int]) → list`  \r\n       获取指定字段 ID 的字段值.  \r\n       *Gets field values for the specified field_ids.*\r\n\r\n  - `GetLabel(self: liblgraph_python_api.OutEdgeIterator) → str`  \r\n    返回边的标签名称.  \r\n    *Returns the name of the edge label.*\r\n\r\n  - `GetLabelId(self: liblgraph_python_api.OutEdgeIterator) → int`  \r\n    返回边标签的 ID.  \r\n    *Returns the id of the edge label.*\r\n\r\n  - `GetSrc(self: liblgraph_python_api.OutEdgeIterator) → int`  \r\n    返回源顶点的 ID.  \r\n    *Returns the id of the source vertex.*\r\n\r\n  - `GetUid(self: liblgraph_python_api.OutEdgeIterator) → liblgraph_python_api.EdgeUid`  \r\n    返回边的 EdgeUid.  \r\n    *Returns the EdgeUid of the edge.*\r\n\r\n  - `Goto(self: liblgraph_python_api.OutEdgeIterator, euid: liblgraph_python_api.EdgeUid, nearest: bool = False) → bool`  \r\n    跳转到指定的出边.  \r\n    *Goes to the outgoing edge specified by euid.*\r\n\r\n  - `IsValid(self: liblgraph_python_api.OutEdgeIterator) → bool`  \r\n    检查迭代器是否有效.\n\n该段落位于 TuGraph 嵌入模式 Python API 文档中的 `liblgraph_python_api.OutEdgeIterator` 类的部分，描述了该类的方法，包括获取出边的字段值、标签名称、标签 ID、源顶点 ID、边的 EdgeUid 以及迭代器的有效性检查。这些方法用于处理图数据库中源顶点的出边信息。"
            },
            {
                "content": "返回源顶点的 ID.  \r\n    *Returns the id of the source vertex.*\r\n\r\n  - `GetUid(self: liblgraph_python_api.OutEdgeIterator) → liblgraph_python_api.EdgeUid`  \r\n    返回边的 EdgeUid.  \r\n    *Returns the EdgeUid of the edge.*\r\n\r\n  - `Goto(self: liblgraph_python_api.OutEdgeIterator, euid: liblgraph_python_api.EdgeUid, nearest: bool = False) → bool`  \r\n    跳转到指定的出边.  \r\n    *Goes to the outgoing edge specified by euid.*\r\n\r\n  - `IsValid(self: liblgraph_python_api.OutEdgeIterator) → bool`  \r\n    检查迭代器是否有效.  \r\n    *Tells whether the iterator is valid.*\r\n\r\n  - `Next(self: liblgraph_python_api.OutEdgeIterator) → bool`  \r\n    跳转到当前源顶点的下一个出边. 如果没有更多的出边，迭代器变为无效.  \r\n    *Goes to the next outgoing edge from the current source vertex.*\r\n\r\n  - `SetField(self: liblgraph_python_api.OutEdgeIterator, field_name: str, field_value_object: object) → None`  \r\n    设置指定字段的值.  \r\n    *Sets the specified field.*\r\n\r\n  - `SetFields(*args, **kwargs)`  \r\n    **重载函数 Overloaded function**:\n\n该片段位于 TuGraph 嵌入模式 Python API 文档中的 `liblgraph_python_api.OutEdgeIterator` 类的具体方法描述部分，主要涉及用于遍历源顶点所有出边的相关方法，包括获取源顶点 ID、跳转到指定出边以及验证迭代器的有效性等功能。"
            },
            {
                "content": "检查迭代器是否有效.  \r\n    *Tells whether the iterator is valid.*\r\n\r\n  - `Next(self: liblgraph_python_api.OutEdgeIterator) → bool`  \r\n    跳转到当前源顶点的下一个出边. 如果没有更多的出边，迭代器变为无效.  \r\n    *Goes to the next outgoing edge from the current source vertex.*\r\n\r\n  - `SetField(self: liblgraph_python_api.OutEdgeIterator, field_name: str, field_value_object: object) → None`  \r\n    设置指定字段的值.  \r\n    *Sets the specified field.*\r\n\r\n  - `SetFields(*args, **kwargs)`  \r\n    **重载函数 Overloaded function**:  \r\n    1. `SetFields(self: liblgraph_python_api.OutEdgeIterator, field_names: List[str], field_value_strings: List[str]) → None`  \r\n       用字符串表示的字段值设置指定字段名.  \r\n       *Sets fields specified by field_names with field values in string representation.*\r\n    2. `SetFields(self: liblgraph_python_api.OutEdgeIterator, field_names: List[str], field_values: List[liblgraph_python_api.FieldData]) → None`  \r\n       用 FieldData 设置指定字段名的字段值.  \r\n       *Sets fields specified by field_names with field values in FieldData.*\n\n该块文本位于文档中关于 `liblgraph_python_api.OutEdgeIterator` 类的部分，主要描述了该类的几个方法，包括检查迭代器有效性、移动到下一个出边以及设置字段值的相关功能。这部分内容为用户提供了关于如何操作源顶点的出边的详细信息。"
            },
            {
                "content": "1. `SetFields(self: liblgraph_python_api.OutEdgeIterator, field_names: List[str], field_value_strings: List[str]) → None`  \r\n       用字符串表示的字段值设置指定字段名.  \r\n       *Sets fields specified by field_names with field values in string representation.*\r\n    2. `SetFields(self: liblgraph_python_api.OutEdgeIterator, field_names: List[str], field_values: List[liblgraph_python_api.FieldData]) → None`  \r\n       用 FieldData 设置指定字段名的字段值.  \r\n       *Sets fields specified by field_names with field values in FieldData.*\r\n    3. `SetFields(self: liblgraph_python_api.OutEdgeIterator, value_dict: dict) → None`  \r\n       根据字典设置字段值.  \r\n       *Sets field values as specified in value_dict.*\r\n    4. `SetFields(self: liblgraph_python_api.OutEdgeIterator, field_ids: List[int], field_values: List[liblgraph_python_api.FieldData]) → None`  \r\n       设置指定字段 ID 的字段值.  \r\n       *Sets fields specified by field_ids with field values.*\r\n\r\n  - `ToString(self: liblgraph_python_api.OutEdgeIterator) → str`  \r\n    返回当前边的字符串表示.\n\n该段落位于 TuGraph 嵌入模式 Python API 文档中，具体描述了 `OutEdgeIterator` 类的 `SetFields` 方法的重载版本，用于设置出边的字段值。同时，还包括 `ToString` 方法，用于返回当前边的字符串表示。这部分内容帮助开发者理解如何在迭代出边时修改字段信息。"
            },
            {
                "content": "3. `SetFields(self: liblgraph_python_api.OutEdgeIterator, value_dict: dict) → None`  \r\n       根据字典设置字段值.  \r\n       *Sets field values as specified in value_dict.*\r\n    4. `SetFields(self: liblgraph_python_api.OutEdgeIterator, field_ids: List[int], field_values: List[liblgraph_python_api.FieldData]) → None`  \r\n       设置指定字段 ID 的字段值.  \r\n       *Sets fields specified by field_ids with field values.*\r\n\r\n  - `ToString(self: liblgraph_python_api.OutEdgeIterator) → str`  \r\n    返回当前边的字符串表示.  \r\n    *Returns the string representation of the current edge.*\r\n\r\n\r\n\r\n### `liblgraph_python_api.PluginErrorCode`\r\n`PluginErrorCode` 表示插件的错误代码.  \r\n*ErrorCode of the plugin.*\r\n\r\n- **成员 Members**:\r\n  - `SUCCESS`  \r\n    表示成功.  \r\n    *Indicates success.*\r\n  \r\n  - `INPUT_ERR`  \r\n    表示输入错误.  \r\n    *Indicates input error.*\r\n  \r\n  - `INTERNAL_ERR`  \r\n    表示内部错误.  \r\n    *Indicates internal error.*\r\n  \r\n  - `SUCCESS_WITH_SIGNATURE`  \r\n    表示成功但有签名.  \r\n    *Indicates success with signature.*\r\n\r\n- **属性 Property**:\r\n  - `name`\n\n该段落位于 TuGraph 嵌入模式 Python API 文档中，具体描述了 `liblgraph_python_api.OutEdgeIterator` 类的几个方法，包括设置字段值的方法及其功能说明，接下来介绍了 `PluginErrorCode` 类及其错误代码的定义。"
            },
            {
                "content": "### `liblgraph_python_api.PluginErrorCode`\r\n`PluginErrorCode` 表示插件的错误代码.  \r\n*ErrorCode of the plugin.*\r\n\r\n- **成员 Members**:\r\n  - `SUCCESS`  \r\n    表示成功.  \r\n    *Indicates success.*\r\n  \r\n  - `INPUT_ERR`  \r\n    表示输入错误.  \r\n    *Indicates input error.*\r\n  \r\n  - `INTERNAL_ERR`  \r\n    表示内部错误.  \r\n    *Indicates internal error.*\r\n  \r\n  - `SUCCESS_WITH_SIGNATURE`  \r\n    表示成功但有签名.  \r\n    *Indicates success with signature.*\r\n\r\n- **属性 Property**:\r\n  - `name`  \r\n    获取错误代码的名称.  \r\n    *Gets the name of the error code.*\r\n\r\n\r\n\r\n### `liblgraph_python_api.Transaction`\r\n`Transaction` 代表一个图数据库事务.在嵌入模式下，所有操作都在事务中执行，因此享有事务的优势，如原子性和隔离性。您可以随时提交或中止事务，而无需担心其已产生的副作用。事务可以被提交或中止，之后它将被销毁并变得无效。在关闭相应的 GraphDB 之前，请确保您已经销毁了每个事务。事务还会跟踪已创建的迭代器，并在销毁期间释放所有迭代器。\n\n该段落介绍了 TuGraph 嵌入模式 Python API 中的 `PluginErrorCode` 和 `Transaction` 类。这些类分别用于表示插件的错误代码以及图数据库中的事务管理，涉及事务的创建、提交和中止等操作的优势和注意事项。"
            },
            {
                "content": "- `INTERNAL_ERR`  \r\n    表示内部错误.  \r\n    *Indicates internal error.*\r\n  \r\n  - `SUCCESS_WITH_SIGNATURE`  \r\n    表示成功但有签名.  \r\n    *Indicates success with signature.*\r\n\r\n- **属性 Property**:\r\n  - `name`  \r\n    获取错误代码的名称.  \r\n    *Gets the name of the error code.*\r\n\r\n\r\n\r\n### `liblgraph_python_api.Transaction`\r\n`Transaction` 代表一个图数据库事务.在嵌入模式下，所有操作都在事务中执行，因此享有事务的优势，如原子性和隔离性。您可以随时提交或中止事务，而无需担心其已产生的副作用。事务可以被提交或中止，之后它将被销毁并变得无效。在关闭相应的 GraphDB 之前，请确保您已经销毁了每个事务。事务还会跟踪已创建的迭代器，并在销毁期间释放所有迭代器。  \r\n*In embedded mode, all operations are performed in transactions, enjoying atomicity and isolation. You can commit or abort a transaction at any time without worrying about the side effects it has already made. Transactions can be either committed or aborted, after which they become invalid. Make sure you have destructed every transaction before closing the corresponding GraphDB. Transactions also track the created iterators and release all iterators during destruction.*\r\n\r\n- **方法 Methods**:\n\n该段落位于 TuGraph 嵌入模式 Python API 文档中的 \"liblgraph_python_api.PluginErrorCode\" 类的描述部分，具体介绍了插件错误代码的成员和属性。接着，文档转向 \"liblgraph_python_api.Transaction\" 类，描述了图数据库事务的功能特性及其方法。这一部分主要涵盖了事务的处理和事务所带来的益处。"
            },
            {
                "content": "*In embedded mode, all operations are performed in transactions, enjoying atomicity and isolation. You can commit or abort a transaction at any time without worrying about the side effects it has already made. Transactions can be either committed or aborted, after which they become invalid. Make sure you have destructed every transaction before closing the corresponding GraphDB. Transactions also track the created iterators and release all iterators during destruction.*\r\n\r\n- **方法 Methods**:\r\n  - `Abort(self: liblgraph_python_api.Transaction) → None`  \r\n    放弃当前事务.  \r\n    *Aborts the current transaction.*\r\n\r\n  - `AddEdge(*args, **kwargs)`  \r\n    添加边. 有多个重载版本:  \r\n    1. `AddEdge(self, src: int, dst: int, label_name: str, field_names: List[str], field_value_strings: List[str]) → liblgraph_python_api.EdgeUid`  \r\n       从 `src` 到 `dst` 添加边，返回新边的 ID。 添加边从 `src` 到 `dst`，使用指定的标签名、字段名和字段值（字符串格式）。返回新添加边的 ID。未在 `field_names` 中的字段被视为 null。\n\n该内容位于 TuGraph 嵌入模式 Python API 文档中的 \"liblgraph_python_api.Transaction\" 类描述部分，详细介绍了事务的特点以及相关方法，包括如何放弃和添加边的操作。"
            },
            {
                "content": "- **方法 Methods**:\r\n  - `Abort(self: liblgraph_python_api.Transaction) → None`  \r\n    放弃当前事务.  \r\n    *Aborts the current transaction.*\r\n\r\n  - `AddEdge(*args, **kwargs)`  \r\n    添加边. 有多个重载版本:  \r\n    1. `AddEdge(self, src: int, dst: int, label_name: str, field_names: List[str], field_value_strings: List[str]) → liblgraph_python_api.EdgeUid`  \r\n       从 `src` 到 `dst` 添加边，返回新边的 ID。 添加边从 `src` 到 `dst`，使用指定的标签名、字段名和字段值（字符串格式）。返回新添加边的 ID。未在 `field_names` 中的字段被视为 null。  \r\n       *Adds an edge from src to dst with the specified label name, field names, and field values in string format. Returns the id of the newly added edge. Fields that are not in field_names are considered null.*\r\n\r\n    2. `AddEdge(self, src: int, dst: int, label_name: str, field_names: List[str], field_values: List[liblgraph_python_api.FieldData]) → liblgraph_python_api.EdgeUid`  \r\n       添加边从 `src` 到 `dst`，使用指定的标签名、字段名和字段值。返回新添加边的 ID。未在 `field_names` 中的字段被视为 null。\n\n该块位于文档中关于`liblgraph_python_api.Transaction`类部分，详细描述了该类的方法，包括事务的放弃和添加边的操作，涉及重载版本的具体功能和参数说明。"
            },
            {
                "content": "*Adds an edge from src to dst with the specified label name, field names, and field values in string format. Returns the id of the newly added edge. Fields that are not in field_names are considered null.*\r\n\r\n    2. `AddEdge(self, src: int, dst: int, label_name: str, field_names: List[str], field_values: List[liblgraph_python_api.FieldData]) → liblgraph_python_api.EdgeUid`  \r\n       添加边从 `src` 到 `dst`，使用指定的标签名、字段名和字段值。返回新添加边的 ID。未在 `field_names` 中的字段被视为 null。  \r\n      *Adds an edge from src to dst with the specified label name, field names, and field values. Returns the id of the newly added edge. Fields that are not in field_names are considered null.*\r\n \r\n    3. `AddEdge(self, src: int, dst: int, label_id: int, field_ids: List[int], field_values: List[liblgraph_python_api.FieldData]) → liblgraph_python_api.EdgeUid`  \r\n       添加边从 `src` 到 `dst`，使用指定的标签 ID、字段 ID 和字段值。返回新添加边的 ID。未在 `field_names` 中的字段被视为 null。\n\n该块内容位于文档中关于 `liblgraph_python_api.Transaction` 类的方法部分，具体描述了 `AddEdge` 方法的不同重载版本，用于在图数据库中添加边，包括边的源顶点和目标顶点，以及相关的标签和字段信息。"
            },
            {
                "content": "*Adds an edge from src to dst with the specified label name, field names, and field values. Returns the id of the newly added edge. Fields that are not in field_names are considered null.*\r\n \r\n    3. `AddEdge(self, src: int, dst: int, label_id: int, field_ids: List[int], field_values: List[liblgraph_python_api.FieldData]) → liblgraph_python_api.EdgeUid`  \r\n       添加边从 `src` 到 `dst`，使用指定的标签 ID、字段 ID 和字段值。返回新添加边的 ID。未在 `field_names` 中的字段被视为 null。  \r\n      *Adds an edge from src to dst with the specified label id, field ids, and field values. Returns the id of the newly added edge. Fields that are not in field_names are considered null.*\r\n\r\n    4. `AddEdge(self, src: int, dst: int, label_name: str, value_dict: dict) → liblgraph_python_api.EdgeUid`  \r\n       添加边从 `src` 到 `dst`，使用指定的标签，并填充 `value_dict` 中给定的值。返回新添加边的 ID。未在 `value_dict` 中的字段被视为 null。\n\n该段落位于 TuGraph 嵌入模式的 Python API 文档中，具体描述了 `Transaction` 类中的 `AddEdge` 方法的不同重载版本，用于在图数据库中添加边。"
            },
            {
                "content": "添加边从 `src` 到 `dst`，使用指定的标签 ID、字段 ID 和字段值。返回新添加边的 ID。未在 `field_names` 中的字段被视为 null。  \r\n      *Adds an edge from src to dst with the specified label id, field ids, and field values. Returns the id of the newly added edge. Fields that are not in field_names are considered null.*\r\n\r\n    4. `AddEdge(self, src: int, dst: int, label_name: str, value_dict: dict) → liblgraph_python_api.EdgeUid`  \r\n       添加边从 `src` 到 `dst`，使用指定的标签，并填充 `value_dict` 中给定的值。返回新添加边的 ID。未在 `value_dict` 中的字段被视为 null。  \r\n      *Adds an edge from src to dst with the specified label, and fill it with the values given in value_dict. Returns the id of the newly added edge. Fields that are not in value_dict are considered null.*\r\n\r\n\r\n  - `AddVertex(*args, **kwargs)`  \r\n    添加顶点. 有多个重载版本:  \r\n    1. `AddVertex(self, label_name: str, field_names: List[str], field_value_strings: List[str]) → int`  \r\n       添加顶点，使用指定的标签名、字段名和字段值（字符串格式）。返回新添加顶点的 ID。未在 `field_names` 中的字段被视为 null。\n\n该部分位于 TuGraph 嵌入模式 Python API 文档中的“liblgraph_python_api.Transaction”类介绍中，具体讲解了添加边的方法及其重载版本，说明了如何通过指定的标签和字段值从源顶点到目标顶点添加边。"
            },
            {
                "content": "*Adds an edge from src to dst with the specified label, and fill it with the values given in value_dict. Returns the id of the newly added edge. Fields that are not in value_dict are considered null.*\r\n\r\n\r\n  - `AddVertex(*args, **kwargs)`  \r\n    添加顶点. 有多个重载版本:  \r\n    1. `AddVertex(self, label_name: str, field_names: List[str], field_value_strings: List[str]) → int`  \r\n       添加顶点，使用指定的标签名、字段名和字段值（字符串格式）。返回新添加顶点的 ID。未在 `field_names` 中的字段被视为 null。  \r\n      *Adds a vertex with the specified label name, field names, and field values in string format. Returns the id of the newly added vertex. Fields that are not in field_names are considered null.*\r\n\r\n    2. `AddVertex(self, label_name: str, field_names: List[str], field_values: List[liblgraph_python_api.FieldData]) → int`  \r\n       添加顶点，使用指定的标签名、字段名和字段值。返回新添加顶点的 ID。未在 `field_names` 中的字段被视为 null。\n\n该块内容位于文档的“liblgraph_python_api.Transaction”类下，详细介绍了如何在事务中添加边和顶点的不同重载版本，包括使用标签名、字段名和字段值创建边或顶点的示例。"
            },
            {
                "content": "添加顶点，使用指定的标签名、字段名和字段值（字符串格式）。返回新添加顶点的 ID。未在 `field_names` 中的字段被视为 null。  \r\n      *Adds a vertex with the specified label name, field names, and field values in string format. Returns the id of the newly added vertex. Fields that are not in field_names are considered null.*\r\n\r\n    2. `AddVertex(self, label_name: str, field_names: List[str], field_values: List[liblgraph_python_api.FieldData]) → int`  \r\n       添加顶点，使用指定的标签名、字段名和字段值。返回新添加顶点的 ID。未在 `field_names` 中的字段被视为 null。  \r\n      *Adds a vertex with the specified label name, field names, and field values. Returns the id of the newly added vertex. Fields that are not in field_names are considered null.*\r\n\r\n    3. `AddVertex(self, label_id: int, field_ids: List[int], field_values: List[liblgraph_python_api.FieldData]) → int`  \r\n       添加顶点，使用指定的标签 ID、字段 ID 和字段值。返回新添加顶点的 ID。未在 `field_ids` 中的字段被视为 null。\n\n该块内容位于 TuGraph 嵌入模式的 Python API 文档中，具体在描述添加顶点的方法部分。它详细说明了如何使用不同参数调用 `AddVertex` 方法以添加顶点，并返回新顶点的 ID，包括对未指定字段的处理情况。"
            },
            {
                "content": "添加顶点，使用指定的标签名、字段名和字段值。返回新添加顶点的 ID。未在 `field_names` 中的字段被视为 null。  \r\n      *Adds a vertex with the specified label name, field names, and field values. Returns the id of the newly added vertex. Fields that are not in field_names are considered null.*\r\n\r\n    3. `AddVertex(self, label_id: int, field_ids: List[int], field_values: List[liblgraph_python_api.FieldData]) → int`  \r\n       添加顶点，使用指定的标签 ID、字段 ID 和字段值。返回新添加顶点的 ID。未在 `field_ids` 中的字段被视为 null。  \r\n      *Adds a vertex with the specified label ids, field ids, and field values. Returns the id of the newly added vertex. Fields that are not in field_ids are considered null.*\r\n\r\n    4. `AddVertex(self, label_name: str, value_dict: dict) → int`  \r\n       添加顶点，使用指定的标签名，并根据 `value_dict` 中指定的值进行设置。返回新添加顶点的 ID。未在字典中指定的字段被视为 null。  \r\n      *Adds a vertex with the specified label name and set the value as specified in value_dict. Returns the id of the newly added vertex. Fields that are not specified in the dict are considered null.*\n\n该片段位于 TuGraph 嵌入模式的 Python API 文档中，具体描述了 `Transaction` 类中的 `AddVertex` 方法的不同重载版本。该方法用于添加顶点，并详细说明了如何根据标签名、标签 ID、字段名、字段值及值字典进行操作及返回新顶点的 ID。"
            },
            {
                "content": "4. `AddVertex(self, label_name: str, value_dict: dict) → int`  \r\n       添加顶点，使用指定的标签名，并根据 `value_dict` 中指定的值进行设置。返回新添加顶点的 ID。未在字典中指定的字段被视为 null。  \r\n      *Adds a vertex with the specified label name and set the value as specified in value_dict. Returns the id of the newly added vertex. Fields that are not specified in the dict are considered null.*\r\n\r\n\r\n  - `Commit(self: liblgraph_python_api.Transaction) → None`  \r\n    提交当前事务.  \r\n    *Commits the current transaction.*\r\n\r\n  - `DumpGraph(self: liblgraph_python_api.Transaction) → None`  \r\n    打印整个图的字符串表示.  \r\n    *Prints the string representation of the whole graph.*\r\n\r\n  - `GetEdgeFieldId(*args, **kwargs)`  \r\n    获取边字段 ID. 有多个重载版本:  \r\n    1. `GetEdgeFieldId(self, label_id: int, field_name: str) → int`  \r\n       获取与此 (label_id, field_name) 关联的边字段 ID。  \r\n      *Gets the edge field id associated with this (label_id, field_name).*\r\n    2. `GetEdgeFieldId(self, label_id: int, field_names: List[str]) → List[int]`  \r\n       获取多个字段的边字段 ID.\n\n该块内容位于 TuGraph 嵌入模式的 Python API 文档中，具体讨论了 `Transaction` 类的方法，重点介绍了如何添加顶点并提交事务，其中包括针对特定标签的顶点添加操作及其相关方法。"
            },
            {
                "content": "打印整个图的字符串表示.  \r\n    *Prints the string representation of the whole graph.*\r\n\r\n  - `GetEdgeFieldId(*args, **kwargs)`  \r\n    获取边字段 ID. 有多个重载版本:  \r\n    1. `GetEdgeFieldId(self, label_id: int, field_name: str) → int`  \r\n       获取与此 (label_id, field_name) 关联的边字段 ID。  \r\n      *Gets the edge field id associated with this (label_id, field_name).*\r\n    2. `GetEdgeFieldId(self, label_id: int, field_names: List[str]) → List[int]`  \r\n       获取多个字段的边字段 ID.\r\n       *Gets the edge field ids associated with this (label_id, field_names).*\r\n\r\n  - `GetEdgeLabelId(self: liblgraph_python_api.Transaction, label_name: str) → int`  \r\n    获取边标签 ID.  \r\n    *Gets the edge label ID associated with this label.*\r\n\r\n  - `GetEdgeSchema(self: liblgraph_python_api.Transaction, label_name: str) → List[liblgraph_python_api.FieldSpec]`  \r\n    获取边标签的模式说明.  \r\n    *Gets the schema specification of the edge label.*\r\n\r\n  - `GetInEdgeIterator(*args, **kwargs)`  \r\n    获取入边迭代器. 有多个重载版本:\n\n该内容位于 TuGraph 嵌入模式 Python API 文档的 `liblgraph_python_api.Transaction` 类部分，描述了与图数据库事务相关的方法，包括获取边字段 ID、边标签 ID、边标签模式说明以及获取入边迭代器的功能。这些方法允许用户在事务中操作和查询图数据。"
            },
            {
                "content": "*Gets the edge field ids associated with this (label_id, field_names).*\r\n\r\n  - `GetEdgeLabelId(self: liblgraph_python_api.Transaction, label_name: str) → int`  \r\n    获取边标签 ID.  \r\n    *Gets the edge label ID associated with this label.*\r\n\r\n  - `GetEdgeSchema(self: liblgraph_python_api.Transaction, label_name: str) → List[liblgraph_python_api.FieldSpec]`  \r\n    获取边标签的模式说明.  \r\n    *Gets the schema specification of the edge label.*\r\n\r\n  - `GetInEdgeIterator(*args, **kwargs)`  \r\n    获取入边迭代器. 有多个重载版本:  \r\n    1. `GetInEdgeIterator(self, euid: liblgraph_python_api.EdgeUid, nearest: bool) → lgraph_api::InEdgeIterator`  \r\n       获取指向具有 EdgeUid==euid 的入边的 InEdgeIterator。  \r\n      *Gets an InEdgeIterator pointing to the in-edge of vertex dst with EdgeUid==euid.*\r\n\r\n    2. `GetInEdgeIterator(self, src: int, dst: int, label_id: int) → lgraph_api::InEdgeIterator`  \r\n        获取从 src 到 dst 的 InEdgeIterator，标签由 label_id 指定。  \r\n      *Gets an InEdgeIterator from src to dst with the label specified by label_id.*\n\n该块内容位于 TuGraph 嵌入模式的 Python API 文档中，属于 `liblgraph_python_api.Transaction` 类的方法部分，主要介绍与边相关的操作，包括获取边标签 ID、边标签的模式说明以及获取入边迭代器的方法。这些方法用于处理边的定义和管理，适用于进行图数据库的边操作。"
            },
            {
                "content": "1. `GetInEdgeIterator(self, euid: liblgraph_python_api.EdgeUid, nearest: bool) → lgraph_api::InEdgeIterator`  \r\n       获取指向具有 EdgeUid==euid 的入边的 InEdgeIterator。  \r\n      *Gets an InEdgeIterator pointing to the in-edge of vertex dst with EdgeUid==euid.*\r\n\r\n    2. `GetInEdgeIterator(self, src: int, dst: int, label_id: int) → lgraph_api::InEdgeIterator`  \r\n        获取从 src 到 dst 的 InEdgeIterator，标签由 label_id 指定。  \r\n      *Gets an InEdgeIterator from src to dst with the label specified by label_id.*\r\n\r\n\r\n  - `GetNumEdgeLabels(self: liblgraph_python_api.Transaction) → int`  \r\n    获取边标签数量.  \r\n    *Gets the number of edge labels.*\r\n\r\n  - `GetNumVertexLabels(self: liblgraph_python_api.Transaction) → int`  \r\n    获取顶点标签数量.  \r\n    *Gets the number of vertex labels.*\r\n\r\n  - `GetOutEdgeIterator(*args, **kwargs)`  \r\n    获取指向源顶点的出边迭代器。  \r\n    *Gets an OutEdgeIterator pointing to the out-edge of vertex src.*\n\n该段落位于TuGraph嵌入模式Python API文档中，具体涉及`liblgraph_python_api.Transaction`类的方法，描述了如何获取与图中顶点相关的入边迭代器和出边迭代器以及获取边和顶点标签的数量。这些方法为开发者在图数据库中操作边和顶点提供了基本的功能接口。"
            },
            {
                "content": "*Gets an InEdgeIterator from src to dst with the label specified by label_id.*\r\n\r\n\r\n  - `GetNumEdgeLabels(self: liblgraph_python_api.Transaction) → int`  \r\n    获取边标签数量.  \r\n    *Gets the number of edge labels.*\r\n\r\n  - `GetNumVertexLabels(self: liblgraph_python_api.Transaction) → int`  \r\n    获取顶点标签数量.  \r\n    *Gets the number of vertex labels.*\r\n\r\n  - `GetOutEdgeIterator(*args, **kwargs)`  \r\n    获取指向源顶点的出边迭代器。  \r\n    *Gets an OutEdgeIterator pointing to the out-edge of vertex src.*\r\n    1. `GetOutEdgeIterator(self, euid: liblgraph_python_api.EdgeUid, nearest: bool) → lgraph_api::OutEdgeIterator`  \r\n       获取指向具有 EdgeUid==euid 的出边的 OutEdgeIterator。  \r\n      *Gets an OutEdgeIterator pointing to the out-edge of vertex src with EdgeUid==euid.*\r\n\r\n    2. `GetOutEdgeIterator(self, src: int, dst: int, label_id: int) → lgraph_api::OutEdgeIterator`  \r\n       获取从 src 到 dst 的 OutEdgeIterator，标签由 label_id 指定。  \r\n      *Gets an OutEdgeIterator from src to dst with the label specified by label_id.*\n\n该段落位于 TuGraph 嵌入模式 Python API 文档中的 `liblgraph_python_api.Transaction` 类部分，主要介绍与事务相关的方法，包括获取边标签数量、顶点标签数量以及出边迭代器的获取方式。这部分内容帮助用户了解如何在事务中处理出边，进而操作图数据库中的边数据。"
            },
            {
                "content": "获取指向具有 EdgeUid==euid 的出边的 OutEdgeIterator。  \r\n      *Gets an OutEdgeIterator pointing to the out-edge of vertex src with EdgeUid==euid.*\r\n\r\n    2. `GetOutEdgeIterator(self, src: int, dst: int, label_id: int) → lgraph_api::OutEdgeIterator`  \r\n       获取从 src 到 dst 的 OutEdgeIterator，标签由 label_id 指定。  \r\n      *Gets an OutEdgeIterator from src to dst with the label specified by label_id.*\r\n\r\n\r\n  - `GetVertexByUniqueIndex(*args, **kwargs)`  \r\n    通过唯一索引获取顶点迭代器. 有多个重载版本:  \r\n    1. `GetVertexByUniqueIndex(self, label_name: str, field_name: str, field_value_string: str) → lgraph_api::VertexIterator`  \r\n       *Gets vertex iterator by unique index. Throws exception if there is no such vertex. label_name specifies the name of the indexed label. field_name specifies the name of the indexed field. field_value_string specifies the string representation of the indexed field value.*\r\n    2. `GetVertexByUniqueIndex(self, label_name: str, field_name: str, field_value: object) → lgraph_api::VertexIterator`\n\n该内容位于 TuGraph 嵌入模式的 Python API 文档中，主要介绍了 `GraphDB` 类的一些方法，特别是与出边和唯一索引相关的迭代器。这部分详细描述了如何获取目标顶点的出边迭代器以及通过唯一索引获取顶点迭代器的重载函数。"
            },
            {
                "content": "*Gets vertex iterator by unique index. Throws exception if there is no such vertex. label_name specifies the name of the indexed label. field_name specifies the name of the indexed field. field_value_string specifies the string representation of the indexed field value.*\r\n    2. `GetVertexByUniqueIndex(self, label_name: str, field_name: str, field_value: object) → lgraph_api::VertexIterator`  \r\n       *Gets vertex iterator by unique index. Throws exception if there is no such vertex. label_name specifies the name of the indexed label. field_name specifies the name of the indexed field. field_value specifies the indexed field value.*\r\n    3. `GetVertexByUniqueIndex(self, label_id: int, field_id: int, field_value: liblgraph_python_api.FieldData) → lgraph_api::VertexIterator`\n\n该片段位于 TuGraph 嵌入模式 Python API 文档中，具体属于 `Transaction` 类的方法部分，主要描述如何通过唯一索引获取顶点迭代器，包括相关重载的函数签名和功能说明。这部分内容对于理解如何高效地检索特定顶点信息至关重要。"
            },
            {
                "content": "*Gets vertex iterator by unique index. Throws exception if there is no such vertex. label_name specifies the name of the indexed label. field_name specifies the name of the indexed field. field_value specifies the indexed field value.*\r\n    3. `GetVertexByUniqueIndex(self, label_id: int, field_id: int, field_value: liblgraph_python_api.FieldData) → lgraph_api::VertexIterator`  \r\n       *Gets vertex iterator by unique index. Throws exception if there is no such vertex. label_id specifies the id of the indexed label. field_id specifies the id of the indexed field. field_value is a FieldData specifying the indexed field value. *\r\n\r\n  - `GetVertexFieldId(self: liblgraph_python_api.Transaction, label_id: int, field_name: str) → int`  \r\n    获取与此 (label_id, field_name) 关联的顶点字段 ID。  \r\n    *Gets the vertex field ID associated with this (label_id, field_name).*\r\n\r\n  - `GetVertexFieldIds(self: liblgraph_python_api.Transaction, label_id: int, field_names: List[str]) → List[int]`\n\n该片段位于文档中关于 `liblgraph_python_api.Transaction` 类的部分，具体描述了如何通过唯一索引获取顶点迭代器的方法。在此之前的部分提到了多个重载版本的 `GetVertexByUniqueIndex` 方法，以及获取与特定标签 ID 和字段名称相关联的顶点字段 ID 的方法。这些信息与图数据库操作中的顶点检索和字段管理有关。"
            },
            {
                "content": "- `GetVertexFieldId(self: liblgraph_python_api.Transaction, label_id: int, field_name: str) → int`  \r\n    获取与此 (label_id, field_name) 关联的顶点字段 ID。  \r\n    *Gets the vertex field ID associated with this (label_id, field_name).*\r\n\r\n  - `GetVertexFieldIds(self: liblgraph_python_api.Transaction, label_id: int, field_names: List[str]) → List[int]`  \r\n    获取与此 (label_id, field_names) 关联的顶点字段 ID。  \r\n    *Gets the vertex field IDs associated with this (label_id, field_names).*\r\n\r\n  - `GetVertexIndexIterator(*args, **kwargs)`  \r\n    获取顶点索引迭代器. 有多个重载版本:  \r\n    1. `GetVertexIndexIterator(self, label_id: int, field_id: int, key_start: liblgraph_python_api.FieldData, key_end: liblgraph_python_api.FieldData) → lgraph_api::VertexIndexIterator`\n\n这段文字位于 TuGraph 嵌入模式 Python API 文档中的 `liblgraph_python_api.Transaction` 类的描述部分，主要介绍与顶点字段相关的方法，包括获取字段 ID 和顶点索引迭代器的功能。这些方法允许用户在图数据库的事务中方便地处理和检索顶点数据。"
            },
            {
                "content": "- `GetVertexFieldIds(self: liblgraph_python_api.Transaction, label_id: int, field_names: List[str]) → List[int]`  \r\n    获取与此 (label_id, field_names) 关联的顶点字段 ID。  \r\n    *Gets the vertex field IDs associated with this (label_id, field_names).*\r\n\r\n  - `GetVertexIndexIterator(*args, **kwargs)`  \r\n    获取顶点索引迭代器. 有多个重载版本:  \r\n    1. `GetVertexIndexIterator(self, label_id: int, field_id: int, key_start: liblgraph_python_api.FieldData, key_end: liblgraph_python_api.FieldData) → lgraph_api::VertexIndexIterator`  \r\n       Gets an VertexIndexIterator pointing to the indexed item which has index value [key_start, key_end]. key_start=key_end=v returns an iterator pointing to all vertexes that has field value v. label_id specifies the id of the indexed label. field_id specifies the id of the indexed field. key_start is a FieldData containing the minimum indexed value. key_end is a FieldData containing the maximum indexed value.\n\n该段落位于 TuGraph 嵌入模式 Python API 文档的 `liblgraph_python_api.Transaction` 类中，具体描述了与图数据库事务相关的方法，尤其是获取与特定标签 ID 和字段名称关联的顶点字段 ID 以及获取顶点索引迭代器的方法。这些方法支持对图数据的操作和查询，确保用户可以有效地管理和访问图中的数据。"
            },
            {
                "content": "Gets an VertexIndexIterator pointing to the indexed item which has index value [key_start, key_end]. key_start=key_end=v returns an iterator pointing to all vertexes that has field value v. label_id specifies the id of the indexed label. field_id specifies the id of the indexed field. key_start is a FieldData containing the minimum indexed value. key_end is a FieldData containing the maximum indexed value.\r\n    2. `GetVertexIndexIterator(self, label_id: int, field_id: int, value: liblgraph_python_api.FieldData) → lgraph_api::VertexIndexIterator`  \r\n       label_id specifies the id of the indexed label. field_id specifies the id of the indexed field. value is a FieldData containing the indexed value.\r\n\r\n  - `GetVertexIterator(*args, **kwargs)`  \r\n    获取顶点迭代器. 有多个重载版本:  \r\n    1. `GetVertexIterator(self: liblgraph_python_api.Transaction) → lgraph_api::VertexIterator`  \r\n       返回指向第一个顶点的迭代器.  \r\n    2. `GetVertexIterator(self: liblgraph_python_api.Transaction, vid: int) → lgraph_api::VertexIterator`\n\n该段落位于 TuGraph 嵌入模式 Python API 文档的 `liblgraph_python_api.Transaction` 类下，主要介绍与获取顶点索引迭代器相关的方法。它包含关于如何通过特定索引值和字段获取顶点的详细说明，并接着介绍获取顶点迭代器的方法重载。"
            },
            {
                "content": "label_id specifies the id of the indexed label. field_id specifies the id of the indexed field. value is a FieldData containing the indexed value.\r\n\r\n  - `GetVertexIterator(*args, **kwargs)`  \r\n    获取顶点迭代器. 有多个重载版本:  \r\n    1. `GetVertexIterator(self: liblgraph_python_api.Transaction) → lgraph_api::VertexIterator`  \r\n       返回指向第一个顶点的迭代器.  \r\n    2. `GetVertexIterator(self: liblgraph_python_api.Transaction, vid: int) → lgraph_api::VertexIterator`  \r\n       返回指向指定顶点的迭代器.  \r\n\r\n  - `GetVertexLabelId(self: liblgraph_python_api.Transaction, label_name: str) → int`  \r\n    获取顶点标签 ID.  \r\n    *Gets the vertex label ID associated with this label.*\r\n\r\n  - `GetVertexSchema(self: liblgraph_python_api.Transaction, label_name: str) → List[liblgraph_python_api.FieldSpec]`  \r\n    获取顶点标签的模式说明.  \r\n    *Gets the schema specification of the vertex label.*\r\n\r\n  - `IsReadOnly(self: liblgraph_python_api.Transaction) → bool`  \r\n    检查事务是否为只读.  \r\n    *Checks if the transaction is read-only.*\n\n该段落位于 TuGraph 嵌入模式 Python API 文档的 `liblgraph_python_api.Transaction` 类部分，主要介绍与顶点相关的操作方法，包括获取顶点迭代器、顶点标签 ID 以及顶点标签的模式说明等功能。这些方法使用户能够有效地管理和查询图数据库中的顶点数据。"
            },
            {
                "content": "- `GetVertexLabelId(self: liblgraph_python_api.Transaction, label_name: str) → int`  \r\n    获取顶点标签 ID.  \r\n    *Gets the vertex label ID associated with this label.*\r\n\r\n  - `GetVertexSchema(self: liblgraph_python_api.Transaction, label_name: str) → List[liblgraph_python_api.FieldSpec]`  \r\n    获取顶点标签的模式说明.  \r\n    *Gets the schema specification of the vertex label.*\r\n\r\n  - `IsReadOnly(self: liblgraph_python_api.Transaction) → bool`  \r\n    检查事务是否为只读.  \r\n    *Checks if the transaction is read-only.*\r\n\r\n  - `IsValid(self: liblgraph_python_api.Transaction) → bool`  \r\n    检查事务是否有效.  \r\n    *Checks if the transaction is valid.*\r\n\r\n  - `IsVertexIndexed(self: liblgraph_python_api.Transaction, label_name: str, field_name: str) → bool`  \r\n    检查指定字段是否被索引.  \r\n    *Tells whether the specified field is indexed.*\r\n\r\n  - `ListEdgeLabels(self: liblgraph_python_api.Transaction) → List[str]`  \r\n    获取所有边标签的列表.  \r\n    *Gets the list of all edge labels in the DB.*\n\n该段落位于文档的 `liblgraph_python_api.Transaction` 类下，主要描述与事务相关的方法，包括获取顶点标签 ID、顶点标签的模式说明、检查事务的只读状态和有效性，以及列出数据库中的所有边标签等功能。这些方法提供对图数据库操作的事务管理能力。"
            },
            {
                "content": "*Checks if the transaction is read-only.*\r\n\r\n  - `IsValid(self: liblgraph_python_api.Transaction) → bool`  \r\n    检查事务是否有效.  \r\n    *Checks if the transaction is valid.*\r\n\r\n  - `IsVertexIndexed(self: liblgraph_python_api.Transaction, label_name: str, field_name: str) → bool`  \r\n    检查指定字段是否被索引.  \r\n    *Tells whether the specified field is indexed.*\r\n\r\n  - `ListEdgeLabels(self: liblgraph_python_api.Transaction) → List[str]`  \r\n    获取所有边标签的列表.  \r\n    *Gets the list of all edge labels in the DB.*\r\n\r\n  - `ListVertexLabels(self: liblgraph_python_api.Transaction) → List[str]`  \r\n    获取所有顶点标签的列表.  \r\n    *Gets the list of all vertex labels in the DB.*\r\n\r\n  - `UpsertEdge(*args, **kwargs)`  \r\n    更新或插入边. 有多个重载版本:  \r\n    \r\n    1. `UpsertEdge(self: liblgraph_python_api.Transaction, src: int, dst: int, label_name: str, field_names: List[str], field_value_strings: List[str]) → bool`\n\n该块内容位于 TuGraph 嵌入模式的 Python API 文档中的 `liblgraph_python_api.Transaction` 类部分，主要描述了与事务相关的几个方法，包括检查事务状态、获取边和顶点标签列表以及更新或插入边的功能。这些方法确保在图数据库操作中管理事务的有效性和数据的完整性。"
            },
            {
                "content": "获取所有边标签的列表.  \r\n    *Gets the list of all edge labels in the DB.*\r\n\r\n  - `ListVertexLabels(self: liblgraph_python_api.Transaction) → List[str]`  \r\n    获取所有顶点标签的列表.  \r\n    *Gets the list of all vertex labels in the DB.*\r\n\r\n  - `UpsertEdge(*args, **kwargs)`  \r\n    更新或插入边. 有多个重载版本:  \r\n    \r\n    1. `UpsertEdge(self: liblgraph_python_api.Transaction, src: int, dst: int, label_name: str, field_names: List[str], field_value_strings: List[str]) → bool`  \r\n       从 `src` 到 `dst` 插入或更新一条边，使用指定的标签名、字段名和字段值（字符串格式）。如果已经存在 `src->dst` 边，则使用新值更新；否则创建新边。如果边被创建，返回 True；如果边被更新，返回 False。未在 `field_names` 中的字段被视为 null。  \r\n       *Upserts an edge from src to dst with the specified label name, field names, and field values in string format. If an src->dst edge already exists, it is updated with the new value. Otherwise, a new edge is created. Returns True if the edge is created, False if the edge is updated. Fields that are not in field_names are considered null.*\n\n该块内容位于 TuGraph 嵌入模式 Python API 文档的 `liblgraph_python_api.Transaction` 类中，描述了与图数据库相关的操作，包括获取所有边和顶点标签的列表，以及更新或插入边的详细方法。"
            },
            {
                "content": "从 `src` 到 `dst` 插入或更新一条边，使用指定的标签名、字段名和字段值（字符串格式）。如果已经存在 `src->dst` 边，则使用新值更新；否则创建新边。如果边被创建，返回 True；如果边被更新，返回 False。未在 `field_names` 中的字段被视为 null。  \r\n       *Upserts an edge from src to dst with the specified label name, field names, and field values in string format. If an src->dst edge already exists, it is updated with the new value. Otherwise, a new edge is created. Returns True if the edge is created, False if the edge is updated. Fields that are not in field_names are considered null.*\r\n\r\n    2. `UpsertEdge(self: liblgraph_python_api.Transaction, src: int, dst: int, label_id: int, field_ids: List[int], field_values: List[liblgraph_python_api.FieldData]) → bool`  \r\n       从 `src` 到 `dst` 插入或更新一条边，使用指定的标签 ID、字段 ID 和字段值。如果已经存在 `src->dst` 边，则使用新值更新；否则创建新边。如果边被创建，返回 True；如果边被更新，返回 False。未在 `field_names` 中的字段被视为 null。\n\n该段落位于 TuGraph 嵌入模式的 Python API 文档中的 `liblgraph_python_api.Transaction` 类的 `UpsertEdge` 方法部分，描述了如何通过指定的标签名或标签 ID 进行边的插入或更新操作，并简要说明了边的创建和更新逻辑。"
            },
            {
                "content": "2. `UpsertEdge(self: liblgraph_python_api.Transaction, src: int, dst: int, label_id: int, field_ids: List[int], field_values: List[liblgraph_python_api.FieldData]) → bool`  \r\n       从 `src` 到 `dst` 插入或更新一条边，使用指定的标签 ID、字段 ID 和字段值。如果已经存在 `src->dst` 边，则使用新值更新；否则创建新边。如果边被创建，返回 True；如果边被更新，返回 False。未在 `field_names` 中的字段被视为 null。  \r\n       *Upserts an edge from src to dst with the specified label id, field ids, and field values. If an src->dst edge already exists, it is updated with the new value. Otherwise, a new edge is created. Returns True if the edge is created, False if the edge is updated. Fields that are not in field_names are considered null.*\r\n\r\n    3. `UpsertEdge(self: liblgraph_python_api.Transaction, src: int, dst: int, label_name: str, field_names: List[str], field_values: List[liblgraph_python_api.FieldData]) → bool`  \r\n       从 `src` 到 `dst` 插入或更新一条边，使用指定的标签名、字段名和字段值。如果已经存在 `src->dst` 边，则使用新值更新；否则创建新边。如果边被创建，返回 True；如果边被更新，返回 False。未在 `field_names` 中的字段被视为 null。\n\n该块内容位于文档中关于 `Transaction` 类的方法部分，具体描述了 `UpsertEdge` 方法的重载版本。这个方法用于在图数据库中插入或更新边，提供了不同参数形式的使用方式，并强调了边的创建与更新返回值的逻辑。"
            },
            {
                "content": "3. `UpsertEdge(self: liblgraph_python_api.Transaction, src: int, dst: int, label_name: str, field_names: List[str], field_values: List[liblgraph_python_api.FieldData]) → bool`  \r\n       从 `src` 到 `dst` 插入或更新一条边，使用指定的标签名、字段名和字段值。如果已经存在 `src->dst` 边，则使用新值更新；否则创建新边。如果边被创建，返回 True；如果边被更新，返回 False。未在 `field_names` 中的字段被视为 null。  \r\n       *Upserts an edge from src to dst with the specified label name, field names, and field values. If an src->dst edge already exists, it is updated with the new value. Otherwise, a new edge is created. Returns True if the edge is created, False if the edge is updated. Fields that are not in field_names are considered null.*\r\n\r\n    4. `UpsertEdge(self: liblgraph_python_api.Transaction, src: int, dst: int, label_name: str, value_dict: dict) → bool`  \r\n       从 `src` 到 `dst` 插入或更新一条边，使用指定的标签，并填充 `value_dict` 中给定的值。如果已经存在 `src->dst` 边，则使用新值更新；否则创建新边。如果边被创建，返回 True；如果边被更新，返回 False。未在 `value_dict` 中的字段被视为 null。\n\n该块内容位于 TuGraph 嵌入模式 Python API 文档中的事务类 (`Transaction`) 部分，详细描述了如何通过 `UpsertEdge` 方法在事务中插入或更新边。这些方法允许用户根据指定的标签名和字段名更新已存在的边或创建新边，并提供相应的返回值指示操作结果。"
            },
            {
                "content": "4. `UpsertEdge(self: liblgraph_python_api.Transaction, src: int, dst: int, label_name: str, value_dict: dict) → bool`  \r\n       从 `src` 到 `dst` 插入或更新一条边，使用指定的标签，并填充 `value_dict` 中给定的值。如果已经存在 `src->dst` 边，则使用新值更新；否则创建新边。如果边被创建，返回 True；如果边被更新，返回 False。未在 `value_dict` 中的字段被视为 null。  \r\n       *Upserts an edge from src to dst with the specified label, and fill it with the values given in value_dict. If an src->dst edge already exists, it is updated with the new value. Otherwise, a new edge is created. Returns True if the edge is created, False if the edge is updated. Fields that are not in value_dict are considered null.*\r\n \r\n\r\n  - `VertexToString(self: liblgraph_python_api.Transaction, vid: int) → str`  \r\n    返回指定顶点的字符串表示.  \r\n    *Returns the string representation of the vertex specified by vid.*\r\n\r\n\r\n\r\n### `liblgraph_python_api.VertexIndexIterator`\r\n`VertexIndexIterator` 用于检索索引顶点的 ID。顶点 ID 按照 (index_value, vertex_id) 的升序排序。\n\n该块内容位于 TuGraph 嵌入模式 Python API 文档的交易部分，具体介绍了事务中的 `UpsertEdge` 方法，该方法用于插入或更新边的操作。紧接着是 `VertexToString` 方法的描述，并且最后提到了与索引相关的 `VertexIndexIterator`。"
            },
            {
                "content": "- `VertexToString(self: liblgraph_python_api.Transaction, vid: int) → str`  \r\n    返回指定顶点的字符串表示.  \r\n    *Returns the string representation of the vertex specified by vid.*\r\n\r\n\r\n\r\n### `liblgraph_python_api.VertexIndexIterator`\r\n`VertexIndexIterator` 用于检索索引顶点的 ID。顶点 ID 按照 (index_value, vertex_id) 的升序排序。\r\n *VertexIndexIterator can be used to retrieve the id of indexed vertices. Vertex ids are sorted in ascending order of (index_value, vertex_id).*\r\n- **方法 Methods**:\r\n  - `GetIndexValue(self: liblgraph_python_api.VertexIndexIterator) → liblgraph_python_api.FieldData`  \r\n    获取索引值。由于顶点 ID 按照 (index_value, vertex_id) 的顺序排序，调用 `Next()` 可能会改变当前的索引值。\r\n    *Gets the indexed value. Since vertex ids are sorted in (index_value, vertex_id) order, calling Next() may change the current indexed value.*\r\n\r\n  - `GetVid(self: liblgraph_python_api.VertexIndexIterator) → int`  \r\n    获取当前指向的顶点 ID。\r\n    *Gets the id of the vertex currently pointed to.*\r\n\r\n  - `IsValid(self: liblgraph_python_api.VertexIndexIterator) → bool`\n\n该块内容位于 TuGraph 嵌入模式 Python API 文档的后半部分，主要介绍 `liblgraph_python_api.Transaction` 类中的 `VertexToString` 方法以及 `liblgraph_python_api.VertexIndexIterator` 类的相关方法。这部分内容涉及如何获取顶点的字符串表示和检索索引顶点的ID，适用于处理图数据库中的顶点相关操作。"
            },
            {
                "content": "获取索引值。由于顶点 ID 按照 (index_value, vertex_id) 的顺序排序，调用 `Next()` 可能会改变当前的索引值。\r\n    *Gets the indexed value. Since vertex ids are sorted in (index_value, vertex_id) order, calling Next() may change the current indexed value.*\r\n\r\n  - `GetVid(self: liblgraph_python_api.VertexIndexIterator) → int`  \r\n    获取当前指向的顶点 ID。\r\n    *Gets the id of the vertex currently pointed to.*\r\n\r\n  - `IsValid(self: liblgraph_python_api.VertexIndexIterator) → bool`  \r\n    检查此迭代器是否有效。\r\n    *Tells whether this iterator is valid.*\r\n\r\n  - `Next(self: liblgraph_python_api.VertexIndexIterator) → bool`  \r\n    移动到下一个索引的顶点 ID。如果在指定的键范围内没有更多顶点，迭代器将变为无效。\r\n    *Goes to the next indexed vid. If there is no more vertex within the specified key range, the iterator becomes invalid.*\r\n\r\n\r\n\r\n\r\n### `liblgraph_python_api.VertexIterator`\r\n`VertexIterator` 可以用来检索一个顶点的信息，或扫描多个顶点。顶点按照其 ID 的升序排列。\r\n\r\n- **方法 Methods**:\r\n  - `Delete(self: liblgraph_python_api.VertexIterator) → Tuple[int, int]`  \r\n    删除当前顶点。如果有下一个顶点，迭代器将指向下一个顶点。\n\n该块内容位于 `liblgraph_python_api.VertexIndexIterator` 类的部分，描述了该类的方法，包括获取索引值、当前顶点 ID、迭代器有效性检查和移动到下一个索引顶点 ID 的功能。在此之前的部分介绍了 `VertexIndexIterator` 的用途和特点，而后面则是 `liblgraph_python_api.VertexIterator` 类的介绍，继续描述与顶点相关的操作。"
            },
            {
                "content": "- `Next(self: liblgraph_python_api.VertexIndexIterator) → bool`  \r\n    移动到下一个索引的顶点 ID。如果在指定的键范围内没有更多顶点，迭代器将变为无效。\r\n    *Goes to the next indexed vid. If there is no more vertex within the specified key range, the iterator becomes invalid.*\r\n\r\n\r\n\r\n\r\n### `liblgraph_python_api.VertexIterator`\r\n`VertexIterator` 可以用来检索一个顶点的信息，或扫描多个顶点。顶点按照其 ID 的升序排列。\r\n\r\n- **方法 Methods**:\r\n  - `Delete(self: liblgraph_python_api.VertexIterator) → Tuple[int, int]`  \r\n    删除当前顶点。如果有下一个顶点，迭代器将指向下一个顶点。  \r\n    *Deletes current vertex. The iterator will point to the next vertex if there is any.*\r\n\r\n  - `GetAllFields(self: liblgraph_python_api.VertexIterator) → dict`  \r\n    获取所有字段值，并以字典形式返回。  \r\n    *Gets all the field values and return as a dict.*\r\n\r\n  - `GetField(*args, **kwargs)`  \r\n    重载函数。\r\n\r\n    1. `GetField(self: liblgraph_python_api.VertexIterator, field_name: str) → object`  \r\n       获取指定字段名的字段值。  \r\n       *Gets the field value of the field specified by field_name.*\n\n该内容位于 TuGraph 嵌入模式 Python API 文档中的 `liblgraph_python_api.VertexIndexIterator` 部分，具体描述了 `Next` 方法，支持在索引中移动到下一个顶点 ID，并包括对 `liblgraph_python_api.VertexIterator` 的引入，后续介绍了该类的各个方法。"
            },
            {
                "content": "*Deletes current vertex. The iterator will point to the next vertex if there is any.*\r\n\r\n  - `GetAllFields(self: liblgraph_python_api.VertexIterator) → dict`  \r\n    获取所有字段值，并以字典形式返回。  \r\n    *Gets all the field values and return as a dict.*\r\n\r\n  - `GetField(*args, **kwargs)`  \r\n    重载函数。\r\n\r\n    1. `GetField(self: liblgraph_python_api.VertexIterator, field_name: str) → object`  \r\n       获取指定字段名的字段值。  \r\n       *Gets the field value of the field specified by field_name.*\r\n\r\n    2. `GetField(self: liblgraph_python_api.VertexIterator, field_id: int) → object`  \r\n       获取指定字段 ID 的字段值。  \r\n       *Gets the field value of the field specified by field_id.*\r\n\r\n  - `GetFields(*args, **kwargs)`  \r\n    重载函数。\r\n\r\n    1. `GetFields(self: liblgraph_python_api.VertexIterator, field_names: List[str]) → list`  \r\n       获取指定字段名的字段值。  \r\n       *Gets the field values of the fields specified by field_names.*\r\n\r\n    2. `GetFields(self: liblgraph_python_api.VertexIterator, field_ids: List[int]) → list`  \r\n       获取指定字段 ID 的字段值。\n\n该块内容位于文档的 `liblgraph_python_api.VertexIterator` 类的描述部分，详细介绍了用于操作图数据库中顶点的迭代器的方法，包括删除顶点、获取所有字段值及获取指定字段值的重载函数。这部分内容对于理解如何通过迭代器管理和查询顶点信息至关重要。"
            },
            {
                "content": "获取指定字段 ID 的字段值。  \r\n       *Gets the field value of the field specified by field_id.*\r\n\r\n  - `GetFields(*args, **kwargs)`  \r\n    重载函数。\r\n\r\n    1. `GetFields(self: liblgraph_python_api.VertexIterator, field_names: List[str]) → list`  \r\n       获取指定字段名的字段值。  \r\n       *Gets the field values of the fields specified by field_names.*\r\n\r\n    2. `GetFields(self: liblgraph_python_api.VertexIterator, field_ids: List[int]) → list`  \r\n       获取指定字段 ID 的字段值。  \r\n       *Gets the field values of the fields specified by field_ids.*\r\n\r\n  - `GetId(self: liblgraph_python_api.VertexIterator) → int`  \r\n    获取此顶点的整数 ID。GraphDB 为每个顶点分配一个整数 ID。  \r\n    *Gets the integer id of this vertex. GraphDB assigns an integer id for each vertex.*\r\n\r\n  - `GetInEdgeIterator(*args, **kwargs)`  \r\n    重载函数。\r\n\r\n    1. `GetInEdgeIterator(self: liblgraph_python_api.VertexIterator) → lgraph_api::InEdgeIterator`  \r\n       获取指向此顶点的第一个入边的 InEdgeIterator。  \r\n       *Gets an InEdgeIterator pointing to the first in-coming edge of this edge.*\n\n此块内容位于 `liblgraph_python_api.VertexIterator` 类的描述部分，主要介绍该类的获取字段值的方法，包括 `GetField` 和 `GetFields` 方法的重载，以及获取顶点 ID 和入边迭代器的方法。这些方法使用户能够检索和操作图数据库中顶点的属性和相关边的信息。"
            },
            {
                "content": "- `GetId(self: liblgraph_python_api.VertexIterator) → int`  \r\n    获取此顶点的整数 ID。GraphDB 为每个顶点分配一个整数 ID。  \r\n    *Gets the integer id of this vertex. GraphDB assigns an integer id for each vertex.*\r\n\r\n  - `GetInEdgeIterator(*args, **kwargs)`  \r\n    重载函数。\r\n\r\n    1. `GetInEdgeIterator(self: liblgraph_python_api.VertexIterator) → lgraph_api::InEdgeIterator`  \r\n       获取指向此顶点的第一个入边的 InEdgeIterator。  \r\n       *Gets an InEdgeIterator pointing to the first in-coming edge of this edge.*\r\n\r\n    2. `GetInEdgeIterator(self: liblgraph_python_api.VertexIterator, arg0: liblgraph_python_api.EdgeUid, arg1: bool) → lgraph_api::InEdgeIterator`  \r\n       获取 EdgeUid 为 euid 的此顶点的入边 InEdgeIterator。  \r\n       *Gets an InEdgeIterator pointing to the in-edge of this vertex with EdgeUid==euid.*\r\n\r\n  - `GetLabel(self: liblgraph_python_api.VertexIterator) → str`  \r\n    获取当前顶点的标签名。  \r\n    *Gets the label name of current vertex.*\r\n\r\n  - `GetLabelId(self: liblgraph_python_api.VertexIterator) → int`  \r\n    获取当前顶点的标签 ID。\n\n该段落位于 TuGraph 嵌入模式 Python API 文档的 `liblgraph_python_api.VertexIterator` 类中，详细介绍了用于检索和操作图数据库中顶点的相关方法，包括获取顶点 ID、入边迭代器、顶点标签及其 ID 的功能。"
            },
            {
                "content": "获取 EdgeUid 为 euid 的此顶点的入边 InEdgeIterator。  \r\n       *Gets an InEdgeIterator pointing to the in-edge of this vertex with EdgeUid==euid.*\r\n\r\n  - `GetLabel(self: liblgraph_python_api.VertexIterator) → str`  \r\n    获取当前顶点的标签名。  \r\n    *Gets the label name of current vertex.*\r\n\r\n  - `GetLabelId(self: liblgraph_python_api.VertexIterator) → int`  \r\n    获取当前顶点的标签 ID。  \r\n    *Gets the label id of current vertex.*\r\n\r\n  - `GetNumInEdges(self: liblgraph_python_api.VertexIterator, n_limit: int = 18446744073709551615) → Tuple[int, bool]`  \r\n    获取此顶点的入边数量。n_limit 指定扫描的最大边数。返回一个包含入边数量和一个布尔值的元组，指示是否超过限制。  \r\n    *Gets the number of in-coming edges of this vertex. n_limit specifies the maximum number of edges to scan. Returns a tuple containing the number of in-edges and a bool value indicating whether the limit is exceeded.*\r\n\r\n  - `GetNumOutEdges(self: liblgraph_python_api.VertexIterator, n_limit: int = 18446744073709551615) → Tuple[int, bool]`  \r\n    获取此顶点的出边数量。n_limit 指定扫描的最大顶点数。返回一个包含出边数量和一个布尔值的元组，指示是否超过限制。\n\n该块内容位于 TuGraph 嵌入模式 Python API 文档的 `liblgraph_python_api.VertexIterator` 类部分，详细描述了该类的方法，包括获取入边迭代器、获取当前顶点标签及其 ID，以及获取顶点的入边和出边数量的方法。这些方法用于操作和查询图数据库中的顶点信息。"
            },
            {
                "content": "获取此顶点的入边数量。n_limit 指定扫描的最大边数。返回一个包含入边数量和一个布尔值的元组，指示是否超过限制。  \r\n    *Gets the number of in-coming edges of this vertex. n_limit specifies the maximum number of edges to scan. Returns a tuple containing the number of in-edges and a bool value indicating whether the limit is exceeded.*\r\n\r\n  - `GetNumOutEdges(self: liblgraph_python_api.VertexIterator, n_limit: int = 18446744073709551615) → Tuple[int, bool]`  \r\n    获取此顶点的出边数量。n_limit 指定扫描的最大顶点数。返回一个包含出边数量和一个布尔值的元组，指示是否超过限制。  \r\n    *Gets the number of out edges of this vertex. n_limit specifies the maximum number of vids to scan. Returns a tuple containing the number of out-edges and a bool value indicating whether the limit is exceeded.*\r\n\r\n  - `GetOutEdgeIterator(*args, **kwargs)`  \r\n    重载函数。\r\n\r\n    1. `GetOutEdgeIterator(self: liblgraph_python_api.VertexIterator) → lgraph_api::OutEdgeIterator`  \r\n       获取指向此顶点的第一个出边的 OutEdgeIterator。  \r\n       *Gets an OutEdgeIterator pointing to the first out-going edge of this edge.*\n\n该块内容位于 TuGraph 嵌入模式 Python API 文档中的 `liblgraph_python_api.VertexIterator` 类部分，描述了获取顶点的入边和出边数量的方法，以及如何获取指向顶点的出边迭代器。这些方法提供了对图数据库中顶点关系的访问和操作功能。"
            },
            {
                "content": "*Gets the number of out edges of this vertex. n_limit specifies the maximum number of vids to scan. Returns a tuple containing the number of out-edges and a bool value indicating whether the limit is exceeded.*\r\n\r\n  - `GetOutEdgeIterator(*args, **kwargs)`  \r\n    重载函数。\r\n\r\n    1. `GetOutEdgeIterator(self: liblgraph_python_api.VertexIterator) → lgraph_api::OutEdgeIterator`  \r\n       获取指向此顶点的第一个出边的 OutEdgeIterator。  \r\n       *Gets an OutEdgeIterator pointing to the first out-going edge of this edge.*\r\n\r\n    2. `GetOutEdgeIterator(self: liblgraph_python_api.VertexIterator, arg0: liblgraph_python_api.EdgeUid, arg1: bool) → lgraph_api::OutEdgeIterator`  \r\n       获取 EdgeUid 为 euid 的此顶点的出边 OutEdgeIterator。  \r\n       *Gets an OutEdgeIterator pointing to the out-edge of this vertex with EdgeUid==euid.*\r\n\r\n  - `Goto(self: liblgraph_python_api.VertexIterator, vid: int, nearest: bool) → bool`  \r\n    转到指定 ID 的顶点。如果 nearest==true，转到 ID >= vid 的最近顶点。\n\n该块内容位于 TuGraph 嵌入模式的 Python API 文档中，具体位于 `liblgraph_python_api.VertexIterator` 类的部分，描述了该类方法用于获取和操作顶点的出边，包括获取出边数量和获取出边迭代器的方法。"
            },
            {
                "content": "2. `GetOutEdgeIterator(self: liblgraph_python_api.VertexIterator, arg0: liblgraph_python_api.EdgeUid, arg1: bool) → lgraph_api::OutEdgeIterator`  \r\n       获取 EdgeUid 为 euid 的此顶点的出边 OutEdgeIterator。  \r\n       *Gets an OutEdgeIterator pointing to the out-edge of this vertex with EdgeUid==euid.*\r\n\r\n  - `Goto(self: liblgraph_python_api.VertexIterator, vid: int, nearest: bool) → bool`  \r\n    转到指定 ID 的顶点。如果 nearest==true，转到 ID >= vid 的最近顶点。  \r\n    *Goes to the vertex specified by vid. If nearest==true, go to the nearest vertex with id>=vid.*\r\n    \r\n  - `IsValid(self: liblgraph_python_api.VertexIterator) → bool`  \r\n    检查当前迭代器是否有效。  \r\n    *Checks if the current iterator is valid.*\r\n\r\n  - `ListDstVids(self: liblgraph_python_api.VertexIterator, n_limit: int = 18446744073709551615) → Tuple[List[int], bool]`  \r\n    列出所有出边的目标顶点 ID。n_limit 指定返回的最大顶点数。返回一个包含顶点列表和一个布尔值的元组，指示是否超过限制。\n\n该片段位于 TuGraph 嵌入模式 Python API 文档中的 `liblgraph_python_api.VertexIterator` 类部分，描述了与顶点迭代器相关的方法，包括获取出边迭代器、转到指定顶点、检查迭代器有效性以及列出出边目标顶点 ID 的功能。这些方法是用于操作图中顶点和其出边的核心功能。"
            },
            {
                "content": "转到指定 ID 的顶点。如果 nearest==true，转到 ID >= vid 的最近顶点。  \r\n    *Goes to the vertex specified by vid. If nearest==true, go to the nearest vertex with id>=vid.*\r\n    \r\n  - `IsValid(self: liblgraph_python_api.VertexIterator) → bool`  \r\n    检查当前迭代器是否有效。  \r\n    *Checks if the current iterator is valid.*\r\n\r\n  - `ListDstVids(self: liblgraph_python_api.VertexIterator, n_limit: int = 18446744073709551615) → Tuple[List[int], bool]`  \r\n    列出所有出边的目标顶点 ID。n_limit 指定返回的最大顶点数。返回一个包含顶点列表和一个布尔值的元组，指示是否超过限制。  \r\n    *Lists all destination vids of the out edges. n_limit specifies the maximum number of vids to return. Returns a tuple containing a list of vids and a bool value indicating whether the limit is exceeded.*\r\n\r\n  - `ListSrcVids(self: liblgraph_python_api.VertexIterator, n_limit: int = 18446744073709551615) → Tuple[List[int], bool]`  \r\n    列出所有入边的源顶点 ID。n_limit 指定返回的最大源顶点数。返回一个包含顶点列表和一个布尔值的元组，指示是否超过限制。\n\n该段落位于 TuGraph 嵌入模式的 Python API 文档中的 `VertexIterator` 类部分，具体描述了与顶点迭代器相关的方法，主要用于检索和操作顶点信息，包括移动到指定 ID 的顶点、检查迭代器是否有效，以及列出出边和入边的目标源顶点 ID。"
            },
            {
                "content": "列出所有出边的目标顶点 ID。n_limit 指定返回的最大顶点数。返回一个包含顶点列表和一个布尔值的元组，指示是否超过限制。  \r\n    *Lists all destination vids of the out edges. n_limit specifies the maximum number of vids to return. Returns a tuple containing a list of vids and a bool value indicating whether the limit is exceeded.*\r\n\r\n  - `ListSrcVids(self: liblgraph_python_api.VertexIterator, n_limit: int = 18446744073709551615) → Tuple[List[int], bool]`  \r\n    列出所有入边的源顶点 ID。n_limit 指定返回的最大源顶点数。返回一个包含顶点列表和一个布尔值的元组，指示是否超过限制。  \r\n    *Lists all source vids of the in edges. n_limit specifies the maximum number of src vids to return. Returns a tuple containing a list of vids and a bool value indicating whether the limit is exceeded.*\r\n\r\n  - `Next(self: liblgraph_python_api.VertexIterator) → bool`  \r\n    转到 ID 大于 {current_vid} 的下一个顶点。  \r\n    *Goes to the next vertex with id>{current_vid}.*\r\n\r\n  - `SetField(self: liblgraph_python_api.VertexIterator, field_name: str, field_value_object: object) → None`  \r\n    设置指定字段的值。  \r\n    *Sets the specified field.*\n\n该块内容位于文档的 `liblgraph_python_api.VertexIterator` 类的部分，具体介绍了该类的几个方法，包括列出出边的目标顶点 ID 和入边的源顶点 ID，以及处理当前顶点的迭代和字段设置等功能。这些方法用于遍历图数据库中的顶点及其相关边的信息。"
            },
            {
                "content": "- `Next(self: liblgraph_python_api.VertexIterator) → bool`  \r\n    转到 ID 大于 {current_vid} 的下一个顶点。  \r\n    *Goes to the next vertex with id>{current_vid}.*\r\n\r\n  - `SetField(self: liblgraph_python_api.VertexIterator, field_name: str, field_value_object: object) → None`  \r\n    设置指定字段的值。  \r\n    *Sets the specified field.*\r\n\r\n  - `SetFields(*args, **kwargs)`  \r\n    重载函数。\r\n\r\n    1. `SetFields(self: liblgraph_python_api.VertexIterator, field_names: List[str], field_value_strings: List[str]) → None`  \r\n       使用字符串表示形式的字段值设置指定字段名的字段。  \r\n       *Sets the fields specified by field_names with field values in string representation.*\r\n\r\n    2. `SetFields(self: liblgraph_python_api.VertexIterator, field_names: List[str], field_values: List[liblgraph_python_api.FieldData]) → None`  \r\n       使用新值设置指定字段名的字段。  \r\n       *Sets the fields specified by field_names with new values.*\r\n\r\n    3. `SetFields(self: liblgraph_python_api.VertexIterator, value_dict: dict) → None`  \r\n       使用 value_dict 中指定的值设置字段。\n\n该段落位于 TuGraph 嵌入模式 Python API 文档中的 `liblgraph_python_api.VertexIterator` 类下，描述了与顶点迭代器相关的方法，包括移动到下一个顶点以及设置字段值的重载函数。这些方法对于遍历和修改图数据库中的顶点数据至关重要。"
            },
            {
                "content": "使用字符串表示形式的字段值设置指定字段名的字段。  \r\n       *Sets the fields specified by field_names with field values in string representation.*\r\n\r\n    2. `SetFields(self: liblgraph_python_api.VertexIterator, field_names: List[str], field_values: List[liblgraph_python_api.FieldData]) → None`  \r\n       使用新值设置指定字段名的字段。  \r\n       *Sets the fields specified by field_names with new values.*\r\n\r\n    3. `SetFields(self: liblgraph_python_api.VertexIterator, value_dict: dict) → None`  \r\n       使用 value_dict 中指定的值设置字段。  \r\n       *Sets the fields with values as specified in value_dict.*\r\n\r\n    4. `SetFields(self: liblgraph_python_api.VertexIterator, field_ids: List[int], field_values: List[liblgraph_python_api.FieldData]) → None`  \r\n       使用字段值设置指定字段 ID 的字段。  \r\n       *Sets the fields specified by field_ids with field values.*\r\n\r\n  - `ToString(self: liblgraph_python_api.VertexIterator) → str`  \r\n    返回当前顶点的字符串表示，包括属性和边。  \r\n    *Returns the string representation of current vertex, including properties and edges.*\n\n该代码块位于 TuGraph 嵌入模式的 Python API 文档中，具体介绍了 `VertexIterator` 类中 `SetFields` 方法的重载版本。这些方法用于设置顶点的字段值，并说明了如何通过字符串、字段数据和字典来更新这些值。该块还包括一个方法 `ToString`，用于返回当前顶点的字符串表示。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_79.md",
        "chunks": [
            {
                "content": "# TuGraph Analytics 文档地图\n\n## 介绍\n**TuGraph Analytics** (别名：GeaFlow) 是蚂蚁集团开源的流图计算引擎，支持万亿级图存储、图表混合处理、实时图计算、交互式图分析等核心能力，目前广泛应用于数仓加速、金融风控、知识图谱以及社交网络等场景。\n\nGeaFlow设计论文参考：[GeaFlow: A Graph Extended and Accelerated Dataflow System](https://dl.acm.org/doi/abs/10.1145/3589771)\n\n## 特性\n\n* 分布式实时图计算\n* 图表混合处理（SQL+GQL语言）\n* 统一流批图计算\n* 万亿级图原生存储\n* 交互式图分析\n* 高可用和Exactly Once语义\n* 高阶API算子开发\n* UDF/图算法/Connector插件支持\n* 一站式图研发平台\n* 云原生部署\n\n## 快速上手\n\n1. 准备Git、JDK8、Maven、Docker环境。\n2. 下载源码：`git clone https://github.com/TuGraph-family/tugraph-analytics`\n3. 项目构建：`mvn clean install -DskipTests`\n4. 测试任务：`./bin/gql_submit.sh --gql geaflow/geaflow-examples/gql/loop_detection.sql`\n3. 构建镜像：`./build.sh --all`\n4. 启动容器：`docker run -d --name geaflow-console -p 8888:8888 geaflow-console:0.1`\n\n## 开发手册\n\nGeaFlow支持DSL和API两套编程接口（DSL应用开发和API应用开发），您既可以通过GeaFlow提供的类SQL扩展语言SQL+ISO/GQL进行流图计算作业的开发，也可以通过GeaFlow的高阶API编程接口通过Java语言进行应用开发。\n\n## 实时能力\n\n相比传统的流式计算引擎比如Flink、Storm这些以表为模型的实时处理系统而言，GeaFlow以图为数据模型，在处理Join关系运算，尤其是复杂多跳的关系运算如3跳以上的Join、复杂环路查找上具备极大的性能优势。\n\n该文档介绍了TuGraph Analytics（GeaFlow）的核心功能、特性以及快速上手指南，旨在为开发者提供一个全面的流图计算引擎的开发与应用参考。包含了软件的设计背景、开发手册和实时计算能力的比较，适合对图计算有兴趣的用户和开发者查阅。"
            },
            {
                "content": "## 开发手册\n\nGeaFlow支持DSL和API两套编程接口（DSL应用开发和API应用开发），您既可以通过GeaFlow提供的类SQL扩展语言SQL+ISO/GQL进行流图计算作业的开发，也可以通过GeaFlow的高阶API编程接口通过Java语言进行应用开发。\n\n## 实时能力\n\n相比传统的流式计算引擎比如Flink、Storm这些以表为模型的实时处理系统而言，GeaFlow以图为数据模型，在处理Join关系运算，尤其是复杂多跳的关系运算如3跳以上的Join、复杂环路查找上具备极大的性能优势。\n\n基于GQL的关联分析Demo：\n\n```roomsql\n--GQL Style\nMatch (s:student)-[sc:selectCource]->(c:cource)\nReturn c.name\n;\n```\n\n基于SQL的关联分析Demo：\n\n```roomsql\n--SQL Style\nSELECT c.name\nFROM course c JOIN selectCourse sc \nON c.id = sc.targetId\nJOIN student s ON sc.srcId = s.id\n;\n```\n\n## 参与贡献\n非常感谢您参与到GeaFlow的贡献中来，无论是Bug反馈还是文档完善，或者是大的功能点贡献，我们都表示热烈的欢迎。\n\n**如果您对GeaFlow感兴趣，欢迎给我们项目一颗[ ⭐️ ](https://github.com/TuGraph-family/tugraph-analytics)。**\n\n## 联系我们\n您可以通过以下方式联系我们。\n\n微信公众号: TuGraph\n\n邮箱（商务沟通等其他问题）: tugraph@service.alipay.com\n\n电话：400-903-0809\n\n## 致谢\nGeaFlow开发过程中部分模块参考了一些业界优秀的开源项目，包括Apache Flink、Apache Spark以及Apache Calcite等, 这里表示特别的感谢。\n\n该文档介绍了TuGraph Analytics（GeaFlow）的特性和功能，主要围绕图计算的能力展开，特别是在实时计算、数据模型及编程接口方面。其中，\"开发手册\"部分详细说明了GeaFlow的DSL和API接口支持，\"实时能力\"部分则突出其在复杂关系运算中的性能优势，接下来的部分提到参与贡献的方式及联系信息，最后对参考的开源项目表示致谢。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_80.md",
        "chunks": [
            {
                "content": "# TuGraph\n\nTuGraph 现在在阿里云计算巢提供免费试用(https://computenest.console.aliyun.com/user/cn-hangzhou/serviceInstanceCreate?ServiceId=service-7b50ea3d20e643da95bf&ServiceVersion=1&isTrial=true)**。\n\n## 1. 简介\nTuGraph 是支持大数据容量、低延迟查找和快速图分析功能的高效图数据库。\n\n主要功能：\n\n- 标签属性图模型\n- 完善的 ACID 事务处理\n- 内置 34 图分析算法\n- 支持全文/主键/二级索引\n- OpenCypher 图查询语言\n- 基于 C++/Python 的存储过程\n\n性能和可扩展性：\n\n- LDBC SNB世界记录保持者 (2022/9/1)\n- 支持存储多达数十TB的数据\n- 每秒访问数百万个顶点\n- 快速批量导入\n\nTuGraph的文档在 https://tugraph-db.readthedocs.io/zh_CN/latest ，欢迎访问我们的官网 https://www.tugraph.org。\n\n## 2. 快速上手\n\n一个简单的方法是使用docker进行设置，可以在DockerHub(https://hub.docker.com/u/tugraph)中找到, 名称为`tugraph/tugraph-runtime-[os]:[tugraph version]`,\n例如， `tugraph/tugraph-runtime-centos7:3.3.0`。\n\n更多详情请参考 [快速上手文档](./docs/zh-CN/source/3.quick-start/1.preparation.md) 和 [业务开发指南](./docs/zh-CN/source/development_guide.md).\n\n## 3. 从源代码编译\n\n建议在Linux系统中构建TuGraph，Docker环境是个不错的选择。如果您想设置一个新的环境，请参考[Dockerfile](ci/images).\n\n以下是编译TuGraph的步骤：\n\n该文档介绍了TuGraph图数据库的主要功能、性能特点及其在阿里云计算巢的免费试用信息，随后提供了快速上手和从源代码编译的指导。此块主要涵盖了对TuGraph的简介和快速上手方法，包括使用Docker进行设置的建议。"
            },
            {
                "content": "## 2. 快速上手\n\n一个简单的方法是使用docker进行设置，可以在DockerHub(https://hub.docker.com/u/tugraph)中找到, 名称为`tugraph/tugraph-runtime-[os]:[tugraph version]`,\n例如， `tugraph/tugraph-runtime-centos7:3.3.0`。\n\n更多详情请参考 [快速上手文档](./docs/zh-CN/source/3.quick-start/1.preparation.md) 和 [业务开发指南](./docs/zh-CN/source/development_guide.md).\n\n## 3. 从源代码编译\n\n建议在Linux系统中构建TuGraph，Docker环境是个不错的选择。如果您想设置一个新的环境，请参考[Dockerfile](ci/images).\n\n以下是编译TuGraph的步骤：\n\n1. 如果需要web接口运行`deps/build_deps.sh`，不需要web接口则跳过此步骤\n2. 根据容器系统信息执行`cmake .. -DOURSYSTEM=centos`或者`cmake .. -DOURSYSTEM=ubuntu`\n3. `make`\n4. `make package` 或者 `cpack --config CPackConfig.cmake`\n\n示例：`tugraph/tugraph-compile-centos7`Docker环境\n\n```bash\n$ git clone --recursive https://github.com/TuGraph-family/tugraph-db.git\n$ cd tugraph-db\n$ deps/build_deps.sh\n$ mkdir build && cd build\n$ cmake .. -DOURSYSTEM=centos7\n$ make\n$ make package\n```\n\n## 4. 开发\n\n我们已为在DockerHub中编译准备了环境docker镜像，可以帮助开发人员轻松入门，名称为 `tugraph/tugraph-compile-[os]:[compile version]`, 例如， `tugraph/tugraph-compile-centos7:1.1.0`。\n\n该部分内容介绍了TuGraph的快速上手方法，包括如何使用Docker进行设置，以及从源代码编译的具体步骤。紧接着是关于开发环境的搭建和相关资源的描述。"
            },
            {
                "content": "示例：`tugraph/tugraph-compile-centos7`Docker环境\n\n```bash\n$ git clone --recursive https://github.com/TuGraph-family/tugraph-db.git\n$ cd tugraph-db\n$ deps/build_deps.sh\n$ mkdir build && cd build\n$ cmake .. -DOURSYSTEM=centos7\n$ make\n$ make package\n```\n\n## 4. 开发\n\n我们已为在DockerHub中编译准备了环境docker镜像，可以帮助开发人员轻松入门，名称为 `tugraph/tugraph-compile-[os]:[compile version]`, 例如， `tugraph/tugraph-compile-centos7:1.1.0`。\n\n可以访问 [技术规划](docs/zh-CN/source/12.contributor-manual/5.roadmap.md) 来了解TuGraph进展。\n\n如需贡献，请阅读 [如何贡献](docs/zh-CN/source/12.contributor-manual/1.contributing.md)。\n\n注意：如果您想贡献代码，需要签署[个人贡献者许可协议](docs/zh-CN/source/12.contributor-manual/3.individual-cla.md)或者[公司贡献者许可协议](docs/zh-CN/source/12.contributor-manual/4.corporate-cla.md)。\n\n## 5. 合作伙伴\n华中科技大学、大数据技术与系统国家地方联合工程研究中心、服务计算技术与系统教育部重点实验室、集群与网格计算湖北省重点实验室、复旦大学知识工场实验室、浙江大学数据库与大数据分析实验室、WhaleOps、OceanBase、SecretFlow隐语。\n\n## 6. 联系我们\n\n官网: https://tugraph.tech\n\nSlack (在线开发沟通):\n[TuGraph.slack](https://join.slack.com/t/tugraph/shared_invite/zt-1hha8nuli-bqdkwn~w4zH1vlk0QvqIfg)\n\n该chunk位于文档的第3部分“从源代码编译”之后，介绍了在Docker环境中编译TuGraph的示例步骤，并紧接着转向第4部分“开发”，讨论了DockerHub中的编译环境及贡献相关信息。"
            },
            {
                "content": "注意：如果您想贡献代码，需要签署[个人贡献者许可协议](docs/zh-CN/source/12.contributor-manual/3.individual-cla.md)或者[公司贡献者许可协议](docs/zh-CN/source/12.contributor-manual/4.corporate-cla.md)。\n\n## 5. 合作伙伴\n华中科技大学、大数据技术与系统国家地方联合工程研究中心、服务计算技术与系统教育部重点实验室、集群与网格计算湖北省重点实验室、复旦大学知识工场实验室、浙江大学数据库与大数据分析实验室、WhaleOps、OceanBase、SecretFlow隐语。\n\n## 6. 联系我们\n\n官网: https://tugraph.tech\n\nSlack (在线开发沟通):\n[TuGraph.slack](https://join.slack.com/t/tugraph/shared_invite/zt-1hha8nuli-bqdkwn~w4zH1vlk0QvqIfg)\n\n通过钉钉群、微信群、微信公众号、邮箱和电话联系我们:\n\n微信公众号: TuGraph\n\n邮箱（商务沟通等其他问题）: tugraph@service.alipay.com\n\n电话：400-903-0809\n\n该块内容位于文档的末尾，主要涉及对贡献者的要求以及有关合作伙伴的信息，最后提供了联系TuGraph的方式，包括官网、Slack和其他联系方式。这部分信息对潜在贡献者和合作伙伴尤为重要，有助于建立社区和支持。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_81.md",
        "chunks": [
            {
                "content": "# Cypher API\n\n> 此文档主要介绍了TuGraph-Cypher的详细使用说明。\n\n## 1.Operators\n\n### 1.1.Summary\n\nOperators支持进度一览：\n\n该文档概述了TuGraph-Cypher的使用说明，主要包括操作符、子句、函数以及与OpenCypher的区别。所提供的“Operators”部分为用户介绍了可用的运算符及其支持情况，旨在帮助用户有效地构建查询。"
            },
            {
                "content": "| 类别                                 | 支持                                                                                                        | 待支持                             |\n| ------------------------------------ | ----------------------------------------------------------------------------------------------------------- | ---------------------------------- |\n| General operators                    | `DISTINCT`, `.` for property access                                                                     | `[]` for dynamic property access |\n| Mathematical operators               | `+`, `-`, `*`, `/`, `%`, `^`                                                                    |                                    |\n| Comparison operators                 | `=`, `<>`, `<`, `>`, `<=`, `>=`, `IS NULL`, `IS NOT NULL`                                   |                                    |\n\n该块内容位于文档的第一部分“Operators”中，具体是“1.1.Summary”节，概述了查询语言中各种运算符的支持情况和待支持的功能，帮助用户快速了解目前可用的功能与限制。"
            },
            {
                "content": "| Mathematical operators               | `+`, `-`, `*`, `/`, `%`, `^`                                                                    |                                    |\n| Comparison operators                 | `=`, `<>`, `<`, `>`, `<=`, `>=`, `IS NULL`, `IS NOT NULL`                                   |                                    |\n| String-specific comparison operators | `STARTS WITH`, `ENDS WITH`, `CONTAINS`, `REGEXP`                                                    |                                    |\n| Boolean operators                    | `AND`, `OR`, `XOR`, `NOT`                                                                           |                                    |\n| String operators                     | `+` for concatenation                                                                                     |                                    |\n\n此块内容位于文档的“运算符”部分，具体属于“数学运算符”、“比较运算符”、“字符串特定比较运算符”、“布尔运算符”和“字符串运算符”的支持情况，详细列出了在TuGraph-Cypher中各类运算符的使用。"
            },
            {
                "content": "| Boolean operators                    | `AND`, `OR`, `XOR`, `NOT`                                                                           |                                    |\n| String operators                     | `+` for concatenation                                                                                     |                                    |\n| List operators                       | `+` for concatenation, `IN` to check existence of an element in a list, `[]` for accessing element(s) |                                    |\n表格内容描述: 此表格包含两个主要列：类别和支持/待支持。  \n- 第一行中，\"General operators\"类别支持使用`DISTINCT`和`.`来访问属性，而待支持的则是`[]`用于动态属性访问。  \n- 第二行中，\"Mathematical operators\"类别支持以下运算符：`+`, `-`, `*`, `/`, `%`, `^`，待支持项为空。  \n- 第三行中，\"Comparison operators\"类别支持的运算符包括`=`, `<>`, `<`, `>`, `<=`, `>=`, `IS NULL`, 和 `IS NOT NULL`，待支持项为空。  \n- 第四行中，\"String-specific comparison operators\"类别支持使用`STARTS WITH`, `ENDS WITH`, `CONTAINS`, `REGEXP`进行字符串特定的比较，待支持项为空。\n\n该块内容位于文档的\"Operators\"部分，具体是1.1小节\"Summary\"中的一部分，列出了各种运算符（包括布尔运算符、字符串运算符和列表运算符）的支持情况，提供了对运算符类别及其支持状态的概览。这部分帮助用户理解当前可用的操作符功能及其使用限制。"
            },
            {
                "content": "表格内容描述: 此表格包含两个主要列：类别和支持/待支持。  \n- 第一行中，\"General operators\"类别支持使用`DISTINCT`和`.`来访问属性，而待支持的则是`[]`用于动态属性访问。  \n- 第二行中，\"Mathematical operators\"类别支持以下运算符：`+`, `-`, `*`, `/`, `%`, `^`，待支持项为空。  \n- 第三行中，\"Comparison operators\"类别支持的运算符包括`=`, `<>`, `<`, `>`, `<=`, `>=`, `IS NULL`, 和 `IS NOT NULL`，待支持项为空。  \n- 第四行中，\"String-specific comparison operators\"类别支持使用`STARTS WITH`, `ENDS WITH`, `CONTAINS`, `REGEXP`进行字符串特定的比较，待支持项为空。  \n- 第五行中，\"Boolean operators\"类别支持`AND`, `OR`, `XOR`, 和 `NOT`，待支持项为空。  \n- 第六行中，\"String operators\"类别支持使用`+`进行字符串拼接，待支持项为空。  \n- 第七行中，\"List operators\"类别支持使用`+`进行拼接、`IN`检查元素是否存在于列表中，以及`[]`用于访问元素，待支持项为空。\n\n此段文字位于文档的第一部分，主要介绍了TuGraph-Cypher中操作符的支持情况，并通过表格详细列出不同类别的运算符（如一般运算符、数学运算符、比较运算符等）的已支持和待支持项。"
            },
            {
                "content": "总的来说，表格列出了各种运算符和操作符的支持情况，其中大部分运算符已有支持，只有一般运算符的动态属性访问功能尚待支持。\n\n### 1.2.General operators\n\n- ✓ Using the DISTINCT operator\n\n```\nMATCH (p:person) RETURN DISTINCT p.born\n```\n\n- ❏ Accessing properties of a nested literal map using the `.` operator\n\n```\nWITH {person: {name: 'Anne', age: 25}} AS p\nRETURN p.person.name\n```\n\n- ❏ Filtering on a dynamically-computed property key using the `[]` operator\n\n```\nCREATE (a:Restaurant {name: 'Hungry Jo', rating_hygiene: 10, rating_food: 7}),\n       (b:Restaurant {name: 'Buttercup Tea Rooms', rating_hygiene: 5, rating_food:6}),\n       (c1:Category {name: 'hygiene'}), (c2:Category {name: 'food'})\n```\n\n```\nMATCH (restaurant:Restaurant), (category:Category)\nWHERE restaurant[\"rating_\" + category.name] > 6\nRETURN DISTINCT restaurant.name\n```\n\n### 1.3.Mathematical operators\n\n- ✓ Using the exponentiation operator  `^`\n\n```\nWITH 2 AS number, 3 AS exponent\nRETURN number ^ exponent AS result\n```\n\n- ✓ Using the unary minus operator `-`\n\n```\nWITH -3 AS a, 4 AS b\nRETURN b - a AS result\n```\n\n此章节位于文档的第一部分，主要介绍了TuGraph-Cypher中的运算符支持情况，具体涵盖了一般运算符、数学运算符及其用法示例，帮助用户理解和使用Cypher查询语言。"
            },
            {
                "content": "```\nMATCH (restaurant:Restaurant), (category:Category)\nWHERE restaurant[\"rating_\" + category.name] > 6\nRETURN DISTINCT restaurant.name\n```\n\n### 1.3.Mathematical operators\n\n- ✓ Using the exponentiation operator  `^`\n\n```\nWITH 2 AS number, 3 AS exponent\nRETURN number ^ exponent AS result\n```\n\n- ✓ Using the unary minus operator `-`\n\n```\nWITH -3 AS a, 4 AS b\nRETURN b - a AS result\n```\n\n### 1.4.Comparison operators\n\n- ✓ Comparing two numbers\n\n```\nWITH 4 AS one, 3 AS two\nRETURN one > two AS result\n```\n \n### 1.5.String-specific comparison operators\n\n- ✓ Using STARTS WITH to filter names\n\n```\nWITH ['John', 'Mark', 'Jonathan', 'Bill'] AS somenames\nUNWIND somenames AS names\nWITH names AS candidate\nWHERE candidate STARTS WITH 'Jo'\nRETURN candidate\n```\n\n- ✓ Using REGEXP to filter names\n\n```\nWITH ['John', 'Mark', 'Jonathan', 'Bill'] AS somenames\nUNWIND somenames AS names\nWITH names AS candidate\nWHERE candidate REGEXP 'Jo.*n'\nRETURN candidate\n```\n\n### 1.6.Boolean operators\n\n- ✓ Using boolean operators to filter numbers\n\n该代码块位于文档的运算符部分，其中展示了使用动态属性访问和数学、比较、字符串特定比较及布尔操作符的示例。这些示例帮助用户理解如何在TuGraph-Cypher中执行基本的查询和逻辑操作。"
            },
            {
                "content": "- ✓ Using STARTS WITH to filter names\n\n```\nWITH ['John', 'Mark', 'Jonathan', 'Bill'] AS somenames\nUNWIND somenames AS names\nWITH names AS candidate\nWHERE candidate STARTS WITH 'Jo'\nRETURN candidate\n```\n\n- ✓ Using REGEXP to filter names\n\n```\nWITH ['John', 'Mark', 'Jonathan', 'Bill'] AS somenames\nUNWIND somenames AS names\nWITH names AS candidate\nWHERE candidate REGEXP 'Jo.*n'\nRETURN candidate\n```\n\n### 1.6.Boolean operators\n\n- ✓ Using boolean operators to filter numbers\n\n```\nWITH [2, 4, 7, 9, 12] AS numberlist\nUNWIND numberlist AS number\nWITH number\nWHERE number = 4 OR (number > 6 AND number < 10)\nRETURN number\n```\n\n### 1.7.String operators\n\nString operators comprise:\n\n- ✓ concatenating strings: `+`\n\n### 1.8.List operators\n\n- ✓ Concatenating two lists using +\n\n```\nRETURN [1,2,3,4,5]+[6,7] AS myList\n```\n\n- ✓ Using IN to check if a number is in a list\n\n```\nWITH [2, 3, 4, 5] AS numberlist\nUNWIND numberlist AS number\nWITH number\nWHERE number IN [2, 3, 8]\nRETURN number\n```\n\n此代码块位于文档的\"Operators\"部分，详细介绍了字符串特定比较运算符（如`STARTS WITH`和`REGEXP`）的使用示例，以及布尔运算符和列表运算符的相关操作，包括如何使用布尔运算符过滤数字、连接字符串和列表，以及检查数字是否在列表中的存在。"
            },
            {
                "content": "```\nWITH [2, 4, 7, 9, 12] AS numberlist\nUNWIND numberlist AS number\nWITH number\nWHERE number = 4 OR (number > 6 AND number < 10)\nRETURN number\n```\n\n### 1.7.String operators\n\nString operators comprise:\n\n- ✓ concatenating strings: `+`\n\n### 1.8.List operators\n\n- ✓ Concatenating two lists using +\n\n```\nRETURN [1,2,3,4,5]+[6,7] AS myList\n```\n\n- ✓ Using IN to check if a number is in a list\n\n```\nWITH [2, 3, 4, 5] AS numberlist\nUNWIND numberlist AS number\nWITH number\nWHERE number IN [2, 3, 8]\nRETURN number\n```\n\n- ✓ Accessing elements in a list using the [] operator\n\n```\nWITH ['Anne', 'John', 'Bill', 'Diane', 'Eve'] AS names\nRETURN names[1..3] AS result\n```\n\n## 2.Clauses\n\n### 2.1.Summary\n\nClauses支持进度一览：\n\n此代码块包含了关于列表操作符的示例，主要展示了如何利用`UNWIND`和`WHERE`子句对列表中的数字进行筛选，并且在接下来的部分继续介绍更多关于字符串操作和列表操作的内容。这一部分属于文档中关于运算符和子句的章节，说明了在TuGraph-Cypher中如何使用不同的运算符和语法结构。"
            },
            {
                "content": "| 类别                    | 语法                                  | 备注   |\n| ----------------------- | ------------------------------------- | ------ |\n| Reading clauses         | MATCH                                 | 支持   |\n|                         | OPTIONAL MATCH                        | 支持   |\n|                         | MANDATORY MATCH                       | 待支持 |\n| Projecting clauses      | RETURN … [AS]                        | 支持   |\n|                         | WITH … [AS]                          | 支持   |\n|                         | UNWIND … [AS]                        | 支持   |\n| Reading sub-clauses     | WHERE                                 | 支持   |\n|                         | ORDER BY [ASC[ENDING] / DESC[ENDING]] | 支持   |\n|                         | SKIP                                  | 支持   |\n|                         | LIMIT                                 | 支持   |\n| Writing clauses         | CREATE                                | 支持   |\n\n该内容位于文档的第二部分“2.Clauses”中，具体介绍了TuGraph-Cypher的各类语法结构的支持情况和备注，包括读取子句、投影子句、读取子子句和写入子句的详细信息，以及各自的支持状态。"
            },
            {
                "content": "|                         | UNWIND … [AS]                        | 支持   |\n| Reading sub-clauses     | WHERE                                 | 支持   |\n|                         | ORDER BY [ASC[ENDING] / DESC[ENDING]] | 支持   |\n|                         | SKIP                                  | 支持   |\n|                         | LIMIT                                 | 支持   |\n| Writing clauses         | CREATE                                | 支持   |\n|                         | DELETE                                | 支持   |\n|                         | DETACH DELETE                         | 支持   |\n|                         | SET                                   | 支持   |\n|                         | REMOVE                                | 支持   |\n| Reading/Writing clauses | MERGE                                 | 支持   |\n|                         | CALL […YIELD]                        | 支持   |\n| Set operations          | UNION                                 | 待支持 |\n\n该内容块位于文档的第2部分“Clauses”中的“2.1.Summary”小节，主要总结了TuGraph-Cypher的各类子句的支持情况，包括读取子句、投影子句、写入子句以及集合操作等，指明哪些子句已被支持，哪些尚待支持。"
            },
            {
                "content": "|                         | DETACH DELETE                         | 支持   |\n|                         | SET                                   | 支持   |\n|                         | REMOVE                                | 支持   |\n| Reading/Writing clauses | MERGE                                 | 支持   |\n|                         | CALL […YIELD]                        | 支持   |\n| Set operations          | UNION                                 | 待支持 |\n|                         | UNION ALL                             | 支持   |\n表格内容描述：\n该表格包含三列，分别为“类别”、“语法”和“备注”。\n\n该内容属于文档的“2. Clauses”部分，具体为“2.1. Summary”小节中的一部分，描述了支持的語法类别及其相关信息，包括阅读和写入子句、设置操作等，并指出哪些语法已被支持或待支持。"
            },
            {
                "content": "在“Reading clauses”类别中，支持的语法包括MATCH、OPTIONAL MATCH，而MANDATORY MATCH则待支持。 \n在“Projecting clauses”类别中，所有列出的语法（RETURN … [AS]、WITH … [AS]、UNWIND … [AS]）均为支持。 \n在“Reading sub-clauses”类别中，支持的语法包括WHERE、ORDER BY [ASC[ENDING] / DESC[ENDING]、SKIP和LIMIT。 \n在“Writing clauses”类别中，CREATE、DELETE、DETACH DELETE、SET和REMOVE均得到支持。 \n“Reading/Writing clauses”中的MERGE和CALL […YIELD]也分别被支持。 \n最后，在“Set operations”类别中，UNION待支持，而UNION ALL则被支持。\n\n整体上，该表格总结了不同类别的语法支持情况，指出了哪些语法已被支持，哪些则尚待支持。\n\n### 2.2.MATCH\n\n- Basic node finding\n\n  - ✓ Get all nodes\n\n  ```\n  MATCH (n)\n  RETURN n\n  ```\n\n  - ✓ Get all nodes with a label\n\n  ```\n  MATCH (movie:movie)\n  RETURN movie.title\n  ```\n\n  - ✓ Related nodes\n\n  ```\n  MATCH (person {name: 'Laurence Fishburne'})-[]-(movie)\n  RETURN movie.title\n  ```\n\n  - ✓ Match with labels\n\n  ```\n  MATCH (:person {name: 'Laurence Fishburne'})-[]-(movie:movie)\n  RETURN movie.title\n  ```\n\n- Relationship basics\n\n  - ✓ Outgoing relationships\n\n  ```\n  MATCH (:person {name: 'Laurence Fishburne'})-[]->(movie)\n  RETURN movie.title\n  ```\n\n该段落位于文档的第2部分“Clauses”中，具体总结了支持的语法和类别，包括“Reading clauses”、“Projecting clauses”、“Reading sub-clauses”、“Writing clauses”，以及“Reading/Writing clauses”和“Set operations”。它概述了各类别中已支持和待支持的语法情况，为后续对具体语法的详细说明（如MATCH的用法）提供了背景。"
            },
            {
                "content": "```\n  MATCH (n)\n  RETURN n\n  ```\n\n  - ✓ Get all nodes with a label\n\n  ```\n  MATCH (movie:movie)\n  RETURN movie.title\n  ```\n\n  - ✓ Related nodes\n\n  ```\n  MATCH (person {name: 'Laurence Fishburne'})-[]-(movie)\n  RETURN movie.title\n  ```\n\n  - ✓ Match with labels\n\n  ```\n  MATCH (:person {name: 'Laurence Fishburne'})-[]-(movie:movie)\n  RETURN movie.title\n  ```\n\n- Relationship basics\n\n  - ✓ Outgoing relationships\n\n  ```\n  MATCH (:person {name: 'Laurence Fishburne'})-[]->(movie)\n  RETURN movie.title\n  ```\n\n  - ✓ Directed relationships and variable\n\n  ```\n  MATCH (:person {name: 'Laurence Fishburne'})-[r]->(movie)\n  RETURN type(r)\n  ```\n\n  - ✓ Match on relationship type\n\n  ```\n  MATCH (matrix:movie {title: 'The Matrix'})<-[:acted_in]-(actor)\n  RETURN actor.name\n  ```\n\n  - ✓ Match on multiple relationship types\n\n  ```\n  MATCH (matrix {title: 'The Matrix'})<-[:acted_in|:directed]-(person)\n  RETURN person.name\n  ```\n\n  - ✓ Match on relationship type and use a variable\n\n该块内容位于文档第二部分“2.2.MATCH”中，主要介绍了通过MATCH语句查询图数据库中的节点和关系的基础用法，包括获取所有节点、带标签的节点、相关节点、出度关系、以及基于关系类型的匹配等。"
            },
            {
                "content": "- ✓ Directed relationships and variable\n\n  ```\n  MATCH (:person {name: 'Laurence Fishburne'})-[r]->(movie)\n  RETURN type(r)\n  ```\n\n  - ✓ Match on relationship type\n\n  ```\n  MATCH (matrix:movie {title: 'The Matrix'})<-[:acted_in]-(actor)\n  RETURN actor.name\n  ```\n\n  - ✓ Match on multiple relationship types\n\n  ```\n  MATCH (matrix {title: 'The Matrix'})<-[:acted_in|:directed]-(person)\n  RETURN person.name\n  ```\n\n  - ✓ Match on relationship type and use a variable\n\n  ```\n  MATCH (matrix {title: 'The Matrix'})<-[r:acted_in]-(actor)\n  RETURN r.role\n  ```\n- Relationships in depth\n\n  - ❏ Relationship types with uncommon characters\n\n  ```\n  MATCH (n {name: 'Rob Reiner'})-[r:`TYPE WITH SPACE`]->()\n  RETURN type(r)\n  ```\n\n  - ✓ Multiple relationships\n\n  ```\n  MATCH (laurence {name: 'Laurence Fishburne'})-[:acted_in]->(movie)<-[:directed]-(director)\n  RETURN movie.title, director.name\n  ```\n\n  - ✓ Variable-length relationships\n\n该块内容位于第二章“Clauses”中的“2.2.MATCH”部分，主要讨论了图数据库中如何通过MATCH语句进行节点和关系的匹配，具体包括有向关系、关系类型的匹配以及多种关系类型的匹配示例。它为用户提供了实际的Cypher查询示例，便于理解如何在图数据库中执行复杂的关系查询。"
            },
            {
                "content": "```\n  MATCH (matrix {title: 'The Matrix'})<-[r:acted_in]-(actor)\n  RETURN r.role\n  ```\n- Relationships in depth\n\n  - ❏ Relationship types with uncommon characters\n\n  ```\n  MATCH (n {name: 'Rob Reiner'})-[r:`TYPE WITH SPACE`]->()\n  RETURN type(r)\n  ```\n\n  - ✓ Multiple relationships\n\n  ```\n  MATCH (laurence {name: 'Laurence Fishburne'})-[:acted_in]->(movie)<-[:directed]-(director)\n  RETURN movie.title, director.name\n  ```\n\n  - ✓ Variable-length relationships\n\n  ```\n  MATCH (laurence {name: 'Laurence Fishburne'})-[:acted_in*1..3]-(movie:movie)\n  RETURN movie.title\n  ```\n\n  - ✓ Relationship variable in variable-length relationships\n\n  ```\n  MATCH p = (laurence {name: 'Laurence Fishburne'})-[:acted_in*2]-(co_actor)\n  RETURN p\n  ```\n\n  - ❏ Match with properties on a variable-length path\n\n  ```\n  MATCH p = (charlie:person)-[* {blocked:false}]-(martin:person)\n  WHERE charlie.name = 'Charlie Sheen' AND martin.name = 'Martin Sheen'\n  RETURN p\n  ```\n\n  - ✓ Zero-length paths\n\n该片段位于文档的\"2.2.MATCH\"章节中，主要介绍了匹配关系的深度特性，包括使用不同匹配模式的示例，例如与角色的关系、多重关系、可变长度关系及其属性匹配等。此部分展示了如何在Cypher查询中处理复杂的图形关系。"
            },
            {
                "content": "- ✓ Relationship variable in variable-length relationships\n\n  ```\n  MATCH p = (laurence {name: 'Laurence Fishburne'})-[:acted_in*2]-(co_actor)\n  RETURN p\n  ```\n\n  - ❏ Match with properties on a variable-length path\n\n  ```\n  MATCH p = (charlie:person)-[* {blocked:false}]-(martin:person)\n  WHERE charlie.name = 'Charlie Sheen' AND martin.name = 'Martin Sheen'\n  RETURN p\n  ```\n\n  - ✓ Zero-length paths\n\n  ```\n  MATCH (matrix:movie {title: 'The Matrix'})-[*0..1]-(x)\n  RETURN x\n  ```\n\n  - ✓ Named paths\n\n  ```\n  MATCH p = (michael {name: 'Michael Douglas'})-[]->() RETURN p\n  ```\n\n  - ✓ Matching on a bound relationship\n\n  ```\n  MATCH (a)-[r]->(b)\n  WHERE euid(r)=\"0_3937_0_0_0\"\n  RETURN a,b\n  ```\n\n- Shortest path\n\n  - ✓ Single shortest path\n\n  ```\n  MATCH (martin:person {name: 'Carrie-Anne Moss'}), (laurence:person {name: 'Laurence Fishburne'})\n  CALL algo.shortestPath(martin, laurence) YIELD nodeCount,totalCost,path RETURN nodeCount,totalCost,path\n  ```\n\n  - ✓ All shortest paths\n\n该内容位于文档的第二部分“2.2.MATCH”中，主要介绍了在Cypher查询中与匹配（MATCH）相关的不同用例和示例，包括可变长度关系的匹配、零长度路径、具名路径以及约束关系的匹配，并引入了最短路径的概念，具体展示了如何计算单条和所有最短路径的示例。"
            },
            {
                "content": "- ✓ Named paths\n\n  ```\n  MATCH p = (michael {name: 'Michael Douglas'})-[]->() RETURN p\n  ```\n\n  - ✓ Matching on a bound relationship\n\n  ```\n  MATCH (a)-[r]->(b)\n  WHERE euid(r)=\"0_3937_0_0_0\"\n  RETURN a,b\n  ```\n\n- Shortest path\n\n  - ✓ Single shortest path\n\n  ```\n  MATCH (martin:person {name: 'Carrie-Anne Moss'}), (laurence:person {name: 'Laurence Fishburne'})\n  CALL algo.shortestPath(martin, laurence) YIELD nodeCount,totalCost,path RETURN nodeCount,totalCost,path\n  ```\n\n  - ✓ All shortest paths\n\n  ```\n  MATCH (martin:person {name: 'Carrie-Anne Moss'}), (laurence:person {name: 'Laurence Fishburne'}) WITH martin, laurence\n  CALL algo.allShortestPaths(martin, laurence) YIELD nodeIds,relationshipIds,cost RETURN nodeIds,relationshipIds,cost\n  ```\n- Get node or relationship by id\n\n  - ✓ Node by id\n\n  ```\n  MATCH (n)\n  WHERE id(n)= 0\n  RETURN n\n  ```\n\n  - ✓ Relationship by id\n\n  ```\n  MATCH ()-[r]->()\n  WHERE euid(r) = \"0_3937_0_0_0\"\n  RETURN r\n  ```\n\n  - ✓ Multiple nodes by id\n\n该内容位于文档的“2.2.MATCH”部分，主要介绍了如何进行图数据库中节点和关系的匹配，包括命名路径、最短路径查询及通过ID获取节点或关系的方法。这部分为用户提供了多种匹配与查询的示例，以帮助他们在使用TuGraph-Cypher时进行有效的数据操作。"
            },
            {
                "content": "- ✓ All shortest paths\n\n  ```\n  MATCH (martin:person {name: 'Carrie-Anne Moss'}), (laurence:person {name: 'Laurence Fishburne'}) WITH martin, laurence\n  CALL algo.allShortestPaths(martin, laurence) YIELD nodeIds,relationshipIds,cost RETURN nodeIds,relationshipIds,cost\n  ```\n- Get node or relationship by id\n\n  - ✓ Node by id\n\n  ```\n  MATCH (n)\n  WHERE id(n)= 0\n  RETURN n\n  ```\n\n  - ✓ Relationship by id\n\n  ```\n  MATCH ()-[r]->()\n  WHERE euid(r) = \"0_3937_0_0_0\"\n  RETURN r\n  ```\n\n  - ✓ Multiple nodes by id\n\n  ```\n  MATCH (n)\n  WHERE id(n) IN [0, 3, 5]\n  RETURN n\n  ```\n\n### 2.3.RETURN\n\n- ✓ Return nodes\n\n```\nMATCH (n {name: 'Carrie-Anne Moss'}) RETURN n\n```\n\n- ✓ Return relationships\n\n```\nMATCH (n {name: 'Carrie-Anne Moss'})-[r:acted_in]->(c)\nRETURN r\n```\n\n- ✓ Return property\n\n```\nMATCH (n {name: 'Carrie-Anne Moss'}) RETURN n.born\n```\n\n- ❏ Return all elements\n\n```\nMATCH p = (a {name: 'A'})-[r]->(b)\nRETURN *\n```\n\n- ❏ Variable with uncommon characters\n\n该段落位于文档的第二章“Clauses”中，主要介绍如何使用TuGraph的MATCH语句获取最短路径以及通过ID获取节点或关系的示例。接下来将讨论RETURN子句，包括返回节点、关系和属性的不同方式。"
            },
            {
                "content": "- ✓ Multiple nodes by id\n\n  ```\n  MATCH (n)\n  WHERE id(n) IN [0, 3, 5]\n  RETURN n\n  ```\n\n### 2.3.RETURN\n\n- ✓ Return nodes\n\n```\nMATCH (n {name: 'Carrie-Anne Moss'}) RETURN n\n```\n\n- ✓ Return relationships\n\n```\nMATCH (n {name: 'Carrie-Anne Moss'})-[r:acted_in]->(c)\nRETURN r\n```\n\n- ✓ Return property\n\n```\nMATCH (n {name: 'Carrie-Anne Moss'}) RETURN n.born\n```\n\n- ❏ Return all elements\n\n```\nMATCH p = (a {name: 'A'})-[r]->(b)\nRETURN *\n```\n\n- ❏ Variable with uncommon characters\n\n```\nMATCH (`This isn\\'t a common variable`)\nWHERE `This isn\\'t a common variable`.name = 'A'\nRETURN `This isn\\'t a common variable`.happy\n```\n\n- ✓ Aliasing a field\n\n```\nMATCH (a {name: 'Carrie-Anne Moss'})\nRETURN a.born AS SomethingTotallyDifferent\n```\n\n- ✓ Optional properties\n\n```\nMATCH (n)\nRETURN n.age\n```\n\n- ❏ Other expressions\n\n```\nMATCH (a {name: 'Carrie-Anne Moss'})\nRETURN a.born > 1900, \"I'm a literal\", (a)-[]->()\n```\n\n`(a)-[]->()`  not supported.\n\n- ✓ Unique results\n\n该片段位于文档的第2节“Clauses”下，具体在2.2节“RETURN”中，介绍了如何使用RETURN子句来返回节点、关系和属性，并给出了一系列示例，包括成功的返回情况和一些不支持的案例。此部分为用户提供了RETURN子句的基本用法和常见操作示例。"
            },
            {
                "content": "```\nMATCH (`This isn\\'t a common variable`)\nWHERE `This isn\\'t a common variable`.name = 'A'\nRETURN `This isn\\'t a common variable`.happy\n```\n\n- ✓ Aliasing a field\n\n```\nMATCH (a {name: 'Carrie-Anne Moss'})\nRETURN a.born AS SomethingTotallyDifferent\n```\n\n- ✓ Optional properties\n\n```\nMATCH (n)\nRETURN n.age\n```\n\n- ❏ Other expressions\n\n```\nMATCH (a {name: 'Carrie-Anne Moss'})\nRETURN a.born > 1900, \"I'm a literal\", (a)-[]->()\n```\n\n`(a)-[]->()`  not supported.\n\n- ✓ Unique results\n\n```\nMATCH (a {name: 'Carrie-Anne Moss'})-[]->(b)\nRETURN DISTINCT b\n```\n\n### 2.4.WHERE\n\n- Basic usage\n  - ✓ Boolean operations\n\n  ```\n  MATCH (n)\n  WHERE n.name = 'Laurence Fishburne' XOR (n.born > 1965 AND n.name = 'Carrie-Anne Moss')\n  RETURN n.name, n.born\n  ```\n\n  - ✓ Filter on node label\n\n  ```\n  MATCH (n)\n  WHERE n:person\n  RETURN n.name, n.born\n  ```\n\n  - ✓ Filter on node property\n\n  ```\n  MATCH (n)\n  WHERE n.born > 2000\n  RETURN n.name, n.born\n  ```\n\n  - ✓ Filter on relationship property\n\n该文块位于文档的第2.3节和第2.4节之间，主要介绍了MATCH语句的用法，包括字段别名、可选属性、其他表达式，以及在WHERE子句中的基本用法，如布尔运算、节点标签过滤、节点属性过滤和关系属性过滤。这些内容为用户提供了在TuGraph-Cypher查询中处理节点和关系的多种方法与示例。"
            },
            {
                "content": "```\nMATCH (a {name: 'Carrie-Anne Moss'})-[]->(b)\nRETURN DISTINCT b\n```\n\n### 2.4.WHERE\n\n- Basic usage\n  - ✓ Boolean operations\n\n  ```\n  MATCH (n)\n  WHERE n.name = 'Laurence Fishburne' XOR (n.born > 1965 AND n.name = 'Carrie-Anne Moss')\n  RETURN n.name, n.born\n  ```\n\n  - ✓ Filter on node label\n\n  ```\n  MATCH (n)\n  WHERE n:person\n  RETURN n.name, n.born\n  ```\n\n  - ✓ Filter on node property\n\n  ```\n  MATCH (n)\n  WHERE n.born > 2000\n  RETURN n.name, n.born\n  ```\n\n  - ✓ Filter on relationship property\n\n  ```\n  MATCH (n)-[k:acted_in]->(f)\n  WHERE k.role = \"Trinity\"\n  RETURN f.title\n  ```\n\n  - ❏ Filter on dynamically-computed property\n\n  ```\n  WITH 'AGE' AS propname\n  MATCH (n)\n  WHERE n[toLower(propname)]< 30\n  RETURN n.name, n.age\n  ```\n\n  - ✓ Property existence checking\n\n  ```\n  MATCH (n)\n  WHERE exists(n.born)\n  RETURN n.name, n.born\n  ```\n\n- String matching\n  - ✓ Match the beginning of a string\n\n  ```\n  MATCH (n)\n  WHERE n.name STARTS WITH 'Pet'\n  RETURN n.name, n.born\n  ```\n\n  - ✓ Match the ending of a string\n\n该段落位于文档的第2.4节“WHERE”中，介绍了在TuGraph-Cypher查询语言中如何使用WHERE子句进行条件过滤，包括布尔运算、节点标签筛选、节点属性和关系属性的过滤，以及字符串匹配等功能，以便进行精准查询。"
            },
            {
                "content": "- ❏ Filter on dynamically-computed property\n\n  ```\n  WITH 'AGE' AS propname\n  MATCH (n)\n  WHERE n[toLower(propname)]< 30\n  RETURN n.name, n.age\n  ```\n\n  - ✓ Property existence checking\n\n  ```\n  MATCH (n)\n  WHERE exists(n.born)\n  RETURN n.name, n.born\n  ```\n\n- String matching\n  - ✓ Match the beginning of a string\n\n  ```\n  MATCH (n)\n  WHERE n.name STARTS WITH 'Pet'\n  RETURN n.name, n.born\n  ```\n\n  - ✓ Match the ending of a string\n\n  ```\n  MATCH (n)\n  WHERE n.name ENDS WITH 'ter'\n  RETURN n.name, n.born\n  ```\n\n  - ✓ Match anywhere within a string\n\n  ```\n  MATCH (n)\n  WHERE n.name CONTAINS 'ete'\n  RETURN n.name, n.born\n  ```\n\n  - ✓ String matching negation\n\n  ```\n  MATCH (n)\n  WHERE NOT n.name ENDS WITH 's'\n  RETURN n.name, n.born\n  ```\n\n- Using path patterns in `WHERE`\n  - ❏ Filter on patterns\n\n  ```\n  MATCH (tobias {name: 'Tobias'}), (others)\n  WHERE others.name IN ['Andres', 'Peter'] AND (tobias)<-[]-(others)\n  RETURN others.name, others.age\n  ```\n\n  - ❏ Filter on patterns using NOT\n\n该内容位于文档的第2.4节“WHERE”中，涵盖了在Cypher查询中使用WHERE子句进行动态计算属性过滤、属性存在性检查以及字符串匹配的示例。此外，还包括在WHERE条件中使用路径模式的过滤示例。这部分内容详细介绍了如何利用WHERE子句进行复杂条件筛选。"
            },
            {
                "content": "- ✓ Match anywhere within a string\n\n  ```\n  MATCH (n)\n  WHERE n.name CONTAINS 'ete'\n  RETURN n.name, n.born\n  ```\n\n  - ✓ String matching negation\n\n  ```\n  MATCH (n)\n  WHERE NOT n.name ENDS WITH 's'\n  RETURN n.name, n.born\n  ```\n\n- Using path patterns in `WHERE`\n  - ❏ Filter on patterns\n\n  ```\n  MATCH (tobias {name: 'Tobias'}), (others)\n  WHERE others.name IN ['Andres', 'Peter'] AND (tobias)<-[]-(others)\n  RETURN others.name, others.age\n  ```\n\n  - ❏ Filter on patterns using NOT\n\n  ```\n  MATCH (persons), (peter {name: 'Peter'})\n  WHERE NOT (persons)-[]->(peter)\n  RETURN persons.name, persons.age\n  ```\n\n  - ❏ Filter on patterns with properties\n\n  ```\n  MATCH (n)\n  WHERE (n)-[:KNOWS]-({name: 'Tobias'})\n  RETURN n.name, n.age\n  ```\n\n  - ✓ Filter on relationship type\n\n  ```\n  MATCH (n)-[r]->()\n  WHERE n.name='Laurence Fishburne' AND type(r) STARTS WITH 'ac'\n  RETURN type(r), r.role\n  ```\n\n- Lists\n  - ✓ IN operator\n\n该段落位于第二章的WHERE子句部分，主要介绍字符串匹配、路径模式过滤以及列表运算符的使用示例，展示了在Cypher查询中如何使用WHERE子句进行条件过滤和匹配。"
            },
            {
                "content": "- ❏ Filter on patterns using NOT\n\n  ```\n  MATCH (persons), (peter {name: 'Peter'})\n  WHERE NOT (persons)-[]->(peter)\n  RETURN persons.name, persons.age\n  ```\n\n  - ❏ Filter on patterns with properties\n\n  ```\n  MATCH (n)\n  WHERE (n)-[:KNOWS]-({name: 'Tobias'})\n  RETURN n.name, n.age\n  ```\n\n  - ✓ Filter on relationship type\n\n  ```\n  MATCH (n)-[r]->()\n  WHERE n.name='Laurence Fishburne' AND type(r) STARTS WITH 'ac'\n  RETURN type(r), r.role\n  ```\n\n- Lists\n  - ✓ IN operator\n\n  ```\n  MATCH (a)\n  WHERE a.name IN ['Laurence Fishburne', 'Tobias']\n  RETURN a.name, a.born\n  ```\n\n- Missing properties and values\n  - ✓ Default to false if property is missing\n\n  ```\n  MATCH (n)\n  WHERE n.belt = 'white'\n  RETURN n.name, n.age, n.belt\n  ```\n\n  - ✓ Default to true if property is missing\n\n  ```\n  MATCH (n)\n  WHERE n.belt = 'white' OR n.belt IS NULL RETURN n.name, n.age, n.belt\n  ORDER BY n.name\n  ```\n\n  - ✓ Filter on null\n\n该段落位于文档的\"2.4.WHERE\"小节中，主要介绍使用WHERE子句进行模式过滤和属性检查的示例，包括使用NOT进行模式过滤、根据属性过滤和关系类型过滤的方法，同时也涵盖了列表操作、缺失属性和值的处理方式。"
            },
            {
                "content": "- Lists\n  - ✓ IN operator\n\n  ```\n  MATCH (a)\n  WHERE a.name IN ['Laurence Fishburne', 'Tobias']\n  RETURN a.name, a.born\n  ```\n\n- Missing properties and values\n  - ✓ Default to false if property is missing\n\n  ```\n  MATCH (n)\n  WHERE n.belt = 'white'\n  RETURN n.name, n.age, n.belt\n  ```\n\n  - ✓ Default to true if property is missing\n\n  ```\n  MATCH (n)\n  WHERE n.belt = 'white' OR n.belt IS NULL RETURN n.name, n.age, n.belt\n  ORDER BY n.name\n  ```\n\n  - ✓ Filter on null\n\n  ```\n  MATCH (person)\n  WHERE person.name = 'Peter' AND person.belt IS NULL RETURN person.name, person.age,\n  person.belt\n  ```\n\n- Using ranges\n  - ✓ Simple range\n\n  ```\n  MATCH (a)\n  WHERE a.name >= 'Peter'\n  RETURN a.name, a.born\n  ```\n\n  - ✓ Composite range\n\n  ```\n  MATCH (a)\n  WHERE a.name > 'Andres' AND a.name < 'Tobias'\n  RETURN a.name, a.born\n  ```\n\n### 2.5.SKIP\n\n- ✓ Skip first three records\n\n```\nMATCH (n:person)\nRETURN n.name\nORDER BY n.name\nSKIP 3\n```\n\n- ✓ Return middle two records\n\n该部分内容位于文档的第二章“Clauses”下，具体在子章节2.4“WHERE”中，主要涵盖使用IN运算符、默认值的处理、空值过滤，以及范围查询的示例。这些示例展示了如何在查询中灵活运用条件，使得用户在编写Cypher查询时能够高效地进行数据筛选和条件判断。"
            },
            {
                "content": "```\n  MATCH (person)\n  WHERE person.name = 'Peter' AND person.belt IS NULL RETURN person.name, person.age,\n  person.belt\n  ```\n\n- Using ranges\n  - ✓ Simple range\n\n  ```\n  MATCH (a)\n  WHERE a.name >= 'Peter'\n  RETURN a.name, a.born\n  ```\n\n  - ✓ Composite range\n\n  ```\n  MATCH (a)\n  WHERE a.name > 'Andres' AND a.name < 'Tobias'\n  RETURN a.name, a.born\n  ```\n\n### 2.5.SKIP\n\n- ✓ Skip first three records\n\n```\nMATCH (n:person)\nRETURN n.name\nORDER BY n.name\nSKIP 3\n```\n\n- ✓ Return middle two records\n\n```\nMATCH (n:person)\nRETURN n.name\nORDER BY n.name\nSKIP 1\nLIMIT 2\n```\n\n- ❏ Using an expression with SKIP to return a subset of the records\n\n```\nMATCH (n:person)\nRETURN n.name\nORDER BY n.name\nSKIP toInteger(3*rand())+ 1\n```\n\n### 2.6.LIMIT\n\n- ✓ Return a subset of the records\n\n```\nMATCH (n:person)\nRETURN n.name\nLIMIT 3\n```\n\n- ❏ Using an expression with LIMIT to return a subset of the records\n\n```\nMATCH (n:person)\nRETURN n.name\nLIMIT toInteger(3 * rand())+ 1\n```\n\n### 2.7.CREATE\n\n- Create nodes\n\n该内容片段位于文档的第2部分，具体涉及Cypher查询语言中的条件过滤和结果分页操作，包括使用条件运算符和范围查询（如使用\"WITH\"和\"WHERE\"子句进行数据筛选），以及使用\"SKIP\"和\"LIMIT\"进行结果集的控制，后续将介绍节点创建操作。"
            },
            {
                "content": "```\nMATCH (n:person)\nRETURN n.name\nORDER BY n.name\nSKIP 1\nLIMIT 2\n```\n\n- ❏ Using an expression with SKIP to return a subset of the records\n\n```\nMATCH (n:person)\nRETURN n.name\nORDER BY n.name\nSKIP toInteger(3*rand())+ 1\n```\n\n### 2.6.LIMIT\n\n- ✓ Return a subset of the records\n\n```\nMATCH (n:person)\nRETURN n.name\nLIMIT 3\n```\n\n- ❏ Using an expression with LIMIT to return a subset of the records\n\n```\nMATCH (n:person)\nRETURN n.name\nLIMIT toInteger(3 * rand())+ 1\n```\n\n### 2.7.CREATE\n\n- Create nodes\n\n> **Note**\n> TuGraph不支持创建空的nodes，不支持多labels。\n\n  - ☒ Create single node\n\n  ```\n  CREATE (n)\n  ```\n\n  - ☒ Create multiple nodes\n\n  ```\n  CREATE (n), (m)\n  ```\n\n  - ☒ Create a node with a label\n\n  ```\n  CREATE (n:person)\n  ```\n\n  - ☒ Create a node with multiple labels\n\n  ```\n  CREATE (n:Person:Swedish)\n  ```\n\n  - ✓ Create node and add labels and properties\n\n  ```\n  CREATE (n:person {id:2001, name: 'Andres'})\n  ```\n\n  - ✓ Return created node\n\n  ```\n  CREATE (n:person {id:2002, name: 'Andres'})\n  RETURN n\n  ```\n\n该块内容位于文档的第2节，主要讨论LIMIT和SKIP子句的使用。在此之前，文档详细介绍了MATCH语句和其他相关子句的基本用法，后续部分将讨论创建节点及相关操作的具体例子。此部分强调了如何利用SKIP和LIMIT控制查询结果的输出。"
            },
            {
                "content": "- ☒ Create single node\n\n  ```\n  CREATE (n)\n  ```\n\n  - ☒ Create multiple nodes\n\n  ```\n  CREATE (n), (m)\n  ```\n\n  - ☒ Create a node with a label\n\n  ```\n  CREATE (n:person)\n  ```\n\n  - ☒ Create a node with multiple labels\n\n  ```\n  CREATE (n:Person:Swedish)\n  ```\n\n  - ✓ Create node and add labels and properties\n\n  ```\n  CREATE (n:person {id:2001, name: 'Andres'})\n  ```\n\n  - ✓ Return created node\n\n  ```\n  CREATE (n:person {id:2002, name: 'Andres'})\n  RETURN n\n  ```\n\n- Create relationships\n  - ✓ Create a relationship between two nodes\n\n  ```\n  MATCH (n:person), (m:movie)\n  WHERE n.name = 'Jada Pinkett Smith' AND m.title = 'The Matrix'\n  CREATE (n)-[r:write]->(m)\n  ```\n\n  - ✓ Create a relationship and set properties\n\n  ```\n  MATCH (n:person), (m:movie)\n  WHERE n.name = 'Jada Pinkett Smith' AND m.title = 'The Matrix'\n  CREATE (n)-[r:acted_in{role: 'Trinity'}]->(m)\n  ```\n\n  - ❏ Create a full path\n\n该文档主要介绍了TuGraph-Cypher的使用说明，其中包括运算符、子句、函数，以及创建和管理节点和关系的具体语法。这段内容位于有关创建节点和关系的部分，详细说明了支持的语法及其示例，包括如何创建单个或多个节点、带标签的节点以及节点之间的关系。"
            },
            {
                "content": "```\n  CREATE (n:person {id:2002, name: 'Andres'})\n  RETURN n\n  ```\n\n- Create relationships\n  - ✓ Create a relationship between two nodes\n\n  ```\n  MATCH (n:person), (m:movie)\n  WHERE n.name = 'Jada Pinkett Smith' AND m.title = 'The Matrix'\n  CREATE (n)-[r:write]->(m)\n  ```\n\n  - ✓ Create a relationship and set properties\n\n  ```\n  MATCH (n:person), (m:movie)\n  WHERE n.name = 'Jada Pinkett Smith' AND m.title = 'The Matrix'\n  CREATE (n)-[r:acted_in{role: 'Trinity'}]->(m)\n  ```\n\n  - ❏ Create a full path\n\n  ```\n  CREATE p = (andres:person {id: 2005, name:'Andres'})-[:acted_in {role: 'Trinity'}]->\n  (m:movie {id: 2006})<-[:acted_in {role: 'Trinity'}]-(michael {id: 2006, name:'Michael'})\n  RETURN p\n  ```\n\n- Use parameters with CREATE\n  - ❏ Create node with a parameter for the properties\n\n  ```\n  CREATE (n:Person $props)\n  RETURN n\n  ```\n\n  - ☒ Create multiple nodes with a parameter for their properties\n\n  ```\n  UNWIND $props AS map\n  CREATE (n)\n  SET n = map\n  ```\n  cannot create vertex without label.\n\n该片段位于文档的第2.7节“CREATE”中，主要介绍如何创建节点及其关系，包括创建节点的示例和使用参数创建节点的相关注意事项。"
            },
            {
                "content": "```\n  CREATE p = (andres:person {id: 2005, name:'Andres'})-[:acted_in {role: 'Trinity'}]->\n  (m:movie {id: 2006})<-[:acted_in {role: 'Trinity'}]-(michael {id: 2006, name:'Michael'})\n  RETURN p\n  ```\n\n- Use parameters with CREATE\n  - ❏ Create node with a parameter for the properties\n\n  ```\n  CREATE (n:Person $props)\n  RETURN n\n  ```\n\n  - ☒ Create multiple nodes with a parameter for their properties\n\n  ```\n  UNWIND $props AS map\n  CREATE (n)\n  SET n = map\n  ```\n  cannot create vertex without label.\n\n### 2.8.CALL[…YIELD]\n\n- ✓ Call a procedure using CALL\n\n```\nCALL db.vertexLabels\n```\n\n- ✓ View the signature for a procedure\n\n```\nCALL dbms.procedures() YIELD name, signature\nRETURN signature\n```\n\n- ❏ Call a procedure using a quoted namespace and name\n\n```\nCALL `db`.`vertexLabels`\n```\n\n- ✓ Call a procedure with literal arguments\n\n```\nCALL org.opencypher.procedure.example.addNodeToIndex('users', 0, 'name')\n```\n\n- ❏ Call a procedure with parameter arguments\n\n该代码块位于文档的第2.7节“CREATE”部分，主要展示了使用CREATE命令创建节点和关系的示例。其中包括创建节点时使用参数的方式，并提到不能创建没有标签的顶点。此后，块中还延续至第2.8节“CALL…YIELD”，提供了有关调用程序的示例和注意事项。"
            },
            {
                "content": "### 2.8.CALL[…YIELD]\n\n- ✓ Call a procedure using CALL\n\n```\nCALL db.vertexLabels\n```\n\n- ✓ View the signature for a procedure\n\n```\nCALL dbms.procedures() YIELD name, signature\nRETURN signature\n```\n\n- ❏ Call a procedure using a quoted namespace and name\n\n```\nCALL `db`.`vertexLabels`\n```\n\n- ✓ Call a procedure with literal arguments\n\n```\nCALL org.opencypher.procedure.example.addNodeToIndex('users', 0, 'name')\n```\n\n- ❏ Call a procedure with parameter arguments\n\n```\nCALL org.opencypher.procedure.example.addNodeToIndex($indexName,$node,$propKey)\n```\n\n- ❏ Call a procedure with mixed literal and parameter arguments\n\n```\nCALL org.opencypher.procedure.example.addNodeToIndex('users', $node, 'name')\n```\n\n- ✓ Call a procedure with literal and default arguments\n\n```\nCALL org.opencypher.procedure.example.addNodeToIndex('users', 0)\n```\n\n- ✓ Call a procedure within a complex query using CALL…YIELD\n\n```\nCALL db.vertexLabels() YIELD label\nRETURN count(label) AS numLabels\n```\n\n- ❏ Call a procedure and filter its results\n\n该块内容位于文档的第二部分，专门讨论CALL语句及其在TuGraph-Cypher中的使用。它详细列出了通过CALL调用过程的示例，包括调用过程、查看签名、使用字面值和参数的方式等，旨在帮助用户理解如何有效地调用和使用数据库中的存储过程。"
            },
            {
                "content": "- ❏ Call a procedure with mixed literal and parameter arguments\n\n```\nCALL org.opencypher.procedure.example.addNodeToIndex('users', $node, 'name')\n```\n\n- ✓ Call a procedure with literal and default arguments\n\n```\nCALL org.opencypher.procedure.example.addNodeToIndex('users', 0)\n```\n\n- ✓ Call a procedure within a complex query using CALL…YIELD\n\n```\nCALL db.vertexLabels() YIELD label\nRETURN count(label) AS numLabels\n```\n\n- ❏ Call a procedure and filter its results\n\n```\nCALL db.vertexLabels() YIELD label\nWHERE label CONTAINS 'User'\nRETURN count(label) AS numLabels\n```\n\n- ❏ Call a procedure within a complex query and rename its outputs\n\n```\nCALL db.propertyKeys() YIELD propertyKey AS prop\nMATCH (n)\nWHERE n[prop] IS NOT NULL RETURN prop, count(n) AS numNodes\n```\n\n### 2.9.UNION\n\n- ✓ Combine two queries and retain duplicates\n\n```\nMATCH (n:person)\nRETURN n.name AS name\nUNION ALL MATCH (n:movie)\nRETURN n.title AS name\n```\n\n- ❏ Combine two queries and remove duplicates\n\n该段落位于文档的“2.8.CALL[…YIELD]”部分，主要介绍了如何调用程序，包括不同的调用方式（如使用字面量和参数、复杂查询等）以及如何过滤和重命名输出结果。这一部分为用户提供了关于如何有效使用调用命令的具体示例，旨在帮助用户更好地理解和应用TuGraph的查询功能。"
            },
            {
                "content": "```\nCALL db.vertexLabels() YIELD label\nWHERE label CONTAINS 'User'\nRETURN count(label) AS numLabels\n```\n\n- ❏ Call a procedure within a complex query and rename its outputs\n\n```\nCALL db.propertyKeys() YIELD propertyKey AS prop\nMATCH (n)\nWHERE n[prop] IS NOT NULL RETURN prop, count(n) AS numNodes\n```\n\n### 2.9.UNION\n\n- ✓ Combine two queries and retain duplicates\n\n```\nMATCH (n:person)\nRETURN n.name AS name\nUNION ALL MATCH (n:movie)\nRETURN n.title AS name\n```\n\n- ❏ Combine two queries and remove duplicates\n\n```\nMATCH (n:Actor)\nRETURN n.name AS name\nUNION\nMATCH (n:Movie)\nRETURN n.title AS name\n```\n\n## 3.Functions\n\n### 3.1.Whole List Of Functions\n\n该块内容位于文档中关于内置程序和函数的部分，具体涉及调用程序的例子和UNION操作的使用示例，后续则是函数的整体列表。此部分展示了如何在复杂查询中使用调用程序以及合并查询的操作。"
            },
            {
                "content": "| 种类                   | 功能               | 备注                      |\n| ---------------------- |------------------| ------------------------- |\n| Predicate functions    | exists()         |                           |\n|                        | all()            | 不支持                    |\n|                        | any()            | 不支持                    |\n|                        | single()         | 不支持                    |\n|                        | none()           | 不支持                    |\n| Scalar functions       | id()             |                           |\n|                        | euid()           |                           |\n|                        | properties()     |                           |\n|                        | head()           |                           |\n|                        | last()           |                           |\n|                        | toBoolean()      |                           |\n|                        | toFloat()        |                           |\n\n此块内容位于文档的“3.Functions”部分，主要列出了图数据库中可用的函数类型，包括谓词函数和标量函数，并简要描述了它们的功能及支持情况，便于用户查找和使用相关函数。"
            },
            {
                "content": "|                        | euid()           |                           |\n|                        | properties()     |                           |\n|                        | head()           |                           |\n|                        | last()           |                           |\n|                        | toBoolean()      |                           |\n|                        | toFloat()        |                           |\n|                        | toInteger()      |                           |\n|                        | toString()       |                           |\n|                        | type()           |                           |\n|                        | startnode()      |                           |\n|                        | endnode()        |                           |\n|                        | size()           |                           |\n|                        | length()         |                           |\n\n该块内容属于第三部分“函数”的子类别“3.3.标量函数”，具体列出了TuGraph-Cypher中可用的标量函数，包括`euid()`、`properties()`、`head()`、`last()`、`toBoolean()`、`toFloat()`、`toInteger()`、`toString()`、`type()`、`startnode()`、`endnode()`、`size()`和`length()`等函数。这些函数在整个文档中用于处理节点和关系的属性及其相关操作。"
            },
            {
                "content": "|                        | toString()       |                           |\n|                        | type()           |                           |\n|                        | startnode()      |                           |\n|                        | endnode()        |                           |\n|                        | size()           |                           |\n|                        | length()         |                           |\n|                        | substring()      |                           |\n|                        | concat()         |                           |\n|                        | label()          | OpenCypher扩展方法      |\n| Aggregating functions  | avg()            |                           |\n|                        | collect()        |                           |\n|                        | count()          |                           |\n|                        | max()            |                           |\n\n该文本块位于文档的“3. Functions”部分，具体集中在“Scalar functions”和“Aggregating functions”的类别中，列出了可用的标量函数以及聚合函数，提供每个函数的名称和相关备注，以便用户了解和使用这些功能。"
            },
            {
                "content": "|                        | substring()      |                           |\n|                        | concat()         |                           |\n|                        | label()          | OpenCypher扩展方法      |\n| Aggregating functions  | avg()            |                           |\n|                        | collect()        |                           |\n|                        | count()          |                           |\n|                        | max()            |                           |\n|                        | min()            |                           |\n|                        | percentileCont() |                           |\n|                        | percentileDisc() |                           |\n|                        | stDev()          |                           |\n|                        | stDevP()         |                           |\n|                        | variance()       |                           |\n\n该块内容属于文档中关于函数的部分，具体关注于“函数”类别下的内容，列出了不同类型的聚合函数及其功能，包括字符串函数和统计分析函数的相关信息，旨在为用户提供有关数据处理和分析的功能概述。"
            },
            {
                "content": "|                        | min()            |                           |\n|                        | percentileCont() |                           |\n|                        | percentileDisc() |                           |\n|                        | stDev()          |                           |\n|                        | stDevP()         |                           |\n|                        | variance()       |                           |\n|                        | varianceP()      |                           |\n|                        | sum()            |                           |\n| List functions         | keys()           |                           |\n|                        | labels()         | 返回结果有且只有一个label |\n|                        | nodes()          |                           |\n|                        | range()          |                           |\n|                        | subscript()      | 不支持                    |\n| Mathematical functions | abs()            |                           |\n\n该片段位于文档的第三部分“函数”中，具体是对聚合函数和列表函数的分类及其描述，包括多种聚合统计函数和列表操作函数，以便于用户查找和使用。"
            },
            {
                "content": "|                        | sum()            |                           |\n| List functions         | keys()           |                           |\n|                        | labels()         | 返回结果有且只有一个label |\n|                        | nodes()          |                           |\n|                        | range()          |                           |\n|                        | subscript()      | 不支持                    |\n| Mathematical functions | abs()            |                           |\n|                        | ceil()           |                           |\n|                        | floor()          |                           |\n|                        | rand()           |                           |\n|                        | round()          |                           |\n|                        | sign()           |                           |\n| String functions       | /                |                           |\n表格内容描述: 该表格列出了多种函数的分类，包括“种类”、“功能”和“备注”三列。\n\n该块内容位于文档的函数部分，主要展示了列表函数和数学函数的分类及功能，强调每种函数的用途和支持情况，旨在为用户提供函数使用的清晰概览。"
            },
            {
                "content": "逐行描述表格中的数据内容：\n1. 在“Predicate functions”类别下，存在函数 `exists()`，而 `all()`、`any()`、`single()` 和 `none()` 函数均不支持。\n2. 在“Scalar functions”类别下，列出了多个可用的函数，包括 `id()`、`euid()`、`properties()`、`head()`、`last()`、`toBoolean()`、`toFloat()`、`toInteger()`、`toString()`、`type()`、`startnode()`、`endnode()`、`size()`、`length()`、`substring()`、`concat()` 和 `label()`（其中 `label()` 是 OpenCypher 扩展方法）。\n3. 在“Aggregating functions”类别下，存在 `avg()`、`collect()`、`count()`、`max()`、`min()`、`percentileCont()`、`percentileDisc()`、`stDev()`、`stDevP()`、`variance()`、`varianceP()` 和 `sum()` 函数。\n4. 在“List functions”类别下，列出了 `keys()`、`labels()`（返回结果有且只有一个 label）、`nodes()` 和 `range()` 函数，`subscript()` 不支持。\n5. 在“Mathematical functions”类别下，列出了 `abs()`、`ceil()`、`floor()`、`rand()`、`round()` 和 `sign()` 函数。\n6. “String functions”类别下未列出任何具体函数功能。\n\n表格整体内容的概要总结：该表格系统性地展示了不同类型函数的列表，涵盖了谓词函数、标量函数、聚合函数、列表函数、数学函数和字符串函数，并指出了一些不支持的函数。整体来看，表格为用户提供了函数可用性和相关备注的清晰概览。\n\n### 3.2.Predicate functions\n\n该段落位于文档的“函数”部分，主要集中在不同类别函数的描述和分类，包括谓词函数、标量函数、聚合函数、列表函数、数学函数和字符串函数，提供了关于每种函数可用性和支持情况的详细信息，帮助用户理解这些函数的功能和限制。"
            },
            {
                "content": "表格整体内容的概要总结：该表格系统性地展示了不同类型函数的列表，涵盖了谓词函数、标量函数、聚合函数、列表函数、数学函数和字符串函数，并指出了一些不支持的函数。整体来看，表格为用户提供了函数可用性和相关备注的清晰概览。\n\n### 3.2.Predicate functions\n\n- exists()\n  judge it whether a vertex or edge has the field  .\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n)\nWHERE exists(n.born)\nRETURN n.name, n.born\n```\n\n**Example output:**\n\n| exists(name) |\n| ------------ |\n| true         |\n表格内容描述: 该表格包含一列名为\"exists(name)\"，表示某个名称的存在状态。表格中只有一行数据，值为\"true\"，表示该名称确实存在。整体来看，该表格的内容表明名称的存在性为真实。\n\n### 3.3.Scalar functions\n\n- id()\n  get the id of vertex.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (a)\nRETURN id(a)\n```\n\n**Example output:**\n\n| vid |\n| --- |\n| 1   |\n| 2   |\n| ... |\n表格内容描述: 此表格包含一列，列名为“vid”。该列记录了不同的唯一标识符（ID）。表格中列出了多个ID，从1开始依次递增，显示了数字1和2以及后续的ID（以“...”表示后续的序号）。整体来看，该表格是一系列唯一标识符的简要列表，显示了系统中可能存在的多个条目的ID。\n\n- properties()\n  get  a map containing all the properties of a node or relationship.\n  **Scope:** whole instance.\n  **Example input:**\n\n该chunk位于文档的第三部分，主要介绍了TuGraph-Cypher中的函数功能，包括谓词函数和标量函数的定义、使用示例及其输出结果，旨在为用户提供有关函数可用性及其应用的详细说明。"
            },
            {
                "content": "### 3.3.Scalar functions\n\n- id()\n  get the id of vertex.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (a)\nRETURN id(a)\n```\n\n**Example output:**\n\n| vid |\n| --- |\n| 1   |\n| 2   |\n| ... |\n表格内容描述: 此表格包含一列，列名为“vid”。该列记录了不同的唯一标识符（ID）。表格中列出了多个ID，从1开始依次递增，显示了数字1和2以及后续的ID（以“...”表示后续的序号）。整体来看，该表格是一系列唯一标识符的简要列表，显示了系统中可能存在的多个条目的ID。\n\n- properties()\n  get  a map containing all the properties of a node or relationship.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n:person {name: 'Laurence Fishburne'})\nRETURN n\n```\n\n- head()\n  get the first element of a list.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nWITH ['one','two','three'] AS coll RETURN coll, head(coll)\n```\n\n**Example output:**\n\n| coll                  | head(coll)    |\n| --------------------- | ------------- |\n| [\"one\",\"two\",\"three\"] | \"one\"         |\n表格内容描述：该表格包含两列，分别为\"coll\"和\"head(coll)\"。\n\n- 第一行数据显示，\"coll\"列的内容是一个包含三个字符串的数组：[\"one\", \"two\", \"three\"]。而\"head(coll)\"列的内容是该数组的第一个元素，即\"one\"。\n\n总体来说，该表格展示了一个字符串数组及其第一个元素的对应关系。\n\n该内容位于文档的第三部分，主要介绍TuGraph中的标量函数，包括其功能、使用示例及返回结果。通过具体的示例代码和输出表格，展示了如何利用这些函数获取节点的唯一标识符、属性以及列表的首个元素，便于用户理解和使用相关功能。"
            },
            {
                "content": "- head()\n  get the first element of a list.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nWITH ['one','two','three'] AS coll RETURN coll, head(coll)\n```\n\n**Example output:**\n\n| coll                  | head(coll)    |\n| --------------------- | ------------- |\n| [\"one\",\"two\",\"three\"] | \"one\"         |\n表格内容描述：该表格包含两列，分别为\"coll\"和\"head(coll)\"。\n\n- 第一行数据显示，\"coll\"列的内容是一个包含三个字符串的数组：[\"one\", \"two\", \"three\"]。而\"head(coll)\"列的内容是该数组的第一个元素，即\"one\"。\n\n总体来说，该表格展示了一个字符串数组及其第一个元素的对应关系。\n\n- last()\n  get the last element of a list.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nWITH ['one','two','three'] AS coll RETURN coll, last(coll)\n```\n\n**Example output:**\n\n| coll                  | last(coll)    |\n| --------------------- | ------------- |\n| [\"one\",\"two\",\"three\"] | \"three\"       |\n表格内容描述: 此表格包含两列，分别是“coll”和“last(coll)”。第一行中，“coll”列中的数据为一个包含三个字符串的数组，具体为“one”、“two”和“three”；而“last(coll)”列则显示这个数组的最后一个元素“three”。整体来看，表格展示了一个字符串数组及其最后一个元素的关系。\n\n该内容位于文档的“3.3.Scalar functions”部分，具体介绍了两个标量函数`head()`和`last()`的使用方法，包括它们的功能、作用范围、示例输入和输出，旨在帮助用户理解如何提取列表中的第一个和最后一个元素。"
            },
            {
                "content": "总体来说，该表格展示了一个字符串数组及其第一个元素的对应关系。\n\n- last()\n  get the last element of a list.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nWITH ['one','two','three'] AS coll RETURN coll, last(coll)\n```\n\n**Example output:**\n\n| coll                  | last(coll)    |\n| --------------------- | ------------- |\n| [\"one\",\"two\",\"three\"] | \"three\"       |\n表格内容描述: 此表格包含两列，分别是“coll”和“last(coll)”。第一行中，“coll”列中的数据为一个包含三个字符串的数组，具体为“one”、“two”和“three”；而“last(coll)”列则显示这个数组的最后一个元素“three”。整体来看，表格展示了一个字符串数组及其最后一个元素的关系。\n\n- toFloat()\n  Converts an integer or string value to a floating point number.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN toFloat('11.5')\n```\n\n**Example output:**\n\n| float |\n| ----- |\n| 11.5  |\n表格内容描述: 该表格只有一列，列名为\"float\"，表示浮点数数据。表格中包含一行数据，数值为11.5。整体来看，表格简单明了，仅提供了一个浮点数值11.5。\n\n- toInteger()\n  Converts a floating point or string value to an integer value.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN toInteger('2.3') AS integer\n```\n\n**Example output:**\n\n该片段位于文档的\"Functions\"部分，具体是在\"Scalar functions\"小节中，围绕着不同的标量函数进行详细介绍，包括如何获取列表的最后一个元素以及将数值转换为浮点数和整数的示例。这些内容为用户提供了有关标量函数的清晰理解和应用示例，有助于其在使用TuGraph-Cypher时进行查询和数据操作。"
            },
            {
                "content": "- toFloat()\n  Converts an integer or string value to a floating point number.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN toFloat('11.5')\n```\n\n**Example output:**\n\n| float |\n| ----- |\n| 11.5  |\n表格内容描述: 该表格只有一列，列名为\"float\"，表示浮点数数据。表格中包含一行数据，数值为11.5。整体来看，表格简单明了，仅提供了一个浮点数值11.5。\n\n- toInteger()\n  Converts a floating point or string value to an integer value.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN toInteger('2.3') AS integer\n```\n\n**Example output:**\n\n| integer |\n| ------- |\n| 2       |\n表格内容描述: 该表格包含一列，列名为“integer”。在数据行中，唯一的一项数据是数字2。综上所述，该表格只有一条记录，表示整数2。\n\n- toString()\n  Converts an integer, float, boolean value to a string.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN toString(2.3)\n```\n\n- type()\n  get the string representation of the relationship type.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n)-[r]->()\nWHERE n.name = 'Laurence Fishburne'\nRETURN type(r)\n```\n\n**Example output:**\n\n该片段位于\"3.3.标量函数\"部分，介绍了几个标量函数的功能及其用法，包括`toFloat()`、`toInteger()`、`toString()`和`type()`，并提供了相应的示例输入和输出，以便用户了解如何在TuGraph-Cypher中进行数值类型转换和获取关系类型的字符串表示。"
            },
            {
                "content": "**Example output:**\n\n| integer |\n| ------- |\n| 2       |\n表格内容描述: 该表格包含一列，列名为“integer”。在数据行中，唯一的一项数据是数字2。综上所述，该表格只有一条记录，表示整数2。\n\n- toString()\n  Converts an integer, float, boolean value to a string.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN toString(2.3)\n```\n\n- type()\n  get the string representation of the relationship type.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n)-[r]->()\nWHERE n.name = 'Laurence Fishburne'\nRETURN type(r)\n```\n\n**Example output:**\n\n| type     |\n| -------- |\n| acted_in |\n| acted_in |\n表格内容描述: 该表格只有一列，列名为\"type\"。在该列中，所有的行数据均为\"acted_in\"。整体来看，表格的内容表明，该类型在记录中出现了多次，具体为两次\"acted_in\"。\n\n### 3.4.Aggregating functions\n\n- avg()\n  Returns the average of a set of numeric values.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n:person)\nRETURN avg(n.born)\n```\n\n**Example output:**\n\n| avg(n.born)        |\n| ------------------ |\n| 1869.2661654135338 |\n表格内容描述: 表格中只有一列，列名为 \"avg(n.born)\"，表示平均出生人数。该列的唯一数据值为 1869.27（四舍五入到两位小数）。整体来看，该表格显示的结果表明，平均出生人数为大约 1869 人。\n\n该部分内容位于文档的第三章“Functions”中，主要介绍标量函数的使用，包括整数转化、获取关系类型的字符串表示以及聚合函数的示例输出与说明。这些函数的示例和输出展示了如何在TuGraph-Cypher中进行数据处理和统计计算。"
            },
            {
                "content": "### 3.4.Aggregating functions\n\n- avg()\n  Returns the average of a set of numeric values.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n:person)\nRETURN avg(n.born)\n```\n\n**Example output:**\n\n| avg(n.born)        |\n| ------------------ |\n| 1869.2661654135338 |\n表格内容描述: 表格中只有一列，列名为 \"avg(n.born)\"，表示平均出生人数。该列的唯一数据值为 1869.27（四舍五入到两位小数）。整体来看，该表格显示的结果表明，平均出生人数为大约 1869 人。\n\n- collect()\n  Returns a list containing the values returned by an expression.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n:person)\nRETURN collect(n.born)\n```\n\n**Example output:**\n\n| collect(n.born) |\n| --------------- |\n| [1967,...]      |\n表格内容描述: 该表格包含一列数据，列名为“collect(n.born)”。该列的数据内容为一个数组，表示出生年份，具体值为[1967,...]，意味着该数组包含1967年及之后的一系列年份。整体来看，此表格显示了一个出生年份的集合，暗示可能是用于统计或分析某个特定年份及其后续年份的出生数据。\n\n- count()\n  Returns the number of values or records.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n {name: 'Laurence Fishburne'})-[]->(x)\nRETURN labels(n), n.born, count(*)\n```\n\n**Example output:**\n\n该内容块位于文档的第三部分，专门介绍聚合函数的使用，包括对数值集合计算平均值、收集值列表和计数记录的函数。该部分提供了每个函数的功能、示例输入和输出，旨在帮助用户理解如何在TuGraph中使用这些聚合函数。"
            },
            {
                "content": "```\nMATCH (n:person)\nRETURN collect(n.born)\n```\n\n**Example output:**\n\n| collect(n.born) |\n| --------------- |\n| [1967,...]      |\n表格内容描述: 该表格包含一列数据，列名为“collect(n.born)”。该列的数据内容为一个数组，表示出生年份，具体值为[1967,...]，意味着该数组包含1967年及之后的一系列年份。整体来看，此表格显示了一个出生年份的集合，暗示可能是用于统计或分析某个特定年份及其后续年份的出生数据。\n\n- count()\n  Returns the number of values or records.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n {name: 'Laurence Fishburne'})-[]->(x)\nRETURN labels(n), n.born, count(*)\n```\n\n**Example output:**\n\n| labels(n)  | n.born | count(*) |\n| ---------- | ------ | -------- |\n| [\"person\"] | 1961   | 3        |\n表格内容描述: 该表格包含三列：`labels(n)`、`n.born`和`count(*)`。在这一行数据中，`labels(n)`列的值为[\"person\"]，表示该条目对应的人物标签；`n.born`列的值为1961，说明该人物的出生年份为1961年；`count(*)`列的值为3，表示与这个标签和出生年份相关的记录数量为3。\n\n总体来看，表格展示了一位于1961年出生的“person”标签下的记录总数为3。\n\n- max()\n  Returns the maximum value in a set of values.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n:person)\nRETURN max(n.born)\n```\n\n**Example output:**\n\n该块内容位于文档的第三部分“函数”下，主要介绍了与数据聚合相关的函数，包括`collect()`、`count()`和`max()`，并提供了相应的示例输入和输出，以帮助用户理解如何在TuGraph中进行统计和分析。"
            },
            {
                "content": "**Example output:**\n\n| labels(n)  | n.born | count(*) |\n| ---------- | ------ | -------- |\n| [\"person\"] | 1961   | 3        |\n表格内容描述: 该表格包含三列：`labels(n)`、`n.born`和`count(*)`。在这一行数据中，`labels(n)`列的值为[\"person\"]，表示该条目对应的人物标签；`n.born`列的值为1961，说明该人物的出生年份为1961年；`count(*)`列的值为3，表示与这个标签和出生年份相关的记录数量为3。\n\n总体来看，表格展示了一位于1961年出生的“person”标签下的记录总数为3。\n\n- max()\n  Returns the maximum value in a set of values.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n:person)\nRETURN max(n.born)\n```\n\n**Example output:**\n\n| max(n.born) |\n| ----------- |\n| 2003        |\n表格内容描述: 本表格包含一列，列名为 \"max(n.born)\"，用于显示出生年份的最大值。根据表格中的数据，最大出生年份为 2003。总体来看，该表格显示在登记的出生年份中，最新的年份为 2003。\n\n- min()\n  Returns the minimum value in a set of values.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n:person)\nRETURN min(n.born)\n```\n\n**Example output:**\n\n| min(n.born) |\n| ----------- |\n| 1000        |\n表格内容描述: 该表格包含一列，列名为 \"min(n.born)\"，表示某一项统计数据的最小值。在表格中，数据内容为 1000，显示这一最小值为 1000。总体来看，该表格简单明了，展示了一个最小出生数量的统计结果。\n\n该段落位于文档的第三部分“Functions”中的“聚合函数”子部分，具体介绍了聚合函数`count()`、`max()`和`min()`的用法，以及对应的示例输出和详细的表格内容描述，展示了如何在TuGraph中进行统计分析和数据汇总。"
            },
            {
                "content": "**Example output:**\n\n| max(n.born) |\n| ----------- |\n| 2003        |\n表格内容描述: 本表格包含一列，列名为 \"max(n.born)\"，用于显示出生年份的最大值。根据表格中的数据，最大出生年份为 2003。总体来看，该表格显示在登记的出生年份中，最新的年份为 2003。\n\n- min()\n  Returns the minimum value in a set of values.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n:person)\nRETURN min(n.born)\n```\n\n**Example output:**\n\n| min(n.born) |\n| ----------- |\n| 1000        |\n表格内容描述: 该表格包含一列，列名为 \"min(n.born)\"，表示某一项统计数据的最小值。在表格中，数据内容为 1000，显示这一最小值为 1000。总体来看，该表格简单明了，展示了一个最小出生数量的统计结果。\n\n- percentileCont()\n  Returns the percentile of a value over a group using linear interpolation.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n:person)\nRETURN percentileCont(n.born, 0.4)\n```\n\n**Example output:**\n\n| percentileCont(n.born, 0.4) |\n| --------------------------- |\n| 1953                        |\n表格内容描述: 表格包含一列，列名为“percentileCont(n.born, 0.4)”。该列的唯一数据值为1953。整体来看，该表格显示在出生人数的40百分位数处的值为1953。\n\n该块内容位于文档的第三部分“函数”，具体针对聚合函数的使用示例，包括`max()`、`min()`和`percentileCont()`函数。它展示了这些函数的输入示例、输出结果及相关表格描述，旨在帮助用户理解如何在TuGraph中使用聚合函数进行数据统计分析。"
            },
            {
                "content": "- percentileCont()\n  Returns the percentile of a value over a group using linear interpolation.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n:person)\nRETURN percentileCont(n.born, 0.4)\n```\n\n**Example output:**\n\n| percentileCont(n.born, 0.4) |\n| --------------------------- |\n| 1953                        |\n表格内容描述: 表格包含一列，列名为“percentileCont(n.born, 0.4)”。该列的唯一数据值为1953。整体来看，该表格显示在出生人数的40百分位数处的值为1953。\n\n- percentileDisc()\n  Returns the nearest value to the given percentile over a group using a rounding method.\n  **Scope:** whole instance.\n  **Output:** the percentile of the given value over a group.\n  **Example input:**\n\n```\nMATCH (n:person)\nRETURN percentileDisc(n.born, 0.5)\n```\n\n**Example output:**\n\n| percentileDisc(n.age, 0.5) |\n| -------------------------- |\n| 1959                       |\n表格内容描述: 表格包含一列名为“percentileDisc(n.age, 0.5)”，该列显示了一个百分位数的值。在此表格中，唯一的一行数据为1959。这表示在某项分析中，年龄的50百分位数（中位数）为1959。总体来看，该表格提供了一个与年龄相关的统计数据，指出中位数为1959。\n\n该段落位于文档的第三部分“Functions”下，具体列出了有关统计函数的子章节，详细介绍了`percentileCont()`和`percentileDisc()`函数的功能、示例输入及输出。这些函数用于计算数据集中某一值的百分位数，适用于整合数据分析结果。"
            },
            {
                "content": "```\nMATCH (n:person)\nRETURN percentileDisc(n.born, 0.5)\n```\n\n**Example output:**\n\n| percentileDisc(n.age, 0.5) |\n| -------------------------- |\n| 1959                       |\n表格内容描述: 表格包含一列名为“percentileDisc(n.age, 0.5)”，该列显示了一个百分位数的值。在此表格中，唯一的一行数据为1959。这表示在某项分析中，年龄的50百分位数（中位数）为1959。总体来看，该表格提供了一个与年龄相关的统计数据，指出中位数为1959。\n\n- stDev()\n  Returns the standard deviation for the given value over a group for a sample of a population.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n)\nRETURN stDev(n.born)\n```\n\n**Example output:**\n\n| stDev(n.born)      |\n| ------------------ |\n| 279.53117993401725 |\n表格内容描述: 该表格只有一列，列名为“stDev(n.born)”，表示与出生人数相关的标准偏差。根据表中的数据，出生人数的标准偏差为279.53117993401725。这一数值提供了对出生人数波动程度的量化，反映了样本中出生人数的变化范围。总体而言，表格的内容显示了出生人数在统计学上的离散程度。\n\n- stDevP()\n  Returns the standard deviation for the given value over a group for an entire population.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n)\nRETURN stDevP(n.born)\n```\n\n**Example output:**\n\n该块内容位于文档的“函数”部分，专门讨论了聚合函数，尤其是用于计算百分位数和标准差的函数，包括 `percentileDisc()`、`stDev()` 和 `stDevP()`，并提供了示例输入和输出，以帮助用户理解如何在TuGraph-Cypher中使用这些函数进行数据分析和统计计算。"
            },
            {
                "content": "```\nMATCH (n)\nRETURN stDev(n.born)\n```\n\n**Example output:**\n\n| stDev(n.born)      |\n| ------------------ |\n| 279.53117993401725 |\n表格内容描述: 该表格只有一列，列名为“stDev(n.born)”，表示与出生人数相关的标准偏差。根据表中的数据，出生人数的标准偏差为279.53117993401725。这一数值提供了对出生人数波动程度的量化，反映了样本中出生人数的变化范围。总体而言，表格的内容显示了出生人数在统计学上的离散程度。\n\n- stDevP()\n  Returns the standard deviation for the given value over a group for an entire population.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n)\nRETURN stDevP(n.born)\n```\n\n**Example output:**\n\n| stDevP(n.born)     |\n| ------------------ |\n| 279.3209270423399  |\n表格内容描述: 该表格包含一列，列名为“stDevP(n.born)”，表示在特定样本中，出生人数的标准差。该列中的数据为279.3209270423399，这一数值反映了样本中出生人数的分布波动程度。整体来看，该表格呈现出一个与出生人数相关的统计数据，指示出这一变量的变化幅度。\n\n- variance()\n  Returns the variance for the given value over a group for a sample of a population.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n)\nRETURN variance(n.born)\n```\n\n**Example output:**\n\n该文本块位于文档的第三部分，具体讲述了统计函数中的标准差和方差函数，包括`stDev()`、`stDevP()`和`variance()`的用法及示例。这些函数用于计算与出生年份相关的数据的波动和分布特征，是TuGraph-Cypher查询语言中重要的统计分析工具。"
            },
            {
                "content": "```\nMATCH (n)\nRETURN stDevP(n.born)\n```\n\n**Example output:**\n\n| stDevP(n.born)     |\n| ------------------ |\n| 279.3209270423399  |\n表格内容描述: 该表格包含一列，列名为“stDevP(n.born)”，表示在特定样本中，出生人数的标准差。该列中的数据为279.3209270423399，这一数值反映了样本中出生人数的分布波动程度。整体来看，该表格呈现出一个与出生人数相关的统计数据，指示出这一变量的变化幅度。\n\n- variance()\n  Returns the variance for the given value over a group for a sample of a population.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n)\nRETURN variance(n.born)\n```\n\n**Example output:**\n\n| variance(n.age)   |\n| ----------------- |\n| 78137.68055530392 |\n表格内容描述: 本表格包含一列数据，列名为“variance(n.age)”，表示样本中年龄的方差。该行数据的数值为78137.68055530392，这表明在该样本中，年龄的分布存在一定程度的波动和差异。总体来看，表格显示了年龄数据的方差信息，提示其在样本中相对较大的变异性。\n\n- varianceP()\n  Returns the variance for the given value over a group for an entire population.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n)\nRETURN varianceP(n.born)\n```\n\n**Example output:**\n\n该内容片段位于文档的第三部分，具体涉及函数的部分，特别是描述了与标准差和方差相关的聚合函数的使用示例及其输出结果。这部分内容提供了关于如何在TuGraph-Cypher中使用标准差和方差函数的具体示例，确保用户理解其功能和应用场景。"
            },
            {
                "content": "```\nMATCH (n)\nRETURN variance(n.born)\n```\n\n**Example output:**\n\n| variance(n.age)   |\n| ----------------- |\n| 78137.68055530392 |\n表格内容描述: 本表格包含一列数据，列名为“variance(n.age)”，表示样本中年龄的方差。该行数据的数值为78137.68055530392，这表明在该样本中，年龄的分布存在一定程度的波动和差异。总体来看，表格显示了年龄数据的方差信息，提示其在样本中相对较大的变异性。\n\n- varianceP()\n  Returns the variance for the given value over a group for an entire population.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n)\nRETURN varianceP(n.born)\n```\n\n**Example output:**\n\n| varianceP(n.age)  |\n| ----------------- |\n| 78020.18028379219 |\n表格内容描述: 该表格只有一列，列名为“varianceP(n.age)”。在该列中，只有一个数值数据，具体为78020.18028379219。这一数据代表了某个变量（n.age）的方差值。总体来看，该表格简洁地呈现了一个关于n.age的方差计算结果。\n\n- sum()\n  Returns the sum of a set of numeric values.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n:person)\nRETURN sum(n.born)\n```\n\n**Example output:**\n\n| sum(n.born) |\n| ----------- |\n| 1243062     |\n表格内容描述: 该表格包含一列，列名为“sum(n.born)”，表示出生人数的总和。在该表中，数据的唯一一行显示，总出生人数为1243062。总体来看，该表格记录了一个特定时间段或区域内的出生总数，数值为1243062。\n\n该块内容位于文档的第三部分“函数”下，具体介绍了统计函数，包括方差（variance）、总体方差（varianceP）和总和（sum）的使用示例及其输出结果，旨在帮助用户理解如何在TuGraph-Cypher中进行数据统计分析。"
            },
            {
                "content": "- sum()\n  Returns the sum of a set of numeric values.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (n:person)\nRETURN sum(n.born)\n```\n\n**Example output:**\n\n| sum(n.born) |\n| ----------- |\n| 1243062     |\n表格内容描述: 该表格包含一列，列名为“sum(n.born)”，表示出生人数的总和。在该表中，数据的唯一一行显示，总出生人数为1243062。总体来看，该表格记录了一个特定时间段或区域内的出生总数，数值为1243062。\n\n### 3.5.List Funtions:\n\n- keys()\n  get the field names of some vertex.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (a)\nRETURN keys(a) LIMIT 1\n```\n\n**Example output:**\n\n| keys(a)               |\n| --------------------- |\n| [\"name\",\"age\",\"eyes\"] |\n表格内容描述: 该表格包含一列，列名为\"keys(a)\"。在该列下方，唯一的一行数据为一个包含多个元素的数组，元素包括\"name\"、\"age\"和\"eyes\"。整体来看，表格的内容展示了与个人或对象相关的三个重要属性：姓名、年龄和眼睛颜色。\n\n- labels()/label()\n  Returns a list containing the string representations for all the property names of a node, relationship, or map.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (a)\nRETURN labels(a) LIMIT 1\n```\n\n**Example output:**\n\n该内容位于文档的函数部分，具体属于聚合函数和列表函数的分类，介绍了如何计算出生人数的总和以及获取某个节点的字段名称。"
            },
            {
                "content": "```\nMATCH (a)\nRETURN keys(a) LIMIT 1\n```\n\n**Example output:**\n\n| keys(a)               |\n| --------------------- |\n| [\"name\",\"age\",\"eyes\"] |\n表格内容描述: 该表格包含一列，列名为\"keys(a)\"。在该列下方，唯一的一行数据为一个包含多个元素的数组，元素包括\"name\"、\"age\"和\"eyes\"。整体来看，表格的内容展示了与个人或对象相关的三个重要属性：姓名、年龄和眼睛颜色。\n\n- labels()/label()\n  Returns a list containing the string representations for all the property names of a node, relationship, or map.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (a)\nRETURN labels(a) LIMIT 1\n```\n\n**Example output:**\n\n| labels                 |\n| ---------------------- |\n| [\"Person\"]             |\n表格内容描述:该表格只有一列，列名为“labels”。在该列中，唯一的内容为一个包含“Person”的列表。整体来看，这个表格表示了一个标签，描述了与“Person”相关的内容。\n\n- nodes()\n\n  Get vertex ids of a path\n\n  **Scope:** whole instance.\n\n  **Example input:**\n\n  ```\n  MATCH p = (from {name: 'Bob'})-[*1..]->(to {name: 'Alice\"})\n  RETURN nodes(p)\n  ```\n\n  **Example output:**\n\n  | nodes(p)       |\n  | -------------- |\n  | [0, 1, 10, 12] |\n\n\n### 3.6.Mathematical functions\n\n该部分内容位于文档的“函数”章节，主要介绍了用于获取节点、关系或映射的属性名称和节点ID的函数示例，包括`keys()`、`labels()`和`nodes()`等函数的用法及其输出示例。"
            },
            {
                "content": "**Example output:**\n\n| labels                 |\n| ---------------------- |\n| [\"Person\"]             |\n表格内容描述:该表格只有一列，列名为“labels”。在该列中，唯一的内容为一个包含“Person”的列表。整体来看，这个表格表示了一个标签，描述了与“Person”相关的内容。\n\n- nodes()\n\n  Get vertex ids of a path\n\n  **Scope:** whole instance.\n\n  **Example input:**\n\n  ```\n  MATCH p = (from {name: 'Bob'})-[*1..]->(to {name: 'Alice\"})\n  RETURN nodes(p)\n  ```\n\n  **Example output:**\n\n  | nodes(p)       |\n  | -------------- |\n  | [0, 1, 10, 12] |\n\n\n### 3.6.Mathematical functions\n\n- abs()\n  get the absolute value of some data.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (a:person {name: 'Laurence Fishburne'}),(e:person {name: 'Carrie-Anne Moss'})\nRETURN a.born, e.born, abs(a.born-e.born)\n```\n\n**Example output:**\n\n  | a.born | e.born | abs(a.born - e.born) |\n  |--------|--------|-----------------------|\n  | 1961   | 1967   | 6                     |\n\n该段落位于文档的第三部分，具体介绍了TuGraph中与节点标签和函数相关的内容，涵盖了标签提取、节点ID获取以及数学函数（如绝对值函数）的例子和使用方法，旨在为用户提供实际操作示例和输出格式的清晰说明。"
            },
            {
                "content": "**Example output:**\n\n  | nodes(p)       |\n  | -------------- |\n  | [0, 1, 10, 12] |\n\n\n### 3.6.Mathematical functions\n\n- abs()\n  get the absolute value of some data.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nMATCH (a:person {name: 'Laurence Fishburne'}),(e:person {name: 'Carrie-Anne Moss'})\nRETURN a.born, e.born, abs(a.born-e.born)\n```\n\n**Example output:**\n\n  | a.born | e.born | abs(a.born - e.born) |\n  |--------|--------|-----------------------|\n  | 1961   | 1967   | 6                     |\n\n- ceil()\n  Returns the smallest floating point number that is greater than or equal to a number and equal to a mathematical integer.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN ceil(0.1)\n```\n\n**Example output:**\n\n| ceil(0.1) |\n| --------- |\n| 1.0       |\n表格内容描述: \n\n该表格包含一列，列名为 \"ceil(0.1)\"。在该列中，只有一行数据，其值为 1.0。 \n\n整体概要总结: 本表格展示了计算 0.1 的上取整值，结果为 1.0。\n\n该chunk位于文档的第三部分，涵盖了数学函数的使用说明，其中包括函数如abs()和ceil()的具体应用示例及其输出，帮助用户理解如何在TuGraph-Cypher中进行相关数学计算。"
            },
            {
                "content": "| a.born | e.born | abs(a.born - e.born) |\n  |--------|--------|-----------------------|\n  | 1961   | 1967   | 6                     |\n\n- ceil()\n  Returns the smallest floating point number that is greater than or equal to a number and equal to a mathematical integer.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN ceil(0.1)\n```\n\n**Example output:**\n\n| ceil(0.1) |\n| --------- |\n| 1.0       |\n表格内容描述: \n\n该表格包含一列，列名为 \"ceil(0.1)\"。在该列中，只有一行数据，其值为 1.0。 \n\n整体概要总结: 本表格展示了计算 0.1 的上取整值，结果为 1.0。\n\n- floor()\n  get the largest floating point number that is less than or equal to the given number and equal to a mathematical integer.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN floor(0.9)\n```\n\n**Example output:**\n\n| floor(0.9) |\n| ---------- |\n| 0.0        |\n表格内容描述: 该表格包含一列，列名为“floor(0.9)”。在这一列中，只有一行数据，数值为0.0。整体来看，表格展示了对0.9进行下取整后的结果，即为0.0。\n\n- round()\n  Returns the value of a number rounded to the nearest integer.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN round(3.141592)\n```\n\n该块内容位于文档的“3.6. 数学函数”部分，其中详细介绍了数学函数如`abs()`、`ceil()`、`floor()`和`round()`的用法、输入示例及输出示例，旨在帮助用户理解和使用TuGraph-Cypher中的数学运算功能。"
            },
            {
                "content": "```\nRETURN floor(0.9)\n```\n\n**Example output:**\n\n| floor(0.9) |\n| ---------- |\n| 0.0        |\n表格内容描述: 该表格包含一列，列名为“floor(0.9)”。在这一列中，只有一行数据，数值为0.0。整体来看，表格展示了对0.9进行下取整后的结果，即为0.0。\n\n- round()\n  Returns the value of a number rounded to the nearest integer.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN round(3.141592)\n```\n\n**Example output:**\n\n| round |\n| ----- |\n| 3     |\n表格内容描述: 该表格包含一列，列名为“round”。在该列中，只有一行数据，数值为3。总体来看，表格展示的信息非常简洁，主要传达了一个值，即“round”的数值为3。\n\n- rand()\n  Returns returns a random floating point number in the range from 0 (inclusive) to 1 exclusive).\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN rand()\n```\n\n**Example output:**\n\n| rand()             |\n| ------------------ |\n| 0.9797131960534085 |\n表格内容描述: \n\n该表格包含一列数据，列名为“rand()”。在这一列中，只有一行数据，其值为0.9797131960534085。\n\n总体来看，该表格展示了一个随机生成的数值0.9797131960534085。\n\n该段落位于文档的第三部分“函数”中，具体介绍了数学函数的使用示例，包括对浮点数和整数的取整、四舍五入以及生成随机数的功能，配有使用示例和输出结果的表格。"
            },
            {
                "content": "| round |\n| ----- |\n| 3     |\n表格内容描述: 该表格包含一列，列名为“round”。在该列中，只有一行数据，数值为3。总体来看，表格展示的信息非常简洁，主要传达了一个值，即“round”的数值为3。\n\n- rand()\n  Returns returns a random floating point number in the range from 0 (inclusive) to 1 exclusive).\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN rand()\n```\n\n**Example output:**\n\n| rand()             |\n| ------------------ |\n| 0.9797131960534085 |\n表格内容描述: \n\n该表格包含一列数据，列名为“rand()”。在这一列中，只有一行数据，其值为0.9797131960534085。\n\n总体来看，该表格展示了一个随机生成的数值0.9797131960534085。\n\n- sign()\n  Get the signum of the given number: 0 if the number is 0, -1 for any negative number, and 1 for any positive number.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN sign(-17), sign(0.1)\n```\n\n**Example output:**\n\n| sign(-17) | sign(0.1) |\n| --------- | --------- |\n| -1        | 1         |\n表格内容描述: 该表格包含两列，分别为“sign(-17)”和“sign(0.1)”。第一行的数据为“-1”和“1”。具体来说，sign(-17)的值为-1，表示输入的-17是一个负数；sign(0.1)的值为1，表示输入的0.1是一个正数。整体来看，该表格展示了不同数值的符号信息，表明-17为负，0.1为正。\n\nTuGraph 查询语言与 OpenCypher 的不同点如下：\n\n该内容位于文档的第三部分“函数”中，具体讨论了与数学运算相关的函数，包括“round”、“rand”和“sign”。这些函数的用法、示例输入输出及其应用范围被详细说明，帮助用户了解如何在TuGraph中进行数学计算及其区别于OpenCypher的相关信息。"
            },
            {
                "content": "- sign()\n  Get the signum of the given number: 0 if the number is 0, -1 for any negative number, and 1 for any positive number.\n  **Scope:** whole instance.\n  **Example input:**\n\n```\nRETURN sign(-17), sign(0.1)\n```\n\n**Example output:**\n\n| sign(-17) | sign(0.1) |\n| --------- | --------- |\n| -1        | 1         |\n表格内容描述: 该表格包含两列，分别为“sign(-17)”和“sign(0.1)”。第一行的数据为“-1”和“1”。具体来说，sign(-17)的值为-1，表示输入的-17是一个负数；sign(0.1)的值为1，表示输入的0.1是一个正数。整体来看，该表格展示了不同数值的符号信息，表明-17为负，0.1为正。\n\nTuGraph 查询语言与 OpenCypher 的不同点如下：\n\n- Label 数量\n  - TuGraph: Each node/relationship must have one and only one label. So error occurs when there is no label, and the 1st label will be picked as the label if there are more than one label.\n  - OpenCypher: One node/relationship may have 0 to many labels.\n- Schema.\n  - TuGraph: TuGraph has strong schema\n  - OpenCypher: schema-less\n\n## 4.附录1. 语法扩充及不同\n\nTuGraph查询语言与OpenCypher的不同点如下：\n\n该片段涵盖了TuGraph查询语言中的一个数学函数`sign()`，主要介绍了其功能、用法示例及输出结果，并提供了一个表格展示示例的详细信息。此外，片段还提及了TuGraph与OpenCypher在标签数量和模式方面的主要区别，为读者提供了对两者不同之处的整体理解。这部分内容属于文档的函数功能章节，并联系到后续的语法扩展及不同点讨论。"
            },
            {
                "content": "TuGraph 查询语言与 OpenCypher 的不同点如下：\n\n- Label 数量\n  - TuGraph: Each node/relationship must have one and only one label. So error occurs when there is no label, and the 1st label will be picked as the label if there are more than one label.\n  - OpenCypher: One node/relationship may have 0 to many labels.\n- Schema.\n  - TuGraph: TuGraph has strong schema\n  - OpenCypher: schema-less\n\n## 4.附录1. 语法扩充及不同\n\nTuGraph查询语言与OpenCypher的不同点如下：\n\n- Label数量\n  - TuGraph: Each node/relationship must have one and only one label. So error occurs when there is no label, and the 1st label will be picked as the label if there are more than one label.\n  - OpenCypher: One node/relationship may have 0 to many labels.\n- Schema.\n  - TuGraph: TuGraph has strong schema\n  - OpenCypher: schema-less\n\n## 5.附录2. 内置procedures列表\n### 5.1.procedures样例\n\n* dbms.procedures()\n\n  Lists all available procedures.\n\n  **Scope:** whole instance.\n\n  **Output:** a list of {`signature`, `name`}.\n\n  **Example input:**\n\n  ```\n  CALL dbms.procedures()\n  ```\n\n该段落位于文档的第4部分和第5部分之间，主要比较TuGraph查询语言与OpenCypher在标签数量和架构方面的不同之处，属于关于语法扩展和差异的讨论内容，紧接着介绍内置程序列表的相关信息。"
            },
            {
                "content": "## 5.附录2. 内置procedures列表\n### 5.1.procedures样例\n\n* dbms.procedures()\n\n  Lists all available procedures.\n\n  **Scope:** whole instance.\n\n  **Output:** a list of {`signature`, `name`}.\n\n  **Example input:**\n\n  ```\n  CALL dbms.procedures()\n  ```\n\n  **Example output:**\n\n  | signature                        | name         |\n  | ---------------------------------------------------- | -------------------- |\n  | db.vertexLabels() :: (label::STRING)               | db.vertexLabels        |\n  | db.edgeLabels() :: (edgeLabels::STRING) | db.edgeLabels |\n  | db.indexes() :: (index::LIST)            | db.indexes       |\n  | ...                          | ...          |\n\n* db.subgraph()\n\n  **Scope:** whole instance.\n\n  **Parameters:**\n\n该块内容位于文档的第五部分，专注于TuGraph的内置存储过程，具体介绍了可用存储过程的示例和参数详情，旨在帮助用户理解如何调用和使用这些存储过程进行图数据库操作。"
            },
            {
                "content": "**Example output:**\n\n  | signature                        | name         |\n  | ---------------------------------------------------- | -------------------- |\n  | db.vertexLabels() :: (label::STRING)               | db.vertexLabels        |\n  | db.edgeLabels() :: (edgeLabels::STRING) | db.edgeLabels |\n  | db.indexes() :: (index::LIST)            | db.indexes       |\n  | ...                          | ...          |\n\n* db.subgraph()\n\n  **Scope:** whole instance.\n\n  **Parameters:**\n\n  | parameter  | parameter type | description                                                           |\n  | ---------- | -------------- | --------------------------------------------------------------------- |\n  | vids       | list           | list of vertex id                                                     |\n\n  **Output:**\n\n  Get a json containing all the properties of nodes and relationships.\n\n  **Example input:**\n\n  ```\n  CALL db.subgraph([3937,4126,4066,4010])\n  ```\n\n  **Example output**\n\n该块内容位于文档的第5.2节“内置procedures完整列表”中，具体介绍了TuGraph中的系统内置过程，包括每个过程的签名、作用范围、参数及输出示例，旨在帮助用户了解可用的内置功能及其使用方法。"
            },
            {
                "content": "| subgraph |\n  | -------- |\n\n该内容来自于文档第5.1节中的“db.subgraph”部分，描述了一个内置的存储过程，该过程用于列出点的子图，并提供了其输入和输出的相关信息。"
            },
            {
                "content": "| {\"nodes\":[{\"identity\":3937,\"label\":\"movie\",\"properties\":{\"duration\":136,\"id\":1,\"poster_image\":\"http://image.tmdb.org/t/p/w185/gynBNzwyaHKtXqlEKKLioNkjKgN.jpg\",\"rated\":\"R\",\"summary\":\"Thomas A. Anderson is a man living two lives. By day he is an average computer programmer and by night a malevolent hacker known as Neo who finds himself targeted by the police when he is contacted by Morpheus a legendary computer hacker who reveals the shocking truth about our reality.\",\"tagline\":\"Welcome to the Real World.\",\"title\":\"The\n\n该片段展示了一个电影节点的详细信息，包括其属性如持续时间、ID、海报图片、评级、摘要、标签和标题，属于文档中关于图数据库中节点和关系属性的部分，总体上涉及图数据库的节点结构和属性管理。"
            },
            {
                "content": "A. Anderson is a man living two lives. By day he is an average computer programmer and by night a malevolent hacker known as Neo who finds himself targeted by the police when he is contacted by Morpheus a legendary computer hacker who reveals the shocking truth about our reality.\",\"tagline\":\"Welcome to the Real World.\",\"title\":\"The Matrix\"}},{\"identity\":4010,\"label\":\"user\",\"properties\":{\"id\":44,\"login\":\"Howard\"}},{\"identity\":4066,\"label\":\"user\",\"properties\":{\"id\":202,\"login\":\"Enoch\"}},{\"identity\":4126,\"label\":\"user\",\"properties\":{\"id\":464,\"login\":\"Wilburn\"}}],\"relationships\":[{\"dst\":4126,\"forward\":true,\"identity\":0,\"label\":\"is_friend\",\"label_id\":3,\"src\":4010,\"temporal_id\":0},{\"dst\":4010,\"forward\":true,\"identity\":0,\"label\":\"is_friend\",\"label_id\":3,\"src\":4066,\"temporal_id\":0},{\"dst\":4066,\"forward\":true,\"identity\":0,\"label\":\"is_friend\",\"label_id\":3,\"src\":4126,\"temporal_id\":0}]} |\n\n该片段包含了关于电影《黑客帝国》及相关角色的描述，包括主角A. Anderson（Neo）和多个用户的属性信息，属于文档中关于图数据库中节点和关系的详细数据结构示例，适用于展示如何在TuGraph中表示复杂的对象和其关系。"
            },
            {
                "content": "* db.vertexLabels()\n\n  Lists all available vertex labels of vertex.\n\n  **Scope:** whole instance.\n\n  **Output:** a list of {`name`}.\n\n  **Example input:**\n\n  ```\n  CALL db.vertexLabels()\n  ```\n  **Example output:**\n\n    | label   |\n    | ------- |\n    | genre   |\n    | keyword |\n    | movie   |\n    | ...     |\n\n* db.edgeLabels()\n\n  Lists all available labels of edges.\n\n  **Scope:** whole instance.\n\n  **Output:** a list of {edge labels}.\n\n  **Example input:**\n\n  ```\n  CALL db.edgeLabels()\n  ```\n\n  **Example output:**\n\n  | relationshipType |\n  | ---------------- |\n  | acted_in     |\n  | directed     |\n  | ...          |\n\n* db.createVertexLabel(label_name, primary_field, field_spec...)\n\n  Create a vertex label.\n\n  **Scope:** whole instance.\n\n  **Parameters:**\n\n该内容位于文档的“5.附录2. 内置procedures列表”部分，主要介绍了TuGraph中的几种内置程序，包括列出所有顶点标签和边标签的功能，以及创建顶点标签的方法。这些程序的描述包括其作用、作用范围、输入输出示例等，有助于用户了解如何操作TuGraph数据库中的标签。"
            },
            {
                "content": "* db.edgeLabels()\n\n  Lists all available labels of edges.\n\n  **Scope:** whole instance.\n\n  **Output:** a list of {edge labels}.\n\n  **Example input:**\n\n  ```\n  CALL db.edgeLabels()\n  ```\n\n  **Example output:**\n\n  | relationshipType |\n  | ---------------- |\n  | acted_in     |\n  | directed     |\n  | ...          |\n\n* db.createVertexLabel(label_name, primary_field, field_spec...)\n\n  Create a vertex label.\n\n  **Scope:** whole instance.\n\n  **Parameters:**\n\n  | parameter  | parameter type | description          |\n  | ---------- | -------------- | ------------------------ |\n  | label_name | string     | name of  vertex label    |\n  | primary_field | string  | primary field of vertex label |\n  | field_spec | list       | specification of a field |\n\n   in which each `field_spec` is a list of string in the form of `[field_name, field_type, true]`, where true is specified only for optional fields.\n\n    **Output:** If successful, it returns a success message.\n\n    **Example input:**\n\n该段落位于文档的“内置procedures列表”部分，具体介绍了与边标签（edge labels）相关的命令，包括列出所有可用的边标签和创建顶点标签的操作。该部分提供了相关命令的输入示例、输出格式和参数说明，以帮助用户有效使用这些功能。"
            },
            {
                "content": "in which each `field_spec` is a list of string in the form of `[field_name, field_type, true]`, where true is specified only for optional fields.\n\n    **Output:** If successful, it returns a success message.\n\n    **Example input:**\n\n    ```\n    CALL db.createVertexLabel('Person', 'id', 'id', 'int64', false, 'name', 'string', true)\n    ```\n\n    **Example output:**\n\n    ```\n    Added label [Person]\n    ```\n\n* db.getLabelSchema(label_type, label_name)\n\n  Get the schema definition of the label in a subgraph.\n\n  **Scope:** subgraph, as specified in the `graph` parameter in REST or RPC request.\n\n  **Parameters:**\n\n  | parameter  | parameter type | description           |\n  | ---------- | -------------- | ------------------------- |\n  | label_type | string     | either 'vertex' or 'edge' |\n  | label_name | string     | name of the label     |\n\n  **Output:** a list of label specifications, in which each element is a list of the following fields:\n\n该内容位于文档的第五部分，即“附录2. 内置procedures列表”下，具体讨论了创建标签和获取标签架构的过程及其参数、输出示例，提供了数据库中如何定义和使用字段规格的相关信息。"
            },
            {
                "content": "Get the schema definition of the label in a subgraph.\n\n  **Scope:** subgraph, as specified in the `graph` parameter in REST or RPC request.\n\n  **Parameters:**\n\n  | parameter  | parameter type | description           |\n  | ---------- | -------------- | ------------------------- |\n  | label_type | string     | either 'vertex' or 'edge' |\n  | label_name | string     | name of the label     |\n\n  **Output:** a list of label specifications, in which each element is a list of the following fields:\n\n  | field_name | field_type | description           |\n  | ---------- | ---------- | ----------------------------- |\n  | name       | string     | name of the field         |\n  | type       | string     | type of the field         |\n  | optional   | boolean    | whether the field is optional |\n\n  **Example input:**\n\n  ```\n  CALL db.getLabelSchema('vertex', 'Person')\n  ```\n\n  **Example output:**\n\n在本文件的第5.1节“内置procedures列表”中，介绍了多种数据库操作的内置过程，其中包含了查询标签模式的操作。该段落详细描述了如何获取子图中标签的模式定义，包括参数、输出格式及示例输入和输出。"
            },
            {
                "content": "**Output:** a list of label specifications, in which each element is a list of the following fields:\n\n  | field_name | field_type | description           |\n  | ---------- | ---------- | ----------------------------- |\n  | name       | string     | name of the field         |\n  | type       | string     | type of the field         |\n  | optional   | boolean    | whether the field is optional |\n\n  **Example input:**\n\n  ```\n  CALL db.getLabelSchema('vertex', 'Person')\n  ```\n\n  **Example output:**\n\n  | name     | type   | optional |\n  | ------------ | ------ | -------- |\n  | id       | INT32  | false    |\n  | born     | INT32  | true     |\n  | name     | STRING | true     |\n  | poster_image | STRING | true     |\n\n* db.createLabel(label_type, label_name, extra, field_spec...)\n\n  Create a vertex or edge label.\n\n  **Parameters:**\n\n该段落位于文档的第五部分“附录2. 内置procedures列表”中，具体介绍了在图数据库中获取标签架构信息的存储格式及示例，包括字段名称、类型及是否为可选字段，并展示了相应的调用示例。同时，接下来的内容将介绍如何创建顶点或边的标签。"
            },
            {
                "content": "**Example input:**\n\n  ```\n  CALL db.getLabelSchema('vertex', 'Person')\n  ```\n\n  **Example output:**\n\n  | name     | type   | optional |\n  | ------------ | ------ | -------- |\n  | id       | INT32  | false    |\n  | born     | INT32  | true     |\n  | name     | STRING | true     |\n  | poster_image | STRING | true     |\n\n* db.createLabel(label_type, label_name, extra, field_spec...)\n\n  Create a vertex or edge label.\n\n  **Parameters:**\n\n  | parameter  | parameter type | description           |\n  | ---------- | -------------- | ------------------------- |\n  | label_type | string     | either 'vertex' or 'edge' |\n  | label_name | string     | name of the label     |\n  | extra      | string     | for edge, it means constraints; for vertex, it means primary property |\n  | field_spec | list       | specification of a field  |\n\n该内容位于文档的第五部分“附录2. 内置procedures列表”，具体描述了 `db.getLabelSchema` 和 `db.createLabel` 两个内置过程的用法及其参数说明。"
            },
            {
                "content": "* db.createLabel(label_type, label_name, extra, field_spec...)\n\n  Create a vertex or edge label.\n\n  **Parameters:**\n\n  | parameter  | parameter type | description           |\n  | ---------- | -------------- | ------------------------- |\n  | label_type | string     | either 'vertex' or 'edge' |\n  | label_name | string     | name of the label     |\n  | extra      | string     | for edge, it means constraints; for vertex, it means primary property |\n  | field_spec | list       | specification of a field  |\n\n    in which each `field_spec` is a list of string in the form of `[field_name, field_type, optional]`.\n    for edge, `extra` should be a json array string, like this `[[\"label1\",\"label2\"], [\"label3\",\"label4\"]]`, if edge has no constraints, give an empty json array, like this `[]`\n\n  **Output:**\n\n  If successful, it returns a success message.\n\n  **Example input:**\n\n该块内容来自于文档的第5.1节“内置procedures样例”，具体描述了`db.createLabel`命令的功能、参数、输出及示例输入。这一节整体上列出了图数据库中可用的内置存储过程及其详细信息，方便用户进行图形操作和管理。"
            },
            {
                "content": "in which each `field_spec` is a list of string in the form of `[field_name, field_type, optional]`.\n    for edge, `extra` should be a json array string, like this `[[\"label1\",\"label2\"], [\"label3\",\"label4\"]]`, if edge has no constraints, give an empty json array, like this `[]`\n\n  **Output:**\n\n  If successful, it returns a success message.\n\n  **Example input:**\n\n  ```\n  CALL db.createLabel('vertex', 'new_label', 'id', ['id','int32',false], ['name','string', true]);\n  CALL db.createLabel('edge', 'new_edge', '[[\"id1\",\"id2\"]]', ['id','int32',false], ['name', 'string', true]);\n  ```\n\n  **Example output:**\n\n  ```\n  Vertex label [new_label] successfully added.\n  ```\n\n* db.deleteLabel(label_type, label_name)\n\n  Delete a vertex or edge label.\n\n  **Parameters:**\n\n  | parameter  | parameter type | description           |\n  | ---------- | -------------- | ------------------------- |\n  | label_type | string     | either 'vertex' or 'edge' |\n  | label_name | string     | name of the label     |\n\n  **Output:**\n\n该块内容位于文档的第五部分“附录2. 内置procedures列表”中，主要介绍了创建标签和删除标签的参数要求及示例。它详细说明了如何定义标签的字段规范以及边的约束条件，帮助用户理解如何在TuGraph中有效管理标签结构。"
            },
            {
                "content": "**Example output:**\n\n  ```\n  Vertex label [new_label] successfully added.\n  ```\n\n* db.deleteLabel(label_type, label_name)\n\n  Delete a vertex or edge label.\n\n  **Parameters:**\n\n  | parameter  | parameter type | description           |\n  | ---------- | -------------- | ------------------------- |\n  | label_type | string     | either 'vertex' or 'edge' |\n  | label_name | string     | name of the label     |\n\n  **Output:**\n\n  | field_name | field_type | description              |\n  | ---------- | ---------- | -------------------------------- |\n  | affected   | integer    | number of vertexes/edges deleted |\n\n  **Example input:**\n\n  ```\n  CALL db.deleteLabel('vertex', 'Person')\n  ```\n\n  **Example output:**\n\n  | affected |\n  | -------- |\n  | 1024     |\n\n* db.alterLabelDelFields(label_type, label_name, field_names)\n\n  Delete specified fields from the label.\n\n  **Parameters:**\n\n该代码块位于文档的“附录2. 内置procedures列表”部分，具体描述了用于删除图数据库中节点或边标签的内置过程（`db.deleteLabel`）及其相关参数、输入输出示例。这一部分帮助用户了解如何管理图数据库中的标签设置。"
            },
            {
                "content": "**Output:**\n\n  | field_name | field_type | description              |\n  | ---------- | ---------- | -------------------------------- |\n  | affected   | integer    | number of vertexes/edges deleted |\n\n  **Example input:**\n\n  ```\n  CALL db.deleteLabel('vertex', 'Person')\n  ```\n\n  **Example output:**\n\n  | affected |\n  | -------- |\n  | 1024     |\n\n* db.alterLabelDelFields(label_type, label_name, field_names)\n\n  Delete specified fields from the label.\n\n  **Parameters:**\n\n  | parameter   | parameter type  | description           |\n  | ----------- | --------------- | ----------------------------- |\n  | label_type  | string      | either 'vertex' or 'edge'     |\n  | label_name  | string      | name of the label         |\n  | field_names | list of strings | names of the fields to delete |\n\n  **Output:**\n\n  | field_name | field_type | description               |\n  | ---------- | ---------- | --------------------------------- |\n  | affected   | integer    | number of vertexes/edges modified |\n\n  **Example input:**\n\n该段落位于文档的\"5.2.内置procedures完整列表\"部分，详细描述了`db.deleteLabel`和`db.alterLabelDelFields`这两个程序的用法，包括其参数、输出格式及示例输入输出，使用户能够理解如何在TuGraph中删除标签及指定字段。"
            },
            {
                "content": "**Output:**\n\n  | field_name | field_type | description               |\n  | ---------- | ---------- | --------------------------------- |\n  | affected   | integer    | number of vertexes/edges modified |\n\n  **Example input:**\n\n  ```\n  CALL db.alterLabelDelFields('vertex', 'Person', ['name', 'image'])\n  ```\n\n  **Example output:**\n\n  | affected |\n  | -------- |\n  | 1024     |\n\n* db.alterLabelAddFields(label_type, label_name, field_value_spec...)\n\n  Adds specified fields to the label.\n\n  **Parameters:**\n\n  | parameter    | parameter type | description           |\n  | ---------------- | -------------- | ------------------------- |\n  | label_type       | string     | either 'vertex' or 'edge' |\n  | label_name       | string     | name of the label     |\n  | field_value_spec | list       | specification of a field  |\n\n    in which each `field_value_spec` is a list of string in the form of `[field_name, field_type, field_value, optional]`, where: `field_value` is the default value of the field.\n\n  **Output:**\n\n该段落位于文档的第5部分“附录2. 内置procedures列表”中，具体描述了TuGraph查询语言中的内置过程，尤其是与调整标签字段相关的过程，包括删除和添加字段的具体参数、输出及示例输入输出。"
            },
            {
                "content": "| parameter    | parameter type | description           |\n  | ---------------- | -------------- | ------------------------- |\n  | label_type       | string     | either 'vertex' or 'edge' |\n  | label_name       | string     | name of the label     |\n  | field_value_spec | list       | specification of a field  |\n\n    in which each `field_value_spec` is a list of string in the form of `[field_name, field_type, field_value, optional]`, where: `field_value` is the default value of the field.\n\n  **Output:**\n\n  | field_name | field_type | description               |\n  | ---------- | ---------- | --------------------------------- |\n  | affected   | integer    | number of vertexes/edges modified |\n\n  **Example input:**\n\n  ```\n  CALL db.alterLabelAddFields(\n  'vertex',\n  'new_label',\n  ['birth_date', DATE, '', true],\n  ['img', BLOB, '', true])\n  ```\n\n  **Example output:**\n\n  | affected |\n  | -------- |\n  | 1024     |\n\n* db.alterLabelModFields(label_type, label_name, field_spec...)\n\n该内容位于文档的第5.2节“内置procedures完整列表”中，具体描述了`db.alterLabelAddFields`命令的参数、输出以及示例输入输出，主要用于在图数据库中为指定的标签添加新的字段。"
            },
            {
                "content": "**Output:**\n\n  | field_name | field_type | description               |\n  | ---------- | ---------- | --------------------------------- |\n  | affected   | integer    | number of vertexes/edges modified |\n\n  **Example input:**\n\n  ```\n  CALL db.alterLabelAddFields(\n  'vertex',\n  'new_label',\n  ['birth_date', DATE, '', true],\n  ['img', BLOB, '', true])\n  ```\n\n  **Example output:**\n\n  | affected |\n  | -------- |\n  | 1024     |\n\n* db.alterLabelModFields(label_type, label_name, field_spec...)\n\n  Modifies the specified fields in the label.\n\n  **Parameters:**\n\n  | parameter  | parameter type | description           |\n  | ---------- | -------------- | ------------------------- |\n  | label_type | string     | either 'vertex' or 'edge' |\n  | label_name | string     | name of the label     |\n  | field_spec | list       | specification of a field  |\n\n    in which each `field_spec` is a list of string in the form of `[field_name, field_type, optional]`.The target field should exist.\n\n  **Output:**\n\n该块内容位于文档的“附录2. 内置procedures列表”部分，主要描述了`db.alterLabelAddFields`和`db.alterLabelModFields`两个存储过程的功能、参数和输出示例，属于对图数据库标签管理相关操作的详细说明。"
            },
            {
                "content": "Modifies the specified fields in the label.\n\n  **Parameters:**\n\n  | parameter  | parameter type | description           |\n  | ---------- | -------------- | ------------------------- |\n  | label_type | string     | either 'vertex' or 'edge' |\n  | label_name | string     | name of the label     |\n  | field_spec | list       | specification of a field  |\n\n    in which each `field_spec` is a list of string in the form of `[field_name, field_type, optional]`.The target field should exist.\n\n  **Output:**\n\n  | field_name | field_type | description               |\n  | ---------- | ---------- | --------------------------------- |\n  | affected   | integer    | number of vertexes/edges modified |\n\n  **Example input:**\n\n    ```\n    CALL db.alterLabelModFields(\n    'vertex',\n    'new_label',\n    ['birth_date', DATETIME, true],\n    ['gender', BOOL, true])\n    ```\n\n  **Example output:**\n\n  | affected |\n  | -------- |\n  | 1024     |\n\n* db.createEdgeLabel( label_name, field_spec...)\n\n  Create an edge label.\n\n该文本块位于文档的「附录2. 内置procedures列表」部分，具体描述了`db.alterLabelModFields`这一内置过程的功能和用法，涉及到如何修改指定标签中的字段，包括参数说明、输出结果及示例输入输出。"
            },
            {
                "content": "| field_name | field_type | description               |\n  | ---------- | ---------- | --------------------------------- |\n  | affected   | integer    | number of vertexes/edges modified |\n\n  **Example input:**\n\n    ```\n    CALL db.alterLabelModFields(\n    'vertex',\n    'new_label',\n    ['birth_date', DATETIME, true],\n    ['gender', BOOL, true])\n    ```\n\n  **Example output:**\n\n  | affected |\n  | -------- |\n  | 1024     |\n\n* db.createEdgeLabel( label_name, field_spec...)\n\n  Create an edge label.\n\n  **Parameters:**\n\n  | parameter  | parameter type | description          |\n  | ---------- | -------------- | ------------------------ |\n  | label_name | string     | name of the label    |\n  | edge_constraints | string | edge constraints |\n  | field_spec | list       | specification of a field |\n\n  in which each `field_spec` is a list of string in the form of `[field_name, field_type, optional]`, where optional is specified as true, only for  optional fields.\n\n该块内容位于文档的第5部分“附录2. 内置procedures列表”中，具体介绍了`db.alterLabelModFields`和`db.createEdgeLabel`两个程序的功能、参数及示例。此部分主要集中于图数据库中的标签管理和边标签创建的相关操作。"
            },
            {
                "content": "Create an edge label.\n\n  **Parameters:**\n\n  | parameter  | parameter type | description          |\n  | ---------- | -------------- | ------------------------ |\n  | label_name | string     | name of the label    |\n  | edge_constraints | string | edge constraints |\n  | field_spec | list       | specification of a field |\n\n  in which each `field_spec` is a list of string in the form of `[field_name, field_type, optional]`, where optional is specified as true, only for  optional fields.\n\n  `edge_constraints` is a json array string, This parameter limits the combination of starting and ending vertex of the edge, for example: `'[[\"vertex_label1\",\"vertex_label2\"],[\"vertex_label3\",\"vertex_label4\"]]'`, which limits the edge direction can only be from `vertex_label1` to `vertex_label2` or from `vertex_label3` to `vertex_label4`. If you don't want to have any constraints, give an empty array string, like this `'[]'`\n\n  **Output:**\n\n    If successful, it returns a success message.\n\n   **Example input:**\n\n该片段位于文档的“5.2.内置procedures完整列表”部分，具体介绍了如何创建边标签的具体参数、说明以及示例输入。这一内容属于图数据库操作的一个重要功能，适用于用户在进行边标签定义时参考。"
            },
            {
                "content": "**Output:**\n\n    If successful, it returns a success message.\n\n   **Example input:**\n\n  ```\n  CALL db.createEdgeLabel('KNOWS', '[]', 'name', 'int32', true)\n  ```\n\n  **Example output:**\n\n  ```\n  Added type [KNOWS]\n  ```\n\n* db.addIndex(label_name, field_name, unique)\n\n  create an index on some field of one vertex label .\n\n  **Parameters:**\n\n  | parameter | parameter type | description               |\n  | ---------- | -------------- | ------------------------------------- |\n  | label_name | string     | name of the label             |\n  | field_name | string     | specification of a field          |\n  | unique  | boolean    | Specifies whether the index is unique |\n\n   **Output:**\n\n    If successful, it returns a success message.\n\n   **Example input:**\n\n  ```\n  CALL db.addIndex('Person', 'id', true)\n  ```\n\n   **Example output:**\n\n  ```\n  Added index [Perosn:id]\n  ```\n* db.addEdgeIndex(label_name, field_name, unique, pair_unique)\n\n  create an index on some field of one edge label .\n\n  **Parameters:**\n\n该段落位于文档的\"5.2.内置procedures完整列表\"部分，主要介绍了创建边标签和索引的相关命令及其参数、输出示例，包括`db.createEdgeLabel`、`db.addIndex`和`db.addEdgeIndex`的使用方式。这部分内容为用户提供了在TuGraph中管理标签和索引的功能与示例。"
            },
            {
                "content": "**Output:**\n\n    If successful, it returns a success message.\n\n   **Example input:**\n\n  ```\n  CALL db.addIndex('Person', 'id', true)\n  ```\n\n   **Example output:**\n\n  ```\n  Added index [Perosn:id]\n  ```\n* db.addEdgeIndex(label_name, field_name, unique, pair_unique)\n\n  create an index on some field of one edge label .\n\n  **Parameters:**\n\n  | parameter | parameter type | description               |\n    | ---------- | -------------- | ------------------------------------- |\n  | label_name | string     | name of the label             |\n  | field_name | string     | specification of a field          |\n  | unique  | boolean    | Specifies whether the index is unique |\n  | pair_unique | boolean    | Specifies whether the index is pair_unique |\n\n  **Output:**\n\n  If successful, it returns a success message.\n\n  **Example input:**\n\n  ```\n  CALL db.addEdgeIndex('BornIn', 'id', true, false)\n  ```\n\n  **Example output:**\n\n  ```\n  Added index [BornIn:id]\n  ```\n\n此块内容位于文档的第5.2节“内置procedures完整列表”中，具体是关于`db.addIndex`和`db.addEdgeIndex`两个过程的描述。这部分为用户提供了如何在图数据库中为顶点和边标签创建索引的示例和参数说明，帮助用户理解和使用这些功能。"
            },
            {
                "content": "**Output:**\n\n  If successful, it returns a success message.\n\n  **Example input:**\n\n  ```\n  CALL db.addEdgeIndex('BornIn', 'id', true, false)\n  ```\n\n  **Example output:**\n\n  ```\n  Added index [BornIn:id]\n  ```\n\n* dbms.security.changePassword(current_password ,new_password)\n\n  Change the current user's password.\n\n  **Parameters:**\n\n  | parameter    | parameter type | description      |\n  | ---------------- | -------------- | -------------------- |\n  | current_password | string     | the current password |\n  | new_password     | string     | new password     |\n\n  **Output:**\n\n    If successful, it returns a success message.\n\n   **Example input:**\n\n  ```\n  CALL dbms.security.changePassword('73@TuGraph','admin')\n  ```\n\n   **Example output:**\n\n  ```\n  true\n  ```\n\n* dbms.security.changeUserPassword(user_name, new_password)\n\n  Change the current user's password.\n\n  **Parameters:**\n\n该块内容位于文档的第5.2节“内置procedures完整列表”中，主要描述与用户密码管理和索引创建相关的程序，包括更改用户密码、创建边索引的示例输入和输出，以及相关参数的说明。这部分内容有助于用户理解如何在TuGraph中管理用户安全及数据结构。"
            },
            {
                "content": "**Output:**\n\n    If successful, it returns a success message.\n\n   **Example input:**\n\n  ```\n  CALL dbms.security.changePassword('73@TuGraph','admin')\n  ```\n\n   **Example output:**\n\n  ```\n  true\n  ```\n\n* dbms.security.changeUserPassword(user_name, new_password)\n\n  Change the current user's password.\n\n  **Parameters:**\n\n  | parameter    | parameter type | description     |\n  | ------------ | -------------- | --------------- |\n  | user_name    | string     | the user's name |\n  | new_password | string     | new password    |\n\n  **Output:**\n\n    If successful, it returns a success message.\n\n   **Example input:**\n\n  ```\n  CALL dbms.security.changeUserPassword('quest','73@TuGraph')\n  ```\n\n  **Example output:**\n\n  ```\n  true\n  ```\n\n* dbms.security.createUser(user_name, password)\n\n  create  new user on this graph database.\n\n  **Parameters:**\n\n该片段位于文档的内置程序列表部分，具体介绍了与用户安全相关的程序，包括更改当前用户密码、改变指定用户密码和创建新用户的操作及其参数说明。"
            },
            {
                "content": "**Output:**\n\n    If successful, it returns a success message.\n\n   **Example input:**\n\n  ```\n  CALL dbms.security.changeUserPassword('quest','73@TuGraph')\n  ```\n\n  **Example output:**\n\n  ```\n  true\n  ```\n\n* dbms.security.createUser(user_name, password)\n\n  create  new user on this graph database.\n\n  **Parameters:**\n\n  | parameter | parameter type | description              |\n  | --------- | -------------- | -------------------------------- |\n  | user_name | string     | the new user name        |\n  | password  | string     | the password of new user     |\n  \n   **Output:**\n  \n    If successful, it returns a success message.\n  \n   **Example input:**\n  \n  ```\n  CALL dbms.security.createUser('quest',\"admin\")\n  ```\n  \n   **Example output:**\n  \n  ```\n  true\n  ```\n  \n* dbms.security.deleteUser(user_name)\n\n  delete user on this graph database.\n\n  **Parameters:**\n\n这个片段位于文档的第五部分，具体是关于内置过程（procedures）的完整列表，主要涉及用户管理相关的过程，包括更改用户密码、创建新用户和删除用户的相关操作和示例。"
            },
            {
                "content": "delete user on this graph database.\n\n  **Parameters:**\n\n  | parameter | parameter type | description         |\n  | --------- | -------------- | --------------------------- |\n  | user_name | string     | the user name to be deleted |\n\n  **Output:**\n\n    If successful, it returns a success message.\n\n  **Example input:**\n\n  ```\n  CALL dbms.security.deleteUser('quest')\n  ```\n\n  **Example output:**\n\n  ```\n  true\n  ```\n\n* dbms.security.listUsers()\n\n  get all user's name of the graph database.\n\n  **Output:**\n\n   a list of user names, in which each element is a list of the following fields:\n\n  | parameter | parameter type | description         |\n  | --------- | -------------- | --------------------------- |\n  | user.name | string     | the user name           |\n  | is.admin  | boolean    | the permission of this user |\n\n   **Example input:**\n\n  ```\n  CALL dbms.security.listUsers()\n  ```\n\n  **Example output:**\n\n该块内容位于文档的第五部分“附录2. 内置procedures列表”中，具体介绍了`dbms.security.deleteUser`和`dbms.security.listUsers`这两个内置过程，分别用于删除用户和列出所有用户的信息。这些内容帮助用户理解如何管理图数据库中的用户。"
            },
            {
                "content": "* dbms.security.listUsers()\n\n  get all user's name of the graph database.\n\n  **Output:**\n\n   a list of user names, in which each element is a list of the following fields:\n\n  | parameter | parameter type | description         |\n  | --------- | -------------- | --------------------------- |\n  | user.name | string     | the user name           |\n  | is.admin  | boolean    | the permission of this user |\n\n   **Example input:**\n\n  ```\n  CALL dbms.security.listUsers()\n  ```\n\n  **Example output:**\n\n  | user.name | is.admin |\n  | --------- | -------- |\n  | admin     | true     |\n  | ...       |  ...    |\n\n* dbms.security.showCurrentUser()\n\n  get current user's name.\n\n  **Output:**\n\n    a list of user names, in which each element is a list of the following fields:\n\n  | parameter | parameter type | description       |\n  | --------- | -------------- | --------------------- |\n  | user.user | string     | the current user name |\n\n  **Example input:**\n\n  ```\n  CALL dbms.security.showCurrentUser()\n  ```\n\n该内容块位于文档的\"5.2.内置procedures完整列表\"部分，其中详细描述了两条与用户管理相关的系统存储过程：`dbms.security.listUsers()`用于列出数据库中所有用户的名称及其权限信息，而`dbms.security.showCurrentUser()`则用于获取当前用户的名称。这些命令可帮助用户管理和查询图数据库的用户权限设置。"
            },
            {
                "content": "| user.name | is.admin |\n  | --------- | -------- |\n  | admin     | true     |\n  | ...       |  ...    |\n\n* dbms.security.showCurrentUser()\n\n  get current user's name.\n\n  **Output:**\n\n    a list of user names, in which each element is a list of the following fields:\n\n  | parameter | parameter type | description       |\n  | --------- | -------------- | --------------------- |\n  | user.user | string     | the current user name |\n\n  **Example input:**\n\n  ```\n  CALL dbms.security.showCurrentUser()\n  ```\n\n  **Example output:**\n\n  | user.name |\n  | --------- |\n  | admin     |\n\n* dbms.security.listAllowedHosts()\n\n  get the list of ips to be allowed .\n\n  **Output:**\n\n   a list of  ips which are allowed.\n\n  **Example input:**\n\n  ```\n  CALL dbms.security.listAllowedHosts()\n  ```\n\n  **Example output:**\n\n  | host     |\n  | ------------ |\n  | 192.168.1.22 |\n  | ...      |\n\n* dbms.security.deleteAllowedHosts(hosts)\n\n  delete some ips from the list of ips to be allowed .\n\n  **Output:**\n\n此部分内容位于文档的安全管理章节，具体讨论了与用户和权限相关的命令，包括获取当前用户信息、列出允许的IP地址以及删除允许IP的命令。这些命令对于管理图数据库的安全性和用户访问控制至关重要。"
            },
            {
                "content": "**Example output:**\n\n  | user.name |\n  | --------- |\n  | admin     |\n\n* dbms.security.listAllowedHosts()\n\n  get the list of ips to be allowed .\n\n  **Output:**\n\n   a list of  ips which are allowed.\n\n  **Example input:**\n\n  ```\n  CALL dbms.security.listAllowedHosts()\n  ```\n\n  **Example output:**\n\n  | host     |\n  | ------------ |\n  | 192.168.1.22 |\n  | ...      |\n\n* dbms.security.deleteAllowedHosts(hosts)\n\n  delete some ips from the list of ips to be allowed .\n\n  **Output:**\n\n   the number of ip which been deleted.\n\n   **Example input:**\n\n  ```\n  CALL dbms.security.deleteAllowedHosts('192.168.1.22','192.168.1.23')\n  ```\n\n  **Example output:**\n\n  | success |\n  | ------- |\n  | 2       |\n\n* dbms.security.addAllowedHosts(hosts)\n\n  add some ips from the list of ips to be allowed .\n\n  **Output:**\n\n    the number of ip which been added.\n\n  **Example input:**\n\n  ```\n  CALL dbms.security.addAllowedHosts('192.168.1.22','192.168.1.23')\n  ```\n\n  **Example output:**\n\n  | success |\n  | ------- |\n  | 2       |\n\n该块内容位于文档的“5.2.内置procedures完整列表”部分，详细介绍了与用户安全管理相关的程序，包括获取允许的IP列表、删除和添加允许的IP。"
            },
            {
                "content": "**Example input:**\n\n  ```\n  CALL dbms.security.deleteAllowedHosts('192.168.1.22','192.168.1.23')\n  ```\n\n  **Example output:**\n\n  | success |\n  | ------- |\n  | 2       |\n\n* dbms.security.addAllowedHosts(hosts)\n\n  add some ips from the list of ips to be allowed .\n\n  **Output:**\n\n    the number of ip which been added.\n\n  **Example input:**\n\n  ```\n  CALL dbms.security.addAllowedHosts('192.168.1.22','192.168.1.23')\n  ```\n\n  **Example output:**\n\n  | success |\n  | ------- |\n  | 2       |\n\n* dbms.graph.createGraph(graph_name, description, max_size_GB)\n\n  create a new subgraph in this graph database .\n\n  **Parameters:**\n\n  | parameter   | parameter type | description              |\n  | ----------- | -------------- | -------------------------------- |\n  | graph_name  | string     | the name of new subgraph     |\n  | description | string     | description of new subgraph      |\n  | max_size_GB | integer    | Upper limit of subgraph capacity |\n\n   **Output:**\n\n    if successful , it will return true.\n\n该块内容位于文档的第5.1节“procedures样例”中，介绍了如何使用特定的内置过程，如添加和删除允许的IP地址，以及创建新的子图，包括具体的输入示例、输出示例和参数说明。这部分内容对用户了解TuGraph中安全管理和图管理的API方法非常重要。"
            },
            {
                "content": "create a new subgraph in this graph database .\n\n  **Parameters:**\n\n  | parameter   | parameter type | description              |\n  | ----------- | -------------- | -------------------------------- |\n  | graph_name  | string     | the name of new subgraph     |\n  | description | string     | description of new subgraph      |\n  | max_size_GB | integer    | Upper limit of subgraph capacity |\n\n   **Output:**\n\n    if successful , it will return true.\n\n   **Example input:**\n\n  ```\n  CALL dbms.graph.createGraph('graph1', 'description', 2045)\n  ```\n\n  **Example output:**\n\n  | success |\n  | ------- |\n  | true    |\n\n* dbms.graph.deleteGraph(graph_name)\n\n  delete a subgraph in this graph database .\n\n  | parameter  | parameter type | description              |\n  | ---------- | -------------- | ------------------------------------ |\n  | graph_name | string     | the name of subgraph to been deleted |\n\n  **Output:**\n\n    if successful , it will return true.\n\n  **Example input:**\n\n该块内容位于文档的第五部分，描述了在图数据库中创建和删除子图的功能，具体涵盖了参数说明、输出结果以及示例输入和输出，属于数据库管理和操作的相关命令。"
            },
            {
                "content": "```\n  CALL dbms.graph.createGraph('graph1', 'description', 2045)\n  ```\n\n  **Example output:**\n\n  | success |\n  | ------- |\n  | true    |\n\n* dbms.graph.deleteGraph(graph_name)\n\n  delete a subgraph in this graph database .\n\n  | parameter  | parameter type | description              |\n  | ---------- | -------------- | ------------------------------------ |\n  | graph_name | string     | the name of subgraph to been deleted |\n\n  **Output:**\n\n    if successful , it will return true.\n\n  **Example input:**\n\n  ```\n  CALL dbms.graph.deleteGraph('graph1')\n  ```\n\n   **Example output:**\n\n  | success |\n  | ------- |\n  | true    |\n\n* dbms.graph.modGraph(graph_name, config)\n\n  delete a subgraph in this graph database .\n\n  **Parameters:**\n\n  | parameter  | parameter type | description              |\n  | ---------- | -------------- | ------------------------------------ |\n  | graph_name | string     | the name of subgraph to been deleted |\n  | config     | map        | the configuration to be modified     |\n\n  **Output:**\n\n该文本块位于文档的第5部分“附录2. 内置procedures列表”的相关内容中，具体介绍了与图数据库子图操作有关的内置过程，包括创建子图、删除子图和修改子图配置。这部分为用户提供了关于如何管理和操作图数据库子图的具体示例和参数说明。"
            },
            {
                "content": "**Example output:**\n\n  | success |\n  | ------- |\n  | true    |\n\n* dbms.graph.modGraph(graph_name, config)\n\n  delete a subgraph in this graph database .\n\n  **Parameters:**\n\n  | parameter  | parameter type | description              |\n  | ---------- | -------------- | ------------------------------------ |\n  | graph_name | string     | the name of subgraph to been deleted |\n  | config     | map        | the configuration to be modified     |\n\n  **Output:**\n\n    if successful , it will return true.\n\n  **Example input:**\n\n  ```\n  CALL dbms.graph.modGraph('graph1',{description:'this graph', max_size_GB:20})\n  ```\n\n  **Example output:**\n\n  | success |\n  | ------- |\n  | true    |\n\n* dbms.graph.listGraphs()\n\n  get all subgraphs in this graph database.\n\n  **Output:**\n\n    a list of {subgraph and configuration}.\n\n  **Example input:**\n\n  ```\n  CALL dbms.graph.listGraphs()\n  ```\n\n  **Example output:**\n\n该块内容位于文档的第五部分“附录2. 内置procedures列表”中，详细列出了TuGraph中的内置过程，以及它们的功能、参数和示例输入输出，包括对图子图的修改和列出子图的功能。"
            },
            {
                "content": "**Output:**\n\n    if successful , it will return true.\n\n  **Example input:**\n\n  ```\n  CALL dbms.graph.modGraph('graph1',{description:'this graph', max_size_GB:20})\n  ```\n\n  **Example output:**\n\n  | success |\n  | ------- |\n  | true    |\n\n* dbms.graph.listGraphs()\n\n  get all subgraphs in this graph database.\n\n  **Output:**\n\n    a list of {subgraph and configuration}.\n\n  **Example input:**\n\n  ```\n  CALL dbms.graph.listGraphs()\n  ```\n\n  **Example output:**\n\n  | graph.name | configuration                 |\n  | ---------- | --------------------------------------------- |\n  | default    | {\"description\":\"\",\"max_size_GB\":1024}     |\n  | graph1     | {\"description\":\"this graph\",\"max_size_GB\":20} |\n  | ...    |         ...                  |\n\n\n* dbms.graph.listUserGraphs(user_name)\n\n  get subgraph list which specified user can read or write\n\n  **Output:**\n\n  a list of {subgraph and configuration}.\n\n  **Example input:**\n\n  ```\n  CALL dbms.graph.listUserGraphs(\"test_user\")\n  ```\n\n  **Example output:**\n\n该内容位于文档的第五部分“附录2. 内置procedures列表”下，主要介绍了与图数据库操作相关的一些内置过程，包括修改子图属性、列出所有子图以及列出指定用户能够读取或写入的子图的功能和示例。此部分为用户提供了具体的调用示例和预期的输出结果。"
            },
            {
                "content": "* dbms.graph.listUserGraphs(user_name)\n\n  get subgraph list which specified user can read or write\n\n  **Output:**\n\n  a list of {subgraph and configuration}.\n\n  **Example input:**\n\n  ```\n  CALL dbms.graph.listUserGraphs(\"test_user\")\n  ```\n\n  **Example output:**\n\n  | graph.name | configuration                 |\n    | ---------- | --------------------------------------------- |\n  | default    | {\"description\":\"\",\"max_size_GB\":1024}     |\n  | graph1     | {\"description\":\"this graph\",\"max_size_GB\":20} |\n  | ...    |         ...                  |\n\n* dbms.config.list()\n\n  get config of this graph database.\n\n  **Output:**\n\n    a list of {configuration}.\n\n  **Example input:**\n\n  ```\n  CALL dbms.config.list()\n  ```\n\n  **Example output:**\n\n  | name      | value   |\n  |-----------| ---------|\n  | bind_host | 0.0.0.0 |\n  | durable   | true    |\n  | ...       |  ...    |\n\n* dbms.config.update(updates)\n\n  get some config of this graph database.\n\n  **Output:**\n\n    If successful, it returns a success message\n\n此块内容位于文档的最后部分，主要介绍了与TuGraph图数据库相关的内置过程，包括列出指定用户可读写的子图和获取图数据库配置的功能。这部分为用户提供了关于数据库管理和配置的示例和输出格式，对数据库操作的理解和使用十分重要。"
            },
            {
                "content": "* dbms.config.list()\n\n  get config of this graph database.\n\n  **Output:**\n\n    a list of {configuration}.\n\n  **Example input:**\n\n  ```\n  CALL dbms.config.list()\n  ```\n\n  **Example output:**\n\n  | name      | value   |\n  |-----------| ---------|\n  | bind_host | 0.0.0.0 |\n  | durable   | true    |\n  | ...       |  ...    |\n\n* dbms.config.update(updates)\n\n  get some config of this graph database.\n\n  **Output:**\n\n    If successful, it returns a success message\n\n  **Example input:**\n\n  ```\n  CALL dbms.config.update({\n    enable_ip_check:false,\n    durable:true,\n    optimistic_txn:true,\n    enable_audit_log:true})\n  ```\n\n  **Example output:**\n\n  ```\n  Update succeeded.\n  ```\n\n* dbms.takeSnapshot()\n\n  take the  snapshot  on this current graph database.\n\n  **Output:**\n\n    If successful, it returns the path of snapshot.\n\n  **Example input:**\n\n  ```\n  CALL dbms.takeSnapshot()\n  ```\n\n  **Example output:**\n\n  | path                |\n  | ----------------------------------- |\n  | log/db/snapshot/2020-07-20_17.20.03 |\n\n此段落位于文档的第五部分“附录2. 内置procedures列表”中，详细描述了与数据库配置管理和快照功能相关的内置过程，包括获取当前数据库配置、更新配置以及创建快照的相关命令及示例。"
            },
            {
                "content": "**Example output:**\n\n  ```\n  Update succeeded.\n  ```\n\n* dbms.takeSnapshot()\n\n  take the  snapshot  on this current graph database.\n\n  **Output:**\n\n    If successful, it returns the path of snapshot.\n\n  **Example input:**\n\n  ```\n  CALL dbms.takeSnapshot()\n  ```\n\n  **Example output:**\n\n  | path                |\n  | ----------------------------------- |\n  | log/db/snapshot/2020-07-20_17.20.03 |\n\n* dbms.listBackupFiles()\n\n  get the path of backuped files.\n\n  **Output:**\n\n    If successful, it returns the path of snapshot.\n\n  **Example input:**\n\n  ```\n  CALL dbms.listBackupFiles()\n  ```\n\n  **Example output:**\n\n  | path               |\n  | -------------------------- |\n  | tugraph/db/binlog/binlog_0 |\n\n* algo.shortestPath(startNode, endNode, config)\n\n  get one of the shortest paths between two vertexes.\n\n  **Parameters:**\n\n该片段位于文档的第5.2节，涵盖了TuGraph中的内置过程和相关命令，具体涉及快照操作、备份文件路径获取以及最短路径算法的使用示例。这些内容为用户提供了有关数据管理和查询功能的实用示例。"
            },
            {
                "content": "* dbms.listBackupFiles()\n\n  get the path of backuped files.\n\n  **Output:**\n\n    If successful, it returns the path of snapshot.\n\n  **Example input:**\n\n  ```\n  CALL dbms.listBackupFiles()\n  ```\n\n  **Example output:**\n\n  | path               |\n  | -------------------------- |\n  | tugraph/db/binlog/binlog_0 |\n\n* algo.shortestPath(startNode, endNode, config)\n\n  get one of the shortest paths between two vertexes.\n\n  **Parameters:**\n\n  | parameter | parameter type | description                          |\n  | --------- | -------------- | ------------------------------------------------------------ |\n  | startNode | Node       | the source node of paths                     |\n  | endNode   | Node       | the destination node paths                   |\n  | config    | MAP        | the filter of shortest paths, the formate as {maxHops:3, relationshipQuery:'HAS_CHILD'} |\n\n  **Output:**\n\n    If successful, it will returns one group result of the shortest path.\n\n  **Example input:**\n\n该块内容介绍了TuGraph中的两个重要内置程序：`dbms.listBackupFiles()`用于获取备份文件的路径，以及`algo.shortestPath()`用于查询两个节点之间的最短路径。这部分信息位于文档的“内置procedures完整列表”章节中，旨在帮助用户了解如何使用这些程序进行数据备份和路径查询。"
            },
            {
                "content": "**Output:**\n\n    If successful, it will returns one group result of the shortest path.\n\n  **Example input:**\n\n  ```\n  MATCH (n1 {name:'Hugo Weaving'}),(n2 {title:'The Matrix'})\n  CALL algo.shortestPath(n1,n2) YIELD nodeCount,totalCost RETURN nodeCount,totalCost\n  ```\n\n  **Example output:**\n\n  | nodeCount | totalCost |\n  | --------- | --------- |\n  | 2     | 1     |\n\n* algo.allShortestPaths(startNode, endNode, config))\n\n  get the path of backuped files.\n\n  **Output:**\n\n    If successful, it returns the path of snapshot.\n\n  **Example input:**\n\n  ```\n  MATCH (n1 {name:'Hugo Weaving'}),(n2 {title:'The Matrix'})\n  CALL algo.allShortestPaths(n1,n2) YIELD nodeIds,cost RETURN nodeIds,cost\n  ```\n\n  **Example output:**\n\n  | nodeIds | cost |\n  | ------- | ---- |\n  | [2,665] | 1    |\n  | ...     |      |\n\n* algo.algo.native.extract(id, config))\n\n  get the field values of a list of vertexes or edges.\n\n  **Parameters:**\n\n该段落位于文档的第四部分，介绍了TuGraph-Cypher查询语言中的算法相关功能，具体包括最短路径查询（algo.shortestPath和algo.allShortestPaths）以及提取顶点或边的字段值（algo.native.extract）。这一部分提供了相应的输入示例、输出结果以及使用说明，帮助用户理解如何在TuGraph中进行路径查询和数据提取。"
            },
            {
                "content": "get the path of backuped files.\n\n  **Output:**\n\n    If successful, it returns the path of snapshot.\n\n  **Example input:**\n\n  ```\n  MATCH (n1 {name:'Hugo Weaving'}),(n2 {title:'The Matrix'})\n  CALL algo.allShortestPaths(n1,n2) YIELD nodeIds,cost RETURN nodeIds,cost\n  ```\n\n  **Example output:**\n\n  | nodeIds | cost |\n  | ------- | ---- |\n  | [2,665] | 1    |\n  | ...     |      |\n\n* algo.algo.native.extract(id, config))\n\n  get the field values of a list of vertexes or edges.\n\n  **Parameters:**\n\n  | parameter | parameter type | description                        |\n  | --------- | -------------- | ---------------------------------------------------------- |\n  | id    | ANY        | the id of vertexes or edges , the id must be variable      |\n  | config    | MAP        | the configuration of  this extraction of vertexes or edges |\n\n  in which each `config` is a map in the form of `{isNode:true, filed:'HAS_CHILD'}`, if `isNode` is specified true, the `id` is a vertex id, or  it is an edge id.\n\n  **Output:**\n\n该段落位于文档的\"5.2.内置procedures完整列表\"部分，主要介绍了图数据库中的内置过程和函数，包括如何获取备份文件路径以及提取点或边的字段值。尤其侧重于`algo.allShortestPaths`和`algo.native.extract`这两个功能的输入输出示例，帮助用户理解其用法和参数配置。"
            },
            {
                "content": "in which each `config` is a map in the form of `{isNode:true, filed:'HAS_CHILD'}`, if `isNode` is specified true, the `id` is a vertex id, or  it is an edge id.\n\n  **Output:**\n\n    If successful, it returns a list of the value of vertexes or edges specified field .\n\n  **Example input:**\n\n  ```\n  with [2,3] as vids CALL algo.native.extract(vids,{isNode:true, field:'id'})\n  YIELD value  RETURN value\n  ```\n\n  **Example output:**\n\n  | value |\n  | ----- |\n  | [4,5] |\n\n### 5.2.内置procedures完整列表\n\n该段落位于文档的第5.1节“内置procedures列表”中，介绍了`algo.native.extract`命令的用法及其输出示例。此命令用于提取给定顶点或边的指定字段的值。紧接着，该段落后面有关于所有内置过程的完整列表。"
            },
            {
                "content": "| Name                                  | Description                           | Signature                                                                                                                                                                               |\n|---------------------------------------|---------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| db.subgraph                           | 列出点的子图                                | db.subgraph(vids::LIST) :: (subgraph::STRING)                                                                                                                                           |\n\n该部分内容位于文档的第5.2节，列出了TuGraph的内置程序的完整列表，主要包含各种数据库操作命令及其描述和签名信息。本文块特定描述了`db.subgraph`命令，用于列出图中点的子图。"
            },
            {
                "content": "| db.subgraph                           | 列出点的子图                                | db.subgraph(vids::LIST) :: (subgraph::STRING)                                                                                                                                           |\n| db.vertexLabels                       | 列出所有Vertex Label                      | db.vertexLabels() :: (label::STRING)                                                                                                                                                    |\n| db.edgeLabels                         | 列出所有Edge Label                        | db.edgeLabels() :: (edgeLabels::STRING)                                                                                                                                                 |\n\n该信息块包含了一系列内置程序的列表，主要展示了不同命令的名称、描述和调用签名。这些程序用于图数据库操作，如列出子图、获取节点标签和边标签，方便用户在使用TuGraph进行查询和管理时快速查找相关功能。"
            },
            {
                "content": "| db.edgeLabels                         | 列出所有Edge Label                        | db.edgeLabels() :: (edgeLabels::STRING)                                                                                                                                                 |\n| db.indexes                            | 列出所有索引                                | db.indexes() :: (label::STRING,field::STRING,label_type:STRING,unique::BOOLEAN,pair_unique::BOOLEAN)                                                                                    |\n| db.listLabelIndexes                   | 列出所有与某个Label相关的索引                     | db.listLabelIndexes(label_name:STRING,label_type:STRING) :: (label::STRING,field::STRING,unique::BOOLEAN,pair_unique::BOOLEAN)                                                          |\n\n该部分包含了三个内置的数据库过程，分别用于列出所有边标签（Edge Labels）、所有索引（Indexes）以及与特定标签相关的索引（Label Indexes）。这些过程的描述和签名有助于用户快速了解如何在TuGraph数据库中进行边标签和索引的管理。"
            },
            {
                "content": "| db.listLabelIndexes                   | 列出所有与某个Label相关的索引                     | db.listLabelIndexes(label_name:STRING,label_type:STRING) :: (label::STRING,field::STRING,unique::BOOLEAN,pair_unique::BOOLEAN)                                                          |\n| db.warmup                             | 预热数据                                  | db.warmup() :: (time_used::STRING)                                                                                                                                                      |\n| db.createVertexLabel                  | 创建Vertex Label                        | db.createVertexLabel(label_name::STRING,field_specs::LIST) :: (::VOID)                                                                                                                  |\n\n该块内容位于文档的第五部分\"附录2. 内置procedures列表\"中，主要列出了与标签（Label）相关的操作程序，包括列出与标签相关的索引、预热数据以及创建Vertex标签的功能。这部分内容为用户提供了有关图数据库操作的具体命令和调用签名，便于进行相应的数据管理和操作。"
            },
            {
                "content": "| db.createVertexLabel                  | 创建Vertex Label                        | db.createVertexLabel(label_name::STRING,field_specs::LIST) :: (::VOID)                                                                                                                  |\n| db.createLabel                        | 创建Vertex/Edge Label                   | db.createLabel(label_type::STRING,label_name::STRING,extra::STRING,field_specs::LIST) :: ()                                                                                             |\n| db.getLabelSchema                     | 列出label schema                        | db.getLabelSchema(label_type::STRING,label_name::STRING) :: (name::STRING,type::STRING,optional::BOOLEAN)                                                                               |\n\n该块内容位于文档的\"5.2.内置procedures完整列表\"部分，列出了与创建标签和获取标签说明相关的内置过程，包括创建顶点标签、创建顶点/边标签以及获取标签模式的功能和其对应的调用签名。"
            },
            {
                "content": "| db.getLabelSchema                     | 列出label schema                        | db.getLabelSchema(label_type::STRING,label_name::STRING) :: (name::STRING,type::STRING,optional::BOOLEAN)                                                                               |\n| db.getVertexSchema                    | 列出点的 schema                           | db.getVertexSchema(label::STRING) :: (schema::MAP)                                                                                                                                      |\n| db.getEdgeSchema                      | 列出边的 schema                           | db.getEdgeSchema(label::STRING) :: (schema::MAP)                                                                                                                                        |\n\n该区块位于文档的第五部分“附录2. 内置procedures列表”中，主要列出了与标签(schema)相关的内置过程，包括获取标签的schema、顶点的schema和边的schema的对应命令及其签名。这些信息对于用户了解如何查询图数据库中的标签结构非常重要。"
            },
            {
                "content": "| db.getEdgeSchema                      | 列出边的 schema                           | db.getEdgeSchema(label::STRING) :: (schema::MAP)                                                                                                                                        |\n| db.deleteLabel                        | 删除Vertex/Edge Label                   | db.deleteLabel(label_type::STRING,label_name::STRING) :: (::VOID)                                                                                                                       |\n| db.alterLabelDelFields                | 修改label删除属性                           | db.alterLabelDelFields(label_type::STRING,label_name::STRING,del_fields::LIST) :: (record_affected::INTEGER)                                                                            |\n\n该段落包含有关TuGraph数据库操作的命令，主要涉及边的schema查询、删除标签功能及删除属性的修改操作。这些命令在数据库管理和数据结构设计中十分重要，适用于开发人员和数据库管理员在运行和维护图数据库时的参考。"
            },
            {
                "content": "| db.alterLabelDelFields                | 修改label删除属性                           | db.alterLabelDelFields(label_type::STRING,label_name::STRING,del_fields::LIST) :: (record_affected::INTEGER)                                                                            |\n| db.alterLabelAddFields                | 修改label添加field                        | db.alterLabelAddFields(label_type::STRING,label_name::STRING,add_field_spec_values::LIST) :: (record_affected::INTEGER)                                                                 |\n| db.alterLabelModFields                | 修改label field                         | db.alterLabelModFields(label_type::STRING,label_name::STRING,mod_field_specs::LIST) :: (record_affected::INTEGER)                                                                       |\n\n该块内容位于文档的\"5.2.内置procedures完整列表\"部分，主要介绍了与图数据库标签字段修改相关的内置程序，包括如何删除、添加和修改标签字段的操作及其签名。"
            },
            {
                "content": "| db.alterLabelModFields                | 修改label field                         | db.alterLabelModFields(label_type::STRING,label_name::STRING,mod_field_specs::LIST) :: (record_affected::INTEGER)                                                                       |\n| db.createEdgeLabel                    | 创建Edge Label                          | db.createEdgeLabel(type_name::STRING,field_specs::LIST) :: (::VOID)                                                                                                                     |\n| db.addIndex                           | 创建索引                                  | db.addIndex(label_name::STRING,field_name::STRING,unique::BOOLEAN) :: (::VOID)                                                                                                          |\n\n该块内容展示了TuGraph中的几个内置命令，具体涉及修改标签字段、创建边标签以及创建索引的功能，属于第五章“附录2. 内置procedures列表”中的一部分，主要用于图数据库的操作和管理。"
            },
            {
                "content": "| db.addIndex                           | 创建索引                                  | db.addIndex(label_name::STRING,field_name::STRING,unique::BOOLEAN) :: (::VOID)                                                                                                          |\n| db.addEdgeIndex                       | 创建索引                                  | db.addEdgeIndex(label_name::STRING,field_name::STRING,unique::BOOLEAN,pair_unique::BOOLEAN) :: (::VOID)                                                                                 |\n| db.addVertexCompositeIndex            | 创建组合索引                                | db.addVertexCompositeIndex(label_name::STRING,field_names::LIST,unique::BOOLEAN) :: (::VOID)                                                                                            |\n\n该内容位于文档的**5.2.内置procedures完整列表**部分，列出与索引相关的操作命令，包括创建索引、创建边索引和创建组合索引的具体签名及功能描述。这部分帮助用户了解如何在TuGraph中管理和配置索引，以优化数据检索和查询性能。"
            },
            {
                "content": "| db.addVertexCompositeIndex            | 创建组合索引                                | db.addVertexCompositeIndex(label_name::STRING,field_names::LIST,unique::BOOLEAN) :: (::VOID)                                                                                            |\n| db.deleteIndex                        | 删除索引                                  | db.deleteIndex(label_name::STRING,field_name::STRING) :: (::VOID)                                                                                                                       |\n| db.deleteCompositeIndex               | 删除组合索引                                | db.deleteIndex(label_name::STRING,field_names::LIST) :: (::VOID)                                                                                                                        |\n\n该块内容位于文档的第5.2节“内置procedures完整列表”中，主要描述了与图数据库操作相关的索引管理命令，包括创建组合索引、删除索引及删除组合索引的具体命令及其签名。"
            },
            {
                "content": "| db.deleteCompositeIndex               | 删除组合索引                                | db.deleteIndex(label_name::STRING,field_names::LIST) :: (::VOID)                                                                                                                        |\n| db.backup                             | 备份数据                                  | db.backup(destination::STRING) :: ()                                                                                                                                                    |\n| dbms.procedures                       | 列出所有procedures                        | dbms.procedures() :: (name::STRING,signature::STRING)                                                                                                                                   |\n\n该部分内容位于文档的第五节“附录2. 内置procedures列表”中，具体列出了图数据库中与组合索引和备份相关的操作命令，以及列出所有可用程序的命令。这些命令的描述及其签名帮助用户了解如何使用数据库的特定功能。"
            },
            {
                "content": "| dbms.procedures                       | 列出所有procedures                        | dbms.procedures() :: (name::STRING,signature::STRING)                                                                                                                                   |\n| dbms.security.changePassword          | 更改当前用户的密码                             | dbms.security.changePassword(current_password::STRING,new_password::STRING) :: (::VOID)                                                                                                 |\n| dbms.security.changeUserPassword      | 更改指定用户的密码                             | dbms.security.changeUserPassword(user_name::STRING,new_password::STRING) :: (::VOID)                                                                                                    |\n\n该块内容位于文档的“5.2.内置procedures完整列表”部分，主要列出了一些用于数据库管理和安全控制的内置过程，包括列出所有可用过程和更改用户密码的操作。这有助于用户了解如何执行常见的管理任务。"
            },
            {
                "content": "| dbms.security.changeUserPassword      | 更改指定用户的密码                             | dbms.security.changeUserPassword(user_name::STRING,new_password::STRING) :: (::VOID)                                                                                                    |\n| dbms.security.createUser              | 创建用户                                  | dbms.security.createUser(user_name::STRING,password::STRING) :: (::VOID)                                                                                                                |\n| dbms.security.deleteUser              | 删除用户                                  | dbms.security.deleteUser(user_name::STRING) :: (::VOID)                                                                                                                                 |\n\n该块内容位于文档中“5.2.内置procedures完整列表”部分，具体描述了与用户管理相关的命令，包括更改用户密码、创建用户和删除用户的操作及其签名。这些命令用于图数据库的安全管理，以确保用户权限和身份的控制。"
            },
            {
                "content": "| dbms.security.deleteUser              | 删除用户                                  | dbms.security.deleteUser(user_name::STRING) :: (::VOID)                                                                                                                                 |\n| dbms.security.listUsers               | 列出所有用户                                | dbms.security.listUsers() :: (user_name::STRING,user_info::MAP)                                                                                                                         |\n| dbms.security.showCurrentUser         | 列出当前用户信息                              | dbms.security.showCurrentUser() :: (current_user::STRING)                                                                                                                               |\n\n该块内容属于文档的\"内置procedures完整列表\"部分，主要列出了与用户管理相关的命令，包括删除用户、列出所有用户以及显示当前用户的信息。这些命令可以帮助用户在图数据库中进行安全管理和用户权限控制。"
            },
            {
                "content": "| dbms.security.showCurrentUser         | 列出当前用户信息                              | dbms.security.showCurrentUser() :: (current_user::STRING)                                                                                                                               |\n| dbms.security.getUserPermissions      | 列出指定用户的权限                             | dbms.security.getUserPermissions(user_name::STRING) :: (user_info::MAP)                                                                                                                 |\n| dbms.graph.createGraph                | 创建子图                                  | dbms.graph.createGraph(graph_name::STRING, description::STRING, max_size_GB::INTEGER) :: (::VOID)                                                                                       |\n\n该片段包含了与数据库安全管理和图形创建相关的命令，包括列出当前用户信息、获取指定用户权限以及创建子图的功能描述和调用签名。这些内容位于文档的“附录2. 内置procedures列表”部分，涉及用户管理和图数据库的操作。"
            },
            {
                "content": "| dbms.graph.createGraph                | 创建子图                                  | dbms.graph.createGraph(graph_name::STRING, description::STRING, max_size_GB::INTEGER) :: (::VOID)                                                                                       |\n| dbms.graph.modGraph                   | 修改子图属性                                | dbms.graph.modGraph(graph_name::STRING,config::MAP) :: (::VOID)                                                                                                                         |\n| dbms.graph.deleteGraph                | 删除子图                                  | dbms.graph.deleteGraph(graph_name::STRING) :: (::VOID)                                                                                                                                  |\n\n该块内容位于文档的第五部分“内置procedures列表”，具体涉及与图数据库子图管理相关的操作命令，包括创建、修改和删除子图的功能。这些命令提供了对图数据库结构进行灵活管理的能力。"
            },
            {
                "content": "| dbms.graph.deleteGraph                | 删除子图                                  | dbms.graph.deleteGraph(graph_name::STRING) :: (::VOID)                                                                                                                                  |\n| dbms.graph.listGraphs                 | 列出所有子图                                | dbms.graph.listGraphs() :: (graph_name::STRING,configuration::MAP)                                                                                                                      |\n| dbms.graph.getGraphInfo               | 列出指定子图的信息                             | dbms.graph.getGraphInfo(graph_name::STRING)::(graph_name::STRING,configuration::MAP)                                                                                                    |\n\n该块内容位于文档的第五部分“附录2. 内置procedures列表”，具体描述了与图数据库操作相关的三个内置程序：删除子图、列出所有子图及获取指定子图的信息。这些程序的调用签名和功能说明有助于用户在图数据库管理中执行相关操作。"
            },
            {
                "content": "| dbms.graph.getGraphInfo               | 列出指定子图的信息                             | dbms.graph.getGraphInfo(graph_name::STRING)::(graph_name::STRING,configuration::MAP)                                                                                                    |\n| dbms.security.addAllowedHosts         | 添加ip到信任列表                             | dbms.security.addAllowedHosts(hosts::LIST) :: (num_new::INTEGER)                                                                                                                        |\n| dbms.security.deleteAllowedHosts      | 从信任列表删除ip                             | dbms.security.deleteAllowedHosts(hosts::LIST) :: (record_affected::INTEGER)                                                                                                             |\n\n该块内容位于文档的“5.2.内置procedures完整列表”部分，列出了与图数据库相关的内置命令，包括获取指定子图的信息、向信任列表添加IP以及从信任列表中删除IP的操作。这些命令主要用于用户管理和安全设置方面。"
            },
            {
                "content": "| dbms.security.deleteAllowedHosts      | 从信任列表删除ip                             | dbms.security.deleteAllowedHosts(hosts::LIST) :: (record_affected::INTEGER)                                                                                                             |\n| dbms.security.listAllowedHosts        | 列出信任列表中的主机ip                          | dbms.security.listAllowedHosts() :: (host::STRING)                                                                                                                                      |\n| dbms.config.update                    | 更新TuGraph配置                           | dbms.config.update(updates::MAP) :: (message::STRING)                                                                                                                                   |\n\n此块内容位于第五部分“附录2. 内置procedures列表”，详细列出了TuGraph图数据库中的一些安全管理和配置相关的内置过程，包括删除信任列表中的IP地址、列出信任列表中的主机IP以及更新数据库配置的命令。"
            },
            {
                "content": "| dbms.config.update                    | 更新TuGraph配置                           | dbms.config.update(updates::MAP) :: (message::STRING)                                                                                                                                   |\n| dbms.config.list                      | 列出TuGraph配置                           | dbms.config.list() :: (name::STRING,value::ANY)                                                                                                                                         |\n| algo.shortestPath                     | 查询两个点间的最短路径                           | algo.shortestPath(startNode::NODE,endNode::NODE,config::MAP) :: (nodeCount::INTEGER,totalCost::FLOAT)                                                                                   |\n\n该片段位于文档的最后一部分，主要列出了TuGraph数据库的内置命令，包括对配置的管理和最短路径查询的相关命令，涵盖了系统配置和图算法操作的功能，旨在提供用户对这些命令的快速参考和使用方式。"
            },
            {
                "content": "| algo.shortestPath                     | 查询两个点间的最短路径                           | algo.shortestPath(startNode::NODE,endNode::NODE,config::MAP) :: (nodeCount::INTEGER,totalCost::FLOAT)                                                                                   |\n| algo.allShortestPaths                 | 查询两个点间的所有最短路径                         | algo.allShortestPaths(startNode::NODE,endNode::NODE,config::MAP) :: (nodeIds::LIST,relationshipIds::LIST,cost::LIST)                                                                    |\n| algo.native.extract                   | 查询指定VertexId/EdgeUid（列表）指定field的值（列表） | algo.native.extract(id::ANY,config::MAP) :: (value::ANY)                                                                                                                                |\n\n该部分内容位于文档的“内置procedures完整列表”章节中，具体描述了与图数据库中算法相关的命令，包括查询两个点间的最短路径、查询所有最短路径以及提取指定VertexId或EdgeUid的字段值。这些命令的签名和功能说明为用户在使用图数据库时提供了重要参考。"
            },
            {
                "content": "| algo.native.extract                   | 查询指定VertexId/EdgeUid（列表）指定field的值（列表） | algo.native.extract(id::ANY,config::MAP) :: (value::ANY)                                                                                                                                |\n| db.flushDB                            | 刷新db                                  | db.flushDB() :: (::VOID)                                                                                                                                                                |\n| dbms.security.listRoles               | 列出所有角色                                | dbms.security.listRoles() :: (role_name::STRING,role_info::MAP)                                                                                                                         |\n\n该块内容位于文档的第五部分“附录2. 内置procedures列表”，主要列出了与图数据库操作相关的一些内置过程及其功能描述，包括数据提取、数据库刷新和角色管理等功能。"
            },
            {
                "content": "| dbms.security.listRoles               | 列出所有角色                                | dbms.security.listRoles() :: (role_name::STRING,role_info::MAP)                                                                                                                         |\n| dbms.security.createRole              | 创建角色                                  | dbms.security.createRole(role_name::STRING,desc::STRING) :: (::VOID)                                                                                                                    |\n| dbms.security.deleteRole              | 删除角色                                  | dbms.security.deleteRole(role_name::STRING) :: (::VOID)                                                                                                                                 |\n\n该部分内容位于文档的第五章，主要介绍了TuGraph数据库中与安全管理相关的内置过程，包括角色的列出、创建和删除等操作。这些命令和其描述为用户提供了管理角色权限和安全性的工具，有助于数据库的安全管理。"
            },
            {
                "content": "| dbms.security.deleteRole              | 删除角色                                  | dbms.security.deleteRole(role_name::STRING) :: (::VOID)                                                                                                                                 |\n| dbms.security.getRoleInfo             | 获取角色详细信息                              | dbms.security.getRoleInfo(role::STRING) :: (role_info::MAP)                                                                                                                             |\n| dbms.security.disableRole             | 禁用/启用角色                               | dbms.security.disableRole(role::STRING,disable::BOOLEAN) :: (::VOID)                                                                                                                    |\n\n该部分内容属于文档的“5.2.内置procedures完整列表”部分，具体列出了与角色管理相关的内置过程，包括删除角色、获取角色详细信息和禁用/启用角色的操作及其相应的签名和描述。这些信息对用户在进行角色权限管理时非常重要。"
            },
            {
                "content": "| dbms.security.disableRole             | 禁用/启用角色                               | dbms.security.disableRole(role::STRING,disable::BOOLEAN) :: (::VOID)                                                                                                                    |\n| dbms.security.modRoleDesc             | 修改角色描述信息                              | dbms.security.modRoleDesc(role::STRING,description::STRING) :: (::VOID)                                                                                                                 |\n| dbms.security.rebuildRoleAccessLevel  | 删除角色权限并重建                             | dbms.security.rebuildRoleAccessLevel(role::STRING,access_level::MAP) :: (::VOID)                                                                                                        |\n\n此部分内容位于文档的第五部分“附录2. 内置procedures列表”中，主要列出与角色管理相关的内置程序，包括禁用/启用角色、修改角色描述信息及重建角色权限等操作。这些命令帮助用户管理数据库中的角色权限和描述，有助于维护安全性和访问控制。"
            },
            {
                "content": "| dbms.security.rebuildRoleAccessLevel  | 删除角色权限并重建                             | dbms.security.rebuildRoleAccessLevel(role::STRING,access_level::MAP) :: (::VOID)                                                                                                        |\n| dbms.security.modRoleAccessLevel      | 修改角色对指定图的访问权限                         | dbms.security.modRoleAccessLevel(role::STRING,access_level::MAP) :: (::VOID)                                                                                                            |\n| dbms.security.modRoleFieldAccessLevel | 修改角色对指定属性的访问权限                        | dbms.security.modRoleFieldAccessLevel(role::STRING,graph::STRING,label::STRING,field::STRING,label_type::STRING,field_access_level::STRING) :: (::VOID)                                 |\n\n该块内容介绍了与角色权限管理相关的几条内置过程命令，包括重建角色权限、修改角色对特定图的访问权限以及修改对指定属性的访问权限。这些命令用于用户管理部分，特别是在安全管理和角色权限控制方面。"
            },
            {
                "content": "| dbms.security.modRoleFieldAccessLevel | 修改角色对指定属性的访问权限                        | dbms.security.modRoleFieldAccessLevel(role::STRING,graph::STRING,label::STRING,field::STRING,label_type::STRING,field_access_level::STRING) :: (::VOID)                                 |\n| dbms.security.getUserInfo             | 获取用户详细信息                              | dbms.security.getUserInfo(user::STRING) :: (user_info::MAP)                                                                                                                             |\n| dbms.security.disableUser             | 禁用/启用用户                               | dbms.security.disableUser(user::STRING,disable::BOOLEAN) :: (::VOID)                                                                                                                    |\n\n该段落位于文档的第5.2节，包含有关用户和角色管理的内置程序示例，主要涵盖修改角色对指定属性的访问权限、获取用户详细信息以及启用或禁用用户的相关命令。这部分内容是关于安全管理的功能介绍。"
            },
            {
                "content": "| dbms.security.disableUser             | 禁用/启用用户                               | dbms.security.disableUser(user::STRING,disable::BOOLEAN) :: (::VOID)                                                                                                                    |\n| dbms.security.setCurrentDesc          | 设置当前用户描述信息                            | dbms.security.setCurrentDesc(description::STRING) :: (::VOID)                                                                                                                           |\n| dbms.security.setUserDesc             | 设置用户描述信息                              | dbms.security.setUserDesc(user::STRING,description::STRING) :: (::VOID)                                                                                                                 |\n\n该块内容位于文档的第五部分“附录2. 内置procedures列表”，专注于与用户管理相关的内置程序，包括禁用用户和设置用户描述信息的功能。这部分提供了关于用户权限和描述设置的具体命令及其用法。"
            },
            {
                "content": "| dbms.security.setUserDesc             | 设置用户描述信息                              | dbms.security.setUserDesc(user::STRING,description::STRING) :: (::VOID)                                                                                                                 |\n| dbms.security.getUserMemoryUsage      | 获取用户内存用量                              | dbms.security.getUserMemoryUsage(user::STRING) :: (memory_usage::INTEGER)                                                                                                               |\n| dbms.security.setUserMemoryLimit      | 设置用户内存限制                              | dbms.security.setUserMemoryLimit(user::STRING,memorylimit::INTEGER) :: (::VOID)                                                                                                         |\n\n此文档的这一部分主要集中于用户管理相关的内置程序，具体包括设置用户描述信息、获取用户内存使用情况以及设置用户内存限制等功能。这些功能使得管理员能够更好地管理和监控用户的资源使用，确保系统的安全和高效。"
            },
            {
                "content": "| dbms.security.setUserMemoryLimit      | 设置用户内存限制                              | dbms.security.setUserMemoryLimit(user::STRING,memorylimit::INTEGER) :: (::VOID)                                                                                                         |\n| dbms.security.deleteUserRoles         | 删除用户与角色的联系                            | dbms.security.deleteUserRoles(user::STRING,roles::LIST) :: (::VOID)                                                                                                                     |\n| dbms.security.rebuildUserRoles        | 清空用户角色的关系并重建                          | dbms.security.rebuildUserRoles(user::STRING,roles::LIST) :: (::VOID)                                                                                                                    |\n\n该内容相关于TuGraph的内置过程列表，具体涉及用户权限管理，包含了设置用户内存限制、删除用户与角色的联系以及重建用户角色关系等操作。这些过程帮助管理员有效管理用户的使用限制和角色关联。"
            },
            {
                "content": "| dbms.security.rebuildUserRoles        | 清空用户角色的关系并重建                          | dbms.security.rebuildUserRoles(user::STRING,roles::LIST) :: (::VOID)                                                                                                                    |\n| dbms.security.addUserRoles            | 新增用户与角色的联系                            | dbms.security.addUserRoles(user::STRING,roles::LIST) :: (::VOID)                                                                                                                        |\n| db.plugin.loadPlugin                  | 装载plugin                              | db.plugin.loadPlugin(plugin_type::STRING,plugin_name::STRING,plugin_content::STRING or MAP,code_type::STRING,plugin_description::STRING,read_only::BOOLEAN,version::STRING) :: (::VOID) |\n\n该块内容位于文档的“内置procedures完整列表”部分，具体列出了与用户角色管理和插件加载相关的命令，包括重建用户角色关系和新增用户角色联系的功能，以及加载插件的操作。"
            },
            {
                "content": "| db.plugin.loadPlugin                  | 装载plugin                              | db.plugin.loadPlugin(plugin_type::STRING,plugin_name::STRING,plugin_content::STRING or MAP,code_type::STRING,plugin_description::STRING,read_only::BOOLEAN,version::STRING) :: (::VOID) |\n| db.plugin.deletePlugin                | 删除plugin                              | db.plugin.deletePlugin(plugin_type::STRING,plugin_name::STRING) :: (::VOID)                                                                                                             |\n| db.plugin.listPlugin                  | 列出已装载的plugin                          | db.plugin.listPlugin(plugin_type::STRING,plugin_version::STRING) :: (plugin_description::LIST)                                                                                          |\n\n该块内容位于文档的第五部分“附录2. 内置procedures列表”，具体列出了与插件相关的操作命令，包括加载、删除和列出已装载的插件，提供了相应的功能描述和调用签名。"
            },
            {
                "content": "| db.plugin.listPlugin                  | 列出已装载的plugin                          | db.plugin.listPlugin(plugin_type::STRING,plugin_version::STRING) :: (plugin_description::LIST)                                                                                          |\n| db.plugin.getPluginInfo               | 获取plugin的详细信息                         | db.plugin.getPluginInfo(plugin_type::STRING,plugin_name::STRING,show_code::BOOLEAN)::(plugin_description::MAP)                                                                          |\n| db.plugin.callPlugin                  | 执行plugin                              | db.plugin.callPlugin(plugin_type::STRING,plugin_name::STRING,param::STRING,timeout::DOUBLE,in_process::BOOLEAN) :: (success::BOOLEAN,result::STRING)                                    |\n\n此片段位于文档的第五部分“附录2. 内置procedures列表”中，具体列出了与插件操作相关的内置程序，包括列出已装载的插件、获取插件的详细信息和执行插件的功能。"
            },
            {
                "content": "| db.plugin.callPlugin                  | 执行plugin                              | db.plugin.callPlugin(plugin_type::STRING,plugin_name::STRING,param::STRING,timeout::DOUBLE,in_process::BOOLEAN) :: (success::BOOLEAN,result::STRING)                                    |\n| db.importor.dataImportor              | 导入点或边数据                               | db.importor.dataImportor(description::STRING,content::STRING,continue_on_error::BOOLEAN,thread_nums::INTEGER,delimiter::STRING) :: (::VOID)                                             |\n| db.importor.schemaImportor            | 导入点或边schema                           | db.importor.schemaImportor(description::STRING) :: (::VOID)                                                                                                                             |\n\n该代码块包含了TuGraph中内置的程序（procedures）相关功能，具体涉及插件的执行以及数据和模式的导入操作。这部分内容位于文档的“内置procedures列表”章节中，重点描述了如何调用插件和导入数据或schema的具体方法，为用户提供在图数据库中进行扩展和数据处理的工具。"
            },
            {
                "content": "| db.importor.schemaImportor            | 导入点或边schema                           | db.importor.schemaImportor(description::STRING) :: (::VOID)                                                                                                                             |\n| db.addFullTextIndex                   | 添加全文索引                                | db.addFullTextIndex(is_vertex::BOOLEAN, label_name::STRING, field_name::STRING) :: (::VOID)                                                                                             |\n| db.deleteFullTextIndex                | 删除全文索引                                | db.deleteFullTextIndex(is_vertex::BOOLEAN, label_name::STRING, field_name::STRING) :: (::VOID)                                                                                          |\n\n此块内容属于文档的第5.2节，列出了TuGraph中有关数据导入和全文索引管理的内置程序，包括导入点或边的schema、添加和删除全文索引的操作。"
            },
            {
                "content": "| db.deleteFullTextIndex                | 删除全文索引                                | db.deleteFullTextIndex(is_vertex::BOOLEAN, label_name::STRING, field_name::STRING) :: (::VOID)                                                                                          |\n| db.rebuildFullTextIndex               | 重建全文索引                                | db.rebuildFullTextIndex(vertex_labels::STRING, edge_labels::STRING) :: (::VOID)                                                                                                         |\n| db.fullTextIndexes                    | 查看全文索引                                | db.fullTextIndexes() :: (is_vertex::BOOLEAN, label::STRING, field::STRING)                                                                                                              |\n\n该块内容位于文档的第五部分“内置procedures列表”中，具体涵盖了与全文检索相关的数据库操作命令，包括删除全文索引、重建全文索引和查看现有全文索引的功能。这些命令对于管理和优化图数据库中的文本数据检索具有重要意义。"
            },
            {
                "content": "| db.fullTextIndexes                    | 查看全文索引                                | db.fullTextIndexes() :: (is_vertex::BOOLEAN, label::STRING, field::STRING)                                                                                                              |\n| dbms.meta.count                       | 查看点边总数                                | db.dbms.meta.count() :: (type::STRING, number::INTEGER)                                                                                                                                 |\n| dbms.meta.countDetail                 | 查看点边总数详情                              | db.dbms.meta.countDetail() :: (is_vertex::BOOLEAN, label::STRING, count::INTEGER)                                                                                                       |\n\n该部分内容属于文档的第五节“附录2. 内置procedures列表”，具体列出了与图数据库相关的内置程序，包括查看全文索引、查询点边总数及其详细信息的命令和签名。这些命令为用户提供了图数据库管理和数据分析的重要工具。"
            },
            {
                "content": "| dbms.meta.countDetail                 | 查看点边总数详情                              | db.dbms.meta.countDetail() :: (is_vertex::BOOLEAN, label::STRING, count::INTEGER)                                                                                                       |\n| dbms.meta.refreshCount                | 重新统计点边数量，统计期间停写。                      | db.dbms.meta.refreshCount() :: (::VOID)                                                                                                                                                 |\n| dbms.task.listTasks                   | 查询正在执行的任务                             | dbms.task.listTasks()::(tasks::LIST)                                                                                                                                                    |\n\n该块内容位于文档的**5.2.内置procedures完整列表**部分，列出了用于查询图数据库中点和边的数量详情、刷新计数以及查询当前正在执行的任务的内置过程。这些过程为用户提供了监控和管理图数据库的重要功能。"
            },
            {
                "content": "| dbms.task.listTasks                   | 查询正在执行的任务                             | dbms.task.listTasks()::(tasks::LIST)                                                                                                                                                    |\n| dbms.task.terminateTask               | 中止任务                                  | dbms.task.terminateTask(task_id::STRING)::(::VOID)                                                                                                                                      |\n| dbms.ha.clusterInfo                   | HA模式下查看集群状态                           | dbms.ha.clusterInfo() :: (cluster_info::LIST, is_master::BOOLEAN)                                                                                                                       |\n\n该文本块属于文档的5.2节“内置procedures完整列表”，具体列出了与任务管理和集群状态相关的内置程序，包括查询正在执行的任务和中止任务的命令，以及在HA模式下查看集群状态的命令。"
            },
            {
                "content": "| dbms.ha.clusterInfo                   | HA模式下查看集群状态                           | dbms.ha.clusterInfo() :: (cluster_info::LIST, is_master::BOOLEAN)                                                                                                                       |\n| db.dropDB                             | 清空数据库                                 | db.dropDB() :: (::VOID)                                                                                                                                                                 |\n表格内容描述:\n\n该段落包含了TuGraph-Cypher中与数据库管理相关的内置procedures的两条记录，主要涉及集群状态查询和数据库清空操作，属于第5.2节“内置procedures完整列表”的一部分。"
            },
            {
                "content": "该表格包含三列，分别是“Name”（命令名）、“Description”（命令描述）、和“Signature”（命令签名）。 \n\n逐行描述表格中的数据内容如下：\n\n该段落位于文档的第五部分，介绍了内置procedures的完整列表，具体说明了每个命令的名称、描述及其签名，帮助用户快速了解TuGraph查询语言中可用的操作和功能。"
            },
            {
                "content": "1. **db.subgraph**: 列出点的子图，签名为 `db.subgraph(vids::LIST) :: (subgraph::STRING)`\n2. **db.vertexLabels**: 列出所有Vertex Label，签名为 `db.vertexLabels() :: (label::STRING)`\n3. **db.edgeLabels**: 列出所有Edge Label，签名为 `db.edgeLabels() :: (edgeLabels::STRING)`\n4. **db.indexes**: 列出所有索引，签名为 `db.indexes() :: (label::STRING,field::STRING,label_type:STRING,unique::BOOLEAN,pair_unique::BOOLEAN)`\n5. **db.listLabelIndexes**: 列出所有与某个Label相关的索引，签名为 `db.listLabelIndexes(label_name::STRING,label_type::STRING) :: (label::STRING,field::STRING,unique::BOOLEAN,pair_unique::BOOLEAN)`\n6. **db.warmup**: 预热数据，签名为 `db.warmup() :: (time_used::STRING)`\n7. **db.createVertexLabel**: 创建Vertex Label，签名为 `db.createVertexLabel(label_name::STRING,field_specs::LIST) :: (::VOID)`\n8. **db.createLabel**: 创建Vertex/Edge Label，签名为 `db.createLabel(label_type::STRING,label_name::STRING,extra::STRING,field_specs::LIST) :: ()`\n\n该段落位于文档的第5.2节，列出了TuGraph中内置的procedures及其功能和调用签名，主要涉及图数据库的基本操作，如列出子图、标签、索引等。这些信息有助于用户快速了解可用的操作及其用法。"
            },
            {
                "content": "5. **db.listLabelIndexes**: 列出所有与某个Label相关的索引，签名为 `db.listLabelIndexes(label_name::STRING,label_type::STRING) :: (label::STRING,field::STRING,unique::BOOLEAN,pair_unique::BOOLEAN)`\n6. **db.warmup**: 预热数据，签名为 `db.warmup() :: (time_used::STRING)`\n7. **db.createVertexLabel**: 创建Vertex Label，签名为 `db.createVertexLabel(label_name::STRING,field_specs::LIST) :: (::VOID)`\n8. **db.createLabel**: 创建Vertex/Edge Label，签名为 `db.createLabel(label_type::STRING,label_name::STRING,extra::STRING,field_specs::LIST) :: ()`\n9. **db.getLabelSchema**: 列出label schema，签名为 `db.getLabelSchema(label_type::STRING,label_name::STRING) :: (name::STRING,type::STRING,optional::BOOLEAN)`\n10. **db.getVertexSchema**: 列出点的 schema，签名为 `db.getVertexSchema(label::STRING) :: (schema::MAP)`\n11. **db.getEdgeSchema**: 列出边的 schema，签名为 `db.getEdgeSchema(label::STRING) :: (schema::MAP)`\n12. **db.deleteLabel**: 删除Vertex/Edge Label，签名为 `db.deleteLabel(label_type::STRING,label_name::STRING) :: (::VOID)`\n\n该段落位于文档的“5.2.内置procedures完整列表”部分，列出了与图数据库操作相关的一系列命令，包括标签相关的操作如创建、获取和删除标签，以及数据预热的操作。"
            },
            {
                "content": "9. **db.getLabelSchema**: 列出label schema，签名为 `db.getLabelSchema(label_type::STRING,label_name::STRING) :: (name::STRING,type::STRING,optional::BOOLEAN)`\n10. **db.getVertexSchema**: 列出点的 schema，签名为 `db.getVertexSchema(label::STRING) :: (schema::MAP)`\n11. **db.getEdgeSchema**: 列出边的 schema，签名为 `db.getEdgeSchema(label::STRING) :: (schema::MAP)`\n12. **db.deleteLabel**: 删除Vertex/Edge Label，签名为 `db.deleteLabel(label_type::STRING,label_name::STRING) :: (::VOID)`\n13. **db.alterLabelDelFields**: 修改label删除属性，签名为 `db.alterLabelDelFields(label_type::STRING,label_name::STRING,del_fields::LIST) :: (record_affected::INTEGER)`\n14. **db.alterLabelAddFields**: 修改label添加field，签名为 `db.alterLabelAddFields(label_type::STRING,label_name::STRING,add_field_spec_values::LIST) :: (record_affected::INTEGER)`\n15. **db.alterLabelModFields**: 修改label field，签名为 `db.alterLabelModFields(label_type::STRING,label_name::STRING,mod_field_specs::LIST) :: (record_affected::INTEGER)`\n\n该部分内容位于文档的“5.2.内置procedures完整列表”章节，主要描述了与图数据库标签管理相关的内置程序，包括列出标签的schema、删除标签以及修改标签的属性字段等操作。这些命令提供了对图数据库结构的管理能力，方便用户进行有效的数据操作和维护。"
            },
            {
                "content": "13. **db.alterLabelDelFields**: 修改label删除属性，签名为 `db.alterLabelDelFields(label_type::STRING,label_name::STRING,del_fields::LIST) :: (record_affected::INTEGER)`\n14. **db.alterLabelAddFields**: 修改label添加field，签名为 `db.alterLabelAddFields(label_type::STRING,label_name::STRING,add_field_spec_values::LIST) :: (record_affected::INTEGER)`\n15. **db.alterLabelModFields**: 修改label field，签名为 `db.alterLabelModFields(label_type::STRING,label_name::STRING,mod_field_specs::LIST) :: (record_affected::INTEGER)`\n16. **db.createEdgeLabel**: 创建Edge Label，签名为 `db.createEdgeLabel(type_name::STRING,field_specs::LIST) :: (::VOID)`\n17. **db.addIndex**: 创建索引，签名为 `db.addIndex(label_name::STRING,field_name::STRING,unique::BOOLEAN) :: (::VOID)`\n18. **db.addEdgeIndex**: 创建索引，签名为 `db.addEdgeIndex(label_name::STRING,field_name::STRING,unique::BOOLEAN,pair_unique::BOOLEAN) :: (::VOID)`\n19. **db.addVertexCompositeIndex**: 创建组合索引，签名为 `db.addVertexCompositeIndex(label_name::STRING,field_names::LIST,unique::BOOLEAN) :: (::VOID)`\n\n该段落位于文档的第5.2节“内置procedures完整列表”中，主要列出了与标签和索引管理相关的操作命令，包括修改标签属性、创建边标签和索引等功能，帮助用户了解如何在TuGraph中高效地管理数据结构和索引。"
            },
            {
                "content": "16. **db.createEdgeLabel**: 创建Edge Label，签名为 `db.createEdgeLabel(type_name::STRING,field_specs::LIST) :: (::VOID)`\n17. **db.addIndex**: 创建索引，签名为 `db.addIndex(label_name::STRING,field_name::STRING,unique::BOOLEAN) :: (::VOID)`\n18. **db.addEdgeIndex**: 创建索引，签名为 `db.addEdgeIndex(label_name::STRING,field_name::STRING,unique::BOOLEAN,pair_unique::BOOLEAN) :: (::VOID)`\n19. **db.addVertexCompositeIndex**: 创建组合索引，签名为 `db.addVertexCompositeIndex(label_name::STRING,field_names::LIST,unique::BOOLEAN) :: (::VOID)`\n20. **db.deleteIndex**: 删除索引，签名为 `db.deleteIndex(label_name::STRING,field_name::STRING) :: (::VOID)`\n21. **db.deleteCompositeIndex**: 删除组合索引，签名为 `db.deleteIndex(label_name::STRING,field_names::LIST) :: (::VOID)`\n22. **db.backup**: 备份数据，签名为 `db.backup(destination::STRING) :: ()`\n23. **dbms.procedures**: 列出所有procedures，签名为 `dbms.procedures() :: (name::STRING,signature::STRING)`\n\n该部分内容位于文档的第五部分“附录2. 内置procedures列表”，主要列出了TuGraph中与标签和索引管理相关的内置过程，包括创建、删除索引和标签的相关命令，以及备份数据和列出所有过程的命令。这些命令帮助用户在图数据库中有效管理数据结构。"
            },
            {
                "content": "20. **db.deleteIndex**: 删除索引，签名为 `db.deleteIndex(label_name::STRING,field_name::STRING) :: (::VOID)`\n21. **db.deleteCompositeIndex**: 删除组合索引，签名为 `db.deleteIndex(label_name::STRING,field_names::LIST) :: (::VOID)`\n22. **db.backup**: 备份数据，签名为 `db.backup(destination::STRING) :: ()`\n23. **dbms.procedures**: 列出所有procedures，签名为 `dbms.procedures() :: (name::STRING,signature::STRING)`\n24. **dbms.security.changePassword**: 更改当前用户的密码，签名为 `dbms.security.changePassword(current_password::STRING,new_password::STRING) :: (::VOID)`\n25. **dbms.security.changeUserPassword**: 更改指定用户的密码，签名为 `dbms.security.changeUserPassword(user_name::STRING,new_password::STRING) :: (::VOID)`\n26. **dbms.security.createUser**: 创建用户，签名为 `dbms.security.createUser(user_name::STRING,password::STRING) :: (::VOID)`\n27. **dbms.security.deleteUser**: 删除用户，签名为 `dbms.security.deleteUser(user_name::STRING) :: (::VOID)`\n28. **dbms.security.listUsers**: 列出所有用户，签名为 `dbms.security.listUsers() :: (user_name::STRING,user_info::MAP)`\n\n该内容片段位于文档的第五部分“内置procedures列表”中，具体列出了与数据库管理相关的一系列命令，包括删除索引、备份数据以及用户管理相关的操作。这些命令的描述和签名为用户提供了在TuGraph数据库中进行操作的具体指导。"
            },
            {
                "content": "25. **dbms.security.changeUserPassword**: 更改指定用户的密码，签名为 `dbms.security.changeUserPassword(user_name::STRING,new_password::STRING) :: (::VOID)`\n26. **dbms.security.createUser**: 创建用户，签名为 `dbms.security.createUser(user_name::STRING,password::STRING) :: (::VOID)`\n27. **dbms.security.deleteUser**: 删除用户，签名为 `dbms.security.deleteUser(user_name::STRING) :: (::VOID)`\n28. **dbms.security.listUsers**: 列出所有用户，签名为 `dbms.security.listUsers() :: (user_name::STRING,user_info::MAP)`\n29. **dbms.security.showCurrentUser**: 列出当前用户信息，签名为 `dbms.security.showCurrentUser() :: (current_user::STRING)`\n30. **dbms.security.getUserPermissions**: 列出指定用户的权限，签名为 `dbms.security.getUserPermissions(user_name::STRING) :: (user_info::MAP)`\n31. **dbms.graph.createGraph**: 创建子图，签名为 `dbms.graph.createGraph(graph_name::STRING, description::STRING, max_size_GB::INTEGER) :: (::VOID)`\n32. **dbms.graph.modGraph**: 修改子图属性，签名为 `dbms.graph.modGraph(graph_name::STRING,config::MAP) :: (::VOID)`\n\n该文本块位于文档的“5.2.内置procedures完整列表”部分，具体描述了与用户管理和图操作相关的内置程序，包括更改用户密码、创建和删除用户、列出用户信息及权限，以及创建和修改子图。这部分内容为用户提供了数据库操作的相关命令和调用签名，方便日常管理及操作查询。"
            },
            {
                "content": "29. **dbms.security.showCurrentUser**: 列出当前用户信息，签名为 `dbms.security.showCurrentUser() :: (current_user::STRING)`\n30. **dbms.security.getUserPermissions**: 列出指定用户的权限，签名为 `dbms.security.getUserPermissions(user_name::STRING) :: (user_info::MAP)`\n31. **dbms.graph.createGraph**: 创建子图，签名为 `dbms.graph.createGraph(graph_name::STRING, description::STRING, max_size_GB::INTEGER) :: (::VOID)`\n32. **dbms.graph.modGraph**: 修改子图属性，签名为 `dbms.graph.modGraph(graph_name::STRING,config::MAP) :: (::VOID)`\n33. **dbms.graph.deleteGraph**: 删除子图，签名为 `dbms.graph.deleteGraph(graph_name::STRING) :: (::VOID)`\n34. **dbms.graph.listGraphs**: 列出所有子图，签名为 `dbms.graph.listGraphs() :: (graph_name::STRING,configuration::MAP)`\n35. **dbms.graph.getGraphInfo**: 列出指定子图的信息，签名为 `dbms.graph.getGraphInfo(graph_name::STRING)::(graph_name::STRING,configuration::MAP)`\n36. **dbms.security.addAllowedHosts**: 添加ip到信任列表，签名为 `dbms.security.addAllowedHosts(hosts::LIST) :: (num_new::INTEGER)`\n\n该部分内容位于文档的第五节“附录2. 内置procedures列表”中，主要列出了与用户权限管理和图结构管理相关的内置过程，包括当前用户信息、用户权限、子图的创建、修改、删除及查询相关的操作。这些过程对于用户管理和图数据库的组织结构优化至关重要。"
            },
            {
                "content": "33. **dbms.graph.deleteGraph**: 删除子图，签名为 `dbms.graph.deleteGraph(graph_name::STRING) :: (::VOID)`\n34. **dbms.graph.listGraphs**: 列出所有子图，签名为 `dbms.graph.listGraphs() :: (graph_name::STRING,configuration::MAP)`\n35. **dbms.graph.getGraphInfo**: 列出指定子图的信息，签名为 `dbms.graph.getGraphInfo(graph_name::STRING)::(graph_name::STRING,configuration::MAP)`\n36. **dbms.security.addAllowedHosts**: 添加ip到信任列表，签名为 `dbms.security.addAllowedHosts(hosts::LIST) :: (num_new::INTEGER)`\n37. **dbms.security.deleteAllowedHosts**: 从信任列表删除ip，签名为 `dbms.security.deleteAllowedHosts(hosts::LIST) :: (record_affected::INTEGER)`\n38. **dbms.security.listAllowedHosts**: 列出信任列表中的主机ip，签名为 `dbms.security.listAllowedHosts() :: (host::STRING)`\n39. **dbms.config.update**: 更新TuGraph配置，签名为 `dbms.config.update(updates::MAP) :: (message::STRING)`\n40. **dbms.config.list**: 列出TuGraph配置，签名为 `dbms.config.list() :: (name::STRING,value::ANY)`\n\n该段落位于文档的第五部分，主要介绍TuGraph的内置程序和相关命令，包括图的创建、删除和管理，以及安全设置如允许的主机列表和配置更新。这些命令支持用户对图数据库的有效操作和安全管理。"
            },
            {
                "content": "37. **dbms.security.deleteAllowedHosts**: 从信任列表删除ip，签名为 `dbms.security.deleteAllowedHosts(hosts::LIST) :: (record_affected::INTEGER)`\n38. **dbms.security.listAllowedHosts**: 列出信任列表中的主机ip，签名为 `dbms.security.listAllowedHosts() :: (host::STRING)`\n39. **dbms.config.update**: 更新TuGraph配置，签名为 `dbms.config.update(updates::MAP) :: (message::STRING)`\n40. **dbms.config.list**: 列出TuGraph配置，签名为 `dbms.config.list() :: (name::STRING,value::ANY)`\n41. **algo.shortestPath**: 查询两个点间的最短路径，签名为 `algo.shortestPath(startNode::NODE,endNode::NODE,config::MAP) :: (nodeCount::INTEGER,totalCost::FLOAT)`\n42. **algo.allShortestPaths**: 查询两个点间的所有最短路径，签名为 `algo.allShortestPaths(startNode::NODE,endNode::NODE,config::MAP) :: (nodeIds::LIST,relationshipIds::LIST,cost::LIST)`\n43. **algo.native.extract**: 查询指定VertexId/EdgeUid（列表）指定field的值（列表），签名为 `algo.native.extract(id::ANY,config::MAP) :: (value::ANY)`\n44. **db.flushDB**: 刷新db，签名为 `db.flushDB() :: (::VOID)`\n\n该片段位于文档的第5.2节，包含了一系列内置的程序和函数列表，具体列出了对数据库和图的操作，包括删除信任主机、列出信任主机、更新配置、查询最短路径等功能。每个条目都附有相应的描述和调用签名，便于用户理解和使用。"
            },
            {
                "content": "41. **algo.shortestPath**: 查询两个点间的最短路径，签名为 `algo.shortestPath(startNode::NODE,endNode::NODE,config::MAP) :: (nodeCount::INTEGER,totalCost::FLOAT)`\n42. **algo.allShortestPaths**: 查询两个点间的所有最短路径，签名为 `algo.allShortestPaths(startNode::NODE,endNode::NODE,config::MAP) :: (nodeIds::LIST,relationshipIds::LIST,cost::LIST)`\n43. **algo.native.extract**: 查询指定VertexId/EdgeUid（列表）指定field的值（列表），签名为 `algo.native.extract(id::ANY,config::MAP) :: (value::ANY)`\n44. **db.flushDB**: 刷新db，签名为 `db.flushDB() :: (::VOID)`\n45. **dbms.security.listRoles**: 列出所有角色，签名为 `dbms.security.listRoles() :: (role_name::STRING,role_info::MAP)`\n46. **dbms.security.createRole**: 创建角色，签名为 `dbms.security.createRole(role_name::STRING,desc::STRING) :: (::VOID)`\n47. **dbms.security.deleteRole**: 删除角色，签名为 `dbms.security.deleteRole(role_name::STRING) :: (::VOID)`\n48. **dbms.security.getRoleInfo**: 获取角色详细信息，签名为 `dbms.security.getRoleInfo(role::STRING) :: (role_info::MAP)`\n\n该段落位于文档的第5.2节“内置procedures完整列表”中，主要列出了TuGraph查询语言中与算法相关的内置过程（如最短路径查询和数据提取）以及与安全管理相关的角色管理命令（如列出、创建和删除角色）。这些命令的签名提供了用户在使用过程中的调用方式和参数信息。"
            },
            {
                "content": "44. **db.flushDB**: 刷新db，签名为 `db.flushDB() :: (::VOID)`\n45. **dbms.security.listRoles**: 列出所有角色，签名为 `dbms.security.listRoles() :: (role_name::STRING,role_info::MAP)`\n46. **dbms.security.createRole**: 创建角色，签名为 `dbms.security.createRole(role_name::STRING,desc::STRING) :: (::VOID)`\n47. **dbms.security.deleteRole**: 删除角色，签名为 `dbms.security.deleteRole(role_name::STRING) :: (::VOID)`\n48. **dbms.security.getRoleInfo**: 获取角色详细信息，签名为 `dbms.security.getRoleInfo(role::STRING) :: (role_info::MAP)`\n49. **dbms.security.disableRole**: 禁用/启用角色，签名为 `dbms.security.disableRole(role::STRING,disable::BOOLEAN) :: (::VOID)`\n50. **dbms.security.modRoleDesc**: 修改角色描述信息，签名为 `dbms.security.modRoleDesc(role::STRING,description::STRING) :: (::VOID)`\n51. **dbms.security.rebuildRoleAccessLevel**: 删除角色权限并重建，签名为 `dbms.security.rebuildRoleAccessLevel(role::STRING,access_level::MAP) :: (::VOID)`\n52. **dbms.security.modRoleAccessLevel**: 修改角色对指定图的访问权限，签名为 `dbms.security.modRoleAccessLevel(role::STRING,access_level::MAP) :: (::VOID)`\n\n该段落介绍了与角色管理相关的内置程序，包括列出所有角色、创建和删除角色、获取角色详细信息、禁用启用角色、修改角色描述以及重建和修改角色的访问权限。这些功能涉及图数据库的安全管理，确保用户对角色的权限和属性进行有效控制。"
            },
            {
                "content": "50. **dbms.security.modRoleDesc**: 修改角色描述信息，签名为 `dbms.security.modRoleDesc(role::STRING,description::STRING) :: (::VOID)`\n51. **dbms.security.rebuildRoleAccessLevel**: 删除角色权限并重建，签名为 `dbms.security.rebuildRoleAccessLevel(role::STRING,access_level::MAP) :: (::VOID)`\n52. **dbms.security.modRoleAccessLevel**: 修改角色对指定图的访问权限，签名为 `dbms.security.modRoleAccessLevel(role::STRING,access_level::MAP) :: (::VOID)`\n53. **dbms.security.modRoleFieldAccessLevel**: 修改角色对指定属性的访问权限，签名为 `dbms.security.modRoleFieldAccessLevel(role::STRING,graph::STRING,label::STRING,field::STRING,label_type::STRING,field_access_level::STRING) :: (::VOID)`\n54. **dbms.security.getUserInfo**: 获取用户详细信息，签名为 `dbms.security.getUserInfo(user::STRING) :: (user_info::MAP)`\n55. **dbms.security.disableUser**: 禁用/启用用户，签名为 `dbms.security.disableUser(user::STRING,disable::BOOLEAN) :: (::VOID)`\n56. **dbms.security.setCurrentDesc**: 设置当前用户描述信息，签名为 `dbms.security.setCurrentDesc(description::STRING) :: (::VOID)`\n\n该块内容位于文档的第五部分“附录2. 内置procedures列表”中，主要列出了与用户和角色管理相关的程序，如修改角色描述、重建角色权限、修改角色访问权限等操作的具体签名和描述。这部分详细介绍了如何管理图数据库中的用户与角色权限，以及相关的函数调用形式。"
            },
            {
                "content": "54. **dbms.security.getUserInfo**: 获取用户详细信息，签名为 `dbms.security.getUserInfo(user::STRING) :: (user_info::MAP)`\n55. **dbms.security.disableUser**: 禁用/启用用户，签名为 `dbms.security.disableUser(user::STRING,disable::BOOLEAN) :: (::VOID)`\n56. **dbms.security.setCurrentDesc**: 设置当前用户描述信息，签名为 `dbms.security.setCurrentDesc(description::STRING) :: (::VOID)`\n57. **dbms.security.setUserDesc**: 设置用户描述信息，签名为 `dbms.security.setUserDesc(user::STRING,description::STRING) :: (::VOID)`\n58. **dbms.security.getUserMemoryUsage**: 获取用户内存用量，签名为 `dbms.security.getUserMemoryUsage(user::STRING) :: (memory_usage::INTEGER)`\n59. **dbms.security.setUserMemoryLimit**: 设置用户内存限制，签名为 `dbms.security.setUserMemoryLimit(user::STRING,memorylimit::INTEGER) :: (::VOID)`\n60. **dbms.security.deleteUserRoles**: 删除用户与角色的联系，签名为 `dbms.security.deleteUserRoles(user::STRING,roles::LIST) :: (::VOID)`\n61. **dbms.security.rebuildUserRoles**: 清空用户角色的关系并重建，签名为 `dbms.security.rebuildUserRoles(user::STRING,roles::LIST) :: (::VOID)`\n\n该段落位于文档的\"5.2.内置procedures完整列表\"部分，列出了与用户管理相关的内置程序，包括获取用户信息、禁用用户、设置用户描述、获取用户内存用量及限制等功能。"
            },
            {
                "content": "59. **dbms.security.setUserMemoryLimit**: 设置用户内存限制，签名为 `dbms.security.setUserMemoryLimit(user::STRING,memorylimit::INTEGER) :: (::VOID)`\n60. **dbms.security.deleteUserRoles**: 删除用户与角色的联系，签名为 `dbms.security.deleteUserRoles(user::STRING,roles::LIST) :: (::VOID)`\n61. **dbms.security.rebuildUserRoles**: 清空用户角色的关系并重建，签名为 `dbms.security.rebuildUserRoles(user::STRING,roles::LIST) :: (::VOID)`\n62. **dbms.security.addUserRoles**: 新增用户与角色的联系，签名为 `dbms.security.addUserRoles(user::STRING,roles::LIST) :: (::VOID)`\n63. **db.plugin.loadPlugin**: 装载plugin，签名为 `db.plugin.loadPlugin(plugin_type::STRING,plugin_name::STRING,plugin_content::STRING or MAP,code_type::STRING,plugin_description::STRING,read_only::BOOLEAN,version::STRING) :: (::VOID)`\n64. **db.plugin.deletePlugin**: 删除plugin，签名为 `db.plugin.deletePlugin(plugin_type::STRING,plugin_name::STRING) :: (::VOID)`\n65. **db.plugin.listPlugin**: 列出已装载的plugin，签名为 `db.plugin.listPlugin(plugin_type::STRING,plugin_version::STRING) :: (plugin_description::LIST)`\n\n此段落位于文档的第五部分“5.2.内置procedures完整列表”中，具体列举了与用户角色管理和插件操作相关的内置过程，涵盖了设置用户内存限制、删除用户角色、重建用户角色以及管理插件的创建、删除和列表等功能。"
            },
            {
                "content": "63. **db.plugin.loadPlugin**: 装载plugin，签名为 `db.plugin.loadPlugin(plugin_type::STRING,plugin_name::STRING,plugin_content::STRING or MAP,code_type::STRING,plugin_description::STRING,read_only::BOOLEAN,version::STRING) :: (::VOID)`\n64. **db.plugin.deletePlugin**: 删除plugin，签名为 `db.plugin.deletePlugin(plugin_type::STRING,plugin_name::STRING) :: (::VOID)`\n65. **db.plugin.listPlugin**: 列出已装载的plugin，签名为 `db.plugin.listPlugin(plugin_type::STRING,plugin_version::STRING) :: (plugin_description::LIST)`\n66. **db.plugin.getPluginInfo**: 获取plugin的详细信息，签名为 `db.plugin.getPluginInfo(plugin_type::STRING,plugin_name::STRING,show_code::BOOLEAN)::(plugin_description::MAP)`\n67. **db.plugin.callPlugin**: 执行plugin，签名为 `db.plugin.callPlugin(plugin_type::STRING,plugin_name::STRING,param::STRING,timeout::DOUBLE,in_process::BOOLEAN) :: (success::BOOLEAN,result::STRING)`\n\n该章节介绍了TuGraph数据库中与插件管理相关的命令，包括如何装载、删除、列出已装载插件、获取插件信息和执行插件的功能。这部分内容对于需要扩展数据库功能或集成第三方工具的用户尤为重要。"
            },
            {
                "content": "65. **db.plugin.listPlugin**: 列出已装载的plugin，签名为 `db.plugin.listPlugin(plugin_type::STRING,plugin_version::STRING) :: (plugin_description::LIST)`\n66. **db.plugin.getPluginInfo**: 获取plugin的详细信息，签名为 `db.plugin.getPluginInfo(plugin_type::STRING,plugin_name::STRING,show_code::BOOLEAN)::(plugin_description::MAP)`\n67. **db.plugin.callPlugin**: 执行plugin，签名为 `db.plugin.callPlugin(plugin_type::STRING,plugin_name::STRING,param::STRING,timeout::DOUBLE,in_process::BOOLEAN) :: (success::BOOLEAN,result::STRING)`\n68. **db.importor.dataImportor**: 导入点或边数据，签名为 `db.importor.dataImportor(description::STRING,content::STRING,continue_on_error::BOOLEAN,thread_nums::INTEGER,delimiter::STRING) :: (::VOID)`\n69. **db.importor.schemaImportor**: 导入点或边schema，签名为 `db.importor.schemaImportor(description::STRING) :: (::VOID)`\n70. **db.addFullTextIndex**: 添加全文索引，签名为 `db.addFullTextIndex(is_vertex::BOOLEAN, label_name::STRING, field_name::STRING) :: (::VOID)`\n\n此块内容位于第五部分“附录2. 内置procedures列表”中，具体列出了与插件管理和数据导入相关的内置过程，包括插件的列出、获取详细信息、执行插件，以及点或边数据和schema的导入功能。"
            },
            {
                "content": "68. **db.importor.dataImportor**: 导入点或边数据，签名为 `db.importor.dataImportor(description::STRING,content::STRING,continue_on_error::BOOLEAN,thread_nums::INTEGER,delimiter::STRING) :: (::VOID)`\n69. **db.importor.schemaImportor**: 导入点或边schema，签名为 `db.importor.schemaImportor(description::STRING) :: (::VOID)`\n70. **db.addFullTextIndex**: 添加全文索引，签名为 `db.addFullTextIndex(is_vertex::BOOLEAN, label_name::STRING, field_name::STRING) :: (::VOID)`\n71. **db.deleteFullTextIndex**: 删除全文索引，签名为 `db.deleteFullTextIndex(is_vertex::BOOLEAN, label_name::STRING, field_name::STRING) :: (::VOID)`\n72. **db.rebuildFullTextIndex**: 重建全文索引，签名为 `db.rebuildFullTextIndex(vertex_labels::STRING, edge_labels::STRING) :: (::VOID)`\n73. **db.fullTextIndexes**: 查看全文索引，签名为 `db.fullTextIndexes() :: (is_vertex::BOOLEAN, label::STRING, field::STRING)`\n74. **dbms.meta.count**: 查看点边总数，签名为 `db.dbms.meta.count() :: (type::STRING, number::INTEGER)`\n\n该文本块位于文档的\"内置procedures完整列表\"部分，具体介绍了与数据导入、全文索引管理以及数据库元数据查询相关的内置程序的名称、功能描述和调用签名。"
            },
            {
                "content": "71. **db.deleteFullTextIndex**: 删除全文索引，签名为 `db.deleteFullTextIndex(is_vertex::BOOLEAN, label_name::STRING, field_name::STRING) :: (::VOID)`\n72. **db.rebuildFullTextIndex**: 重建全文索引，签名为 `db.rebuildFullTextIndex(vertex_labels::STRING, edge_labels::STRING) :: (::VOID)`\n73. **db.fullTextIndexes**: 查看全文索引，签名为 `db.fullTextIndexes() :: (is_vertex::BOOLEAN, label::STRING, field::STRING)`\n74. **dbms.meta.count**: 查看点边总数，签名为 `db.dbms.meta.count() :: (type::STRING, number::INTEGER)`\n75. **dbms.meta.countDetail**: 查看点边总数详情，签名为 `db.dbms.meta.countDetail() :: (is_vertex::BOOLEAN, label::STRING, count::INTEGER)`\n76. **dbms.meta.refreshCount**: 重新统计点边数量，统计期间停写，签名为 `db.dbms.meta.refreshCount() :: (::VOID)`\n77. **dbms.task.listTasks**: 查询正在执行的任务，签名为 `dbms.task.listTasks()::(tasks::LIST)`\n78. **dbms.task.terminateTask**: 中止任务，签名为 `dbms.task.terminateTask(task_id::STRING)::(::VOID)`\n79. **dbms.ha.clusterInfo**: HA模式下查看集群状态，签名为 `dbms.ha.clusterInfo() :: (cluster_info::LIST, is_master::BOOLEAN)`\n\n该文本块位于文档的第五部分，包含了TuGraph数据库的内置procedures列表，具体描述了与全文索引管理、元数据统计以及任务管理相关的命令，包括删除全文索引、重建全文索引、查看全文索引、点边总数统计以及HA模式下的集群状态查询等功能。"
            },
            {
                "content": "75. **dbms.meta.countDetail**: 查看点边总数详情，签名为 `db.dbms.meta.countDetail() :: (is_vertex::BOOLEAN, label::STRING, count::INTEGER)`\n76. **dbms.meta.refreshCount**: 重新统计点边数量，统计期间停写，签名为 `db.dbms.meta.refreshCount() :: (::VOID)`\n77. **dbms.task.listTasks**: 查询正在执行的任务，签名为 `dbms.task.listTasks()::(tasks::LIST)`\n78. **dbms.task.terminateTask**: 中止任务，签名为 `dbms.task.terminateTask(task_id::STRING)::(::VOID)`\n79. **dbms.ha.clusterInfo**: HA模式下查看集群状态，签名为 `dbms.ha.clusterInfo() :: (cluster_info::LIST, is_master::BOOLEAN)`\n80. **db.dropDB**: 清空数据库，签名为 `db.dropDB() :: (::VOID)`\n\n该块内容位于文档的最后部分，主要列出了与图数据库管理相关的命令，包括查询点边数量的详细信息、统计数据刷新、任务管理以及数据库的清空操作。这些命令是对之前提到的数据库操作和管理功能的补充，涉及如何监控正在执行的任务和处理集群状态。"
            },
            {
                "content": "总体总结：该表格汇总了一系列与图数据库操作相关的命令，包括数据管理（如创建、删除、修改标签和索引）、安全管理（如用户和角色的管理）、图操作（如创建和修改子图）、算法查询（如最短路径查询）以及插件和导入数据的功能。每个命令都包含简要描述和其具体的调用签名，便于用户了解其功能及使用方法。\n\n该段落位于文档的末尾，总结了与图数据库操作相关的命令，包括数据管理、安全管理、图操作、算法查询和插件功能，为用户提供了简要描述和调用签名，以便更好地理解和使用这些功能。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_82.md",
        "chunks": [
            {
                "content": "# 联系我们\n您可以通过以下方式联系我们。\n\n微信公众号: TuGraph\n\n邮箱（商务沟通等其他问题）: tugraph@service.alipay.com\n\n电话：400-903-0809\n\n该文档提供了与TuGraph联系的多种方式，包括微信公众号、邮箱及客服电话，旨在帮助用户获取支持或进行商务沟通。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_83.md",
        "chunks": [
            {
                "content": "# 忘记'admin'密码\n> TuGraph 提供了重置密码的功能，当用户忘记管理者账号`admin`密码时，可以通过重置密码的方式来修改密码。\n\n## 1.重置密码\n首先，需要停止TuGraph服务端。如果是容器内部署，需要进入容器中执行如下命令：\n\n```bash\nlgraph_server -c /usr/local/etc/lgraph.json -d stop\n```\n\n再次启动TuGraph服务端时，需要添加如下参数：\n\n```bash\n--reset_admin_password 1\n```\n\n如下所示：\n```bash\nlgraph_server -c /usr/local/etc/lgraph.json --reset_admin_password 1 --log_dir \"\"\n```\n\n这一操作可以使得TuGraph服务端在启动时，重置管理者`admin`的密码为默认密码：`73@TuGraph`。\n密码重置成功会给出相关信息“Reset admin password successfully”并关闭当前服务端进程。\n\n## 2.重启服务\n\n用户需要以正常模式重新启动服务端，然后使用默认账号密码进行登录，登录后重新设置密码即可正常使用。\n重新启动TuGraph服务的命令如下：\n\n```bash\nlgraph_server -c /usr/local/etc/lgraph.json -d start\n```\n\n该文档主要介绍了如何重置TuGraph数据库管理者账号`admin`的密码，提供了详细的步骤，包括停止服务、重置密码和重新启动服务的命令，旨在帮助用户解决忘记密码的问题。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_84.md",
        "chunks": [
            {
                "content": "# 源码部署\n\n## 准备工作\n\n### 编译 GeaFlow 源码\n\n编译 GeaFlow 依赖以下环境：\n\n- JDK8\n- Maven(推荐 3.6.3 及以上版本)\n- Git\n\n执行以下命令来编译 GeaFlow 源码：\n\n```shell\ngit clone https://github.com/TuGraph-family/tugraph-analytics.git\ncd tugraph-analytics/\nmvn clean package -DskipTests\n```\n\n## 本地运行流图作业\n\n下面介绍如何在本地环境运行一个实时环路查找的图计算作业。\n\n1. 启动流图作业\n\n在编译完 geaflow 代码后，在工程目录下执行以下命令，启动实时环路查找的计算作业：\n\n```shell\nbin/gql_submit.sh --gql geaflow/geaflow-examples/gql/loop_detection.sql\n```\n\n如果你想要在进程中使用火焰图进行进程分析，则需要自行下载解压async-profiler，\n并将解压后的文件夹中的profiler.sh的路径加入到参数中。例如：\n\n```shell\nbin/gql_submit.sh --gql geaflow/geaflow-examples/gql/loop_detection.sql --profiler /tmp/async-profiler/profiler.sh\n```\n\n其中 loop_detection.sql 是一段实时查询图中所有四度环路的 DSL 计算作业，其内容如下：\n\n```sql\nset geaflow.dsl.window.size = 1;\nset geaflow.dsl.ignore.exception = true;\n\n本段内容是关于如何准备和编译GeaFlow源码，以及在本地运行实时环路查找的图计算作业的具体步骤，属于文档的开头部分，提供了基础环境要求和作业启动命令。"
            },
            {
                "content": "1. 启动流图作业\n\n在编译完 geaflow 代码后，在工程目录下执行以下命令，启动实时环路查找的计算作业：\n\n```shell\nbin/gql_submit.sh --gql geaflow/geaflow-examples/gql/loop_detection.sql\n```\n\n如果你想要在进程中使用火焰图进行进程分析，则需要自行下载解压async-profiler，\n并将解压后的文件夹中的profiler.sh的路径加入到参数中。例如：\n\n```shell\nbin/gql_submit.sh --gql geaflow/geaflow-examples/gql/loop_detection.sql --profiler /tmp/async-profiler/profiler.sh\n```\n\n其中 loop_detection.sql 是一段实时查询图中所有四度环路的 DSL 计算作业，其内容如下：\n\n```sql\nset geaflow.dsl.window.size = 1;\nset geaflow.dsl.ignore.exception = true;\n\nCREATE GRAPH IF NOT EXISTS dy_modern (\n  Vertex person (\n    id bigint ID,\n    name varchar\n  ),\n  Edge knows (\n    srcId bigint SOURCE ID,\n    targetId bigint DESTINATION ID,\n    weight double\n  )\n) WITH (\n  storeType='rocksdb',\n  shardCount = 1\n);\n\nCREATE TABLE IF NOT EXISTS tbl_source (\n  text varchar\n) WITH (\n  type='socket',\n  `geaflow.dsl.column.separator` = '#',\n  `geaflow.dsl.socket.host` = 'localhost',\n  `geaflow.dsl.socket.port` = 9003\n);\n\n该文档主要介绍了如何部署和运行 GeaFlow 源码，包括准备工作、编译过程、本地运行流图作业的步骤、socket 服务的启动、数据输入、可视化 dashboard 访问等内容。上述片段具体讲述了如何启动实时环路查找的计算作业，包括执行命令和 DSL 计算作业的具体内容。"
            },
            {
                "content": "CREATE GRAPH IF NOT EXISTS dy_modern (\n  Vertex person (\n    id bigint ID,\n    name varchar\n  ),\n  Edge knows (\n    srcId bigint SOURCE ID,\n    targetId bigint DESTINATION ID,\n    weight double\n  )\n) WITH (\n  storeType='rocksdb',\n  shardCount = 1\n);\n\nCREATE TABLE IF NOT EXISTS tbl_source (\n  text varchar\n) WITH (\n  type='socket',\n  `geaflow.dsl.column.separator` = '#',\n  `geaflow.dsl.socket.host` = 'localhost',\n  `geaflow.dsl.socket.port` = 9003\n);\n\nCREATE TABLE IF NOT EXISTS tbl_result (\n  a_id bigint,\n  b_id bigint,\n  c_id bigint,\n  d_id bigint,\n  a1_id bigint\n) WITH (\n  type='socket',\n    `geaflow.dsl.column.separator` = ',',\n    `geaflow.dsl.socket.host` = 'localhost',\n    `geaflow.dsl.socket.port` = 9003\n);\n\nUSE GRAPH dy_modern;\n\nINSERT INTO dy_modern.person(id, name)\nSELECT\ncast(trim(split_ex(t1, ',', 0)) as bigint),\nsplit_ex(t1, ',', 1)\nFROM (\n  Select trim(substr(text, 2)) as t1\n  FROM tbl_source\n  WHERE substr(text, 1, 1) = '.'\n);\n\n该代码块是关于在GeaFlow中创建图和表的DSL（领域特定语言）语句，包含图的定义、数据源和结果表的创建，以及数据插入的部分。它位于文档关于如何在本地运行流图作业的部分，具体用于实时环路查找的图计算作业中。"
            },
            {
                "content": "CREATE TABLE IF NOT EXISTS tbl_result (\n  a_id bigint,\n  b_id bigint,\n  c_id bigint,\n  d_id bigint,\n  a1_id bigint\n) WITH (\n  type='socket',\n    `geaflow.dsl.column.separator` = ',',\n    `geaflow.dsl.socket.host` = 'localhost',\n    `geaflow.dsl.socket.port` = 9003\n);\n\nUSE GRAPH dy_modern;\n\nINSERT INTO dy_modern.person(id, name)\nSELECT\ncast(trim(split_ex(t1, ',', 0)) as bigint),\nsplit_ex(t1, ',', 1)\nFROM (\n  Select trim(substr(text, 2)) as t1\n  FROM tbl_source\n  WHERE substr(text, 1, 1) = '.'\n);\n\nINSERT INTO dy_modern.knows\nSELECT\n cast(split_ex(t1, ',', 0) as bigint),\n cast(split_ex(t1, ',', 1) as bigint),\n cast(split_ex(t1, ',', 2) as double)\nFROM (\n  Select trim(substr(text, 2)) as t1\n  FROM tbl_source\n  WHERE substr(text, 1, 1) = '-'\n);\n\n该段落位于文档中关于如何在本地环境运行实时环路查找的图计算作业的部分，具体描述了创建数据库表和插入数据的 SQL 语句。这些操作是在定义图形模型和数据源之后进行的，为后续图计算提供输入数据。"
            },
            {
                "content": "USE GRAPH dy_modern;\n\nINSERT INTO dy_modern.person(id, name)\nSELECT\ncast(trim(split_ex(t1, ',', 0)) as bigint),\nsplit_ex(t1, ',', 1)\nFROM (\n  Select trim(substr(text, 2)) as t1\n  FROM tbl_source\n  WHERE substr(text, 1, 1) = '.'\n);\n\nINSERT INTO dy_modern.knows\nSELECT\n cast(split_ex(t1, ',', 0) as bigint),\n cast(split_ex(t1, ',', 1) as bigint),\n cast(split_ex(t1, ',', 2) as double)\nFROM (\n  Select trim(substr(text, 2)) as t1\n  FROM tbl_source\n  WHERE substr(text, 1, 1) = '-'\n);\n\nINSERT INTO tbl_result\nSELECT DISTINCT\n  a_id,\n  b_id,\n  c_id,\n  d_id,\n  a1_id\nFROM (\n  MATCH (a:person) -[:knows]->(b:person) -[:knows]-> (c:person)\n   -[:knows]-> (d:person) -> (a:person)\n  RETURN a.id as a_id, b.id as b_id, c.id as c_id, d.id as d_id, a.id as a1_id\n);\n```\n\n该 DSL 实时读取 socket 服务 9003 端口数据，实时构图，然后计算图中所有的 4 度的环路, 并将环路上的点 id 输出到 socket 服务 9003 端口，然后显示在 socket 控制台。\n\n2. 启动 SocketServer\n\n执行以下命令，启动 socket server 程序:\n\n```shell\nbin/socket.sh\n```\n\nsocket 服务启动后，控制台显示如下信息：\n\n该段落位于文档中关于如何在本地环境运行实时环路查找的图计算作业的部分，具体介绍了如何使用DSL语句插入数据到图中，并进行环路检测的SQL查询。这是实时计算作业流程中的关键步骤。"
            },
            {
                "content": "INSERT INTO tbl_result\nSELECT DISTINCT\n  a_id,\n  b_id,\n  c_id,\n  d_id,\n  a1_id\nFROM (\n  MATCH (a:person) -[:knows]->(b:person) -[:knows]-> (c:person)\n   -[:knows]-> (d:person) -> (a:person)\n  RETURN a.id as a_id, b.id as b_id, c.id as c_id, d.id as d_id, a.id as a1_id\n);\n```\n\n该 DSL 实时读取 socket 服务 9003 端口数据，实时构图，然后计算图中所有的 4 度的环路, 并将环路上的点 id 输出到 socket 服务 9003 端口，然后显示在 socket 控制台。\n\n2. 启动 SocketServer\n\n执行以下命令，启动 socket server 程序:\n\n```shell\nbin/socket.sh\n```\n\nsocket 服务启动后，控制台显示如下信息：\n\n```\nStart netty terminal server, waiting connect.\nplease enter the data to the console.\n```\n\n3. 输入数据\n\n输入数据如下，数据前面的\".\"代表一条点数据，\"-\"代表一条边数据(起点、终点和权重)。\n\n```\n. 1,jim\n. 2,kate\n. 3,lily\n. 4,lucy\n. 5,brown\n. 6,jack\n. 7,jackson\n- 1,2,0.2\n- 2,3,0.3\n- 3,4,0.2\n- 4,1,0.1\n- 4,5,0.1\n- 5,1,0.2\n- 5,6,0.1\n- 6,7,0.1\n```\n\n可以看到 socket 控制台上显示计算出来的环路数据。\n\n你也可以继续输入新的点边数据，查看最新计算结果，如输入一下数据：\n\n```\n- 6,3,0.1\n```\n\n可以看到新的环路 3-4-5-6-3 被检查出来。\n\n4. 访问可视化dashboard页面\n\n本地模式的进程会占用本地的8090和8088端口，附带一个可视化页面。\n\n在浏览器中输入*http://localhost:8090*即可访问前端页面。\n\n\n## GeaFlow Console 快速上手\n\n该片段位于文档中，主要介绍如何在本地环境中运行实时环路查找的图计算作业，包括插入结果到结果表的SQL语句、启动SocketServer、输入数据以及访问可视化dashboard页面的步骤。"
            },
            {
                "content": "3. 输入数据\n\n输入数据如下，数据前面的\".\"代表一条点数据，\"-\"代表一条边数据(起点、终点和权重)。\n\n```\n. 1,jim\n. 2,kate\n. 3,lily\n. 4,lucy\n. 5,brown\n. 6,jack\n. 7,jackson\n- 1,2,0.2\n- 2,3,0.3\n- 3,4,0.2\n- 4,1,0.1\n- 4,5,0.1\n- 5,1,0.2\n- 5,6,0.1\n- 6,7,0.1\n```\n\n可以看到 socket 控制台上显示计算出来的环路数据。\n\n你也可以继续输入新的点边数据，查看最新计算结果，如输入一下数据：\n\n```\n- 6,3,0.1\n```\n\n可以看到新的环路 3-4-5-6-3 被检查出来。\n\n4. 访问可视化dashboard页面\n\n本地模式的进程会占用本地的8090和8088端口，附带一个可视化页面。\n\n在浏览器中输入*http://localhost:8090*即可访问前端页面。\n\n\n## GeaFlow Console 快速上手\n\nGeaFlow Console 是 GeaFlow 提供的图计算研发平台，我们将介绍如何在 Docker 容器里面启动 GeaFlow Console 平台，提交流图计算作业。\n\n## GeaFlow Kubernetes Operator快速上手\nGeaflow Kubernetes Operator是一个可以快速将Geaflow应用部署到kubernetes集群中的部署工具。\n我们将介绍如何通过Helm安装geaflow-kubernetes-operator，通过yaml文件快速提交geaflow作业，\n并访问operator的dashboard页面查看集群下的作业状态。\n\n## 使用 G6VP 进行流图计算作业可视化\n\nG6VP 是一个可扩展的图可视分析平台，包括数据源管理、构图、图元素个性化配置、图可视分析等功能模块。使用 G6VP 能够很方便的对 Geaflow 计算结果进行可视化分析。\n\n该chunk位于文档的“本地运行流图作业”部分，具体介绍如何在实时环路查找计算作业中输入数据以及查看计算结果，并说明如何访问可视化dashboard页面以监控作业状态。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_85.md",
        "chunks": [
            {
                "content": "# OlapOnDisk API\n\n> 此文档主要详细介绍了OlapOnDisk API的使用说明\n\n    \n## 1. 简介\n\nTuGraph的Standalone模式可用于加载图数据文件，其中图数据文件来源可包含text文本文件、BINARY_FILE二进制文件和ODPS源。在该模式下，TuGraph可实现多数据来源快速加载成图，然后在该图上运行如BFS、WCC、SSSP等迭代式算法，并输出最终结果至终端。\n\n在TuGraph中，导出和计算过程均可以通过在内存中并行处理的方式进行加速，从而达到近乎实时的处理分析，和传统方法相比，即避免了数据导出落盘的开销，又能使用紧凑的图数据结构获得计算的理想性能。\n\nTuGraph内置了大量的常见图分析算法和丰富的辅助接口，因此用户几乎不需要自己实现具体的图计算过程，只需要在实现自己的存储过程的时候将相应算法库的头文件(.h)包含到自己的程序中，并在编译阶段链接自己的动态库文件即可。\n\n该文档主要介绍了Standalone的常用接口，使用到的辅助函数主要包含在OlapOnDB类。同时为帮助用户理解方便，对BFS算法进行举例说明。\n\n## 2. 算法举例\n\n在这里对BFS算法分块做解释，大体上分为主函数`main`、BFS算法流程`BFSCore`函数和配置类MyConfig。\n\n### 2.1 头文件\n\n```C++\n#include \"olap/olap_on_disk.h\"   \n#include \"tools/json.hpp\"      //使用 TuGraph 时需要包含的头文件\n#include \"./algo.h\"   //包含各种算法逻辑函数的头文件\n```\n\n在使用 TuGraph 实现图数据文件计算应用时，一般首先建立StandaloneGraph类对象graph，将图文件数据加载进graph中，之后通过调用图逻辑函数实现图计算过程，最后对图计算的结果进行打印输出。\n\n### 2.2 配置类MyConfig\n\nMyConfig配置类函数用于提供算法逻辑计算时所需的配置信息，继承于ConfigBase,其中EdgeDate可根据加载图类型不同选择Empty（无权图）、int（带权图权重为整数）或者double（带权图权重为double）类型。\n\nMyConfig配置类一般根据算法不同，需要额外配置信息如下：\n\n该文档主要介绍OlapOnDisk API的使用说明，以下部分详细阐述了该API的基本功能和配置，特别是用于图数据处理的BFS算法的实现方法。在文档的开头，介绍了TuGraph的Standalone模式及其图数据加载的能力，其中包括对BFS算法的具体代码实现和配置类MyConfig的详细描述。"
            },
            {
                "content": "## 2. 算法举例\n\n在这里对BFS算法分块做解释，大体上分为主函数`main`、BFS算法流程`BFSCore`函数和配置类MyConfig。\n\n### 2.1 头文件\n\n```C++\n#include \"olap/olap_on_disk.h\"   \n#include \"tools/json.hpp\"      //使用 TuGraph 时需要包含的头文件\n#include \"./algo.h\"   //包含各种算法逻辑函数的头文件\n```\n\n在使用 TuGraph 实现图数据文件计算应用时，一般首先建立StandaloneGraph类对象graph，将图文件数据加载进graph中，之后通过调用图逻辑函数实现图计算过程，最后对图计算的结果进行打印输出。\n\n### 2.2 配置类MyConfig\n\nMyConfig配置类函数用于提供算法逻辑计算时所需的配置信息，继承于ConfigBase,其中EdgeDate可根据加载图类型不同选择Empty（无权图）、int（带权图权重为整数）或者double（带权图权重为double）类型。\n\nMyConfig配置类一般根据算法不同，需要额外配置信息如下：\n\n1.算法所需参数\n2.算法名称\n3.配置类内Print函数\n其余公用成员继承与ConfigBase，可参考src/olap/olap_config.h查阅。\n\n```C++\nclass MyConfig : public ConfigBase {\n public:\n\n该片段位于文档的第二部分，主要介绍OlapOnDisk API中的BFS算法的实现示例，包括所需的头文件、配置类MyConfig的定义及其功能。这部分旨在帮助用户理解如何在TuGraph中使用BFS算法进行图数据处理。"
            },
            {
                "content": "1.算法所需参数\n2.算法名称\n3.配置类内Print函数\n其余公用成员继承与ConfigBase，可参考src/olap/olap_config.h查阅。\n\n```C++\nclass MyConfig : public ConfigBase {\n public:\n\n    // 算法所需参数初始化\n    size_t root = 0;\n    std::string name = std::string(\"bfs\");\n    void AddParameter(fma_common::Configuration & config) {\n        ConfigBase::AddParameter(config);\n        config.Add(root, \"root\", true)\n                .Comment(\"the root of bfs\");\n    }\n    void Print() {\n        ConfigBase::Print();\n        std::cout << \"  name: \" << name << std::endl;\n        if (root != size_t(-1)) {\n            std::cout << \"  root: \" << root << std::endl;\n        } else {\n            std::cout << \"  root: UNSET\" << std::endl;\n        }\n    }\n    // 配置文件接受命令行参数，该用例会顺次读取命令行调用算法时的参数，优先使用用户指定数值，若用户并未指定则选择默认参数。\n    MyConfig(int &argc, char** &argv): ConfigBase(argc, argv) {\n        fma_common::Configuration config;\n        AddParameter(config);\n        config.ExitAfterHelp(true);\n        config.ParseAndFinalize(argc, argv);\n        Print();\n    }\n};\n```\n\n### 2.3 主函数\n\n在文档中，此部分主要介绍的是自定义配置类`MyConfig`的定义及其功能，重点强调该类在图算法中所需参数的初始化、算法名称的设置，以及如何通过命令行参数来配置算法的执行。同时，该部分还与后续主函数的实现相联系，提供了进行图计算前所需的配置背景。"
            },
            {
                "content": "### 2.3 主函数\n\n```C++\nint main(int argc, char** argv) {\n    double start_time;\n    // 统计内存消耗类MemUsage实例化\n    MemUsage memUsage;\n    memUsage.startMemRecord();\n\n    // prepare\n    start_time = get_time();\n    // 配置类MyConfig实例化\n    MyConfig config(argc, argv);\n    size_t root_vid = config.root;\n    // OlapOnDisk类实例化\n    OlapOnDisk graph;\n    graph.Load(config, DUAL_DIRECTION);\n    memUsage.print();\n    memUsage.reset();\n    // 统计图加载消耗时间\n    auto prepare_cost = get_time() - start_time;\n    printf(\"prepare_cost = %.2lf(s)\\n\", prepare_cost);\n\n    // core\n    start_time = get_time();\n    // 创建数组用于统计某节点是否遍历过\n    auto parent = graph.AllocVertexArray();\n    // 宽度优先搜索算法，返回图内root_vid根结点连接的节点个数\n    size_t count = BFSCore(graph, root_vid, parent);\n    memUsage.print();\n    memUsage.reset();\n    auto core_cost = get_time() - start_time;\n    printf(\"core_cost = %.2lf(s)\\n\", core_cost);\n\n该部分主要介绍了OlapOnDisk API的主函数实现，包含程序的整体流程，从内存统计、配置类实例化、图加载到核心的BFS算法执行，展示了如何设定和调用算法，以及如何进行性能监控与结果输出。"
            },
            {
                "content": "// core\n    start_time = get_time();\n    // 创建数组用于统计某节点是否遍历过\n    auto parent = graph.AllocVertexArray();\n    // 宽度优先搜索算法，返回图内root_vid根结点连接的节点个数\n    size_t count = BFSCore(graph, root_vid, parent);\n    memUsage.print();\n    memUsage.reset();\n    auto core_cost = get_time() - start_time;\n    printf(\"core_cost = %.2lf(s)\\n\", core_cost);\n\n    // output\n    start_time = get_time();\n    // 打印相关信息至终端\n    printf(\"found_vertices = %ld\\n\", count);\n    auto output_cost = get_time() - start_time;\n    printf(\"output_cost = %.2lf(s)\\n\", output_cost);\n\n    printf(\"total_cost = %.2lf(s)\\n\", prepare_cost + core_cost + output_cost);\n    printf(\"DONE.\");\n\n    return 0;\n}\n```\n\n### 2.4 bfs算法流程\n\n`bfs`主流程有两个输入参数，快照类（子图）还有迭代次数，整体流程可以分为以下几步：\n\n1. 相关定义、数据结构的初始化\n2. 使用批处理函数对每个节点进行循环计算，每一轮找到与当前节点相邻的全部节点，并在该轮次终止时进行交换。\n3. 直到找到全部节点，返回节点个数discovered_vertices。\n\n```C++\nsize_t BFSCore(Graph& graph, size_t root_vid, ParallelVector& parent){\n\n该片段位于文档的“算法举例”部分，具体描述了BFS算法的核心计算过程和输出结果的实现，其中包含了对图的遍历操作及相关性能统计信息的计算。"
            },
            {
                "content": "printf(\"total_cost = %.2lf(s)\\n\", prepare_cost + core_cost + output_cost);\n    printf(\"DONE.\");\n\n    return 0;\n}\n```\n\n### 2.4 bfs算法流程\n\n`bfs`主流程有两个输入参数，快照类（子图）还有迭代次数，整体流程可以分为以下几步：\n\n1. 相关定义、数据结构的初始化\n2. 使用批处理函数对每个节点进行循环计算，每一轮找到与当前节点相邻的全部节点，并在该轮次终止时进行交换。\n3. 直到找到全部节点，返回节点个数discovered_vertices。\n\n```C++\nsize_t BFSCore(Graph& graph, size_t root_vid, ParallelVector& parent){\n\n  size_t root = root_vid;\n  auto active_in = graph.AllocVertexSubset();   //分配数组，active_in用于存放上一循环阶段已找到的节点\n  active_in.Add(root);            //把跟节点加入数组中\n  auto active_out = graph.AllocVertexSubset();  //分配数组active_out用于存放当前循环阶段找到的节点\n  parent.Fill((size_t)-1);               //将parent数组中的节点赋值为-1，-1表示未被找到\n  parent[root] = root;\n  size_t num_activations = 1;       //表示当前循环阶段找到的节点个数\n  size_t discovered_vertices = 0;    //表示当前循环阶段找到节点的总个数\n\n该段落位于文档的第二部分，专门介绍BFS（广度优先搜索）算法的主流程和关键实现细节。它紧接在主函数代码块之后，描述了BFS算法的具体步骤和实现方法，包括初始化、循环计算和结果返回，旨在帮助用户理解如何利用TuGraph进行图数据的广度优先搜索。"
            },
            {
                "content": "for (int ii = 0; num_activations != 0; ii++) {       //num_activations表示当前循环阶段找到的节点个数\n      printf(\"activates(%d) <= %lu\\n\", ii, num_activations);\n      discovered_vertices += num_activations;         //discovered_vertices表示当前循环阶段找到节点的总个数\n      active_out.Clear();\n      num_activations = graph.ProcessVertexActive(\n          [&](size_t vi) {\n              size_t num_activations = 0;\n              for (auto& edge : graph.OutEdges(vi)) {   //每一次循环从根节点出发，查找邻近的相邻节点，对其parent值改变，并num_activations+1操作\n                  size_t dst = edge.neighbour;\n                  if (parent[dst] == (size_t)-1) {\n                      auto lock = graph.GuardVertexLock(dst);\n                      if (parent[dst] == (size_t)-1) {\n                          parent[dst] = vi;\n                          num_activations += 1;\n                          active_out.Add(dst);       //存放当前循环阶段找到的节点\n                      }\n                  }\n              }\n              return num_activations;\n          },\n          active_in);\n\n该代码块位于文档的BFS算法流程部分，具体描述了广度优先搜索（BFS）算法的核心循环。在这个循环中，通过遍历当前已激活的节点，查找其相邻节点，更新父节点数组，并统计新发现的节点数。"
            },
            {
                "content": "size_t dst = edge.neighbour;\n                  if (parent[dst] == (size_t)-1) {\n                      auto lock = graph.GuardVertexLock(dst);\n                      if (parent[dst] == (size_t)-1) {\n                          parent[dst] = vi;\n                          num_activations += 1;\n                          active_out.Add(dst);       //存放当前循环阶段找到的节点\n                      }\n                  }\n              }\n              return num_activations;\n          },\n          active_in);\n      active_in.Swap(active_out);\n  }\n  // 返回全部节点数\n  return discovered_vertices;\n}\n```\n\n该代码片段位于文档的第二部分，具体是宽度优先搜索（BFS）算法的核心流程中。它负责处理图中的每一个节点，检查与当前节点相邻的节点是否已被访问，并在未访问的情况下更新其父节点和活动节点集合。这一过程是BFS算法逻辑的重要组成部分。"
            },
            {
                "content": "## 3. 其他常用函数功能描述\n\n### 3.1 图加载\n\nTuGraph-Standalone对于图数据文件的加载来源主要分为三大类：文本文件、二进制文件和ODPS。二进制文件为将边数据的二进制表示按顺序排列的文件，能够节省大量存储空间。其加载函数分为三种，分别是：\n\n- `void Load(ConfigBase config,EdgeDirectionPolicy edge_direction_policy = DUAL_DIRECTION)`：图数据文件的加载方式，包含两个参数，其含义分别表示：\n  - `config`：需要加载的配置参数。该参数内保存了该图的一般信息（如数据来源，算法名称，数据输入、输出路径，点个数等）以及根据不同数据来源、不同算法所配置的不同信息参数。\n  - `edge_direction_policy`：指定图为有向或无向，包含三种模式，分别为DUAL_DIRECTION、MAKE_SYMMETRIC以及INPUT_SYMMETRIC。其中DUAL_DIRECTION为默认的图加载方式。\n  DUAL_DIRECTION : 输入文件为非对称图，加载图为非对称图。\n  MAKE_SYMMETRIC : 输入文件为非对称图，加载图为对称图。\n  INPUT_SYMMETRIC : 输入文件为对称图，加载图为对称图。\n  对应的详细介绍见lgraph文件夹下的olap_config.h文件的`enum EdgeDirectionPolicy`。\n\n- `void LoadVertexArrayTxt(V * array, std::string path, std::function &)> parse_line)`：将文件中的点-数据对按照点id的顺序加载到数组中。各参数表示意义分别为：\n  - `array`：待读入数据的数组\n  - `path`：读取文件的路径，文件中每行表示一对点-数据对\n  - `parse_line`：用户自定义函数，告诉系统如何将一行文本数据解析为一个点-数据对。\n\n该片段位于文档的第三部分，主要介绍了TuGraph-Standalone中常用的图加载功能，包括从文本文件、二进制文件和ODPS获取图数据的不同方法，以及相应的函数接口和参数说明，为用户在实现图计算应用时提供必要的信息。"
            },
            {
                "content": "- `void LoadVertexArrayTxt(V * array, std::string path, std::function &)> parse_line)`：将文件中的点-数据对按照点id的顺序加载到数组中。各参数表示意义分别为：\n  - `array`：待读入数据的数组\n  - `path`：读取文件的路径，文件中每行表示一对点-数据对\n  - `parse_line`：用户自定义函数，告诉系统如何将一行文本数据解析为一个点-数据对。\n\n\n### 3.2 图写入\n- `void Write(ConfigBase & config, ParallelVector& array, size_t array_size, std::string name, std::function filter_output = filter_output_default)`：把array中数据写回文件中，各参数表示意义分别是：\n  - `config`：需要加载的配置参数。该参数内保存了该图的一般信息（如数据来源，算法名称，数据输入、输出路径，点个数等）以及根据不同数据来源、不同算法所配置的不同信息参数。\n  - `array`：待写入数据的数组\n  - `array_size`：待写入数据的数字长度\n  - `name`：算法名称\n  - `filter_output`：写入数据规则函数，待写入数据需要满足该函数的要求。\n\n### 3.3 图解析函数\n- `std::tuple parse_line_unweighted(const char *p, const char *end, EdgeUnit &e)`：对图数据文件进行解析，加载图为无权图。\n\n- `std::tuple parse_line_weighted(const char* p, const char* end, EdgeUnit& e)`：对图数据文件进行解析，加载图为有权图，权重数据类型可以通过修改指定。\n\n该函数可通过MyConfig类定义时的构造函数parse_line进行指定。\n\n该段落位于文档的第3部分，主要介绍了TuGraph的图数据加载和写入功能，包括如何将点-数据对从文件加载到数组、将计算结果写回文件的具体接口和参数说明，以及图解析函数的使用。这些内容为用户在实际应用中进行图数据的操作提供了基础知识和方法。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_86.md",
        "chunks": [
            {
                "content": "# 致谢\nGeaFlow开发过程中部分模块参考了一些业界优秀的开源项目，包括Apache Flink、Apache Spark以及Apache Calcite等, 这里表示特别的感谢。\n\n该文档主要介绍了GeaFlow项目的开发过程、技术架构及其各个模块的设计和实现，致谢部分表达了对参考的开源项目的感谢，强调了其在项目开发中的重要性。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_87.md",
        "chunks": [
            {
                "content": "# Traversal API介绍\nGeaFlow对外提供了实现图遍历算法的接口，通过实现该接口进行子图遍历，全图遍历。用户可在遍历算法中选取点边继续遍历，并定义迭代次数。\n\n## 动态图\n### 接口\n| API | 接口说明 | 入参说明 |\n| --- | --- | --- |\n| void open(IncVertexCentricTraversalFuncContext vertexCentricFuncContext) | vertexCentricFunction进行open操作 | vertexCentricFuncContext：K表示vertexId的类型，VV表示vertex value类型，EV表示edge value类型，M表示图遍历中定义的消息类型，R表示遍历结果类型。 |\n| void init(ITraversalRequest traversalRequest) | 图遍历初始化接口 | traversalRequest：图遍历触发点，其中K表示vertex id的类型。 |\n| void evolve(K vertexId, TemporaryGraph temporaryGraph) | 首轮计算对增量图实现处理逻辑 | vertexId：当前计算点的id，其中K表示vertex id的类型。temporaryGraph：临时增量图，其中K表示vertexId的类型，VV表示vertex value类型，EV表示edge value类型。 |\n| void compute(K vertexId, Iterator messageIterator) | 图遍历接口 | vertexId：当前计算点的id，其中K表示vertex id的类型。messageIterator：图遍历过程中所有发送给当前vertex的消息，其中M表示遍历迭代过程中定义的发送消息类型。 |\n| void finish(K vertexId, MutableGraph mutableGraph) | 图遍历完成接口 | vertexId：当前计算点的id，其中K表示vertex id的类型。mutableGraph：可变图，其中K表示vertexId的类型，VV表示vertex value类型，EV表示edge value类型。 |\n表格内容描述:\n\n该文档详细介绍了GeaFlow的Traversal API，包括动态图和静态图的接口定义及其说明。文中首先概述了图遍历算法的应用背景和功能，然后通过表格形式列出了动态图和静态图的相关API，并提供了每个API的说明及入参类型，最后给出了具体的代码示例以展示如何使用这些接口进行图遍历操作。此处的内容主要聚焦于动态图的API接口。"
            },
            {
                "content": "该表格包含三列，分别为“API”、“接口说明”和“入参说明”。\n\n1. 第一行数据描述：\n   - API: `void open(IncVertexCentricTraversalFuncContext vertexCentricFuncContext)`\n   - 接口说明: 该接口用于对vertexCentricFunction进行open操作。\n   - 入参说明: `vertexCentricFuncContext`包含五种类型参数，其中K表示vertexId的类型，VV表示vertex value类型，EV表示edge value类型，M表示图遍历中定义的消息类型，R表示遍历结果类型。\n\n2. 第二行数据描述：\n   - API: `void init(ITraversalRequest traversalRequest)`\n   - 接口说明: 这是图遍历的初始化接口。\n   - 入参说明: `traversalRequest`为图遍历的触发点，其中K表示vertex id的类型。\n\n3. 第三行数据描述：\n   - API: `void evolve(K vertexId, TemporaryGraph temporaryGraph)`\n   - 接口说明: 该接口实现对增量图的首轮计算处理逻辑。\n   - 入参说明: `vertexId`表示当前计算点的id（K表示vertex id的类型），`temporaryGraph`是一个临时增量图，包含vertexId（K）、vertex value（VV）和edge value（EV）的类型信息。\n\n4. 第四行数据描述：\n   - API: `void compute(K vertexId, Iterator messageIterator)`\n   - 接口说明: 此接口用于图遍历过程。\n   - 入参说明: `vertexId`为当前计算点的id（K表示vertex id的类型），`messageIterator`是发送给当前vertex的消息迭代器，其中M表示遍历过程中的消息类型。\n\n该段内容位于文档的动态图部分，具体描述了用于图遍历的API接口及其入参说明，涵盖了open、init、evolve和compute等关键函数的功能和类型信息。"
            },
            {
                "content": "3. 第三行数据描述：\n   - API: `void evolve(K vertexId, TemporaryGraph temporaryGraph)`\n   - 接口说明: 该接口实现对增量图的首轮计算处理逻辑。\n   - 入参说明: `vertexId`表示当前计算点的id（K表示vertex id的类型），`temporaryGraph`是一个临时增量图，包含vertexId（K）、vertex value（VV）和edge value（EV）的类型信息。\n\n4. 第四行数据描述：\n   - API: `void compute(K vertexId, Iterator messageIterator)`\n   - 接口说明: 此接口用于图遍历过程。\n   - 入参说明: `vertexId`为当前计算点的id（K表示vertex id的类型），`messageIterator`是发送给当前vertex的消息迭代器，其中M表示遍历过程中的消息类型。\n\n5. 第五行数据描述：\n   - API: `void finish(K vertexId, MutableGraph mutableGraph)`\n   - 接口说明: 该接口用于标记图遍历的完成。\n   - 入参说明: `vertexId`表示当前计算点的id（K表示vertex id的类型），`mutableGraph`为可变图，包含vertexId（K）、vertex value（VV）和edge value（EV）的类型信息。\n\n总体上，表格描述了一系列用于图遍历操作的API，包括初始化、增量计算、消息传递及完成状态。这些API的入参具有详细的类型指示，从而便于开发者理解如何使用这些接口进行图的遍历和处理。\n\n\n- 详细接口\n\n```java\n   public interface IncVertexCentricTraversalFunction extends IncVertexCentricFunction {\n\n   void open(IncVertexCentricTraversalFuncContext vertexCentricFuncContext);\n\n   void init(ITraversalRequest traversalRequest);\n\n该块内容位于文档的动态图部分，具体描述了增量图遍历接口中的关键方法，包括`evolve`、`compute`和`finish`的 API 及其说明与入参。这些接口是实现图遍历算法的核心，通过这些方法，开发者可以处理增量图、进行消息传递以及标记遍历的完成状态，进一步解释了如何使用这些接口进行图的遍历和计算。"
            },
            {
                "content": "总体上，表格描述了一系列用于图遍历操作的API，包括初始化、增量计算、消息传递及完成状态。这些API的入参具有详细的类型指示，从而便于开发者理解如何使用这些接口进行图的遍历和处理。\n\n\n- 详细接口\n\n```java\n   public interface IncVertexCentricTraversalFunction extends IncVertexCentricFunction {\n\n   void open(IncVertexCentricTraversalFuncContext vertexCentricFuncContext);\n\n   void init(ITraversalRequest traversalRequest);\n\n   void evolve(K vertexId, TemporaryGraph temporaryGraph);\n\n   void compute(K vertexId, Iterator messageIterator);\n\n   void finish(K vertexId, MutableGraph mutableGraph);\n\n   interface IncVertexCentricTraversalFuncContext extends IncGraphContext {\n   /** 激活遍历起点用以下一轮迭代使用 */\n   void activeRequest(ITraversalRequest request);\n   /** 收集遍历结果 */\n   void takeResponse(ITraversalResponse response);\n\n        void broadcast(IGraphMessage message);\n    \t/** 获取历史图数据 */\n        TraversalHistoricalGraph getHistoricalGraph();\n   }\n\n\n    interface TraversalHistoricalGraph  extends HistoricalGraph {\n    \t/** 获取指定版本快照 */\n        TraversalGraphSnapShot getSnapShot(long version);\n    }\n\n该段落位于文档中与图遍历API相关的部分，主要介绍了增量图遍历函数的详细接口定义，包括其方法和参数说明。这些接口支持图遍历操作，如初始化、计算和消息传递，为开发者提供必要的功能定义与使用指南。"
            },
            {
                "content": "interface IncVertexCentricTraversalFuncContext extends IncGraphContext {\n   /** 激活遍历起点用以下一轮迭代使用 */\n   void activeRequest(ITraversalRequest request);\n   /** 收集遍历结果 */\n   void takeResponse(ITraversalResponse response);\n\n        void broadcast(IGraphMessage message);\n    \t/** 获取历史图数据 */\n        TraversalHistoricalGraph getHistoricalGraph();\n   }\n\n\n    interface TraversalHistoricalGraph  extends HistoricalGraph {\n    \t/** 获取指定版本快照 */\n        TraversalGraphSnapShot getSnapShot(long version);\n    }\n\n    interface TraversalGraphSnapShot extends GraphSnapShot {\n    \t/** 获取开始图遍历的点 */\n        TraversalVertexQuery vertex();\n    \t/** 获取开始图遍历的边 */\n        TraversalEdgeQuery edges();\n    }\n}\n```\n\n### 示例\n\n```java\npublic class IncrGraphTraversalAll {\n\n该代码块定义了增量图遍历函数上下文接口，包含激活遍历请求、收集结果和获取历史图数据的方法。此外，还包括用于获取版本快照和图遍历起点的相关接口。这部分内容位于“动态图”章节关于增量图遍历的详细接口部分，紧接着后面的示例代码，以展示如何实现和使用这些接口进行图遍历。"
            },
            {
                "content": "private static final Logger LOGGER =\n        LoggerFactory.getLogger(IncrGraphTraversalAll.class);\n    \n    public static void main(String[] args) {\n        Environment environment = EnvironmentFactory.onLocalEnvironment();\n        Pipeline pipeline = PipelineFactory.buildPipeline(environment);\n        String graphName = \"graph_view_name\";\n        GraphViewDesc graphViewDesc = GraphViewBuilder.createGraphView(graphName)\n            .withShardNum(2)\n            .withBackend(BackendType.RocksDB)\n            .withSchema(new GraphMetaType(IntegerType.INSTANCE, ValueVertex.class, Integer.class, ValueEdge.class, IntegerType.class))\n            .build();\n        pipeline.withView(graphName, graphViewDesc);\n        pipeline.submit(new PipelineTask() {\n            @Override\n            public void execute(IPipelineTaskContext pipelineTaskCxt) {\n                PWindowSource> vertices =\n                    pipelineTaskCxt.buildSource(new RecoverableFileSource<>(\"data/input/email_edge\",\n\n该代码块位于文档的“动态图”部分，具体是用于示例的实现代码中。它展示了如何设置一个增量图遍历的环境，包括创建管道、定义图视图描述以及提交增量图遍历任务的基本实现。此段代码主要说明了如何在增量图遍历中处理顶点数据的读取和构建。"
            },
            {
                "content": ".withSchema(new GraphMetaType(IntegerType.INSTANCE, ValueVertex.class, Integer.class, ValueEdge.class, IntegerType.class))\n            .build();\n        pipeline.withView(graphName, graphViewDesc);\n        pipeline.submit(new PipelineTask() {\n            @Override\n            public void execute(IPipelineTaskContext pipelineTaskCxt) {\n                PWindowSource> vertices =\n                    pipelineTaskCxt.buildSource(new RecoverableFileSource<>(\"data/input/email_edge\",\n                            line -> {\n                                String[] fields = line.split(\",\");\n                                IVertex vertex1 = new ValueVertex<>(\n                                    Integer.valueOf(fields[0]), 1);\n                                IVertex vertex2 = new ValueVertex<>(\n                                    Integer.valueOf(fields[1]), 1);\n                                return Arrays.asList(vertex1, vertex2);\n                            }), SizeTumblingWindow.of(10000));\n\n该段落位于文档中的示例部分，具体展示了如何在使用动态图遍历API时，构建图的元数据类型和视图，并通过读取文件数据构建顶点数据源。在这里，示例代码展示了如何从输入文件中读取边信息，创建顶点对象，并将其添加到图的遍历任务中。"
            },
            {
                "content": "String[] fields = line.split(\",\");\n                                IVertex vertex1 = new ValueVertex<>(\n                                    Integer.valueOf(fields[0]), 1);\n                                IVertex vertex2 = new ValueVertex<>(\n                                    Integer.valueOf(fields[1]), 1);\n                                return Arrays.asList(vertex1, vertex2);\n                            }), SizeTumblingWindow.of(10000));\n                \n                PWindowSource> edges =\n                    pipelineTaskCxt.buildSource( new RecoverableFileSource<>(\"data/input/email_edge\",\n                        line -> {\n                            String[] fields = line.split(\",\");\n                            IEdge edge = new ValueEdge<>(Integer.valueOf(fields[0]),\n                                Integer.valueOf(fields[1]), 1);\n                            return Collections.singletonList(edge);\n                        }), SizeTumblingWindow.of(5000));\n\n该代码块位于动态图的示例部分，描述了如何从文件中读取顶点和边的数据，并构建相应的源（PWindowSource）。它展示了如何将读取的顶点和边信息封装为图的表示，以便在后续的增量图遍历中使用。"
            },
            {
                "content": "PGraphView fundGraphView =\n                    pipelineTaskCxt.getGraphView(graphName);\n                PIncGraphView incGraphView =\n                    fundGraphView.appendGraph(vertices, edges);\n                incGraphView.incrementalTraversal(new IncGraphTraversalAlgorithms(3))\n                    .start()\n                    .sink(v -> {});\n            }\n        });\n        IPipelineResult result = pipeline.execute();\n        result.get();\n    }\n    \n    public static class IncGraphTraversalAlgorithms extends IncVertexCentricTraversal {\n        \n        public IncGraphTraversalAlgorithms(long iterations) {\n            super(iterations);\n        }\n        \n        @Override\n        public IncVertexCentricTraversalFunction getIncTraversalFunction() {\n            return new IncVertexCentricTraversalFunction() {\n\n                private IncVertexCentricTraversalFuncContext vertexCentricFuncContext;\n\n此代码块位于文档的“静态图”示例部分，展示了如何在增量图遍历过程中，通过获取图视图并追加顶点和边数据，启动增量图遍历的执行过程。代码中包含了对`PIncGraphView`的操作，以及通过实现`IncGraphTraversalAlgorithms`类来定义遍历功能的具体实现。"
            },
            {
                "content": "private IncVertexCentricTraversalFuncContext vertexCentricFuncContext;\n\n                @Override\n                public void open(IncVertexCentricTraversalFuncContext vertexCentricFuncContext) {\n                    this.vertexCentricFuncContext = vertexCentricFuncContext;\n                }\n\n                @Override\n                public void evolve(Integer vertexId,\n                                   TemporaryGraph temporaryGraph) {\n                    MutableGraph mutableGraph = this.vertexCentricFuncContext.getMutableGraph();\n                    IVertex vertex = temporaryGraph.getVertex();\n                    if (vertex != null) {\n                        mutableGraph.addVertex(0, vertex);\n                    }\n                    List> edges = temporaryGraph.getEdges();\n                    if (edges != null) {\n                        for (IEdge edge : edges) {\n                            mutableGraph.addEdge(0, edge);\n                        }\n                    }\n                }\n\n该代码块位于动态图部分的详细接口实现中，具体在`IncGraphTraversalAlgorithms`类的`getIncTraversalFunction`方法内部。它定义了`IncVertexCentricTraversalFuncContext`的一个实例，并实现了`open`和`evolve`方法，用于处理图遍历中的初始化和增量图的计算逻辑。"
            },
            {
                "content": "@Override\n                public void init(ITraversalRequest traversalRequest) {\n                    int requestId = traversalRequest.getVId();\n                    List> edges =\n                        this.vertexCentricFuncContext.getHistoricalGraph().getSnapShot(0).edges().getEdges();\n                    int sum = 0;\n                    if (edges != null) {\n                        for (IEdge edge : edges) {\n                            sum += edge.getValue();\n                        }\n                    }\n                    this.vertexCentricFuncContext.takeResponse(new TraversalResponse(requestId, sum));\n                }\n\n                @Override\n                public void compute(Integer vertexId, Iterator messageIterator) {\n                }\n\n该代码块位于文档中的动态图部分，为`IncGraphTraversalAlgorithms`类中的`init`方法实现，主要负责初始化图遍历请求，计算与给定请求ID相关的边的值总和，并通过`takeResponse`方法返回结果。紧接在其后的`compute`方法定义了图遍历中的计算逻辑，但此处未实现具体功能。"
            },
            {
                "content": "@Override\n                public void compute(Integer vertexId, Iterator messageIterator) {\n                }\n\n                @Override\n                public void finish(Integer vertexId,\n                                   MutableGraph mutableGraph) {\n                }\n            };\n        }\n        @Override\n        public VertexCentricCombineFunction getCombineFunction() {\n            return null;\n        }\n    }\n\n    static class TraversalResponse implements ITraversalResponse {\n\n        private long responseId;\n\n        private int value;\n\n这个代码块来源于文档的“动态图”部分，具体是在“IncrGraphTraversalAlgorithms”类的实现中。该块代码展示了“compute”方法的实现和“finish”方法的空实现，涉及到图遍历算法中的具体逻辑，用于处理顶点计算和遍历完成的过程。"
            },
            {
                "content": "@Override\n                public void finish(Integer vertexId,\n                                   MutableGraph mutableGraph) {\n                }\n            };\n        }\n        @Override\n        public VertexCentricCombineFunction getCombineFunction() {\n            return null;\n        }\n    }\n\n    static class TraversalResponse implements ITraversalResponse {\n\n        private long responseId;\n\n        private int value;\n\n        public TraversalResponse(long responseId, int value) {\n            this.responseId = responseId;\n            this.value = value;\n        }\n        @Override\n        public long getResponseId() {\n            return responseId;\n        }\n        @Override\n        public Integer getResponse() {\n            return value;\n        }\n        @Override\n        public ResponseType getType() {\n            return ResponseType.Vertex;\n        }\n        @Override\n        public String toString() {\n            return responseId + \",\" + value;\n        }\n    }\n}\n```\n\n## 静态图\n\n该代码块位于“动态图”部分的示例实现中，具体实现了`IncGraphTraversalAlgorithms`类中的`finish`方法和`TraversalResponse`类，主要负责图遍历的完成状态处理及响应的定义。在此之前，该文档详细介绍了图遍历相关的API接口及其用法，并为用户提供了动态和静态图的遍历示例。"
            },
            {
                "content": "## 静态图\n\n### 接口\n| API | 接口说明 | 入参说明 |\n| --- | --- | --- |\n| void open(VertexCentricTraversalFuncContext vertexCentricFuncContext) | vertexCentric function进行open操作 | vertexCentricFuncContext：K表示vertexId的类型，VV表示vertex value类型，EV表示edge value类型，M表示图遍历中定义的消息类型，R表示遍历结果类型。 |\n| void init(ITraversalRequest traversalRequest) | 图遍历初始化接口 | traversalRequest：图遍历触发点，其中K表示vertex id的类型。 |\n| void compute(K vertexId, Iterator messageIterator) | 图遍历接口 | vertexId：当前计算点的id，其中K表示vertex id的类型。messageIterator：图遍历过程中所有发送给当前vertex的消息，其中M表示遍历迭代过程中定义的发送消息类型。 |\n表格内容描述:\n\n该表格包含三列：API、接口说明和入参说明。\n\n1. 第一行：\n   - API: `void open(VertexCentricTraversalFuncContext vertexCentricFuncContext)`\n   - 接口说明: 进行 vertexCentric function 的 open 操作。\n   - 入参说明: `vertexCentricFuncContext` 包含多个类型参数，K 表示顶点 ID 的类型，VV 表示顶点值类型，EV 表示边值类型，M 表示图遍历中定义的消息类型，R 表示遍历结果类型。\n\n2. 第二行：\n   - API: `void init(ITraversalRequest traversalRequest)`\n   - 接口说明: 用于图遍历的初始化接口。\n   - 入参说明: `traversalRequest` 指定图遍历的触发点，其中 K 表示顶点 ID 的类型。\n\n该块内容位于文档的“静态图”部分，详细描述了静态图遍历的相关接口，包括API、接口说明和入参说明，旨在为用户提供静态图遍历功能的使用指导和参考，方便开发者理解和实施相关操作。"
            },
            {
                "content": "该表格包含三列：API、接口说明和入参说明。\n\n1. 第一行：\n   - API: `void open(VertexCentricTraversalFuncContext vertexCentricFuncContext)`\n   - 接口说明: 进行 vertexCentric function 的 open 操作。\n   - 入参说明: `vertexCentricFuncContext` 包含多个类型参数，K 表示顶点 ID 的类型，VV 表示顶点值类型，EV 表示边值类型，M 表示图遍历中定义的消息类型，R 表示遍历结果类型。\n\n2. 第二行：\n   - API: `void init(ITraversalRequest traversalRequest)`\n   - 接口说明: 用于图遍历的初始化接口。\n   - 入参说明: `traversalRequest` 指定图遍历的触发点，其中 K 表示顶点 ID 的类型。\n\n3. 第三行：\n   - API: `void compute(K vertexId, Iterator messageIterator)`\n   - 接口说明: 实现图遍历的接口。\n   - 入参说明: `vertexId` 表示当前计算点的 ID，其中 K 为顶点 ID 的类型；`messageIterator` 包含在图遍历过程中所有发送给当前顶点的消息，其类型为 M，表示遍历迭代过程中定义的消息类型。\n\n总体而言，此表格详细列出了图遍历相关的 API 接口及其说明，包括对每个 API 的功能描述和输入参数的具体要求。\n\n\n- 详细接口\n\n```java\npublic interface VertexCentricTraversalFunction extends VertexCentricFunction {\n\n    void open(VertexCentricTraversalFuncContext vertexCentricFuncContext);\n\t/** 图遍历算法初始化方法 */\n    void init(ITraversalRequest traversalRequest);\n\t/** 实现图遍历逻辑 */\n    void compute(K vertexId, Iterator messageIterator);\n\n该段落是关于静态图遍历的API接口细节，具体描述了接口包括`open`、`init`和`compute`方法的功能及其入参说明，旨在为开发者提供详细的接口使用指南，便于理解如何进行图遍历操作。"
            },
            {
                "content": "总体而言，此表格详细列出了图遍历相关的 API 接口及其说明，包括对每个 API 的功能描述和输入参数的具体要求。\n\n\n- 详细接口\n\n```java\npublic interface VertexCentricTraversalFunction extends VertexCentricFunction {\n\n    void open(VertexCentricTraversalFuncContext vertexCentricFuncContext);\n\t/** 图遍历算法初始化方法 */\n    void init(ITraversalRequest traversalRequest);\n\t/** 实现图遍历逻辑 */\n    void compute(K vertexId, Iterator messageIterator);\n\n    void finish();\n\n    void close();\n\t\n    interface VertexCentricTraversalFuncContext extends VertexCentricFuncContext {\n    \t/** 获取图遍历结果 */\n        void takeResponse(ITraversalResponse response);\n    \t/** 获取开始图遍历的点 */\n        TraversalVertexQuery vertex();\n    \t/** 获取开始图遍历的边 */\n        TraversalEdgeQuery edges();\n\n        void broadcast(IGraphMessage message);\n    }\n\n    interface TraversalVertexQuery extends VertexQuery {\n    \t/** 获取图遍历中点的迭代器 */\n        Iterator loadIdIterator();\n    }\n\n    interface TraversalEdgeQuery extends EdgeQuery {\n    \t/** 通过指定的点id，获取对应的图遍历起点 */\n        TraversalEdgeQuery withId(K vertexId);\n    }\n}\n```\n\n### 示例\n\n该段落位于文档关于静态图遍历的部分，详细描述了图遍历相关的API接口及其功能，特别是`VertexCentricTraversalFunction`接口的具体实现，包括其方法及入参说明。此后，还提供了该接口的示例代码，用于展示如何实际应用这些API。"
            },
            {
                "content": "void broadcast(IGraphMessage message);\n    }\n\n    interface TraversalVertexQuery extends VertexQuery {\n    \t/** 获取图遍历中点的迭代器 */\n        Iterator loadIdIterator();\n    }\n\n    interface TraversalEdgeQuery extends EdgeQuery {\n    \t/** 通过指定的点id，获取对应的图遍历起点 */\n        TraversalEdgeQuery withId(K vertexId);\n    }\n}\n```\n\n### 示例\n\n```java\npublic class StaticGraphTraversalAllExample {\n    private static final Logger LOGGER =\n            LoggerFactory.getLogger(StaticGraphTraversalAllExample.class);\n\n该代码块位于文档的“静态图”部分，描述了`VertexCentricTraversalFunction`接口中的方法，包括广播消息的方法和遍历点及边的查询接口。在此之前，文档定义了静态图遍历的相关接口和结构，并提供了示例代码以展示如何使用这些接口进行图遍历。"
            },
            {
                "content": "public static void main(String[] args) {\n        Environment environment = EnvironmentFactory.onLocalEnvironment();\n        Pipeline pipeline = PipelineFactory.buildPipeline(environment);\n        pipeline.submit(new PipelineTask() {\n            @Override\n            public void execute(IPipelineTaskContext pipelineTaskCxt) {\n                PWindowSource> prVertices =\n                        pipelineTaskCxt.buildSource(new FileSource<>(\"data/input/email_vertex\",\n                                line -> {\n                                    String[] fields = line.split(\",\");\n                                    IVertex vertex = new ValueVertex<>(Integer.valueOf(fields[0]),\n                                            Integer.valueOf(fields[1]));\n                                    return Collections.singletonList(vertex);\n                                }), AllWindow.getInstance()).withParallelism(1);\n\n该代码块位于文档中“静态图”部分的示例代码中，展示了如何在静态图遍历的主函数中构建数据源，以从文件中读取顶点数据并创建顶点对象。"
            },
            {
                "content": "PWindowSource> prEdges =\n                        pipelineTaskCxt.buildSource(new FileSource<>(\"data/input/email_edge\",\n                                line -> {\n                                    String[] fields = line.split(\",\");\n                                    IEdge edge = new ValueEdge<>(Integer.valueOf(fields[0]),\n                                            Integer.valueOf(fields[1]), 1);\n                                    return Collections.singletonList(edge);\n                                }), AllWindow.getInstance()).withParallelism(1);\n\n                GraphViewDesc graphViewDesc = GraphViewBuilder\n                        .createGraphView(GraphViewBuilder.DEFAULT_GRAPH)\n                        .withShardNum(1)\n                        .withBackend(BackendType.Memory)\n                        .build();\n\n                PGraphWindow graphWindow =\n                        pipelineTaskCxt.buildWindowStreamGraph(prVertices, prEdges, graphViewDesc);\n\n该代码片段位于\"静态图\"部分的示例代码中，具体实现了如何构建边的数据源，并创建图的视图描述和窗口流图。此段落的目的是演示静态图遍历的设置过程，包括读取边信息和构建图视图。"
            },
            {
                "content": "GraphViewDesc graphViewDesc = GraphViewBuilder\n                        .createGraphView(GraphViewBuilder.DEFAULT_GRAPH)\n                        .withShardNum(1)\n                        .withBackend(BackendType.Memory)\n                        .build();\n\n                PGraphWindow graphWindow =\n                        pipelineTaskCxt.buildWindowStreamGraph(prVertices, prEdges, graphViewDesc);\n\n                graphWindow.traversal(new VertexCentricTraversal(3) {\n                    @Override\n                    public VertexCentricTraversalFunction getTraversalFunction() {\n                        return new VertexCentricTraversalFunction() {\n\n                            private VertexCentricTraversalFuncContext vertexCentricFuncContext;\n\n该代码块位于静态图遍历示例部分，展示了如何使用 `GraphViewBuilder` 创建图视图描述，并构建图窗口流。接着，通过调用 `traversal` 方法实现图遍历，定义了一个 `VertexCentricTraversal` 的遍历函数，准备执行相应的遍历逻辑。"
            },
            {
                "content": "PGraphWindow graphWindow =\n                        pipelineTaskCxt.buildWindowStreamGraph(prVertices, prEdges, graphViewDesc);\n\n                graphWindow.traversal(new VertexCentricTraversal(3) {\n                    @Override\n                    public VertexCentricTraversalFunction getTraversalFunction() {\n                        return new VertexCentricTraversalFunction() {\n\n                            private VertexCentricTraversalFuncContext vertexCentricFuncContext;\n\n                            @Override\n                            public void open(\n                                    VertexCentricTraversalFuncContext vertexCentricFuncContext) {\n                                this.vertexCentricFuncContext = vertexCentricFuncContext;\n                            }\n\n该代码块位于静态图遍历示例部分，具体是在创建图窗口后，定义了一个以顶点为中心的遍历算法，通过实现`VertexCentricTraversalFunction`接口，设置遍历的开启操作，初始化遍历的上下文环境。"
            },
            {
                "content": "@Override\n                            public void init(ITraversalRequest traversalRequest) {\n                                this.vertexCentricFuncContext.takeResponse(\n                                        new TraversalResponse(traversalRequest.getRequestId(), 1));\n                            }\n                            @Override\n                            public void compute(Integer vertexId, Iterator messageIterator) {\n                            }\n                            @Override\n                            public void finish() {\n                            }\n                            @Override\n                            public void close() {\n                            }\n                        };\n                    }\n\n                    @Override\n                    public VertexCentricCombineFunction getCombineFunction() {\n                        return null;\n                    }\n                }).start().sink(v -> {});\n            }\n        });\n\n该代码块位于“静态图”部分的示例中，具体是在`StaticGraphTraversalAllExample`类的`main`方法内，作为`VertexCentricTraversalFunction`接口的实现部分。该部分实现了图遍历的初始化、计算、完成和关闭方法，展示了如何处理图遍历请求并返回结果。"
            },
            {
                "content": "@Override\n                    public VertexCentricCombineFunction getCombineFunction() {\n                        return null;\n                    }\n                }).start().sink(v -> {});\n            }\n        });\n\n        IPipelineResult result = pipeline.execute();\n        result.get();\n    }\n    public static class TraversalResponse implements ITraversalResponse {\n        private long responseId;\n        private int response;\n        public TraversalResponse(long responseId, int response) {\n            this.responseId = responseId;\n            this.response = response;\n        }\n\n        @Override\n        public long getResponseId() {\n            return responseId;\n        }\n\n        @Override\n        public Integer getResponse() {\n            return response;\n        }\n\n        @Override\n        public ResponseType getType() {\n            return ResponseType.Vertex;\n        }\n\n该代码块位于文档的“静态图”部分示例中，主要展示了如何实现图遍历的组合函数（`VertexCentricCombineFunction`）的返回值以及遍历操作的处理逻辑。在这个示例中，函数实现了启动和处理遍历的细节，最后收集遍历的响应结果。此块代码紧接着图遍历的启动和执行逻辑，展示了如何进行图遍历的实际操作。"
            },
            {
                "content": "@Override\n        public long getResponseId() {\n            return responseId;\n        }\n\n        @Override\n        public Integer getResponse() {\n            return response;\n        }\n\n        @Override\n        public ResponseType getType() {\n            return ResponseType.Vertex;\n        }\n\n        @Override\n        public String toString() {\n            return \"TraversalResponse{\" + \"responseId=\" + responseId + \", response=\" + response\n                    + '}';\n        }\n    }\n\n}\n```\n\n该代码块位于文档的静态图部分示例中，具体是在`TraversalResponse`类的实现中。它重写了`ITraversalResponse`接口的几个方法，包括获取响应ID、获取响应值、获取响应类型以及重写`toString`方法，用于更好地表示`TraversalResponse`对象的字符串信息。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_88.md",
        "chunks": [
            {
                "content": "# 名词解释\n\n**图**：图用于展示不同变量之间的关系，通常包括节点（点）和边（线）两部分。节点代表一个个体或对象，边则代表它们之间的关系。图可以用来解释复杂的关系网络和信息流动，如社交网络、交通网络、物流网络等。常见的图形类型包括有向图、无向图、树形图、地图等。\n\n**K8S**：k8s是Kubernetes(https://kubernetes.io/)的简称，是一个开源的容器编排平台，提供了自动化部署、自动扩展、自动管理容器化应用程序的功能。它可以在各种云平台、物理服务器和虚拟机上运行，支持多种容器运行时，可以实现高可用性、负载均衡、自动扩容、自动修复等功能。\n\n**Graph Processing**： Graph Processing是一种计算模型，用于处理图形数据结构的计算问题。图计算模型可以用于解决许多现实世界的问题，例如社交网络分析、网络流量分析、医疗诊断等，典型的系统有 Apache Giraph(https://giraph.apache.org/), Spark GraphX(https://spark.apache.org/docs/latest/graphx-programming-guide.html)。\n\n**DSL**： DSL是领域特定语言（Domain-Specific Language）的缩写。它是一种针对特定领域或问题的编程语言，与通用编程语言不同，DSL主要关注于解决特定领域的问题，并针对该领域的特定需求进行优化。DSL可以使得编程更加简单、高效，同时也能够提高代码的可读性和可维护性。下面的**Gremlin**、**ISO-GQL**就是DSL中的一种。\n\n**HLA**: HLA 是 High level language 的缩写，与**DSL**不同，它使用通用语言进行编程，Geaflow目前只支持Java程序编写。它主要通过计算引擎SDK进行程序编写，执行方式是将程序整体打包交给引擎执行，对比**DSL**，它的执行方式更加灵活，但相对应的编程也会更加复杂。\n\n该块内容位于文档的开头部分，主要对相关术语进行解释和定义，包括图、K8S、Graph Processing、DSL、HLA等概念。这些定义为后续讨论Geaflow相关技术及其功能提供了基础理解。"
            },
            {
                "content": "**DSL**： DSL是领域特定语言（Domain-Specific Language）的缩写。它是一种针对特定领域或问题的编程语言，与通用编程语言不同，DSL主要关注于解决特定领域的问题，并针对该领域的特定需求进行优化。DSL可以使得编程更加简单、高效，同时也能够提高代码的可读性和可维护性。下面的**Gremlin**、**ISO-GQL**就是DSL中的一种。\n\n**HLA**: HLA 是 High level language 的缩写，与**DSL**不同，它使用通用语言进行编程，Geaflow目前只支持Java程序编写。它主要通过计算引擎SDK进行程序编写，执行方式是将程序整体打包交给引擎执行，对比**DSL**，它的执行方式更加灵活，但相对应的编程也会更加复杂。\n\n**Gremlin**: Gremlin(https://tinkerpop.apache.org/gremlin.html)是一种图形遍历语言，用于在图形数据库中进行数据查询和操作。它是一种声明式的、基于图的编程语言，可以用于访问各种类型的图形数据库，如Apache TinkerPop、Neo4j等。它提供了一组灵活的API，可以帮助开发者在图形数据库中执行各种操作，如遍历、过滤、排序、连接、修改等。\n\n**ISO-GQL**：GQL(https://www.gqlstandards.org/)是面向属性图的标准查询语言，全称是“图形查询语言”，其为ISO/IEC国际标准数据库语言。GeaFlow不仅支持了Gremlin查询语言，而且还支持了GQL。\n\n**Window**: 参考VLDB 2015 Google Dataflow Model(https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/43864.pdf)，窗口的概念在 Geaflow 中是其数据处理逻辑中的关键要素，用于统一有界和无界的数据处理。数据流统一被看成一个个窗口数据的集合，系统处理批次的粒度也就是窗口的粒度。\n\n**Cycle**： GeaFlow Scheduler调度模型中的核心数据结构，一个cycle描述为可循环执行的基本单元，包含输入，中间计算和数据交换，输出的描述。由执行计划中的vertex group生成，支持嵌套。\n\n该段落主要介绍了与Geaflow相关的重要概念和术语，包括领域特定语言（DSL）和高级语言（HLA），以及用于图形数据库查询的Gremlin和ISO-GQL语言。还提到了窗口（Window）和周期（Cycle）的定义，它们在Geaflow的数据处理和调度模型中起着关键作用。这些概念为理解Geaflow的图数据处理能力和编程语言支持提供了基础。"
            },
            {
                "content": "**ISO-GQL**：GQL(https://www.gqlstandards.org/)是面向属性图的标准查询语言，全称是“图形查询语言”，其为ISO/IEC国际标准数据库语言。GeaFlow不仅支持了Gremlin查询语言，而且还支持了GQL。\n\n**Window**: 参考VLDB 2015 Google Dataflow Model(https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/43864.pdf)，窗口的概念在 Geaflow 中是其数据处理逻辑中的关键要素，用于统一有界和无界的数据处理。数据流统一被看成一个个窗口数据的集合，系统处理批次的粒度也就是窗口的粒度。\n\n**Cycle**： GeaFlow Scheduler调度模型中的核心数据结构，一个cycle描述为可循环执行的基本单元，包含输入，中间计算和数据交换，输出的描述。由执行计划中的vertex group生成，支持嵌套。\n\n**Event**： Runtime层调度和计算交互的核心数据结构，Scheduler将一系列Event集合构建成一个State Machine，将其分发到Worker上进行计算执行。其中有些Event是可执行的，即自身具备计算语义，整个调度和计算过程为异步执行。\n\n**Graph Traversal** : Graph Traversal 是指遍历图数据结构中所有节点或者部分节点的过程，在特定的顺序下访问所有节点，主要是深度优先搜索（DFS）和 广度优先搜索（BFS）。用于解决许多问题，包括查找两个节点之间的最短路径、检测图中的循环等。\n\n**Graph State**： GraphState 是用来存放Geaflow的图数据或者图迭代计算过程的中间结果，提供Exactly-Once语义，并提供作业级复用的能力。GraphState 分为 Static 和 Dynamic 两种，Static 的 GraphState 将整个图看做是一个完整的，所有操作都在一张全图上进行；Dynamic 的 GraphState 认为图动态变化的，由一个个时间切片构成，所有切片构成一个完整的图，所有的操作都是在切片上进行。\n\n该块内容为文档中的名词解释部分，详细介绍了与Geaflow相关的核心概念，包括ISO-GQL、Window、Cycle、Event、Graph Traversal和Graph State等术语的定义及应用，旨在帮助读者理解图处理系统中的重要概念。"
            },
            {
                "content": "**Graph Traversal** : Graph Traversal 是指遍历图数据结构中所有节点或者部分节点的过程，在特定的顺序下访问所有节点，主要是深度优先搜索（DFS）和 广度优先搜索（BFS）。用于解决许多问题，包括查找两个节点之间的最短路径、检测图中的循环等。\n\n**Graph State**： GraphState 是用来存放Geaflow的图数据或者图迭代计算过程的中间结果，提供Exactly-Once语义，并提供作业级复用的能力。GraphState 分为 Static 和 Dynamic 两种，Static 的 GraphState 将整个图看做是一个完整的，所有操作都在一张全图上进行；Dynamic 的 GraphState 认为图动态变化的，由一个个时间切片构成，所有切片构成一个完整的图，所有的操作都是在切片上进行。\n\n**Key State**： KeyState 用于存放计算过程中的中间结果，通常用于流式处理，例如执行aggregation时在KeyState中记录中间聚合结果。类似GraphState，Geaflow 会将 KeyState 定期持久化，因此KeyState也提供Exactly-Once语义。KeyState根据数据结果不同可以分为KeyValueState、KeyListState、KeyMapState等。\n\n## Graph View\n\n### 基本概念\n\nGraphView是Geaflow中最核心的数据抽象，表示基于图结构的虚拟视图。它是图物理存储的一种抽象，可以表示存储和操作在多个节点上图数据。在 Geaflow中，GraphView是一等公民，用户对图的所有操作都是基于GraphView，例如将分布式点、边流作为 GraphView 增量的点/边数据集，对当前 GraphView 生成快照，用户可以基于快照图或者动态的 GraphView 触发计算。\n\n\n### 功能描述\n\n本段落位于文档的名词解释部分，主要介绍了图遍历（Graph Traversal）、图状态（Graph State）和键状态（Key State）的定义与功能，之后引入了Graph View的基本概念及其功能描述，进一步阐释Geaflow框架中的核心数据抽象和操作方式。"
            },
            {
                "content": "**Key State**： KeyState 用于存放计算过程中的中间结果，通常用于流式处理，例如执行aggregation时在KeyState中记录中间聚合结果。类似GraphState，Geaflow 会将 KeyState 定期持久化，因此KeyState也提供Exactly-Once语义。KeyState根据数据结果不同可以分为KeyValueState、KeyListState、KeyMapState等。\n\n## Graph View\n\n### 基本概念\n\nGraphView是Geaflow中最核心的数据抽象，表示基于图结构的虚拟视图。它是图物理存储的一种抽象，可以表示存储和操作在多个节点上图数据。在 Geaflow中，GraphView是一等公民，用户对图的所有操作都是基于GraphView，例如将分布式点、边流作为 GraphView 增量的点/边数据集，对当前 GraphView 生成快照，用户可以基于快照图或者动态的 GraphView 触发计算。\n\n\n### 功能描述\n\nGraphView 主要有以下几个功能：\n* 图操作，GraphView可以添加或删除点和边数据，亦可以进行查询和在基于某个时间点切片快照。\n* 图介质，GraphView可以存储到图数据库或其他存储介质(如文件系统、KV存储、宽表存储、native graph等)。\n* 图切分，GraphView还支持不同图切分方法。\n* 图计算，GraphView可以进行图的迭代遍历或者计算。\n\n### 示例介绍\n定义一个 Social Network 的 GraphView, 描述人际关系。\n\nDSL 代码\n```SQL\nCREATE GRAPH social_network (\n\tVertex person (\n\t  id int ID,\n\t  name varchar\n\t),\n\tEdge knows (\n\t  person1 int SOURCE ID,\n\t  person2 int DESTINATION ID,\n\t  weight int\n\t)\n) WITH (\n\tstoreType='rocksdb',\n\tshardCount = 128\n);\n```\n\n该文本块位于文档中关于Geaflow的概念部分，具体介绍了**Key State**和**Graph View**的定义、功能及示例代码，阐述了在图数据处理和流式计算中的应用。"
            },
            {
                "content": "### 功能描述\n\nGraphView 主要有以下几个功能：\n* 图操作，GraphView可以添加或删除点和边数据，亦可以进行查询和在基于某个时间点切片快照。\n* 图介质，GraphView可以存储到图数据库或其他存储介质(如文件系统、KV存储、宽表存储、native graph等)。\n* 图切分，GraphView还支持不同图切分方法。\n* 图计算，GraphView可以进行图的迭代遍历或者计算。\n\n### 示例介绍\n定义一个 Social Network 的 GraphView, 描述人际关系。\n\nDSL 代码\n```SQL\nCREATE GRAPH social_network (\n\tVertex person (\n\t  id int ID,\n\t  name varchar\n\t),\n\tEdge knows (\n\t  person1 int SOURCE ID,\n\t  person2 int DESTINATION ID,\n\t  weight int\n\t)\n) WITH (\n\tstoreType='rocksdb',\n\tshardCount = 128\n);\n```\n\n\nHLA 代码\n```java\n//build graph view.\nfinal String graphName = \"social_network\";\nGraphViewDesc graphViewDesc = GraphViewBuilder\n\t.createGraphView(graphName)\n\t.withShardNum(128)\n\t.withBackend(BackendType.RocksDB)\n    .withSchema(new GraphMetaType(IntegerType.INSTANCE, ValueVertex.class,\n                String.class, ValueEdge.class, Integer.class))\n\t.build();\n\n// bind the graphview with pipeline1\npipeline.withView(graphName, graphViewDesc);\npipeline.submit(new PipelineTask());\n\n```\n\n## Stream Graph\n\n### 基本概念\n\n此块内容详细介绍了GraphView的功能描述和示例代码，包括图操作、图介质、图切分和图计算等功能的具体实现，接着引入了Stream Graph的基本概念，为后续流式图数据处理的讨论奠定基础。"
            },
            {
                "content": "HLA 代码\n```java\n//build graph view.\nfinal String graphName = \"social_network\";\nGraphViewDesc graphViewDesc = GraphViewBuilder\n\t.createGraphView(graphName)\n\t.withShardNum(128)\n\t.withBackend(BackendType.RocksDB)\n    .withSchema(new GraphMetaType(IntegerType.INSTANCE, ValueVertex.class,\n                String.class, ValueEdge.class, Integer.class))\n\t.build();\n\n// bind the graphview with pipeline1\npipeline.withView(graphName, graphViewDesc);\npipeline.submit(new PipelineTask());\n\n```\n\n## Stream Graph\n\n### 基本概念\n\nStreaming Graph指的是流式、动态、变化的图数据，同时在GeaFlow内部Streaming Graph也指对流式图的计算模式，它针对流式变化的图，基于图的变化进行图遍历、图匹配和图计算等操作。\n\n基于GeaFlow框架，可以方便的针对流式变化的图动态计算。在GeaFlow中，我们抽象了Dynamic Graph和Static Graph两个核心的概念。\n* Dynamic Graph 是指流式变化的图，它是图在时间轴上不断变化的切片所组成，可以方便的研究图随着时间推移的演化过程。\n* Static Graph 是图在某个时间点的 Snapshot，相当于 Dynamic Graph 的一个时间切片。\n\n### 功能描述\n\n\nStreaming Graph 主要有以下几个功能：\n\n* 支持流式地处理点、边数据，支持在最新的图做查询。\n* 支持持续不断的更新和查询图结构，支持图结构变化带来的增量数据处理。\n* 支持回溯历史，基于历史快照做查询。\n* 支持图计算的计算逻辑顺序，例如基于边的时间序做计算。\n\n\n### 示例介绍\n\n该区块包含了HLA代码示例，用于构建一个名为\"social_network\"的GraphView，紧接着介绍了Streaming Graph的基本概念及其功能描述，阐释了如何在Geaflow框架下处理动态变化的图数据，并定义了Dynamic Graph和Static Graph的概念。"
            },
            {
                "content": "```\n\n## Stream Graph\n\n### 基本概念\n\nStreaming Graph指的是流式、动态、变化的图数据，同时在GeaFlow内部Streaming Graph也指对流式图的计算模式，它针对流式变化的图，基于图的变化进行图遍历、图匹配和图计算等操作。\n\n基于GeaFlow框架，可以方便的针对流式变化的图动态计算。在GeaFlow中，我们抽象了Dynamic Graph和Static Graph两个核心的概念。\n* Dynamic Graph 是指流式变化的图，它是图在时间轴上不断变化的切片所组成，可以方便的研究图随着时间推移的演化过程。\n* Static Graph 是图在某个时间点的 Snapshot，相当于 Dynamic Graph 的一个时间切片。\n\n### 功能描述\n\n\nStreaming Graph 主要有以下几个功能：\n\n* 支持流式地处理点、边数据，支持在最新的图做查询。\n* 支持持续不断的更新和查询图结构，支持图结构变化带来的增量数据处理。\n* 支持回溯历史，基于历史快照做查询。\n* 支持图计算的计算逻辑顺序，例如基于边的时间序做计算。\n\n\n### 示例介绍\n\n读取点、边两个无限数据流增量构图，对于每次增量数据构图完成，会触发 traversal 计算，查找 'Bob' 的2度内的朋友随着时间推移的演进过程。\n\nDSL 代码\n```SQL\n\nset geaflow.dsl.window.size = 1;\n\nCREATE TABLE table_knows (\n  personId int,\n  friendId int,\n  weight int\n) WITH (\n  type='file',\n  geaflow.dsl.file.path = 'resource:///data/table_knows.txt'\n);\n\nINSERT INTO social_network.knows\nSELECT personId, friendId, weight\nFROM table_knows;\n\nCREATE TABLE result (\n  personName varchar,\n  friendName varchar,\n  weight int\n) WITH (\n\ttype='console'\n);\n\n该段落介绍了Geaflow中的流式图（Streaming Graph）的基本概念、主要功能及其示例代码，属于文档中关于图处理和计算模型的内容，特别关注动态变化的图数据及其计算方式。"
            },
            {
                "content": "### 示例介绍\n\n读取点、边两个无限数据流增量构图，对于每次增量数据构图完成，会触发 traversal 计算，查找 'Bob' 的2度内的朋友随着时间推移的演进过程。\n\nDSL 代码\n```SQL\n\nset geaflow.dsl.window.size = 1;\n\nCREATE TABLE table_knows (\n  personId int,\n  friendId int,\n  weight int\n) WITH (\n  type='file',\n  geaflow.dsl.file.path = 'resource:///data/table_knows.txt'\n);\n\nINSERT INTO social_network.knows\nSELECT personId, friendId, weight\nFROM table_knows;\n\nCREATE TABLE result (\n  personName varchar,\n  friendName varchar,\n  weight int\n) WITH (\n\ttype='console'\n);\n\n-- Graph View Name Defined in Graph View Concept --\nUSE GRAPH social_network;\n-- find person id 3's known persons triggered every window.\nINSERT INTO result\nSELECT\n\tname,\n\tknown_name,\n\tweight\nFROM (\n  MATCH (a:person where a.name = 'Bob') -[e:knows]->{1, 2}(b)\n  RETURN a.name as name, b.name as known_name, e.weight as weight\n)\n```\n\nHLA 代码\n\n该块内容位于文档的“Streaming Graph”部分，主要介绍了如何通过DSL和HLA代码实现对流式图数据的增量构建和查询，通过查找特定人物'Bob'的朋友关系来演示流式图的计算过程。"
            },
            {
                "content": "CREATE TABLE result (\n  personName varchar,\n  friendName varchar,\n  weight int\n) WITH (\n\ttype='console'\n);\n\n-- Graph View Name Defined in Graph View Concept --\nUSE GRAPH social_network;\n-- find person id 3's known persons triggered every window.\nINSERT INTO result\nSELECT\n\tname,\n\tknown_name,\n\tweight\nFROM (\n  MATCH (a:person where a.name = 'Bob') -[e:knows]->{1, 2}(b)\n  RETURN a.name as name, b.name as known_name, e.weight as weight\n)\n```\n\nHLA 代码\n\n```java \n//build graph view.\nfinal String graphName = \"social_network\";\nGraphViewDesc graphViewDesc = GraphViewBuilder.createGraphView(graphName).build();\npipeline.withView(graphName, graphViewDesc);\n\n// submit pipeLine task.\npipeline.submit(new PipelineTask() {\n\t@Override\n\tpublic void execute(IPipelineTaskContext pipelineTaskCxt) {\n\n该代码块位于文档中关于**Stream Graph**部分，主要描述了在流式图中如何创建一个结果表并查询特定用户（如“Bob”）的朋友关系。它展示了如何使用DSL和HLA代码实现图的增量计算和查询操作。"
            },
            {
                "content": "HLA 代码\n\n```java \n//build graph view.\nfinal String graphName = \"social_network\";\nGraphViewDesc graphViewDesc = GraphViewBuilder.createGraphView(graphName).build();\npipeline.withView(graphName, graphViewDesc);\n\n// submit pipeLine task.\npipeline.submit(new PipelineTask() {\n\t@Override\n\tpublic void execute(IPipelineTaskContext pipelineTaskCxt) {\n\n        // build vertices streaming source.\n\t\tPStreamSource> persons =\n\t\t\tpipelineTaskCxt.buildSource(\n\t\t\t\tnew CollectionSource.(getVertices()), SizeTumblingWindow.of(5000));\n\t\t// build edges streaming source.\n\t\tPStreamSource> knows =\n\t\t\tpipelineTaskCxt.buildSource(\n\t\t\t\tnew CollectionSource<>(getEdges()), SizeTumblingWindow.of(5000));\n\t\t// build graphview by graph name.\n\t\tPGraphView socialNetwork =\n\t\t\tpipelineTaskCxt.buildGraphView(graphName);\n\t\t// incremental build graph view.\n\t\tPIncGraphView incSocialNetwor =\n\t\t\tsocialNetwork.appendGraph(vertices, edges);\n\n该代码块位于“Streaming Graph”章节的示例介绍部分，展示了如何使用HLA（高层语言）构建一个名为“social_network”的图视图，并提交一个包含动态流式数据的管道任务，用于增量构建图结构和执行图遍历计算。"
            },
            {
                "content": "// traversal by 'Bob'.\n\t\tincGraphView.incrementalTraversal(new IncGraphTraversalAlgorithms(2))\n\t\t\t.start('Bob')\n\t\t\t.map(res -> String.format(\"%s,%s\", res.getResponseId(), res.getResponse()))\n\t\t\t.sink(new ConsoleSink<>());\n\t}\n});\n```\n\n该代码块位于\"Stream Graph\"部分的HLA代码示例中，展示了如何对流式变化的社交网络图进行增量遍历计算，具体是通过对名为'Bob'的节点进行的二度邻接查询，并将结果输出到控制台。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_89.md",
        "chunks": [
            {
                "content": "# RPC API\n\n> 此文档主要介绍 TuGraph 的 RPC API 的调用详情。\n\n## 1.简介\n\nTuGraph 提供丰富的 RPC API，以供开发者通过 RPC 请求远程调用 TuGraph 提供的服务。\n\nRPC（远程过程调用）是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。\n相比REST，RPC 面向方法，主要用于函数方法的调用，可以适合更复杂通信需求的场景，且性能更高。\nbrpc是用c++语言编写的工业级RPC框架，基于brpc，TuGraph 提供了丰富的RPC API，本文档描述\nTuGraph 的 RPC API 使用方式。\n\n## 2.请求\n\n### 2.1.建立连接\n\n开发者向TuGraph服务发送RPC请求，首先要建立连接。以C++语言为例，开发者创建指定url的通道（channel），\n由通道创建指定的服务存根（LGraphRPCService_Stub），后续即可通过存根像调用本地方法一样向远程\n服务器发送请求。\n\n```C++\n    std::shared_ptr options = std::make_shared();\n    options->protocol = \"baidu_std\";\n    options->connection_type = \"\";\n    options->timeout_ms = 60 * 60 * 1000 /*milliseconds*/;\n    options->max_retry = 3;\n    std::string load_balancer = \"\";\n    std::shared_ptr channel = std::make_shared();\n    if (channel->Init(url.c_str(), load_balancer, options.get()) != 0)\n        throw RpcException(\"Fail to initialize channel\");\n    LGraphRPCService_Stub stub(channel.get());\n```\n\n### 2.2.请求类型\n\nTuGraph支持10种RPC请求，其中每种请求的功能如下表所示：\n\n该文档介绍了TuGraph的RPC API使用方式，主要包括RPC的基本概念、建立连接的方法及请求类型的详述，具体列出了支持的请求类型及其功能，为开发者提供远程调用服务的参考。"
            },
            {
                "content": "### 2.2.请求类型\n\nTuGraph支持10种RPC请求，其中每种请求的功能如下表所示：\n\n| 请求              | 功能         |\n|-----------------|------------|\n| GraphApiRequest | 点边索引操作请求   |\n| CypherRequest   | cypher请求   |\n| PluginRequest   | 存储过程请求     |\n| HARequest       | 高可用模式请求    |\n| ImportRequest   | 数据导入请求     |\n| GraphRequest    | 子图操作请求     |\n| AclRequest      | 权限管理请求     |\n| ConfigRequest   | 配置管理请求     |\n| RestoreRequest  | 备份请求       |\n| SchemaRequest   | schema管理请求 |\n表格内容描述:\n\n该表格包含两列，分别是“请求”和“功能”。每一行对应一种请求及其功能描述。\n\n1. 第一个请求是“GraphApiRequest”，功能为“点边索引操作请求”。\n2. 第二个请求是“CypherRequest”，功能为“cypher请求”。\n3. 第三个请求是“PluginRequest”，功能为“存储过程请求”。\n4. 第四个请求是“HARequest”，功能为“高可用模式请求”。\n5. 第五个请求是“ImportRequest”，功能为“数据导入请求”。\n6. 第六个请求是“GraphRequest”，功能为“子图操作请求”。\n7. 第七个请求是“AclRequest”，功能为“权限管理请求”。\n8. 第八个请求是“ConfigRequest”，功能为“配置管理请求”。\n9. 第九个请求是“RestoreRequest”，功能为“备份请求”。\n10. 第十个请求是“SchemaRequest”，功能为“schema管理请求”。\n\n整体上，该表格列出了不同类型的请求及相应的功能，涵盖了数据库操作、权限管理、配置管理及数据导入等多方面的需求。\n\n该段落位于文档的第二部分，详细介绍了TuGraph支持的10种RPC请求类型及其各自的功能，帮助开发者了解可用的RPC请求，以便进行合适的远程调用。"
            },
            {
                "content": "该表格包含两列，分别是“请求”和“功能”。每一行对应一种请求及其功能描述。\n\n1. 第一个请求是“GraphApiRequest”，功能为“点边索引操作请求”。\n2. 第二个请求是“CypherRequest”，功能为“cypher请求”。\n3. 第三个请求是“PluginRequest”，功能为“存储过程请求”。\n4. 第四个请求是“HARequest”，功能为“高可用模式请求”。\n5. 第五个请求是“ImportRequest”，功能为“数据导入请求”。\n6. 第六个请求是“GraphRequest”，功能为“子图操作请求”。\n7. 第七个请求是“AclRequest”，功能为“权限管理请求”。\n8. 第八个请求是“ConfigRequest”，功能为“配置管理请求”。\n9. 第九个请求是“RestoreRequest”，功能为“备份请求”。\n10. 第十个请求是“SchemaRequest”，功能为“schema管理请求”。\n\n整体上，该表格列出了不同类型的请求及相应的功能，涵盖了数据库操作、权限管理、配置管理及数据导入等多方面的需求。\n\n用户发送请求时，需要传入以下参数：\n- client_version: 可选参数，HA模式下可通过对比`client_version`和`server_version`防止响应过时的请求\n- token: 必要参数，客户端登陆之后获得token，每次请求传入token以校验用户身份\n- is_write_op: 可选参数，标志请求是否是写请求\n- user: 可选参数，HA模式下主从之间同步请求时设置user，不需验证token\n\n服务处理完RPC请求之后发回响应，响应消息中除了包含每个请求的单独响应信息之外，还包含以下参数：\n- error_code: 必要参数，标志请求处理状态\n- redirect: 可选参数，HA模式下向follower发送写请求时处理失败，设置redirect为请求转发地址，即leader地址\n- error: 可选参数，请求错误信息\n- server_version: 可选参数，HA模式的请求响应中设置`server_version`以避免client读取数据时发生反向时间旅行问题\n\n该段落位于文档的第二部分关于RPC请求类型的描述中，详细介绍了TuGraph支持的十种RPC请求及其功能，并列出了用户发送请求时所需的参数和服务响应的内容，重点在于请求的多样性和如何正确传递参数以确保服务的有效性。"
            },
            {
                "content": "用户发送请求时，需要传入以下参数：\n- client_version: 可选参数，HA模式下可通过对比`client_version`和`server_version`防止响应过时的请求\n- token: 必要参数，客户端登陆之后获得token，每次请求传入token以校验用户身份\n- is_write_op: 可选参数，标志请求是否是写请求\n- user: 可选参数，HA模式下主从之间同步请求时设置user，不需验证token\n\n服务处理完RPC请求之后发回响应，响应消息中除了包含每个请求的单独响应信息之外，还包含以下参数：\n- error_code: 必要参数，标志请求处理状态\n- redirect: 可选参数，HA模式下向follower发送写请求时处理失败，设置redirect为请求转发地址，即leader地址\n- error: 可选参数，请求错误信息\n- server_version: 可选参数，HA模式的请求响应中设置`server_version`以避免client读取数据时发生反向时间旅行问题\n\n:warning:  **除CypherRequest、PluginRequest、HARequest和AclRequest外，其余RPC接口将逐步废弃，其功能统一至CypherRequest接口。**\n\n## 3.登录\n\n该块内容位于文档的第二部分，描述了用户在发送RPC请求时需要提供的参数及响应中包含的信息。这为后续的登录部分提供背景，说明了身份验证和请求处理的基本要求。"
            },
            {
                "content": "## 3.登录\n\n登录请求信息包含以下参数：\n- user: 必要参数，用户名\n- pass: 必要参数，密码\n以C++为例，用户使用构建好的服务存根发送登录请求：\n```C++\n    auto* req = request.mutable_acl_request();\n    auto* auth = req->mutable_auth_request()->mutable_login();\n    auth->set_user(user);\n    auth->set_password(pass);\n    // send data\n    cntl->Reset();\n    cntl->request_attachment().append(FLAGS_attachment);\n    req->set_client_version(server_version);\n    req->set_token(token);\n    LGraphRPCService_Stub stub(channel.get());\n    LGraphResponse res;\n    stub.HandleRequest(cntl.get(), req, &resp, nullptr);\n    if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());\n    server_version = std::max(server_version, res.server_version());\n    if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());\n    token = res.acl_response().auth_response().token();\n```\n登录响应信息包含以下参数：\n- token: 必要参数，登录成功会收到带有签名的令牌，即 Json Web Token，客户端储存该令牌，并且用于以后的每次发送请求。\n如果登录失败会收到“Authentication failed”错误。\n\n该段落位于文档的第三部分，主要讲述TuGraph的登录请求及其响应信息。它详细描述了登录请求所需的参数，包括用户名和密码，并通过C++示例展示了如何发送登录请求和处理登录响应，特别是如何获取和使用生成的令牌。"
            },
            {
                "content": "## 4.查询\n用户可以通过Cypher查询和TuGraph进行绝大多数的交互，Cypher请求信息包含以下参数：\n- query: 必要参数，Cypher查询语句\n- param_names: 可选参数，参数名\n- param_values: 可选参数，参数值\n- result_in_json_format: 必要参数，查询结果是否以JSON格式返回\n- graph: 可选参数，Cypher语句执行的子图名称\n- timeout: 可选参数，Cypher语句执行的超时时间\n\n该块内容位于文档的第4部分，介绍用户如何通过Cypher查询与TuGraph进行交互。此部分详细说明了Cypher请求的必要和可选参数，强调了Cypher在操作数据库中的重要性。"
            },
            {
                "content": "以C++为例，用户发送Cypher请求的方式如下所示：\n```C++\n    LGraphResponse res;\n    cntl->Reset();\n    cntl->request_attachment().append(FLAGS_attachment);\n    LGraphRequest req;\n    req.set_client_version(server_version);\n    req.set_token(token);\n    lgraph::CypherRequest* cypher_req = req.mutable_cypher_request();\n    cypher_req->set_graph(graph);\n    cypher_req->set_query(query);\n    cypher_req->set_timeout(timeout);\n    cypher_req->set_result_in_json_format(true);\n    LGraphRPCService_Stub stub(channel.get());\n    stub.HandleRequest(cntl.get(), &req, &res, nullptr);\n    if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());\n    if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());\n    server_version = std::max(server_version, res.server_version());\n    CypherResponse cypher_res = res.cypher_response();\n```\nCypher请求响应为以下两个参数之一：\n- json_result: JSON格式的cypher查询结果\n- binary_result: CypherResult格式的cypher查询结果\n\n该片段位于文档的第4部分，主要介绍如何以C++语言发送Cypher请求并处理响应。文档前面部分提供了TuGraph RPC API的整体介绍和请求类型，而这一部分则具体示范了如何构造Cypher请求、发送请求以及处理返回结果的具体代码示例。"
            },
            {
                "content": "## 5.存储过程\n为满足用户较为复杂的查询/更新逻辑，TuGraph支持 C 语言和 Python 语言编写的存储过程。\n用户可以使用RPC请求对存储过程进行增删改查操作。\n\n### 5.1.加载存储过程\n加载存储过程的请求包含以下参数：\n- name: 必要参数，存储过程名称\n- read_only: 必要参数，是否只读\n- code: 必要参数，存储过程文件读入生成的ByteString\n- desc: 可选参数，存储过程描述\n- code_type: 可选参数，存储过程代码类型，PY、SO、CPP、ZIP四者之一\n\n该段落位于文档的第五部分，主要介绍TuGraph支持的存储过程功能，包括如何加载、调用、删除和列举存储过程。此部分详细描述了加载存储过程的请求参数及其重要性，以满足用户在查询和更新逻辑中对复杂操作的需求。"
            },
            {
                "content": "以C++为例，用户加载存储过程的方式如下所示：\n```C++\n    std::string content;\n    if (!FieldSpecSerializer::FileReader(source_file, content)) {\n        std::swap(content, result);\n        return false;\n    }\n    LGraphRequest req;\n    req.set_is_write_op(true);\n    lgraph::PluginRequest* pluginRequest = req.mutable_plugin_request();\n    pluginRequest->set_graph(graph);\n    pluginRequest->set_type(procedure_type == \"CPP\" ? lgraph::PluginRequest::CPP\n                                                    : lgraph::PluginRequest::PYTHON);\n    pluginRequest->set_version(version);\n    lgraph::LoadPluginRequest* loadPluginRequest = pluginRequest->mutable_load_plugin_request();\n    loadPluginRequest->set_code_type([](const std::string& type) {\n        std::unordered_map um{\n            {\"SO\", lgraph::LoadPluginRequest::SO},\n            {\"PY\", lgraph::LoadPluginRequest::PY},\n            {\"ZIP\", lgraph::LoadPluginRequest::ZIP},\n            {\"CPP\", lgraph::LoadPluginRequest::CPP}};\n        return um[type];\n    }(code_type));\n\n该片段位于文档的第五部分，主要介绍了如何通过C++语言加载存储过程的具体实现方式。它包含了构建加载存储过程请求的代码示例，并解释了请求中涉及的参数设置，包括存储过程名称、类型及代码内容等。"
            },
            {
                "content": "pluginRequest->set_version(version);\n    lgraph::LoadPluginRequest* loadPluginRequest = pluginRequest->mutable_load_plugin_request();\n    loadPluginRequest->set_code_type([](const std::string& type) {\n        std::unordered_map um{\n            {\"SO\", lgraph::LoadPluginRequest::SO},\n            {\"PY\", lgraph::LoadPluginRequest::PY},\n            {\"ZIP\", lgraph::LoadPluginRequest::ZIP},\n            {\"CPP\", lgraph::LoadPluginRequest::CPP}};\n        return um[type];\n    }(code_type));\n    loadPluginRequest->set_name(procedure_name);\n    loadPluginRequest->set_desc(procedure_description);\n    loadPluginRequest->set_read_only(read_only);\n    loadPluginRequest->set_code(content);\n    cntl->Reset();\n    cntl->request_attachment().append(FLAGS_attachment);\n    req.set_client_version(server_version);\n    req.set_token(token);\n    LGraphRPCService_Stub stub(channel.get());\n    LGraphResponse res;\n    stub.HandleRequest(cntl.get(), &req, &res, nullptr);\n\n该代码块位于文档的“5.1.加载存储过程”部分，主要描述了如何在TuGraph中通过RPC请求加载存储过程的具体实现细节，包括设置存储过程的名称、描述、代码类型和内容等参数，并发送请求以加载存储过程。"
            },
            {
                "content": "}(code_type));\n    loadPluginRequest->set_name(procedure_name);\n    loadPluginRequest->set_desc(procedure_description);\n    loadPluginRequest->set_read_only(read_only);\n    loadPluginRequest->set_code(content);\n    cntl->Reset();\n    cntl->request_attachment().append(FLAGS_attachment);\n    req.set_client_version(server_version);\n    req.set_token(token);\n    LGraphRPCService_Stub stub(channel.get());\n    LGraphResponse res;\n    stub.HandleRequest(cntl.get(), &req, &res, nullptr);\n    if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());\n    server_version = std::max(server_version, res.server_version());\n    if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());\n```\n加载存储过程的响应不包含参数，如果加载失败则抛出BadInput异常\n\n该代码片段位于文档的“5.1.加载存储过程”部分，主要描述了如何通过RPC请求将存储过程加载到TuGraph中，包括设置加载请求的必要参数、发送请求并处理响应的过程。"
            },
            {
                "content": "### 5.2.调用存储过程\n\n调用存储过程的请求包含以下参数：\n- name: 必要参数，存储过程名称\n- param: 必要参数，存储过程参数\n- result_in_json_format: 可选参数，调用结果是否以JSON格式返回\n- in_process: 可选参数，未来支持\n- timeout: 可选参数，调用存储过程的超时时间\n\n该段落位于文档的第5部分，主要描述了如何调用TuGraph中的存储过程。它列出了调用存储过程所需的请求参数，并为开发者提供了相关操作的背景信息，属于TuGraph RPC API的功能细节部分。"
            },
            {
                "content": "以C++为例，用户调用存储过程的方式如下所示：\n```C++\n    LGraphRequest req;\n    lgraph::PluginRequest* pluginRequest = req.mutable_plugin_request();\n    pluginRequest->set_graph(graph);\n    pluginRequest->set_type(procedure_type == \"CPP\" ? lgraph::PluginRequest::CPP\n                                                    : lgraph::PluginRequest::PYTHON);\n    lgraph::CallPluginRequest *cpRequest = pluginRequest->mutable_call_plugin_request();\n    cpRequest->set_name(procedure_name);\n    cpRequest->set_in_process(in_process);\n    cpRequest->set_param(param);\n    cpRequest->set_timeout(procedure_time_out);\n    cpRequest->set_result_in_json_format(json_format);\n    LGraphResponse res;\n    cntl->Reset();\n    cntl->request_attachment().append(FLAGS_attachment);\n    req.set_client_version(server_version);\n    req.set_token(token);\n    LGraphRPCService_Stub stub(channel.get());\n    stub.HandleRequest(cntl.get(), &req, &res, nullptr);\n    if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());\n\n该块内容位于文档的\"存储过程\"部分，具体描述了用户如何在TuGraph中调用存储过程的方式，采用C++语言作为示例，概述了请求中所需参数的设置以及请求的处理过程。"
            },
            {
                "content": "cpRequest->set_param(param);\n    cpRequest->set_timeout(procedure_time_out);\n    cpRequest->set_result_in_json_format(json_format);\n    LGraphResponse res;\n    cntl->Reset();\n    cntl->request_attachment().append(FLAGS_attachment);\n    req.set_client_version(server_version);\n    req.set_token(token);\n    LGraphRPCService_Stub stub(channel.get());\n    stub.HandleRequest(cntl.get(), &req, &res, nullptr);\n    if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());\n    server_version = std::max(server_version, res.server_version());\n    if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());\n    if (json_format) {\n        result = res.mutable_plugin_response()->mutable_call_plugin_response()->json_result();\n    } else {\n        result = res.mutable_plugin_response()->mutable_call_plugin_response()->reply();\n    }\n```\n调用存储过程的响应为以下两个参数之一：\n- reply: ByteString格式的存储过程调用结果\n- json_result: JSON格式的存储过程调用结果\n\n该代码块位于文档的“5.2.调用存储过程”部分，描述了如何通过RPC请求调用存储过程，包括设置参数、发送请求及处理响应的具体操作。它详细说明了如何处理存储过程调用的结果，以及在成功和失败情况下的不同响应格式。"
            },
            {
                "content": "### 5.3.删除存储过程\n\n删除存储过程的请求包含以下参数：\n- name: 必要参数，存储过程名称\n\n该段落位于文档的第五部分，专门介绍如何管理存储过程，具体说明了删除存储过程的请求格式及所需参数，属于RPC API使用中的存储过程操作章节。"
            },
            {
                "content": "以C++为例，用户删除存储过程的方式如下所示：\n```C++\n    LGraphRequest req;\n    req.set_is_write_op(true);\n    lgraph::PluginRequest* pluginRequest = req.mutable_plugin_request();\n    pluginRequest->set_graph(graph);\n    pluginRequest->set_type(procedure_type == \"CPP\" ? lgraph::PluginRequest::CPP\n                                                    : lgraph::PluginRequest::PYTHON);\n    lgraph::DelPluginRequest* dpRequest = pluginRequest->mutable_del_plugin_request();\n    dpRequest->set_name(procedure_name);\n    cntl->Reset();\n    cntl->request_attachment().append(FLAGS_attachment);\n    req.set_client_version(server_version);\n    req.set_token(token);\n    LGraphRPCService_Stub stub(channel.get());\n    LGraphResponse res;\n    stub.HandleRequest(cntl.get(), &req, &res, nullptr);\n    if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());\n    server_version = std::max(server_version, res.server_version());\n    if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());\n```\n\n该代码块位于文档的“5.存储过程”部分，具体介绍了如何删除存储过程的RPC请求的实现方式，涵盖了所需参数和相应的C++代码示例。"
            },
            {
                "content": "cntl->Reset();\n    cntl->request_attachment().append(FLAGS_attachment);\n    req.set_client_version(server_version);\n    req.set_token(token);\n    LGraphRPCService_Stub stub(channel.get());\n    LGraphResponse res;\n    stub.HandleRequest(cntl.get(), &req, &res, nullptr);\n    if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());\n    server_version = std::max(server_version, res.server_version());\n    if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());\n```\n删除存储过程的响应不包含参数，如果删除失败则抛出BadInput异常\n\n该代码段位于文档的“5.3. 删除存储过程”部分，描述了以C++语言实现删除存储过程的具体请求处理流程，包括请求的初始化、发送以及响应的错误处理逻辑。"
            },
            {
                "content": "### 5.4.列举存储过程\n\n该段落位于文档的第五部分，专门介绍如何管理TuGraph中的存储过程。具体而言，5.4小节提供了列举存储过程的请求方式和返回结果，以帮助用户查看当前加载的存储过程。"
            },
            {
                "content": "列举存储过程请求不需要参数，以C++为例，用户列举存储过程的方式如下所示：\n```C++\n    LGraphRequest req;\n    req.set_is_write_op(false);\n    lgraph::PluginRequest* pluginRequest = req.mutable_plugin_request();\n    pluginRequest->set_graph(graph);\n    pluginRequest->set_type(procedure_type == \"CPP\" ? lgraph::PluginRequest::CPP\n                                                    : lgraph::PluginRequest::PYTHON);\n    pluginRequest->mutable_list_plugin_request();\n    cntl->Reset();\n    cntl->request_attachment().append(FLAGS_attachment);\n    req.set_client_version(server_version);\n    req.set_token(token);\n    LGraphRPCService_Stub stub(channel.get());\n    LGraphResponse res;\n    stub.HandleRequest(cntl.get(), &req, &res, nullptr);\n    if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());\n    server_version = std::max(server_version, res.server_version());\n    if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());\n    result = res.mutable_plugin_response()->mutable_list_plugin_response()->reply();\n\n该片段位于文档的第五部分，主要讲述如何列举存储过程的请求和响应。在介绍存储过程的相关操作时，此处具体示例展示了用户使用C++代码发送列举存储过程请求的方法，包括设置请求参数、处理响应等步骤。"
            },
            {
                "content": "req.set_token(token);\n    LGraphRPCService_Stub stub(channel.get());\n    LGraphResponse res;\n    stub.HandleRequest(cntl.get(), &req, &res, nullptr);\n    if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());\n    server_version = std::max(server_version, res.server_version());\n    if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());\n    result = res.mutable_plugin_response()->mutable_list_plugin_response()->reply();\n```\n列举存储过程的响应的参数如下所示：\n- reply: JSON格式的procedure列表\n\n该段落位于文档的“5.4.列举存储过程”部分，描述了用户如何通过RPC请求列举存储过程的操作和相应的处理流程，包括设置token、发送请求、处理响应以及获取结果。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_90.md",
        "chunks": [
            {
                "content": "# K8S Operator部署\n\n## 准备工作\n1. 下载安装docker和minikube。\n2. 拉取GeaFlow镜像\n\n```shell\ndocker pull tugraph/geaflow:0.4\n```\n\n如果遇到网络问题导致拉取失败，也可以通过下面命令直接构建镜像(构建镜像之前需要先启动docker容器,构建脚本根据机器类型build对应类型的镜像):\n\n\n```shell\ngit clone https://github.com/TuGraph-family/tugraph-analytics.git\ncd tugraph-analytics/\nbash ./build.sh --module=geaflow\n```\n\n\n整个编译过程可能持续一段时间，请耐心等待。镜像编译成功后，通过以下命令查看镜像：\n```shell\ndocker images\n```\n远程拉取的镜像名称为：**tugraph/geaflow:0.4**。\n本地镜像名称为：**geaflow:0.1**，只需选择一种方式构建镜像即可。\n\n## 安装Geaflow Kubernetes Operator\n下面介绍如何安装Geaflow Kubernetes Operator。\n\n1. 下载GeaFlow代码。\n```shell\ngit clone https://github.com/TuGraph-family/tugraph-analytics.git\ncd tugraph-analytics/\n```\n2. 构建Geaflow Kubernetes Operator的镜像\n```shell\ndocker pull tugraph/geaflow-kubernetes-operator:0.4\n```\n\n如果遇到网络问题导致拉取失败，也可以通过下面命令直接构建镜像:\n\n\n```shell\ncd tugraph-analytics/geaflow-kubernetes-operator/\nbash ./build-operator.sh\n```\n\n该chunk包含了K8S Operator部署的准备工作，包括下载安装docker和minikube以及拉取GeaFlow镜像的步骤，同时介绍了如何构建Geaflow的镜像和安装Geaflow Kubernetes Operator的镜像。"
            },
            {
                "content": "## 安装Geaflow Kubernetes Operator\n下面介绍如何安装Geaflow Kubernetes Operator。\n\n1. 下载GeaFlow代码。\n```shell\ngit clone https://github.com/TuGraph-family/tugraph-analytics.git\ncd tugraph-analytics/\n```\n2. 构建Geaflow Kubernetes Operator的镜像\n```shell\ndocker pull tugraph/geaflow-kubernetes-operator:0.4\n```\n\n如果遇到网络问题导致拉取失败，也可以通过下面命令直接构建镜像:\n\n\n```shell\ncd tugraph-analytics/geaflow-kubernetes-operator/\nbash ./build-operator.sh\n```\n\noperator项目最低要求jdk11。整个编译过程可能持续一段时间，请耐心等待。镜像编译成功后，通过以下命令查看镜像：\n```shell\ndocker images\n```\n远程拉取的镜像名称为：**tugraph/geaflow-kubernetes-operator:0.4**。\n本地镜像名称为：**geaflow-kubernetes-operator:0.1**，只需选择一种方式构建镜像即可。\n\n3. 确认helm的镜像名称\n\n打开/helm/geaflow-kubernetes-operator/values.yaml。\n\n如有必要则可修改image.repository和image.tag以使用正确的镜像名。\n\n4. 通过helm安装Geaflow Kubernetes Operator\n```shell\ncd tugraph-analytics/geaflow-kubernetes-operator/\nhelm install geaflow-kubernetes-operator helm/geaflow-kubernetes-operator\n```\n\n5. 在minikube dashboard中查看pod是否正常运行\n\n6. 将GeaFlow-Operator-Dashboard通过portforward代理到本地端口（默认为8089端口）\n\n该块内容位于文档的“安装Geaflow Kubernetes Operator”部分，详细介绍了如何下载GeaFlow代码、构建Geaflow Kubernetes Operator镜像，确认镜像名称，并通过helm安装操作员的步骤。"
            },
            {
                "content": "3. 确认helm的镜像名称\n\n打开/helm/geaflow-kubernetes-operator/values.yaml。\n\n如有必要则可修改image.repository和image.tag以使用正确的镜像名。\n\n4. 通过helm安装Geaflow Kubernetes Operator\n```shell\ncd tugraph-analytics/geaflow-kubernetes-operator/\nhelm install geaflow-kubernetes-operator helm/geaflow-kubernetes-operator\n```\n\n5. 在minikube dashboard中查看pod是否正常运行\n\n6. 将GeaFlow-Operator-Dashboard通过portforward代理到本地端口（默认为8089端口）\n\n请将operator-pod-name替换为实际的operator pod名称。\n```shell\nkubectl port-forward ${operator-pod-name} 8089:8089\n```\n\n7. 浏览器访问localhost:8089即可打开operator集群页面\n\n## 通过Geaflow Kubernetes Operator提交作业\n\nGeaflow-kubernetes-operator成功部署并运行后，就可以编写CR的yaml文件进行作业提交啦。\n\n### 提交作业\ngeaflow-kubernetes-operator成功部署并运行后，就可以编写作业的yaml文件进行作业提交了。\n首先我们编写一个geaflow内置示例作业的yaml文件。\n\n该段落描述了安装Geaflow Kubernetes Operator的具体步骤，包括确认镜像名称、通过helm安装Operator、检查Pod状态以及使用port-forward访问Operator Dashboard。接下来介绍如何通过Geaflow Kubernetes Operator提交作业的过程。"
            },
            {
                "content": "```yaml\napiVersion: geaflow.antgroup.com/v1\nkind: GeaflowJob\nmetadata:\n  # 作业名称\n  name: geaflow-example\nspec:\n  # 作业使用的GeaFlow镜像\n  image: geaflow:0.1\n  # 作业拉取镜像的策略\n  imagePullPolicy: IfNotPresent\n  # 作业使用的k8s service account\n  serviceAccount: geaflow\n  # 作业java进程的主类\n  entryClass: com.antgroup.geaflow.example.graph.statical.compute.khop.KHop\n  clientSpec:\n    # client pod相关的资源设置\n    resource:\n      cpuCores: 1\n      memoryMb: 1000\n      jvmOptions: -Xmx800m,-Xms800m,-Xmn300m\n  masterSpec:\n    # master pod相关的资源设置\n    resource:\n      cpuCores: 1\n      memoryMb: 1000\n      jvmOptions: -Xmx800m,-Xms800m,-Xmn300m\n  driverSpec:\n    # driver pod相关的资源设置\n    resource:\n      cpuCores: 1\n      memoryMb: 1000\n      jvmOptions: -Xmx800m,-Xms800m,-Xmn300m\n    # driver个数\n    driverNum: 1\n  containerSpec:\n    # container pod相关的资源设置\n    resource:\n      cpuCores: 1\n      memoryMb: 1000\n      jvmOptions: -Xmx800m,-Xms800m,-Xmn300m\n    # container个数\n    containerNum: 1\n    # 每个container内部的worker个数(线程数)\n\n该代码块是关于提交Geaflow作业的YAML文件示例，位于文档的\"通过Geaflow Kubernetes Operator提交作业\"节中，展示了Geaflow作业的配置，包括镜像、服务账户、资源设置等信息。"
            },
            {
                "content": "# master pod相关的资源设置\n    resource:\n      cpuCores: 1\n      memoryMb: 1000\n      jvmOptions: -Xmx800m,-Xms800m,-Xmn300m\n  driverSpec:\n    # driver pod相关的资源设置\n    resource:\n      cpuCores: 1\n      memoryMb: 1000\n      jvmOptions: -Xmx800m,-Xms800m,-Xmn300m\n    # driver个数\n    driverNum: 1\n  containerSpec:\n    # container pod相关的资源设置\n    resource:\n      cpuCores: 1\n      memoryMb: 1000\n      jvmOptions: -Xmx800m,-Xms800m,-Xmn300m\n    # container个数\n    containerNum: 1\n    # 每个container内部的worker个数(线程数)\n    workerNumPerContainer: 4\n  userSpec:\n    # 作业指标相关配置\n    metricConfig:\n      geaflow.metric.reporters: slf4j\n      geaflow.metric.stats.type: memory\n    # 作业存储相关配置\n    stateConfig:\n      geaflow.file.persistent.type: LOCAL\n      geaflow.store.redis.host: host.minikube.internal\n      geaflow.store.redis.port: \"6379\"\n    # 用户自定义参数配置\n    additionalArgs:\n      kubernetes.resource.storage.limit.size: 12Gi\n      geaflow.system.state.backend.type: MEMORY\n```\n\n该代码块位于文档的“提交作业”部分，是关于Geaflow作业配置的一个示例，详细描述了master、driver和container pod的资源设置，以及用户自定义参数配置。这些设置是通过YAML文件为Geaflow作业定义的关键参数，用于提升作业的执行性能和资源管理。"
            },
            {
                "content": "Geaflow 作业依赖于redis组件，可以通过docker快速启动一个redis容器并将端口映射到localhost。\n```shell\ndocker pull redis:latest\ndocker run -p 6379:6379 --name geaflow_redis redis:latest\n```\n若你已经部署了一个redis组件，则可以将example.yaml中的以下参数替换为已有的redis host和端口号。\n```yaml\nspec:\n  userSpec:\n    stateConfig:\n      geaflow.store.redis.host: ${your.redis.host}\n      geaflow.store.redis.port: ${your.redis.port}\n```\n\n然后通过如下命令即可将作业提交到k8s集群。\n```shell\ncd tugraph-analysis/geaflow-kubernetes-operator/example\nkubectl apply example_hla.yml\n```\n### 提交HLA作业\n对于提交HLA作业的情况，需要额外注意以下几个参数：\n* entryClass必填。\n* udfJars选填，如有的话请填写自己文件的url地址。\n\n```yaml\nspec:\n  # 必填\n  entryClass: com.example.MyEntryClass\n  # 可选\n  udfJars:\n    - name: myUdf.jar\n      url: http://localhost:8888/download/myUdf.jar\n```\n\n### 提交DSL作业\n对于提交DSL作业的情况，需要额外注意以下几个参数：\n* entryClass不填，留空。\n* gqlFile必填，请填写自己文件的名称和url地址。\n* udfJars选填，如有的话请填写自己文件的url地址。\n\n该段落位于\"通过Geaflow Kubernetes Operator提交作业\"部分，介绍了Geaflow作业对Redis组件的依赖以及如何通过Docker启动Redis容器，同时提供了作业提交的命令和HLA、DSL作业的具体要求及示例配置。"
            },
            {
                "content": "然后通过如下命令即可将作业提交到k8s集群。\n```shell\ncd tugraph-analysis/geaflow-kubernetes-operator/example\nkubectl apply example_hla.yml\n```\n### 提交HLA作业\n对于提交HLA作业的情况，需要额外注意以下几个参数：\n* entryClass必填。\n* udfJars选填，如有的话请填写自己文件的url地址。\n\n```yaml\nspec:\n  # 必填\n  entryClass: com.example.MyEntryClass\n  # 可选\n  udfJars:\n    - name: myUdf.jar\n      url: http://localhost:8888/download/myUdf.jar\n```\n\n### 提交DSL作业\n对于提交DSL作业的情况，需要额外注意以下几个参数：\n* entryClass不填，留空。\n* gqlFile必填，请填写自己文件的名称和url地址。\n* udfJars选填，如有的话请填写自己文件的url地址。\n\n```yaml\nspec:\n  # 不填\n  # entryClass: com.example.MyEntryClass\n  # 必填\n  gqlFile:\n    # name必须填写正确，否则无法找到对应文件\n    name: myGql.gql\n    url: http://localhost:8888/download/myGql.gql\n  # 可选\n  udfJars:\n    - name: myUdf.jar\n      url: http://localhost:8888/download/myUdf.jar\n```\n关于DSL作业和HLA作业的更多参数，我们在项目目录geaflow-kubernetes-operator/example目录中准备了两个demo作业供大家参考，请分别参考项目中的示例文件：\n* example/example-dsl.yml\n* example/example-hla.yml。\n\n该片段位于文档的“通过Geaflow Kubernetes Operator提交作业”部分，详细说明了如何将作业提交到Kubernetes集群，包括HLA和DSL作业的不同参数设置和示例。"
            },
            {
                "content": "```yaml\nspec:\n  # 不填\n  # entryClass: com.example.MyEntryClass\n  # 必填\n  gqlFile:\n    # name必须填写正确，否则无法找到对应文件\n    name: myGql.gql\n    url: http://localhost:8888/download/myGql.gql\n  # 可选\n  udfJars:\n    - name: myUdf.jar\n      url: http://localhost:8888/download/myUdf.jar\n```\n关于DSL作业和HLA作业的更多参数，我们在项目目录geaflow-kubernetes-operator/example目录中准备了两个demo作业供大家参考，请分别参考项目中的示例文件：\n* example/example-dsl.yml\n* example/example-hla.yml。\n\n### 查看作业状态\n#### 通过geaflow-kubernetes-operator-dashboard查看\n浏览器访问http://localhost:8089/，即可打开集群页面查看集群下所有geaflowjob作业列表和详情。\n\n\n#### 通过命令行查看\n执行以下命令可以查看CR的状态\n```shell\nkubectl get geaflowjob geaflow-example\n```\n\n该内容主要涉及通过Geaflow Kubernetes Operator提交DSL作业的配置示例，包含必填与选填字段的说明。同时，文中提到可通过浏览器和命令行查看作业状态，提供了相应的访问地址和命令。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_91.md",
        "chunks": [
            {
                "content": "# LLM本地部署\n\n用户可以在本地完成大模型的服务化部署，以下步骤描述了从下载预训练模型，服务化部署和调试的整个过程。用户机器确保已安装Docker，可访问大模型存储库。\n \n ## 步骤1:下载大模型文件\n \n我们已将预训练好的大模型文件，上传至Hugging Face仓库(https://huggingface.co/tugraph/CodeLlama-7b-GQL-hf)，下载模型文件后解压到本地。下载完成后，解压模型文件到指定的本地目录，如 /home/huggingface。\n \n ## 步骤2:准备 Docker 容器环境\n1. 在终端运行以下命令下载模型服务化所需的 Docker 镜像：\n   \n```\ndocker pull tugraph/llam_infer_service:0.0.1\n\n//使用以下命令来验证镜像是否成功下载\ndocker images\n```\n \n2. 运行以下命令启动Docker容器：\n   \n```\ndocker run -it  --name ${容器名称} -v ${本地模型路径}:${容器模型路径} -p ${本地端口}:${容器服务化端口} -d ${镜像名}  \n\n//例如\ndocker run -it --name my-model-container -v /home/huggingface:/opt/huggingface -p 8000:8000 -d llama_inference_server:v1\n\n// 检查容器是否正常运行\ndocker ps \n```\n\n在这里，我们将容器的 8000 端口映射到本地机器的 8000 端口，将本地模型（/home/huggingface）所在目录挂载到容器的路径（/opt/huggingface），并将容器名称设置为 my-model-container。\n\n## 步骤3:模型服务化部署\n1. 模型转换\n```\n//进入上述刚创建好的容器\ndocker exec -it ${container_id} bash\n\n//执行如下命令\ncd /opt/llama_cpp\npython3 ./convert.py ${容器模型路径}\n```\n执行完成后， 会在容器模型路径下生成前缀为ggml-model的文件\n\n该文档主要介绍如何在本地部署大模型，包括从下载预训练模型到服务化部署和调试的全过程。当前块内容集中在第一步和第二步，即下载大模型文件及准备Docker容器环境的具体操作步骤。"
            },
            {
                "content": "//例如\ndocker run -it --name my-model-container -v /home/huggingface:/opt/huggingface -p 8000:8000 -d llama_inference_server:v1\n\n// 检查容器是否正常运行\ndocker ps \n```\n\n在这里，我们将容器的 8000 端口映射到本地机器的 8000 端口，将本地模型（/home/huggingface）所在目录挂载到容器的路径（/opt/huggingface），并将容器名称设置为 my-model-container。\n\n## 步骤3:模型服务化部署\n1. 模型转换\n```\n//进入上述刚创建好的容器\ndocker exec -it ${container_id} bash\n\n//执行如下命令\ncd /opt/llama_cpp\npython3 ./convert.py ${容器模型路径}\n```\n执行完成后， 会在容器模型路径下生成前缀为ggml-model的文件\n\n2. 模型量化（可选）\n以llam2-7B模型为例：通过convert.py默认转换后的模型精度为F16，模型大小为13.0GB。如果当前机器资源无法满足这么大的模型推理，可通过./quantize对转换后的模型进一步量化。\n```\n// 如下所示 q4_0即将原始模型量化为int4，模型大小压缩至3.5GB；\n// 其它参数类似\ncd /opt/llama_cpp\n./quantize 默认生成的F16模型路径 量化后模型路径 q4_0\n```\n以下是量化后模型的大小和推理速度等参考指标：perplexity（困惑度）、file size（文件大小）、ms/tok @ 4th（每千个token的时间@第4位）、ms/tok @ 8th（每千个token的时间@第8位）和bits/weight（比特数/权重）。\n\n3. 模型服务化\n通过以下命令，将上述生成的模型进行服务化的部署，通过参数指定服务绑定的地址和端口：\n```\n// ./server -h 可查看参数详情\n// ${ggml-model...文件}为生成的ggml-model前缀的文件名\n\n该内容位于文档的步骤2和步骤3之间，主要介绍了如何启动Docker容器以部署大模型，并检查容器是否正常运行。接下来，文档详述了模型的转换、量化和服务化部署的具体指令和流程。"
            },
            {
                "content": "2. 模型量化（可选）\n以llam2-7B模型为例：通过convert.py默认转换后的模型精度为F16，模型大小为13.0GB。如果当前机器资源无法满足这么大的模型推理，可通过./quantize对转换后的模型进一步量化。\n```\n// 如下所示 q4_0即将原始模型量化为int4，模型大小压缩至3.5GB；\n// 其它参数类似\ncd /opt/llama_cpp\n./quantize 默认生成的F16模型路径 量化后模型路径 q4_0\n```\n以下是量化后模型的大小和推理速度等参考指标：perplexity（困惑度）、file size（文件大小）、ms/tok @ 4th（每千个token的时间@第4位）、ms/tok @ 8th（每千个token的时间@第8位）和bits/weight（比特数/权重）。\n\n3. 模型服务化\n通过以下命令，将上述生成的模型进行服务化的部署，通过参数指定服务绑定的地址和端口：\n```\n// ./server -h 可查看参数详情\n// ${ggml-model...文件}为生成的ggml-model前缀的文件名\n\ncd /opt/llama_cpp\n./server --host ${ip} --port ${port} -m ${容器模型路径}/${ggml-model...文件} -c 4096\n\n//例如\n./server --host 0.0.0.0 --port 8000 -m  /opt/huggingface/ggml-model-f16.gguf -c 4096\n```\n\n4. 调试服务\n向服务地址发送http请求，其中\"prompt\"为查询的语句, 在返回的\"content\"中则是推理结果。\n\n```\ncurl --request POST \\\n    --url http://127.0.0.1:8000/completion \\\n    --header \"Content-Type: application/json\" \\\n    --data '{\"prompt\": \"请返回小红的10个年龄大于20的朋友\",\"n_predict\": 128}'\n```\n如下是服务化部署后的模型推理结果：\n\n该文本块主要描述了在大模型本地部署过程中关于模型量化和服务化部署的步骤，具体包括如何量化转换后的模型以减少其大小，以及如何启动服务并进行调试以获取推理结果。这部分内容位于实施和调试模型服务化的流程中，紧接在模型转换之后。"
            },
            {
                "content": "cd /opt/llama_cpp\n./server --host ${ip} --port ${port} -m ${容器模型路径}/${ggml-model...文件} -c 4096\n\n//例如\n./server --host 0.0.0.0 --port 8000 -m  /opt/huggingface/ggml-model-f16.gguf -c 4096\n```\n\n4. 调试服务\n向服务地址发送http请求，其中\"prompt\"为查询的语句, 在返回的\"content\"中则是推理结果。\n\n```\ncurl --request POST \\\n    --url http://127.0.0.1:8000/completion \\\n    --header \"Content-Type: application/json\" \\\n    --data '{\"prompt\": \"请返回小红的10个年龄大于20的朋友\",\"n_predict\": 128}'\n```\n如下是服务化部署后的模型推理结果：\n\n```\n\", 其中至少保留两个朋友。 \\nmatch(a:person where a.age › 20)-[e:friend]->(b)<-[e2:friend]-(c:person where c.name='小红') return b limit 10\\n\"\n```\n\n该块内容位于文档的模型服务化部署部分，具体描述了如何启动服务及调试，通过命令行启动模型服务并进行HTTP请求测试，以验证模型推理的结果。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_92.md",
        "chunks": [
            {
                "content": "# 什么是图数据库\n\n> 本文主要介绍什么是图数据库，图数据库相比于关系型数据库的优势，以及两者特点的对比。\n\n## 1. 图数据库介绍\n\n图数据库是基于图模型的数据库。与关系型数据库相比，图数据库真正注重“关系”。图数据库的主要功能是管理图数据，因此需要支持高效的点、边查询和更新；为方便用户使用，通常还需要增加对事务（transaction）的支持，以确保并发操作下的正常运行。\n\n## 2. 图数据库相比较于关系型数据库的优势\n\n图数据库的功能是传统关系型数据库的扩展。与关系型数据库仅支持的“表结构”相比，图数据库所支持的“图结构”更为灵活。图数据库在基于图的增加、删除、查询和修改方面采用不同于其他数据库的设计。在图数据操作抽象上，采用基于点的视角，例如点通过其所有“出边”（从一个点出发，连接到其他点的边）访问其邻接点。这是图数据库系统设计的核心。\n\n图数据库的独特性体现在以下三个方面:\n\n### 2.1. 性能\n\n在关联关系处理上，使用关系型数据库不可避免地要使用表的JOIN操作，这会对性能产生较大影响；而图数据库则直接跳转访问类指针，操作关联数据的效率更高，比关系型数据库提高2到4个数量级的性能。\n\n### 2.2. 兼容性\n\n现实中，项目进程通常不断演变，数据的内容甚至数据格式也在不断变化。在关系型数据库中，这意味着表结构的变化或建立多个新表，对源数据的修改非常大。而在图数据库中，仅需添加新的点、边和属性，并将其设置为对应的类型即可。从本质上说，一个表代表一种类型的数据，一个点代表一个特定的数据。这意味着关系型数据库更关注数据类型，而图数据库更关注数据个体及其关联关系。\n\n### 2.3. 直观性\n\n使用图的方式表达现实世界的关系更直接和自然，在万物互联的时代尤为突出。如果使用关系型数据，先建立实体表，再建立关系表，最后映射数据，需要高度的抽象思维。在图数据上进行分析查询时，可以直观地通过点边连接的拓扑结构找到所需数据，无需任何专业知识。\n\n## 3. 图数据库与关系型数据库对比\n\n该片段是关于图数据库的介绍，重点阐述其定义、特点以及与关系型数据库的比较，主要涵盖图数据库的优势、性能、兼容性、直观性等方面，适用于对图数据库及其应用有兴趣的读者。"
            },
            {
                "content": "图数据库的独特性体现在以下三个方面:\n\n### 2.1. 性能\n\n在关联关系处理上，使用关系型数据库不可避免地要使用表的JOIN操作，这会对性能产生较大影响；而图数据库则直接跳转访问类指针，操作关联数据的效率更高，比关系型数据库提高2到4个数量级的性能。\n\n### 2.2. 兼容性\n\n现实中，项目进程通常不断演变，数据的内容甚至数据格式也在不断变化。在关系型数据库中，这意味着表结构的变化或建立多个新表，对源数据的修改非常大。而在图数据库中，仅需添加新的点、边和属性，并将其设置为对应的类型即可。从本质上说，一个表代表一种类型的数据，一个点代表一个特定的数据。这意味着关系型数据库更关注数据类型，而图数据库更关注数据个体及其关联关系。\n\n### 2.3. 直观性\n\n使用图的方式表达现实世界的关系更直接和自然，在万物互联的时代尤为突出。如果使用关系型数据，先建立实体表，再建立关系表，最后映射数据，需要高度的抽象思维。在图数据上进行分析查询时，可以直观地通过点边连接的拓扑结构找到所需数据，无需任何专业知识。\n\n## 3. 图数据库与关系型数据库对比\n\n| 分类         | 模型   | 优势                                   | 劣势                                     | 举例           |\n| ------------ | ------ | -------------------------------------- | ---------------------------------------- | -------------- |\n| 关系型数据库 | 表结构 | 数据高度结构化，一致性强，软件成熟度高 | 面向多跳的关联关系查询低效或不支持       | MySQL、Oracle  |\n| 图数据库     | 图结构 | 针对关联关系的建模建模和操作效率非常高 | 高度结构化的数据处理能力不及关系型数据库 | Neo4j、TuGraph |\n表格内容描述:\n该表格包含五列，分别为“分类”、“模型”、“优势”、“劣势”和“举例”。 \n\n第一行描述的是关系型数据库，它的模型是表结构，优势在于数据高度结构化、一致性强且软件成熟度高，劣势是面对多跳的关联关系查询时效率低或不支持。举例包括MySQL和Oracle。\n\n该段落详细探讨了图数据库的独特优势，主要集中在性能、兼容性和直观性三个方面，并在此基础上与关系型数据库进行了对比，随后附上了一个表格总结了两者的不同特点。这部分内容是文章中对图数据库优点的深入分析，帮助读者理解其相对于传统关系型数据库的优势。"
            },
            {
                "content": "第一行描述的是关系型数据库，它的模型是表结构，优势在于数据高度结构化、一致性强且软件成熟度高，劣势是面对多跳的关联关系查询时效率低或不支持。举例包括MySQL和Oracle。\n\n第二行则是图数据库，其模型为图结构，优势在于针对关联关系的建模和操作效率非常高，而劣势是它在处理高度结构化的数据方面的能力不如关系型数据库。举例包括Neo4j和TuGraph。\n\n总结来看，该表格对比了关系型数据库和图数据库，突出了两者的优劣势及应用实例，显示了它们在数据结构和查询效率上的差异。\n\n总之，面对海量数据的存储和处理问题，传统的关系数据库已经无法满足大部分的日常数据存储需求。图数据库技术可以将关系信息存储为实体，灵活拓展数据模型。由于提供了对关联数据最直接的表达方式和图模型对异构数据的天然包容性，图数据库技术必将成为未来最热点的技术之一，为企业提供存储和分析大规模图数据的有力支持。\n\n该段落位于文章的对比部分，具体总结了关系型数据库和图数据库的主要特点、优势与劣势，并强调了图数据库在处理关联数据方面的优势，最后指出图数据库在未来数据存储和分析中的重要性。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_93.md",
        "chunks": [
            {
                "content": "# 参与贡献\n\n感谢参与GeaFlow开源贡献，无论是bug反馈还是使用问题咨询或者是新Feature提交，都将会推动GeaFlow开源项目的发展。GeaFlow社区对此表示极大的欢迎和感谢。\n\n## 贡献代码流程\n\n1. **创建ISSUE**\n\n您可以在GitHub上创建一个ISSUE，包括Bug反馈、新Feature请求以及自定义ISSUE四中类型。在ISSUE中详细描述您的问题或者方案。\n\n2. **开发代码**\n\n您可以选择自己偏好的Java集成开发环境进行代码开发，代码开发需要遵循GeaFlow的代码规范。您可以通过mvn命令打包来校验代码格式问题。同时，为了保证代码质量，需要对新增和修改的代码补充单元测试。\n\n3. **提交PR**\n\n本地代码开发测试完成以后，可以给GeaFlow master分支提交PR。提交PR后，社区Committer会对您的PR做Code Review。\n* Fork代码：首先在GitHub上Fork一份GeaFlow的代码。\n* 添加仓库：`git remote add fork https://github.com//tugraph-analytics.git`\n* Push分支：`git push fork `\n* 创建PR：点击链接 `https://github.com//tugraph-analytics/pull/new/` 创建PR。\n\n4. **CodeReview**\n\n社区Committer会对代码规范、代码逻辑等进行等在GitHub上进行反馈，您需要对反馈的问题做出Feedback和修改。经过数轮反馈和修改后，社区最终接收您的PR合并进master分支。\n\n## 首次贡献\n\nGeaFlow项目ISSUE里面提供了一下简单的issue方便快速上手参与社区贡献，这些ISSUE被标签为 **good first issue** ,您可以选择感兴趣的问题参与贡献。\n\n如果您对GeaFlow感兴趣，欢迎给我们项目一颗 [⭐](https://github.com/TuGraph-family/tugraph-analytics) 。\n\n该文档介绍了GeaFlow开源项目的参与贡献指南，包括如何创建ISSUE、开发代码、提交PR以及进行Code Review的流程，同时也提供了适合新手的简单ISSUE供其参与。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_94.md",
        "chunks": [
            {
                "content": "# Logical\n\nGeaflow支持以下逻辑运算：\n\n该文档详细列出了Geaflow支持的各种逻辑运算，并提供了每种运算的操作及其描述，以便用户理解和应用这些逻辑运算。"
            },
            {
                "content": "操作|描述\n----------------------|------\nboolean1 OR boolean2 | 如果boolean1为true或boolean2为true，则返回true。\nboolean1 AND boolean2 | 仅在boolean1为true和boolean2为true时才返回true。\nNOT boolean | 返回给定布尔变量的NOT操作的结果。\nboolean IS FALSE | 如果布尔变量为false，则返回true。如果布尔变量是UNKNOWN，则返回false。\nboolean IS NOT FALSE | 如果布尔变量为true，则返回true。如果布尔变量是UNKNOWN，则返回true。\nboolean IS TRUE | 如果布尔变量为true，则返回true。如果布尔变量是UNKNOWN，则返回false。\nboolean IS NOT TRUE | 如果布尔变量为false，则返回true。如果布尔变量是UNKNOWN，则返回true。\nvalue1 = value2 | 如果value1等于value2，则返回true。\nvalue1 <> value2 | 如果value1不等于value2，则返回true。\nvalue1 > value2 | 如果value1大于value2，则返回true。\nvalue1 >= value2 | 如果value1大于或等于value2，则返回true。\nvalue1 < value2 | 如果value1小于value2，则返回true。\nvalue1 <= value2 | 如果value1小于或等于value2，则返回true。\nvalue IS NULL | 如果value为null，则返回true。\nvalue IS NOT NULL | 如果value不为null，则返回true。\nvalue1 IS DISTINCT FROM value2 | 如果value1与value2不同，则返回true。如果value1和value2都为null，则它们被视为相等。\nvalue1 IS NOT DISTINCT FROM value2 | 如果value1等于value2，则返回true。如果value1和value2都为null，则它们被视为相等。\n\n该内容块详细列出了Geaflow支持的逻辑运算及其描述，包括布尔运算和比较运算，为用户提供了清晰的操作指南。"
            },
            {
                "content": "value1 <> value2 | 如果value1不等于value2，则返回true。\nvalue1 > value2 | 如果value1大于value2，则返回true。\nvalue1 >= value2 | 如果value1大于或等于value2，则返回true。\nvalue1 < value2 | 如果value1小于value2，则返回true。\nvalue1 <= value2 | 如果value1小于或等于value2，则返回true。\nvalue IS NULL | 如果value为null，则返回true。\nvalue IS NOT NULL | 如果value不为null，则返回true。\nvalue1 IS DISTINCT FROM value2 | 如果value1与value2不同，则返回true。如果value1和value2都为null，则它们被视为相等。\nvalue1 IS NOT DISTINCT FROM value2 | 如果value1等于value2，则返回true。如果value1和value2都为null，则它们被视为相等。\nvalue1 BETWEEN value2 AND value3 | 如果value1大于或等于value2且小于value3，则返回true。\nvalue1 NOT BETWEEN value2 AND value3 | 如果value1小于value2或大于或等于value3，则返回true。\nstring1 LIKE string2 [ ESCAPE string3 ] | 对字符串string1进行模糊匹配，如果匹配到模式string2则返回true，如果不匹配则返回false。\nstring1 NOT LIKE string2 [ ESCAPE string3 ] | 对字符串string1进行模糊匹配，如果匹配到模式string2则返回false，如果不匹配则返回true。\nvalue IN (value [, value]* ) | 如果value等于列表中的任何一个值，则返回true。\nvalue NOT IN (value [, value]* ) | 如果value不等于列表中的任何一个值，则返回true。\n\n该块内容位于Geaflow文档的逻辑运算部分，具体介绍了各种值比较和字符串匹配的运算符及其描述，帮助用户理解如何进行逻辑判断和条件过滤。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_95.md",
        "chunks": [
            {
                "content": "# DSL原理介绍\n\n## GeaFlow DSL架构\n\nGeaFlow DSL整体架构：\n\nDSL层是一个典型的编译器技术架构，即语法分析、语义分析、中间代码生成(IR)、代码优化、目标代码生成（OBJ）的流程。\n\n* **语言设计**：GeaFlow设计了SQL+GQL的融合语法，解决了图+表一体化分析的诉求。\n* **语法分析**：通过扩展Calcite(https://calcite.apache.org/)的SqlNode和SqlOperator，实现SQL+GQL的语法解析器，生成统一的语法树信息。\n* **语义分析**：通过扩展Calcite的Scope和Namespace，实现自定义Validator，对语法树进行约束语义检查。\n* **中间代码生成**：通过扩展Calcite的RelNode，实现图上的Logical RelNode，用于GQL语法的中间表示。\n* **代码优化**：优化器实现了大量的优化规则（RBO）用于提升执行性能，未来也会引入CBO。\n* **目标代码生成**：代码生成器Converter负责将Logical RelNode转换为Physical RelNode，即目标代码。Physical RelNode可以直接翻译为Graph/Table上的API调用。\n* **自定义函数**: GeaFlow提供了大量的内置系统函数，用户也可以根据需要注册自定义函数。\n* **自定义插件**: GeaFlow允许用户扩展自己的Connector类型，以支持不同的数据源和数据格式。\n\n\n## DSL主要执行流程\nDSL的主要执行流程：\n\nDSL文本首先经过Parser解析生成AST语法树，然后再经过Validator校验器做语义检查和类型推导生成校验后的AST语法树。接着通过Logical Plan转换器生成图表一体的逻辑执行计划。逻辑执行计划通过优化器进行优化处理生成优化后的逻辑执行计划，接下来由物理执行计划转换器转换成物理执行计划，物理执行计划通过DAG Builder生成图表一体的物理执行逻辑。GeaFlow DSL采用有两级DAG结构来描述图表一体的物理执行逻辑。\n\n## 两级DAG物理执行计划\n和传统的分布式表数据处理引擎Storm、Flink和Spark的系统不同，GeaFlow是一个流图一体的分布式计算系统。其物理执行计划采用图表两级DAG结构：\n\n该文档介绍了GeaFlow DSL的整体架构和执行流程，重点阐述了其编译器技术架构、DSL的主要执行步骤以及独特的两级DAG物理执行计划设计。"
            },
            {
                "content": "## DSL主要执行流程\nDSL的主要执行流程：\n\nDSL文本首先经过Parser解析生成AST语法树，然后再经过Validator校验器做语义检查和类型推导生成校验后的AST语法树。接着通过Logical Plan转换器生成图表一体的逻辑执行计划。逻辑执行计划通过优化器进行优化处理生成优化后的逻辑执行计划，接下来由物理执行计划转换器转换成物理执行计划，物理执行计划通过DAG Builder生成图表一体的物理执行逻辑。GeaFlow DSL采用有两级DAG结构来描述图表一体的物理执行逻辑。\n\n## 两级DAG物理执行计划\n和传统的分布式表数据处理引擎Storm、Flink和Spark的系统不同，GeaFlow是一个流图一体的分布式计算系统。其物理执行计划采用图表两级DAG结构：\n\n外层DAG包含表处理相关的算子以及图处理的迭代算子，为物理执行逻辑的主体部分，将图表的计算逻辑链接起来。内层DAG则将图计算的逻辑通过DAG方式展开，代表了图迭代计算具体执行方式.\n\n该文档介绍了GeaFlow DSL的整体架构及其执行流程。其中，\"DSL主要执行流程\"部分详细描述了DSL文本从解析到生成物理执行逻辑的各个步骤，紧接着的\"两级DAG物理执行计划\"部分则阐述了GeaFlow如何通过两级DAG结构实现图表一体的物理执行，展示了其与传统数据处理引擎的不同之处。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_96.md",
        "chunks": [
            {
                "content": "# DML\n## Insert Table\n\n**Syntax**\n```\nINSERT INTO \n\n;\n```\n\n**Example**\n例子1\n```sql\nINSERT INTO table VALUES ('json', 111);\n```\n这个例子向**table**表导入一行数据。\n\n例子2\n```sql\nINSERT INTO user_table\nSELECT id, age FROM users\nWHERE age > 20;\n```\n这个例子向**user_table**表导入一个查询语句结果。\n\n例子3\n```sql\nINSERT INTO tbl_result\nMATCH (a:person where a.id = 1) -[e:knows]->(b:person)\nRETURN a.id as a_id, e.weight as weight, b.id as b_id;\n```\n这个例子向**tbl_result**表导入一个走图查询语句返回的结果。\n\n\n## Insert Graph\nInsert命令还可以向图导入数据。与表不同，图使用GeaFlow自主维护的存储。\n\n## 插入点/边\nInsert命令向图中的点或边导入数据时，操作对象以点分的图名加点边名表示，支持字段的重新排序。\n\n**Syntax**\n```\nINSERT INTO .\n[( [{, } ... ])]\n\n;\n```\n\n**Example**\n例子1\n```sql\nINSERT INTO dy_modern.person\nSELECT cast(id as bigint), name, cast(other as int) as age\nFROM modern_vertex WHERE type = 'person'\n;\n```\n这个例子向图**dy_modern**中的点**person**导入来自源表**modern_vertex**的数据，源表modern_vertex的三个字段与person中的字段一一对应。\n\n该文档主要介绍数据操作语言（DML）中的插入操作，包括向表和图中插入数据的语法和示例。该chunk具体阐述了如何向数据库表插入数据以及向图数据结构插入点和边的详细语法和实例。"
            },
            {
                "content": "## Insert Graph\nInsert命令还可以向图导入数据。与表不同，图使用GeaFlow自主维护的存储。\n\n## 插入点/边\nInsert命令向图中的点或边导入数据时，操作对象以点分的图名加点边名表示，支持字段的重新排序。\n\n**Syntax**\n```\nINSERT INTO .\n[( [{, } ... ])]\n\n;\n```\n\n**Example**\n例子1\n```sql\nINSERT INTO dy_modern.person\nSELECT cast(id as bigint), name, cast(other as int) as age\nFROM modern_vertex WHERE type = 'person'\n;\n```\n这个例子向图**dy_modern**中的点**person**导入来自源表**modern_vertex**的数据，源表modern_vertex的三个字段与person中的字段一一对应。\n\n例子2\n```sql\nINSERT INTO dy_modern.person(name, id, age)\nSELECT 'jim', 1,  20\nUNION ALL\nSELECT 'kate', 2, 22\n;\n```\n这个例子向图**dy_modern**中的点**person**导入两行数据，数据的字段以\"name, id, age\"顺序排列，对应点表person的同名字段。假设person还具有其他字段，则那些字段自动填充空值null。\n\n例子3\n```sql\nINSERT INTO dy_modern.knows\nSELECT 1, 2, 0.2\n;\n```\n这个例子向图**dy_modern**中的边**knows**导入一行数据。\n\n## 多表插入\n有时源表需要同时插入到多个点或边中，特别是源表的外键表示一种关系时，往往需要转化为一类边，键值也将成为边的对端点。INSERT语句也支持这种单一源表，多目标点的插入。\n\n**Syntax**\n```\nINSERT INTO \n(. [{, .} ... ])\n\n;\n```\n不同于向点边整体插入数据，这种写法将点边名字放到括号内，每个字段都需要指定所属的节点。和前文一样的是，未被指定的字段自动填充空值null。如果有meta字段(id或timestamp)未被指定，语法检查将报错。\n\n该块内容主要介绍了在图数据库中使用INSERT命令导入数据的不同方式，包括向图中的点和边插入数据的语法、示例及多表插入的机制，属于文档中关于数据插入操作的部分。"
            },
            {
                "content": "例子3\n```sql\nINSERT INTO dy_modern.knows\nSELECT 1, 2, 0.2\n;\n```\n这个例子向图**dy_modern**中的边**knows**导入一行数据。\n\n## 多表插入\n有时源表需要同时插入到多个点或边中，特别是源表的外键表示一种关系时，往往需要转化为一类边，键值也将成为边的对端点。INSERT语句也支持这种单一源表，多目标点的插入。\n\n**Syntax**\n```\nINSERT INTO \n(. [{, .} ... ])\n\n;\n```\n不同于向点边整体插入数据，这种写法将点边名字放到括号内，每个字段都需要指定所属的节点。和前文一样的是，未被指定的字段自动填充空值null。如果有meta字段(id或timestamp)未被指定，语法检查将报错。\n\n**Example**\n例子1\n```sql\nINSERT INTO dy_graph(\n  Country.id, Country.name, Country.url, isPartOf.srcId, isPartOf.targetId\n)\nSELECT CAST(id as BIGINT), name, url,\nCAST(id as BIGINT), CAST(PartOfPlaceId as BIGINT)\nFROM tbl_vertex_place\nWhere type = 'Country';\n```\n这个例子向图**dy_graph**中的点**Country**和边**isPartOf**同时插入。源表中的**PartOfPlaceId**作为一个外键表示国家所属的洲，转化为出边isPartOf。\n\n该段落主要介绍了在图数据库中插入数据的语法和示例，特别是针对多表插入的方式，结合了之前插入边的示例，展示如何同时向多个点和边中插入数据。"
            },
            {
                "content": ";\n```\n不同于向点边整体插入数据，这种写法将点边名字放到括号内，每个字段都需要指定所属的节点。和前文一样的是，未被指定的字段自动填充空值null。如果有meta字段(id或timestamp)未被指定，语法检查将报错。\n\n**Example**\n例子1\n```sql\nINSERT INTO dy_graph(\n  Country.id, Country.name, Country.url, isPartOf.srcId, isPartOf.targetId\n)\nSELECT CAST(id as BIGINT), name, url,\nCAST(id as BIGINT), CAST(PartOfPlaceId as BIGINT)\nFROM tbl_vertex_place\nWhere type = 'Country';\n```\n这个例子向图**dy_graph**中的点**Country**和边**isPartOf**同时插入。源表中的**PartOfPlaceId**作为一个外键表示国家所属的洲，转化为出边isPartOf。\n\n例子2\n```sql\nINSERT INTO dy_graph(\n  Tag.id, Tag.name, Tag.url, hasType.srcId, hasType.targetId, TagClass.id\n)\nSELECT CAST(id as BIGINT), name, url,\nCAST(id as BIGINT), CAST(TypeTagClassId as BIGINT),\nCAST(TypeTagClassId as BIGINT)\nFROM tbl_vertex_tag\nWhere length(url) > 3;\n```\n这个例子向图**dy_modern**中的点**Tag**,边**hasType**,点**TagClass**同时插入数据，源表中的**TypeTagClassId**转化为Tag的hasType类型边，同时插入新的TagClass点。假设TagClass还具有其他字段，则那些字段自动填充空值null。\n\n该块内容位于文档的“多表插入”部分，主要讲解了如何使用INSERT语句同时向图中的多个点和边插入数据，并提供了两个具体的示例来说明不同字段的指定和数据的转换。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_97.md",
        "chunks": [
            {
                "content": "# Kafka Connector介绍\nGeaFlow 支持从 Kafka 中读取数据，并向 Kafka 写入数据。目前支持的 Kafka 版本为 2.4.1。\n## 语法\n\n```sql\nCREATE TABLE kafka_table (\n  id BIGINT,\n  name VARCHAR,\n  age INT\n) WITH (\n\ttype='kafka',\n    geaflow.dsl.kafka.servers = 'localhost:9092',\n\tgeaflow.dsl.kafka.topic = 'test-topic'\n)\n```\n## 参数\n\n| 参数名 | 是否必须 | 描述 |\n| -------- | -------- | -------- |\n| geaflow.dsl.kafka.servers     | 是     | Kafka 的引导服务器（bootstrap）列表     |\n| geaflow.dsl.kafka.topic     | 是     | Kafka topic|\n| geaflow.dsl.kafka.group.id     | 否     | Kafka组（group id），默认是'default-group-id'.|\n表格内容描述: 该表格包含三个列名：参数名、是否必须以及描述。具体数据内容如下：\n\n1. 参数名为 \"geaflow.dsl.kafka.servers\"，该参数是必填的，描述为 \"Kafka 的引导服务器（bootstrap）列表\"。\n2. 参数名为 \"geaflow.dsl.kafka.topic\"，该参数也是必填的，描述为 \"Kafka topic\"。\n3. 参数名为 \"geaflow.dsl.kafka.group.id\"，该参数并非必填，其默认值为 'default-group-id'，描述为 \"Kafka组（group id）\"。\n\n总体总结：此表格详细列出了与Kafka配置相关的参数，包括它们是否为必填项及其简要说明。主要参数包括引导服务器列表、topic和可选的组ID，其中前两个参数是必填的，而组ID有默认值。\n\n\n## 示例\n\n该块内容介绍了GeaFlow中的Kafka连接器，包括其功能、创建表的语法、所需的参数及其描述，并提供了示例代码以展示从Kafka读取和写入数据的用法。"
            },
            {
                "content": "1. 参数名为 \"geaflow.dsl.kafka.servers\"，该参数是必填的，描述为 \"Kafka 的引导服务器（bootstrap）列表\"。\n2. 参数名为 \"geaflow.dsl.kafka.topic\"，该参数也是必填的，描述为 \"Kafka topic\"。\n3. 参数名为 \"geaflow.dsl.kafka.group.id\"，该参数并非必填，其默认值为 'default-group-id'，描述为 \"Kafka组（group id）\"。\n\n总体总结：此表格详细列出了与Kafka配置相关的参数，包括它们是否为必填项及其简要说明。主要参数包括引导服务器列表、topic和可选的组ID，其中前两个参数是必填的，而组ID有默认值。\n\n\n## 示例\n\n```sql\nCREATE TABLE kafka_source (\n  id BIGINT,\n  name VARCHAR,\n  age INT\n) WITH (\n\ttype='kafka',\n    geaflow.dsl.kafka.servers = 'localhost:9092',\n\tgeaflow.dsl.kafka.topic = 'read-topic'\n);\n\nCREATE TABLE kafka_sink (\n  id BIGINT,\n  name VARCHAR,\n  age INT\n) WITH (\n\ttype='kafka',\n    geaflow.dsl.kafka.servers = 'localhost:9092',\n\tgeaflow.dsl.kafka.topic = 'write-topic'\n);\n\nINSERT INTO kafka_sink\nSELECT * FROM kafka_source;\n```\n\n该段落位于Kafka Connector介绍部分，详细描述了与Kafka配置相关的参数，包括必填项和可选项的说明，并提供了创建Kafka数据源和数据接收表的示例SQL代码。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_98.md",
        "chunks": [
            {
                "content": "# TuGraph产品架构\n\n> 此文档主要介绍 TuGraph 的产品架构。\n\n## 1.简介\n\n从功能模块的角度，以 TuGraph 为例，企业级图数据库的整体架构，自下而上包括：\n\n- 软硬件环境。涉及图数据库的开发和使用环境。TuGraph 主要基于底层的 C++语言开发，能够兼容市面上大部分操作系统和 CPU。\n- 存储层，包括 KV 存储层和图存储层。存储层需要支持计算层所需的各个功能。\n- 计算层。计算层应包括图事务引擎、图分析引擎和图神经网络引擎，也包含了服务端提供的多种编程接口，包括描述式查询语言 Cypher，存储过程等。\n- 客户端。客户端 SDK 应支持 Java、Python、C++ 等多种语言，也支持命令行的交互方式。Browser 和 Explorer 通过网页端交互的方式，降低了图数据库的使用门槛。\n- 在生态工具方面，覆盖了企业级图数据库的开发、运维、管理等链路，提升可用性。\n\n本文档旨在全面介绍 TuGraph 的产品架构，重点阐述其功能模块，包括软硬件环境、存储层、计算层、客户端以及生态工具的设计和实现，以便读者理解企业级图数据库的整体框架和优势。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_99.md",
        "chunks": [
            {
                "content": "# 场景：三国（基于tugraph-db的产品内置场景上手体验）\n\n> 此文档主要介绍 三国 demo的使用方法。\n\n## 1. 简介\n由于史料的缺失，一些即使为人们熟知的历史事件也往往存在着很多未解之谜。以三国历史为例，诸葛亮为什么出山帮助当时势力弱小的刘备，同为天下英雄的曹操和刘备为什么成就差距巨大等等。以往学者往往采用二维关系分析历史，这样得出的结论往往比较片面。使用TuGraph将三国的历史人物和事件导入图模型中，使用图计算方式进行分析，能够帮助我们从有限的信息中获得更有价值的知识，是一种非常有意义的跨学科尝试。\n## 2. 数据建模\n我们设计了5类顶点和5类边，点包括“主公”，“州”，“文臣”，“武将”，“战役”，边包括“父亲”，“兄长”，“隶属”，“籍贯”，“参战”。\n\n## 3. 数据导入\n- 手动导入\n  - 数据存放目录：https://github.com/TuGraph-family/tugraph-db-demo （该项目汇集了TuGraph的Demo，每个文件夹为一个能够单独运行的demo，可以在tugraph-db中快速使用。）\n  - 根据数据存放目录对应修改import.json里面的DATA_PATH。\n  - 启动TuGraph服务后，访问${HOST_IP}:7070，打开web页面，确认数据是否导入成功。\n- 自动创建\n    - 点击`新建图项目`，选择三国数据，填写图项目配置，系统会自动完成三国场景图项目创建。\n\n## 4. Cypher分析\n### 4.1. 诸葛亮为什么选择刘备\n通过如下cypher命令可以查看诸葛亮和曹操、刘备之间的关系\n```\nMATCH p = (cc:主公 {name: '曹操'})-[*1..3]-(zgl:文臣 {name: '诸葛亮'}) RETURN p\n```\n\n可以很直观的看出，曹操和诸葛亮之间的最短路径之一包含徐州之战，曹操曾经因父亲被杀对徐州进行过屠城，而诸葛亮是徐州琅琊郡人，任何人都断然不会选择一个屠杀过自己家乡的军阀作为主公。而相反，刘备曾经在徐州之战中阻止过曹操的暴行，这应当是诸葛亮对刘备好感的原因之一。\n\n本chunk位于文档的开头部分，主要介绍了三国历史的背景和TuGraph的应用，通过数据建模和数据导入的方式，为后续的Cypher分析奠定基础。它讨论了如何利用图模型分析历史事件与人物之间的关系，并引出对重要人物如诸葛亮选择刘备的原因进行探讨。"
            },
            {
                "content": "## 4. Cypher分析\n### 4.1. 诸葛亮为什么选择刘备\n通过如下cypher命令可以查看诸葛亮和曹操、刘备之间的关系\n```\nMATCH p = (cc:主公 {name: '曹操'})-[*1..3]-(zgl:文臣 {name: '诸葛亮'}) RETURN p\n```\n\n可以很直观的看出，曹操和诸葛亮之间的最短路径之一包含徐州之战，曹操曾经因父亲被杀对徐州进行过屠城，而诸葛亮是徐州琅琊郡人，任何人都断然不会选择一个屠杀过自己家乡的军阀作为主公。而相反，刘备曾经在徐州之战中阻止过曹操的暴行，这应当是诸葛亮对刘备好感的原因之一。\n\n### 4.2. 曹操为什么成就比刘备高\n通过如下cypher命令可以查看家族对曹操创业的助力\n```\nMATCH (cc:主公{name:\"曹操\"})<-[r:隶属]-(wj:武将) WHERE wj.name REGEXP \"曹.*\" OR wj.name REGEXP \"夏侯.*\" return cc,wj,r\n```\n\n平定天下最重要的就是军事人才，曹操其父本姓夏侯，过继于曹氏，曹氏和夏侯氏在谯县都属于地方大族，在曹操创业初期提供了夏侯惇，夏侯渊，曹仁，曹洪在内大量的军事人才。而刘备其父早丧，没有家族助力，年过50才凑齐了自己的五虎上将，而这时已经过了天下大乱争夺地盘的最佳时机，曹操已经天下九州居其六了。\n\n### 4.3. 三国中最强大的魏国为何最先灭亡\n通过如下cypher命令可以查看曹操集团的重要文官组成\n```\nMATCH (cc:主公)<-[r:隶属]-(wc) WHERE cc.name REGEXP \"曹.*\" AND (label(wc) = \"文臣\" OR label(wc) = \"主公\") return cc,wc,r\n```\n\n曹魏事实上于249年灭亡于高平陵之变，立国29年，少于蜀汉（43年）和东吴（51年）。三国中实力最强大的魏国最先灭亡的原因就在于曹魏的文官制度（九品中正制）使得权力很容易集中在世家大族手中。从图中可以看出，曹操曹丕父子两代的重要文臣几乎都是世家大族，颍川荀氏，颍川钟氏，颍川陈氏，武威贾氏等，甚至还出现了地区化趋势，集中于颍川，最终政权也为和颍川荀氏关系密切的河内司马氏所篡夺。\n\n该章节主要分析三国历史中的关键人物关系和事件，通过Cypher查询语言探讨诸葛亮选择刘备的原因、曹操与刘备之间成就差距的原因、以及魏国早期灭亡的背景，旨在通过数据分析揭示三国历史中的深层次关系和影响因素。"
            },
            {
                "content": "平定天下最重要的就是军事人才，曹操其父本姓夏侯，过继于曹氏，曹氏和夏侯氏在谯县都属于地方大族，在曹操创业初期提供了夏侯惇，夏侯渊，曹仁，曹洪在内大量的军事人才。而刘备其父早丧，没有家族助力，年过50才凑齐了自己的五虎上将，而这时已经过了天下大乱争夺地盘的最佳时机，曹操已经天下九州居其六了。\n\n### 4.3. 三国中最强大的魏国为何最先灭亡\n通过如下cypher命令可以查看曹操集团的重要文官组成\n```\nMATCH (cc:主公)<-[r:隶属]-(wc) WHERE cc.name REGEXP \"曹.*\" AND (label(wc) = \"文臣\" OR label(wc) = \"主公\") return cc,wc,r\n```\n\n曹魏事实上于249年灭亡于高平陵之变，立国29年，少于蜀汉（43年）和东吴（51年）。三国中实力最强大的魏国最先灭亡的原因就在于曹魏的文官制度（九品中正制）使得权力很容易集中在世家大族手中。从图中可以看出，曹操曹丕父子两代的重要文臣几乎都是世家大族，颍川荀氏，颍川钟氏，颍川陈氏，武威贾氏等，甚至还出现了地区化趋势，集中于颍川，最终政权也为和颍川荀氏关系密切的河内司马氏所篡夺。\n\n### 4.4. 三国各自的实力究竟如何\n通过如下cypher命令可以查看三国各集团的人口实力\n```\nMATCH (p) WHERE (label(p)=\"主公\" OR label(p)=\"文臣\" OR label(p)=\"武将\") AND p.hometown IN [\"幽州\",\"冀州\",\"青州\",\"并州\",\"凉州\",\"司州\",\"豫州\",\"兖州\",\"徐州\"] WITH COUNT(p) AS w\nMATCH (p) WHERE (label(p)=\"主公\" OR label(p)=\"文臣\" OR label(p)=\"武将\") AND p.hometown IN [\"益州\"] WITH COUNT(p) AS s,w\nMATCH (p) WHERE (label(p)=\"主公\" OR label(p)=\"文臣\" OR label(p)=\"武将\") AND p.hometown IN [\"扬州\",\"荆州\",\"交州\"]\nRETURN w as 魏人口,s as 蜀人口,count(p) as 吴人口\n```\n\n该部分内容主要分析了曹操和刘备在创业过程中的军事人才背景，以及魏国为何作为最强大的国家却最先灭亡的原因，接着描述了三国各国人口实力的对比。此段落位于第四章的Cypher分析部分，具体探讨了曹操的家族支持与曹魏的文官制度对其历史命运的影响。"
            },
            {
                "content": "### 4.4. 三国各自的实力究竟如何\n通过如下cypher命令可以查看三国各集团的人口实力\n```\nMATCH (p) WHERE (label(p)=\"主公\" OR label(p)=\"文臣\" OR label(p)=\"武将\") AND p.hometown IN [\"幽州\",\"冀州\",\"青州\",\"并州\",\"凉州\",\"司州\",\"豫州\",\"兖州\",\"徐州\"] WITH COUNT(p) AS w\nMATCH (p) WHERE (label(p)=\"主公\" OR label(p)=\"文臣\" OR label(p)=\"武将\") AND p.hometown IN [\"益州\"] WITH COUNT(p) AS s,w\nMATCH (p) WHERE (label(p)=\"主公\" OR label(p)=\"文臣\" OR label(p)=\"武将\") AND p.hometown IN [\"扬州\",\"荆州\",\"交州\"]\nRETURN w as 魏人口,s as 蜀人口,count(p) as 吴人口\n```\n\n古代社会衡量一个国家实力的重要指标是人口数量，由于人口数据缺失，我们使用三国所有主公和文臣武将的籍贯数据估计每个州的人口数量。发现三国主要人物中，按籍贯有60个属于魏国，有23个属于吴国，仅有2个属于蜀国，证明魏国确实是三国中最强大的国家。\n\n### 4.5. 曹操的军事能力如何评价\n通过如下cypher命令可以查看曹操参与的主要战役\n```\nMATCH (cc:主公{name:\"曹操\"})-[e]-(zy:战役) RETURN cc,zy,e\n```\n\n可以看出，曹操在三国主要的15场战役中参加了8场，出场率比较高。但是曹操只获胜了徐州之战、兖州之战、官渡之战和襄樊之战，汉中之战、宛城之战、群雄讨董和赤壁之战都失败了，综合胜率50%，证明曹操并不算一个非常优秀的军事家。\n\n## 5. 备注\n更多的分析有待大家积极补充和尝试！\n\n该段落主要讨论了三国时期各国的人口实力及其对国家势力的影响，接着分析了曹操的军事能力和战役表现，属于Cypher分析部分的内容，旨在通过数据模型揭示历史人物和事件间的关系及其背后的原因。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_100.md",
        "chunks": [
            {
                "content": "# 文档地图\n这里是文档地图，帮助用户快速学习和使用TuGraph Analytics。\n\n## 介绍\n**TuGraph Analytics** (别名：GeaFlow) 是蚂蚁集团开源的性能世界一流(https://ldbcouncil.org/benchmarks/snb-bi/)的OLAP图数据库，支持万亿级图存储、图表混合处理、实时图计算、交互式图分析等核心能力，目前广泛应用于数仓加速、金融风控、知识图谱以及社交网络等场景。\n\nGeaFlow设计论文参考：[GeaFlow: A Graph Extended and Accelerated Dataflow System](https://dl.acm.org/doi/abs/10.1145/3589771)\n\n## 快速上手\n\n1. 准备Git、JDK8、Maven、Docker环境。\n2. 下载源码：`git clone https://github.com/TuGraph-family/tugraph-analytics`\n3. 项目构建：`mvn clean install -DskipTests`\n4. 测试任务：`./bin/gql_submit.sh --gql geaflow/geaflow-examples/gql/loop_detection.sql`\n3. 构建镜像：`./build.sh --all`\n4. 启动容器：`docker run -d --name geaflow-console -p 8888:8888 geaflow-console:0.1`\n\n## 开发手册\n\nGeaFlow支持DSL和API两套编程接口（DSL应用开发和API应用开发），您既可以通过GeaFlow提供的类SQL扩展语言SQL+ISO/GQL进行流图计算作业的开发，也可以通过GeaFlow的高阶API编程接口通过Java语言进行应用开发。\n\n## 实时能力\n\n相比传统的流式计算引擎比如Flink、Storm这些以表为模型的实时处理系统而言，GeaFlow以图为数据模型，在处理Join关系运算，尤其是复杂多跳的关系运算如3跳以上的Join、复杂环路查找上具备极大的性能优势。\n\n## 合作伙伴\n\n该文档介绍了TuGraph Analytics（GeaFlow）的基本信息、快速上手指南、开发手册、实时能力以及合作伙伴。此部分是文档的开头，包括文档地图和各个主题的概述，方便用户对TuGraph Analytics的功能和使用方法进行快速学习和了解。"
            },
            {
                "content": "## 开发手册\n\nGeaFlow支持DSL和API两套编程接口（DSL应用开发和API应用开发），您既可以通过GeaFlow提供的类SQL扩展语言SQL+ISO/GQL进行流图计算作业的开发，也可以通过GeaFlow的高阶API编程接口通过Java语言进行应用开发。\n\n## 实时能力\n\n相比传统的流式计算引擎比如Flink、Storm这些以表为模型的实时处理系统而言，GeaFlow以图为数据模型，在处理Join关系运算，尤其是复杂多跳的关系运算如3跳以上的Join、复杂环路查找上具备极大的性能优势。\n\n## 合作伙伴\n\n华中科技大学、大数据技术与系统国家地方联合工程研究中心、服务计算技术与系统教育部重点实验室、集群与网格计算湖北省重点实验室、复旦大学知识工场实验室、浙江大学数据库与大数据分析实验室、WhaleOps、OceanBase、SecretFlow隐语。\n\n该chunk位于文档的中部，主要介绍TuGraph Analytics（GeaFlow）平台的开发手册、实时计算能力以及合作伙伴信息，旨在帮助用户了解该平台的编程接口和性能优势。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_101.md",
        "chunks": [
            {
                "content": "# 个人贡献者许可协议\n\nAnt_Group_Open_Source_Individual_CLA_English_Chinese_2021\n\nAnt Group\n\nIndividual Contributor License Agreement\n\n蚂蚁集团\n\n个人贡献者许可协议\n\nThank you for your interest in contributing documentation and related software code to a project hosted or managed by Ant Group, or any of its affiliates. In order to clarify the intellectual property license granted with Contributions from any person or entity, Ant Group must have a Contributor License Agreement (\"CLA\") on file that has been signed by each Contributor, indicating agreement to the license terms below.  This version of the Contributor License Agreement allows an individual to submit Contributions to the applicable project.  If you are making a submission on behalf of a legal entity, then you should sign the separation Corporate Contributor License Agreement.\n\n感谢您对向蚂蚁集团或其任何关联方主办或管理的项目贡献文档和相关软件代码的兴趣。为厘清就个人或实体贡献内容而授予的知识产权许可，蚂蚁集团必须对每位贡献者签署的贡献者许可协议（“CLA”）进行归档，以证明就以下许可条件达成的一致。此版本的贡献者许可协议允许个人向相应项目提交贡献内容。如果您是以公司名义进行提交，您应当另行签署一份公司贡献者许可协议。\n\n该片段为蚂蚁集团个人贡献者许可协议的引言部分，介绍了贡献者协议的目的、适用范围及如何签署，包括个人与法律实体的提交要求。"
            },
            {
                "content": "感谢您对向蚂蚁集团或其任何关联方主办或管理的项目贡献文档和相关软件代码的兴趣。为厘清就个人或实体贡献内容而授予的知识产权许可，蚂蚁集团必须对每位贡献者签署的贡献者许可协议（“CLA”）进行归档，以证明就以下许可条件达成的一致。此版本的贡献者许可协议允许个人向相应项目提交贡献内容。如果您是以公司名义进行提交，您应当另行签署一份公司贡献者许可协议。\n\nYou accept and agree to the following terms and conditions for Your present and future Contributions submitted to Ant Group. Except for the license granted herein to Ant Group and recipients of documentation and software distributed by Ant Group, You reserve all right, title, and interest in and to Your Contributions.\n\n就您目前和将来向蚂蚁集团提交的贡献内容，您接受并同意以下条款和条件。除了根据本协议向蚂蚁集团和蚂蚁集团发布文档和软件的接收方授予的许可，您对于您的贡献内容保留所有权利、所有权和利益。\n\n1. Definitions.\n1. 定义。\n\n该chunk位于个人贡献者许可协议的开头部分，介绍了贡献者向蚂蚁集团提交贡献内容的背景和目的，并列出了贡献者接受的条款和条件，为后续定义和权利授予等条款做铺垫。"
            },
            {
                "content": "就您目前和将来向蚂蚁集团提交的贡献内容，您接受并同意以下条款和条件。除了根据本协议向蚂蚁集团和蚂蚁集团发布文档和软件的接收方授予的许可，您对于您的贡献内容保留所有权利、所有权和利益。\n\n1. Definitions.\n1. 定义。\n\n   \"You\" (or \"Your\") shall mean the copyright owner or legal entity authorized by the copyright owner that is making this Agreement with Ant Group. For legal entities, the entity making a Contribution and all other entities that control, are controlled by, or are under common control with that entity are considered to be a single Contributor. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.\n\n   “您”（或“您的”）系指与蚂蚁集团签署本协议的著作权人或经著作权人授权的法律实体。对于法律实体而言，提交贡献内容的实体以及其他任何控制该实体、受其控制或与其受到同一主体控制的实体被视为单个贡献者。为本定义之目的，“控制” 系指（i）通过合同或其他方式，直接或间接对该实体进行指导和管理的权力，（ii）持有该实体百分之五十（50%）或更多的已发行股份，或（iii）间接持有该实体权益。\n\n该块内容位于个人贡献者许可协议的开头部分，明确了贡献者对蚂蚁集团提交贡献内容的同意条款，以及对贡献内容所有权的保留。随后，协议定义了相关术语，特别是“您”或“您的”所指代的著作权人或法律实体。"
            },
            {
                "content": "“您”（或“您的”）系指与蚂蚁集团签署本协议的著作权人或经著作权人授权的法律实体。对于法律实体而言，提交贡献内容的实体以及其他任何控制该实体、受其控制或与其受到同一主体控制的实体被视为单个贡献者。为本定义之目的，“控制” 系指（i）通过合同或其他方式，直接或间接对该实体进行指导和管理的权力，（ii）持有该实体百分之五十（50%）或更多的已发行股份，或（iii）间接持有该实体权益。\n\n   \"Contribution\" shall mean any original work of authorship, including any modifications or additions to an existing work, that is intentionally submitted by You to Ant Group for inclusion in, or documentation of, any of the products or projects owned or managed by Ant Group (the \"Work\"), including without limitation any Work described in Schedule A. For the purposes of this definition, \"submitted\" means any form of electronic or written communication sent to Ant Group or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, Ant Group for the purpose of discussing and improving the Work.\n\n该段落位于个人贡献者许可协议的定义部分，主要阐述了“您”（或“您的”）和“贡献内容”的含义，明确了贡献者的身份及其权利，并具体说明了什么构成贡献内容，以便于理解和执行后续协议条款。"
            },
            {
                "content": "“贡献内容”系指由您有意地向蚂蚁集团提交，以便被包含或记载在任何蚂蚁集团拥有或管理的产品或项目（“作品”，包括但不限于任何在附录A中列举的作品）中的任何原创作品，包括对既存作品的任何修改和增加。为本定义之目的，“提交”系指向蚂蚁集团或其代表进行的任何形式的电子或书面交流，包括但不限于为讨论和改善作品为目的，通过蚂蚁集团管理的（或以蚂蚁集团名义管理的）电子邮件列表、源代码控制系统和问题跟踪系统进行的交流。\n\n2. Grant of Copyright License. Subject to the terms and conditions of this Agreement, You hereby grant to Ant Group and to recipients of documentation and software distributed by Ant Group a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare derivative works of, publicly display, publicly perform, sublicense, and distribute Your Contributions and such derivative works.\n2. 著作权许可的授予。受限于本协议的条款和条件，您在此授予蚂蚁集团以及蚂蚁集团发布文档和软件的接收方永久性的、全球范围内的、非排他的、完全无须许可费的、完全无须版权费的和不可撤销的著作权许可，以复制、衍生、公开展示、公开执行、转授权和发布您的贡献内容和该等衍生作品。\n\n该段落位于“个人贡献者许可协议”的第二条中，主要定义了“贡献内容”的含义，并阐述了贡献者对蚂蚁集团授予的著作权许可，包括复制、衍生、公开展示及转授权等权利的条款。"
            },
            {
                "content": "3. Grant of Patent License. Subject to the terms and conditions of this Agreement, You hereby grant to Ant Group and to recipients of documentation and software distributed by Ant Group a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by You that are necessarily infringed by Your Contribution(s) alone or by combination of Your Contribution(s) with the Work to which such Contribution(s) was submitted. If any entity institutes patent litigation against You or any other entity (including a cross-claim or counterclaim in a lawsuit) alleging that your Contribution, or the Work to which you have contributed, constitutes direct or contributory patent infringement, then any patent licenses granted to that entity under this Agreement for that Contribution or Work shall terminate as of the\n\n该段落位于个人贡献者许可协议的第三部分，主要阐述了贡献者授予蚂蚁集团及其文档和软件接收方的专利许可条款，包括许可的范围、条件以及在特定情况下的终止条款。"
            },
            {
                "content": "Contribution(s) alone or by combination of Your Contribution(s) with the Work to which such Contribution(s) was submitted. If any entity institutes patent litigation against You or any other entity (including a cross-claim or counterclaim in a lawsuit) alleging that your Contribution, or the Work to which you have contributed, constitutes direct or contributory patent infringement, then any patent licenses granted to that entity under this Agreement for that Contribution or Work shall terminate as of the date such litigation is filed.\n\n该段落位于“专利许可的授予”部分，具体讨论了在专利诉讼情况下，贡献者所授予的专利许可的终止条件。这一条款确保如果贡献者被指控其贡献内容或其参与的作品侵犯专利，相关的专利许可将会在诉讼启动时终止。"
            },
            {
                "content": "3. 专利许可的授予。  受限于本协议的条款和条件，您在此授予蚂蚁集团以及蚂蚁集团发布文档和软件的接收方永久性的、全球范围内的、非排他的、完全无须许可费的、完全无须版权费的和不可撤销（本节规定的情形除外）的专利许可，以开发、利用、要约出售、出售、导入或以其他方式转让作品，但该许可仅适用于您有权许可的，且必然会被您的贡献内容侵权（贡献内容单独构成侵权、或与贡献内容的相关作品一同构成侵权）的专利申请范围。如果任何实体针对您或其他实体提起专利诉讼（包括诉讼中的交叉请求或反诉），主张您的贡献内容（或您参与贡献的作品）造成了直接性或辅助性的专利侵权，则任何根据本协议针对该贡献内容或作品授予该实体的专利许可应当在起诉之日终止。\n\n该段落位于个人贡献者许可协议的第三部分，主要关于专利许可的授予，规定了贡献者对蚂蚁集团及其文档和软件的接收方授予的专利权利，以及在特定情况下该许可的终止条件。这是贡献者在参与项目时需理解的重要条款。"
            },
            {
                "content": "4. You represent that you are legally entitled to grant the above license.\n4. 您保证您依法有权授予上述许可。\n\n5. You represent that each of Your Contributions is Your original creation (see section 7 for submissions on behalf of others).  You represent that Your Contribution submissions include complete details of any third-party license or other restriction (including, but not limited to, related patents and trademarks) of which you are personally aware and which are associated with any part of Your Contributions.\n5. 您保证您所有的贡献内容均为您的原创作品（关于为他人提交作品的规定，可参见第7节）。您保证您提交的贡献内容包括任何第三方许可或其他限制（包括但不限于相关专利或商标）的全部细节，只要该等许可或其他限制为您个人所知悉且与您的贡献内容的任何部分相关。\n\n该段落位于个人贡献者许可协议中，主要涉及贡献者的声明，包括合法授权授予许可的能力以及对贡献内容原创性和相关第三方许可或限制的保证。这部分内容确保贡献者在提交贡献时承担相应的法律责任。"
            },
            {
                "content": "6. You are not expected to provide support for Your Contributions, except to the extent You desire to provide support. You may provide support for free, for a fee, or not at all. Unless required by applicable law or agreed to in writing, You provide Your Contributions on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON- INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE.\n6. 在您自愿提供支持的范围之外，您无需对您的贡献内容提供支持。您可以提供免费支持或收费支持，也可以完全不提供支持。除非适用法律另有规定或另有书面约定，您“按照现状”提供您的贡献内容，而不对其提供任何类型的保证或条件，无论明示还是默示，包括但不限于为任何特定目的对所有权、无侵权、适销性或适当性的保证或条件。\n\n该段落位于个人贡献者许可协议中的第6条，主要说明贡献者在提交贡献内容后无需提供支持的条件，并强调贡献内容以“现状”提供，不附带任何明示或默示的保证或条件。这条款意在明确贡献者的责任和权利。"
            },
            {
                "content": "7. Should You wish to submit work that is not Your original creation, You may submit it to Ant Group separately from any Contribution, identifying the complete details of its source and of any license or other restriction (including, but not limited to, related patents, trademarks, and license agreements) of which you are personally aware, and conspicuously marking the work as \"Submitted on behalf of a third-party: [named here]\".\n7. 如果您希望提交并非您原创的作品，您可以在任何贡献内容之外单独向蚂蚁集团提交，标注关于其来源和您个人所知悉的任何许可或其他限制（包括但不限于相关专利、商标和许可协议）的完整信息，并以显著方式标明该作品属于“以第三方名义提交：【填写姓名】”。\n\n8. You agree to notify Ant Group of any facts or circumstances of which you become aware that would make these representations inaccurate in any respect.\n8. 您同意在您获悉任何可能导致上述保证在任何方面不准确的事实或情况之时通知蚂蚁集团。\n\n该段落位于个人贡献者许可协议的第7和第8条中，主要规定了提交非原创作品的要求和义务，以及在发现提交内容不准确时需通知蚂蚁集团的责任。"
            },
            {
                "content": "8. You agree to notify Ant Group of any facts or circumstances of which you become aware that would make these representations inaccurate in any respect.\n8. 您同意在您获悉任何可能导致上述保证在任何方面不准确的事实或情况之时通知蚂蚁集团。\n\n9. This Agreement will be governed by and construed in accordance with the laws of the People's Republic of China excluding that body of laws known as conflict of laws.  The parties expressly agree that the United Nations Convention on Contracts for the International Sale of Goods will not apply.  Any legal action or proceeding arising under this Agreement will be brought exclusively in the courts located in Hangzhou, China, and the parties hereby irrevocably consent to the personal jurisdiction and venue therein.\n9. 本协议受中华人民共和国法律管辖，并依据其进行解释，但冲突法规则除外。协议各方明确同意排除《联合国国际货物销售合同公约》的适用。任何由本协议产生的法律诉讼或程序均应排他性地提交至中国杭州的法院进行审理，且各方在此不可撤销地同意该等关于属人管辖和法院地的安排。\n\n该段落位于《个人贡献者许可协议》的后半部分，主要涉及贡献者的义务和协议的法律适用条款。具体包括贡献者需通知蚂蚁集团关于其声明真实性的任何变化，以及本协议的法律适用和争议解决的地点。"
            },
            {
                "content": "10. For your reading convenience, this Agreement is written in parallel English and Chinese sections. To the extent there is a conflict between the English and Chinese sections, the English sections shall govern.\n10. 为了您的阅读方便，本协议同时提供了英文和中文段落。如果英文和中文段落有矛盾，则以英文段落为准。   \n\nPlease sign请签署: __________________________________ Date日期: ____________\n\nFull name全名: _____________________________________________________\n\nMailing Address信件地址: ________________________________________________\n\nTelephone电话: _____________________________________________________\n\nE-Mail电子邮箱:    ______________________________________________________\n\nSchedule A附录A:\n\nDescription of Initial Contribution:\n\n描述初始贡献内容：\n\n该段落位于个人贡献者许可协议的末尾部分，主要说明协议的语言版本及其优先顺序，并提供签署和联系方式的空白区域，供贡献者填写个人信息及提交初始贡献的描述。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_102.md",
        "chunks": [
            {
                "content": "# 什么是TuGraph\n\n> 本文主要介绍TuGraph社区版的主要功能和特性，以及TuGraph企业版和社区版的差异。\n\n## 1. 简介\n\nTuGraph图数据库由蚂蚁集团与清华大学联合研发，构建了一套包含图存储、图计算、图学习、图研发平台的完善的图技术体系，拥有业界领先规模的图集群，解决了图数据分析面临的大数据量、高吞吐率和低延迟等重大挑战，是蚂蚁集团金融风控能力的重要基础设施，显著提升了欺诈洗钱等金融风险的实时识别能力和审理分析效率，并面向金融、工业、政务服务等行业客户。\n\n## 2. TuGraph社区版\n\n2022年9月，TuGraph单机版开源，提供了完备的图数据库基础功能和成熟的产品设计，支持TB级别的数据规模，为用户管理和分析复杂关联数据提供了高效、易用、可靠的平台。\n\nTuGraph社区版于2022年9月开源，提供了完整的图数据库基础功能和成熟的产品设计（如ACID兼容的事务、编程API和配套工具等），适用于单实例部署。社区版支持TB级别的数据规模，为用户管理和分析复杂关联数据提供了高效、易用、可靠的平台，是学习TuGraph和实现小型项目的理想选择。\n\n## 3. TuGraph特性\n\nTuGraph是支持大数据量、低延迟查找和快速图分析功能的高效图数据库。TuGraph也是基于磁盘的数据库，支持存储多达数十TB的数据。TuGraph提供多种API，使用户能够轻松构建应用程序，并使其易于扩展和优化。\n\n它具有如下功能特征：\n\n- 属性图模型\n- 实时增删查改\n- 多重图（点间允许多重边）\n- 多图（大图与多个子图）\n- 完善的ACID事务处理，隔离级别为可串行化（serializable）\n- 点边索引\n- 混合事务和分析处理（HTAP），支持图查询、图分析、图学习\n- 主流图查询语言（OpenCypher、ISO GQL等）\n- 支持OLAP API，内置30多种图分析算法\n- 基于C++/Python的存储过程，含事务内并行Traversal API\n- 提供图可视化工具\n\n在性能和可扩展性方面的支持：\n\n- 千万点/秒的高吞吐率\n- TB级大容量\n- 高可用性支持\n- 高性能批量导入\n- 在线/离线的备份恢复\n\n## 4. TuGraph企业版\n\n该文档介绍了TuGraph图数据库的整体概念，包括其由蚂蚁集团与清华大学联合研发的背景以及主要功能和特性。文中详细描述了TuGraph的社区版和企业版之间的差异，强调社区版的开源特点和适用场景，同时列出了TuGraph的关键特性和性能优势，最后讨论了企业版的商业化功能支持。"
            },
            {
                "content": "## 3. TuGraph特性\n\nTuGraph是支持大数据量、低延迟查找和快速图分析功能的高效图数据库。TuGraph也是基于磁盘的数据库，支持存储多达数十TB的数据。TuGraph提供多种API，使用户能够轻松构建应用程序，并使其易于扩展和优化。\n\n它具有如下功能特征：\n\n- 属性图模型\n- 实时增删查改\n- 多重图（点间允许多重边）\n- 多图（大图与多个子图）\n- 完善的ACID事务处理，隔离级别为可串行化（serializable）\n- 点边索引\n- 混合事务和分析处理（HTAP），支持图查询、图分析、图学习\n- 主流图查询语言（OpenCypher、ISO GQL等）\n- 支持OLAP API，内置30多种图分析算法\n- 基于C++/Python的存储过程，含事务内并行Traversal API\n- 提供图可视化工具\n\n在性能和可扩展性方面的支持：\n\n- 千万点/秒的高吞吐率\n- TB级大容量\n- 高可用性支持\n- 高性能批量导入\n- 在线/离线的备份恢复\n\n## 4. TuGraph企业版\n\n企业版对商业化功能支持更加完善，包括分布式集群架构，覆盖探索、研发、服务、运维管理全生命周期的一站式图平台，在线、近线、离线的图计算引擎，支持流式、大数据类数据源，多地多中心的部署形态，以及专家支持服务等。企业版是商业化解决方案的理想选择。\n\n如需商业支持，请联系我们：\n\n- 电话：400-903-0809\n- 邮件：tugraph@service.alipay.com\n- 官网：https://tugraph.antgroup.com\n\n该内容块主要介绍了TuGraph图数据库的特性，包括其支持的功能、性能指标以及扩展性，作为信息连贯性的部分，位于TuGraph社区版和企业版介绍之间，旨在突出TuGraph的优势和应用场景。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_103.md",
        "chunks": [
            {
                "content": "# FAQ\n\n在 TuGraph 使用过程中，如果遇到问题可优先查看用户文档。其次，请查看如下 FAQ 列表是否能够匹配您的问题。\n\n## 内核引擎问题汇总\n\n### Q: TuGraph 的边是否支持索引？\nA: TuGraph 在引擎层支持边索引，可通过存储过程使用。Cypher的边索引功能正在开发支持中。\n\n### Q: TuGraph 单机的QPS是多少？\nA: 不同数据规模，不同查询操作的QPS差异较大，比如LDBC SNB典型图操作超过1.2万。\n\n\n## TuGraph Browser问题汇总\n\n### Q: 可视化文件 build 后如何更新到 tugraph 服务？\nA: 可视化文件打包后，需要进行以下操作进行替换。\n- 登录 tugraph 服务所在的服务或 docker 容器内。\n- 通过 `lgraph_server --help` 查看服务启动的配置文件所在目录。通常情况：`/usr/local/etc/lgraph.json`。\n- 查看 `/usr/local/etc/lgraph.json` 文件中 web 的配置目录。通常情况：`/usr/local/share/lgraph/resource`。\n- 将可视化打包后生成的文件夹中的内容全部替换到配置目录下 `/usr/local/share/lgraph/resource`。\n- 重新启动 tugraph 服务。\n\n### Q: 如何通过 npm run dev，连接已有的 tugraph 服务？\nA: 启动之前，需要修改文件 `.env.development` 中的 `VUE_APP_REQUESTURL` 的配置项。然后在通过 `npm run dev` 进行启动。\n示例：\n```\nNODE_ENV=development \nVUE_APP_TITLE=TuGraph(dev) \nVUE_APP_REQUESTURL=http://localhost:7070/\n```\n\n### Q: 3.3.0 版本 TuGraph Browser 删除 node label 失败？\nA: 可视化建模部分删除node label报错的问题，已经在https://github.com/TuGraph-db/tugraph-web/tree/v3.3.1仓库完成修复。\n\n\n## 客户端问题汇总\n\n该块内容为TuGraph的常见问题解答（FAQ）部分，涵盖了内核引擎、TuGraph Browser、客户端及相关问题，旨在帮助用户在使用TuGraph过程中快速找到解决方案。"
            },
            {
                "content": "### Q: 如何通过 npm run dev，连接已有的 tugraph 服务？\nA: 启动之前，需要修改文件 `.env.development` 中的 `VUE_APP_REQUESTURL` 的配置项。然后在通过 `npm run dev` 进行启动。\n示例：\n```\nNODE_ENV=development \nVUE_APP_TITLE=TuGraph(dev) \nVUE_APP_REQUESTURL=http://localhost:7070/\n```\n\n### Q: 3.3.0 版本 TuGraph Browser 删除 node label 失败？\nA: 可视化建模部分删除node label报错的问题，已经在https://github.com/TuGraph-db/tugraph-web/tree/v3.3.1仓库完成修复。\n\n\n## 客户端问题汇总\n\n### Q: client 目前有哪些编程语言，是否支持 node js？\nA: 目前主要支持的编程语言有 c++, python, java；目前不支持 node js。使用 node 作为主要开发语言的用户，可以使用 tugraph 提供的 restful api 来调用。建议使用 Cypher 来封装调用接口。后续版本 restful api 将不再进行更新维护，只会保留登录、登出、刷新 token、cypher 调用这几个常见的 api。\n\n### Q: python client 是否支持 pip install？client 在哪里进行引用？\nA: 目前 python client 不支持 pip 进行安装。client 在目录 https://github.com/TuGraph-db/tugraph-db/tree/master/src/client\n\n\n## 数据导入问题汇总\n\n### Q: TuGraph 可以对接哪些常用数据库？\nA: TuGraph通过DataX可以实现大部分主流数据库的导入导出，支持的数据库包括MySQL、Oracle、Hive 等。\n\n该块内容主要涵盖了 TuGraph Browser 和客户端相关的常见问题解答，包括如何连接已有服务、删除 node label 的问题、支持的编程语言以及 Python 客户端的安装和引用方式。同时，还涉及到 TuGraph 数据导入的数据库对接问题。这部分信息位于文档的中段，紧接着内核引擎和其他实用功能的问答。"
            },
            {
                "content": "## 客户端问题汇总\n\n### Q: client 目前有哪些编程语言，是否支持 node js？\nA: 目前主要支持的编程语言有 c++, python, java；目前不支持 node js。使用 node 作为主要开发语言的用户，可以使用 tugraph 提供的 restful api 来调用。建议使用 Cypher 来封装调用接口。后续版本 restful api 将不再进行更新维护，只会保留登录、登出、刷新 token、cypher 调用这几个常见的 api。\n\n### Q: python client 是否支持 pip install？client 在哪里进行引用？\nA: 目前 python client 不支持 pip 进行安装。client 在目录 https://github.com/TuGraph-db/tugraph-db/tree/master/src/client\n\n\n## 数据导入问题汇总\n\n### Q: TuGraph 可以对接哪些常用数据库？\nA: TuGraph通过DataX可以实现大部分主流数据库的导入导出，支持的数据库包括MySQL、Oracle、Hive 等。\n\n### Q：如何进行数据导入？\nA：可以使用lgraph_import批量导入工具将现有数据导入 TuGraph。lgraph_import支持从 CSV 文件和 JSON 数据源导入数据。TuGraph 支持两种导入模式：1、离线模式：读取数据并将其导入指定服务器的数据文件，应仅在服务器离线时完成。 2、在线模式：读取数据并将其发送到工作中的服务器，然后将数据导入其数据库。\n\n\n## 存储过程问题汇总\n\n### Q: 如何加载存储过程或算法包？\nA: 加载方式有两种：\n- 第一种：通过可视化页面的插件模块，通过交互操作完成加载。\n- 第二种：通过 cypher 语句实现存储过程的加载。\n```\nCALL db.plugin.loadPlugin(plugin_type::STRING, plugin_name::STRING, plugin_content::STRING, code_type::STRING, plugin_description::STRING, read_only::BOOLEAN) :: (::VOID)\n```\n\n该文档为 TuGraph 的常见问题解答 (FAQ)，分为多个主题，包括内核引擎、可视化工具、客户端、数据导入、存储过程、安装部署、Cypher 查询和 Jwt Token 等问题。其中“客户端问题汇总”部分主要针对 TuGraph 的客户端编程语言支持及安装方式进行解答，而“数据导入问题汇总”则涉及如何将数据导入 TuGraph 系统，以及支持的数据库类型等信息。紧接其后的是“存储过程问题汇总”，介绍如何加载和调用存储过程或算法包。"
            },
            {
                "content": "### Q：如何进行数据导入？\nA：可以使用lgraph_import批量导入工具将现有数据导入 TuGraph。lgraph_import支持从 CSV 文件和 JSON 数据源导入数据。TuGraph 支持两种导入模式：1、离线模式：读取数据并将其导入指定服务器的数据文件，应仅在服务器离线时完成。 2、在线模式：读取数据并将其发送到工作中的服务器，然后将数据导入其数据库。\n\n\n## 存储过程问题汇总\n\n### Q: 如何加载存储过程或算法包？\nA: 加载方式有两种：\n- 第一种：通过可视化页面的插件模块，通过交互操作完成加载。\n- 第二种：通过 cypher 语句实现存储过程的加载。\n```\nCALL db.plugin.loadPlugin(plugin_type::STRING, plugin_name::STRING, plugin_content::STRING, code_type::STRING, plugin_description::STRING, read_only::BOOLEAN) :: (::VOID)\n```\n\n### Q: 如何调用或执行存储过程？\nA: 可以使用 cypher 进行存储过程的执行或调用。\n```\nCALL db.plugin.callPlugin(plugin_type::STRING, plugin_name::STRING, param::STRING, timeout::DOUBLE, in_process::BOOLEAN) :: (success::BOOLEAN, result::STRING)\n```\n\n### Q: 开源内置的算法包在哪里？\nA: 算法包代码地址 https://github.com/TuGraph-db/tugraph-db/tree/master/plugins\n\n## 安装部署问题汇总\n\n该内容块位于文档的“数据导入问题汇总”部分，接着介绍了如何使用工具将数据导入TuGraph，同时后续部分涉及存储过程的加载与调用方法，涵盖了相关的操作细节和示例代码。"
            },
            {
                "content": "### Q: 如何调用或执行存储过程？\nA: 可以使用 cypher 进行存储过程的执行或调用。\n```\nCALL db.plugin.callPlugin(plugin_type::STRING, plugin_name::STRING, param::STRING, timeout::DOUBLE, in_process::BOOLEAN) :: (success::BOOLEAN, result::STRING)\n```\n\n### Q: 开源内置的算法包在哪里？\nA: 算法包代码地址 https://github.com/TuGraph-db/tugraph-db/tree/master/plugins\n\n## 安装部署问题汇总\n\n### Q: 如何使用 docker 镜像安装？\nA:\n- 确认本地是否有 docker 环境，可使用 `docker -v` 进行验证。如果没有请安装 docker，安装方式见 docker 官网文档 https://docs.docker.com/install/\n- 下载 docker 镜像，下载方式可使用 `docker pull tugraph/tugraph-runtime-centos7`，也可以在官网下载页面进行下载 https://www.tugraph.org/download [注：下载的文件是 *.tar.gz 的压缩包，不用解压]。\n- 如果使用 `docker pull` 下载的镜像则不用导入镜像。如果使用官网下载的压缩包，则要使用 `docker load -i ./tugraph_x.y.z.tar` [注：x.y.z 是版本号的代替符，具体数值根据自己下载的版本进行改写]。\n- 启动 docker 容器：\n```\ndocker run -d -p 7070:7070 -p 9090:9090 --name tugraph_demo tugraph/tugraph-runtime-centos7 lgraph_server\n```\n[注：具体的镜像名称 tugraph/tugraph-runtime-centos7 要以本地实际镜像名称为准，可用过 `docker images` 命令查看]。\n\n该块内容主要涉及 TuGraph 中存储过程的调用与执行，以及如何使用 Docker 镜像进行安装部署，是针对存储过程和安装部署相关问题的解答，属于文档中“存储过程问题汇总”和“安装部署问题汇总”的部分。"
            },
            {
                "content": "### Q: rpm 包和 deb 包安装后，启动 lgraph_server 服务。提示缺少 'liblgraph.so' 报错？\nA: 此问题主要是环境变量导致，需要配置环境变量。\n示例：\n```\nexport LD_LIBRARY_PATH=/usr/local/lib64\n```\n\n### Q: 如何在 Mac 的 M1 芯片上编译 TuGraph？\nA: 请参考 https://zhuanlan.zhihu.com/p/561139698 中的教程来在Mac 的 M1 芯片上编译 TuGraph。\n\n### Q: 安装报错 jemalloc: Unsupported system page size 该如何处理？\nA: \n1. 重新编译并重新安装 jemalloc 库。\n2. 使用新的 jemalloc 库重新构建 TuGraph 二进制文件:\n```\ncmake .. -DCMAKE_BUILD_TYPE=Release -DENABLE_BUILD_ON_AARCH64=ON\n```\n\n## Cypher问题汇总\n\n### Q: 是否支持不定长边的条件查询？\n示例：\n```\nMATCH p=(v)-[e:acted_in|:rate*1..3]-(v2) WHERE id(v) IN [3937] AND e.stars = 3 RETURN p\n```\nA: 目前还不支持不定长边的过滤查询。目前的代替方案只能是分开写。上面的示例，就需要从 1 跳到 3 跳都写一遍。\n\n### Q: 如何查询最短路径，shortestPath 函数如何使用？\nA: 使用示例如下（示例图谱：MovieDemo）\n```\nMATCH (n1 {name:'Corin Redgrave'}),(n2 {name:'Liam Neeson'})\nCALL algo.allShortestPaths(n1,n2) YIELD nodeIds,relationshipIds,cost\nRETURN nodeIds,relationshipIds,cost\n```\n详尽使用方案请参考官网文档。\n\n该块内容位于文档的“安装部署问题汇总”部分，主要讲述了在使用 rpm 和 deb 包安装后遇到的环境变量配置问题，以及在 Mac 的 M1 芯片上编译 TuGraph 的具体指导。同时，紧接着是关于 Cypher 查询语言的一些常见问题和示例，包括不定长边的条件查询、最短路径查询的使用方式等。"
            },
            {
                "content": "## Cypher问题汇总\n\n### Q: 是否支持不定长边的条件查询？\n示例：\n```\nMATCH p=(v)-[e:acted_in|:rate*1..3]-(v2) WHERE id(v) IN [3937] AND e.stars = 3 RETURN p\n```\nA: 目前还不支持不定长边的过滤查询。目前的代替方案只能是分开写。上面的示例，就需要从 1 跳到 3 跳都写一遍。\n\n### Q: 如何查询最短路径，shortestPath 函数如何使用？\nA: 使用示例如下（示例图谱：MovieDemo）\n```\nMATCH (n1 {name:'Corin Redgrave'}),(n2 {name:'Liam Neeson'})\nCALL algo.allShortestPaths(n1,n2) YIELD nodeIds,relationshipIds,cost\nRETURN nodeIds,relationshipIds,cost\n```\n详尽使用方案请参考官网文档。\n\n### Q: 查询语句 Where 后使用 and 进行拼接查询速度较慢，语句应如何优化改进？\n示例：\n```\nMATCH (n1),(n2) CALL algo.allShortestPaths(n1,n2)\nYIELD nodeIds,relationshipIds,cost\nWHERE id(n1) IN [0] AND id(n2) IN [3938]\nRETURN nodeIds,relationshipIds,cost\n```\nA: 目前 cypher 查询引擎正在优化中。现阶段语句改写可以通过 with 向下传递进行优化。\n示例：\n```\nMATCH (n1) WHERE id(n1) IN [0] WITH n1\nMATCH (n2) WHERE id(n2) IN [3938] WITH n1, n2\nCALL algo.allShortestPaths(n1,n2) YIELD nodeIds,relationshipIds,cost\nRETURN nodeIds,relationshipIds,cost\n```\n\n该块内容属于文档中的 \"Cypher问题汇总\" 部分，专门解答与 Cypher 查询语言相关的常见问题，包括不定长边的条件查询、最短路径查询的实现及优化建议等，为用户提供使用 Cypher 进行图查询时的指导和解决方案。"
            },
            {
                "content": "### Q: 查询语句 Where 后使用 and 进行拼接查询速度较慢，语句应如何优化改进？\n示例：\n```\nMATCH (n1),(n2) CALL algo.allShortestPaths(n1,n2)\nYIELD nodeIds,relationshipIds,cost\nWHERE id(n1) IN [0] AND id(n2) IN [3938]\nRETURN nodeIds,relationshipIds,cost\n```\nA: 目前 cypher 查询引擎正在优化中。现阶段语句改写可以通过 with 向下传递进行优化。\n示例：\n```\nMATCH (n1) WHERE id(n1) IN [0] WITH n1\nMATCH (n2) WHERE id(n2) IN [3938] WITH n1, n2\nCALL algo.allShortestPaths(n1,n2) YIELD nodeIds,relationshipIds,cost\nRETURN nodeIds,relationshipIds,cost\n```\n\n### Q: 如何查询任意跳的边？\nA: 使用 *..  \n示例：\n```\nMATCH p=(a)-[*..]-(b) WHERE id(a) IN [3] AND id(b) IN [19] RETURN p\n```\n\n### Q: Cypher 是否支持 date()函数？\nA: date()函数还没有实现，我们将在之后实现它。\n\n## Jwt Token问题汇总\n\n### Q: 报错“User has reached the maximum number of tokens”后该如何处理？\nA: 这表明当前账号 Token 数量已达上限 10000 个。解决方法如下，任选其一：\n1. 登出不使用的 Token。\n2. 重新启动 TuGraph 服务，会清空所有 Token。\n3. Token 有效期默认为 24 小时，24 小时后会自动失效并删除。\n\n\n\n## 如果问题仍然无法得到解决，我们推荐您在 https://github.com/TuGraph-family/tugraph-db/discussions 跟帖或发起新贴来描述您的问题。同时 TuGraph QA 大汇总也会根据大家在讨论区发起的帖子，进行定期的更新。\n\n该块内容位于文档的 Cypher 问题汇总部分，专注于 Cypher 查询语句的优化和功能支持，包括针对查询速度的优化建议及对特定函数的说明，同时也涉及 JWT Token 的使用限制及解决方案。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_104.md",
        "chunks": [
            {
                "content": "# 用户权限\n\n## 1.介绍\n\n> TuGraph 的权限是基于角色的访问控制进行管理，定义访问控制的权限分配给角色，角色再分配给用户。\n\n## 2.权限层级\n\n- Global 层：即全局权限，对管理、图操作均有权限；\n- Graph 层：即图级别，对每个图的权限；\n- （仅商业化版本支持）Property 层：即属性级别，对某个属性的权限控制\n\n## 3.权限关键字\n\n目前权限的控制较为简洁\n\n- Global 层目前为 admin 权限，并且预置了 admin 用户；\n\n* Graph 层的操作权限分为四种：none，read，write，full\n  - none：无权限，对于图没有任何操作权限\n  - read：只读权限，对于图只具备读取权限\n  - write：读写权限，对于图不仅具备读取权限，还具备了写入的权限\n  - full：所有权限，对于图不仅具备读写权限，同时也具备删除图、修改图、修改 Schema 等权限\n* （仅商业化版本支持）Property 层的权限分别为：none，read，write\n  - none：无权限，对于该属性没有任何操作权限\n  - read：只读权限，对于该属性只具备读取权限\n  - write：读写权限，对于该属性不仅具备读取权限，还具备了写入的权限\n\n## 4.常用权限操作\n\n### 4.1.用户操作\n\n- 创建用户\n\n```cypher\nCALL dbms.security.createUser(user_name::STRING,password::STRING)\n```\n\n- 删除用户\n\n```cypher\nCALL dbms.security.deleteUser(user_name::STRING)\n```\n\n- 修改当前用户密码\n\n```cypher\nCALL dbms.security.changePassword(current_password::STRING,new_password::STRING)\n```\n\n- 修改指定用户密码\n\n```cypher\n\nCALL dbms.security.changeUserPassword(user_name::STRING,new_password::STRING)\n```\n\n- 禁用/启用用户\n\n本段落介绍了TuGraph的用户权限管理，包括权限的介绍、层级、关键字及常用操作，主要集中在用户操作部分，例如创建、删除用户及密码修改等。"
            },
            {
                "content": "## 4.常用权限操作\n\n### 4.1.用户操作\n\n- 创建用户\n\n```cypher\nCALL dbms.security.createUser(user_name::STRING,password::STRING)\n```\n\n- 删除用户\n\n```cypher\nCALL dbms.security.deleteUser(user_name::STRING)\n```\n\n- 修改当前用户密码\n\n```cypher\nCALL dbms.security.changePassword(current_password::STRING,new_password::STRING)\n```\n\n- 修改指定用户密码\n\n```cypher\n\nCALL dbms.security.changeUserPassword(user_name::STRING,new_password::STRING)\n```\n\n- 禁用/启用用户\n\n```cypher\nCALL dbms.security.disableUser(user::STRING,disable::BOOLEAN)\n```\n\n- 列出所有用户\n\n```cypher\nCALL dbms.security.listUsers()\n```\n\n- 列出当前用户信息\n\n```cypher\nCALL dbms.security.showCurrentUser()\n```\n\n- 获取用户详情\n\n```cypher\nCALL dbms.security.getUserInfo(user::STRING)\n```\n\n### 4.2.角色操作\n\n- 创建角色\n\n```cypher\nCALL dbms.security.createRole(role_name::STRING,desc::STRING)\n```\n\n- 删除角色\n\n```cypher\nCALL dbms.security.deleteRole(role_name::STRING\n```\n\n- 列出所有角色\n\n```cypher\nCALL dbms.security.listRoles()\n```\n\n- 禁用/启用角色\n\n```cypher\nCALL dbms.security.disableRole(role::STRING,disable::BOOLEAN)\n```\n\n### 4.3.赋予用户角色\n\n- 新增用户与角色的联系\n\n该块内容位于文档的第4节，详述了TuGraph中常用的用户和角色权限操作，包括用户的创建、删除、密码修改及角色的创建、删除等操作，旨在指导用户如何管理系统中的权限和角色分配。"
            },
            {
                "content": "- 列出当前用户信息\n\n```cypher\nCALL dbms.security.showCurrentUser()\n```\n\n- 获取用户详情\n\n```cypher\nCALL dbms.security.getUserInfo(user::STRING)\n```\n\n### 4.2.角色操作\n\n- 创建角色\n\n```cypher\nCALL dbms.security.createRole(role_name::STRING,desc::STRING)\n```\n\n- 删除角色\n\n```cypher\nCALL dbms.security.deleteRole(role_name::STRING\n```\n\n- 列出所有角色\n\n```cypher\nCALL dbms.security.listRoles()\n```\n\n- 禁用/启用角色\n\n```cypher\nCALL dbms.security.disableRole(role::STRING,disable::BOOLEAN)\n```\n\n### 4.3.赋予用户角色\n\n- 新增用户与角色的联系\n\n```cypher\nCALL dbms.security.addUserRoles(user::STRING,roles::LIST)\n```\n\n- 删除用户与角色的联系\n\nCALL dbms.security.deleteUserRoles(user::STRING,roles::LIST)\n\n- 清空用户角色的关系并重建\n\n```cypher\nCALL dbms.security.rebuildUserRoles(user::STRING,roles::LIST)\n```\n\n### 4.4.角色赋权\n\n- 修改角色对指定图的访问权限\n\n```cypher\nCALL dbms.security.modRoleAccessLevel(role::STRING,access_level::MAP)\n```\n\n示例\n\n```cypher\nCALL dbms.security.modRoleAccessLevel(\"test_role\", {test_graph1:\"FULL\", test_graph2:\"NONE\"})\n```\n\n该片段主要涵盖了用户和角色的操作，包括如何列出当前用户信息、获取用户详情、创建和删除角色，以及赋予用户角色的相关操作。这些内容属于用户权限管理的常用操作部分，具体描述了如何在 TuGraph 中管理用户和角色的权限分配。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_105.md",
        "chunks": [
            {
                "content": "# File Connector介绍\nGeaFlow 支持从文件中读取数据，也支持向文件写入数据。\n## 语法\n\n```sql\nCREATE TABLE file_table (\n  id BIGINT,\n  name VARCHAR,\n  age INT\n) WITH (\n\ttype='file',\n    geaflow.dsl.file.path = '/path/to/file'\n)\n```\n## 参数\n\n| 参数名 | 是否必须 | 描述                           |\n| -------- |------|------------------------------|\n| geaflow.file.persistent.config.json     | 否    | JSON格式的DFS配置，会覆盖系统环境配置。      |\n| geaflow.dsl.file.path     | 是    | 读取或写入的文件或文件夹的路径              |\n| geaflow.dsl.column.separator     | 否    | 用于将文本分割为列的列分隔符。默认值为英文逗号','。  |\n| geaflow.dsl.line.separator     | 否    | 用于将文本分割为列的行分隔符。默认值为换行符'\\n'。  |\n| geaflow.dsl.file.name.regex    | 否    | 读取文件名称正则过滤规则，默认为空。           |\n| geaflow.dsl.file.format     | 否    | 读写文件格式，支持parquet、txt，默认为txt。 |\n表格内容描述: 该表格包含三个列名：参数名、是否必须和描述。\n\n该文档介绍了GeaFlow的文件连接器，包括如何从文件中读取数据和向文件写入数据的语法，重要参数及其描述，并提供了相应的示例代码。上述片段是文档的开头部分，详细列出了文件连接器的参数及其含义。"
            },
            {
                "content": "1. 第一行数据为“geaflow.file.persistent.config.json”，该参数为非必需项，其描述是：此参数为JSON格式的DFS配置，会覆盖系统环境配置。\n2. 第二行数据为“geaflow.dsl.file.path”，该参数为必需项，其描述是：读取或写入的文件或文件夹的路径。\n3. 第三行数据为“geaflow.dsl.column.separator”，该参数为非必需项，其描述是：用于将文本分割为列的列分隔符，默认值为英文逗号（','）。\n4. 第四行数据为“geaflow.dsl.line.separator”，该参数为非必需项，其描述是：用于将文本分割为行的行分隔符，默认值为换行符（'\\n'）。\n5. 第五行数据为“geaflow.dsl.file.name.regex”，该参数为非必需项，其描述是：读取文件名称的正则过滤规则，默认为空。\n6. 第六行数据为“geaflow.dsl.file.format”，该参数为非必需项，其描述是：读写文件格式，支持parquet和txt，默认为txt。\n\n总体而言，这个表格列出了与数据流处理有关的参数信息，其中包括必须和非必须的参数，以及它们的具体用途和默认值。\n\n## 示例\n\n```sql\nCREATE TABLE file_source (\n  id BIGINT,\n  name VARCHAR,\n  age INT\n) WITH (\n\ttype='file',\n    geaflow.dsl.file.path = '/path/to/file'\n);\n\nCREATE TABLE file_sink (\n  id BIGINT,\n  name VARCHAR,\n  age INT\n) WITH (\n\ttype='file',\n    geaflow.dsl.file.path = '/path/to/file'\n);\n\nINSERT INTO file_sink\nSELECT * FROM file_source;\n```\n\n该片段详细列出了GeaFlow文件连接器的参数信息，包括每个参数的名称、是否必需及其具体描述，旨在帮助用户理解如何配置和使用文件操作。之后还提供了创建文件源和文件接收器的SQL示例。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_106.md",
        "chunks": [
            {
                "content": "# 作业Dashboard监控\n## 简介\nGeaflow-dashboard为Geaflow提供作业级别的监控页面，可以轻松地通过dashboard查看作业的以下信息：\n* 作业的健康度（Container和Worker活跃度）\n* 作业的进度（Pipeline和Cycle信息）\n* 作业各个组件的实时日志\n* 作业各个组件的进程指标\n* 作业各个组件的火焰图\n* 作业各个组件的Thread Dump\n\n## 如何访问页面\n当作业运行在k8s集群中时，可以通过master的service对外暴露HTTP服务，直接通过service进行访问即可。\n在本地或开发环境，也可以直接通过kubectl port-forward指令来直接映射到master pod的端口。\n\n### 以minikube为例\n1. 将作业部署到minikube中。\n2. 打开minikube-dashboard，找到master的pod名称（或者在终端中输入以下命令获取）。\n```shell\nkubectl get pods\n```\n3. 打开终端，输入以下命令，即可将pod容器内的8090端口映射到localhost的本机8090端口。\n请将 **${your-master-pod-name}** 替换为你自己的pod名称\n```shell\nkubectl port-forward ${your-master-pod-name} 8090:8090\n```\n4. 打开浏览器，访问localhost:8090即可打开页面。\n\n## 功能介绍\n### Overview\nOverview页面会展示整个作业的健康状态。你可以在这里查看container和driver是否都在正常运行。\n\n除此之外，Overview页面也会展示作业的Pipeline列表。\n\n### Pipeline列表\n也可以通过侧边栏的Pipeline菜单进入页面。页面包括作业的每一项Pipeline的名称、开始时间和耗时。\n耗时为0表示该Pipeline已开始执行，但尚未完成。\n\n\n### Cycle列表\n点击Pipeline名称可以进入二级菜单，查看当前Pipeline下所有的Cycle列表的各项信息。\n\n\n### 作业组件详情\n可以查看作业的各个组件（包括master、driver、container）的各项信息。\n可以通过侧边栏的菜单进行访问。\n\n该chunk位于文档的开头部分，主要介绍了Geaflow-dashboard的监控功能、访问方法及功能概述，包括如何在Kubernetes集群中访问页面、Pipeline及Cycle的展示及作业组件的详细信息。这为用户提供了使用该监控工具的基础信息和使用指南。"
            },
            {
                "content": "## 功能介绍\n### Overview\nOverview页面会展示整个作业的健康状态。你可以在这里查看container和driver是否都在正常运行。\n\n除此之外，Overview页面也会展示作业的Pipeline列表。\n\n### Pipeline列表\n也可以通过侧边栏的Pipeline菜单进入页面。页面包括作业的每一项Pipeline的名称、开始时间和耗时。\n耗时为0表示该Pipeline已开始执行，但尚未完成。\n\n\n### Cycle列表\n点击Pipeline名称可以进入二级菜单，查看当前Pipeline下所有的Cycle列表的各项信息。\n\n\n### 作业组件详情\n可以查看作业的各个组件（包括master、driver、container）的各项信息。\n可以通过侧边栏的菜单进行访问。\n\n其中Driver详情展示所有driver的基础信息。Container详情展示所有Container的基础信息。\n\n\n### 组件运行时详情\n通过点击左边栏的Master详情，或者通过点击Driver/Container详情中的组件名称，可以跳转到组件的运行时页面。\n在运行时页面中，可以查看和操作以下内容。\n* 查看容器的进程指标\n* 查看实时的日志。这里以master为例介绍其中的日志文件。\n  * master.log：Master的java主进程日志。\n  * master.log.1 / master.log.2：Master的java主进程日志备份。\n  * agent.log：Master的agent服务日志。\n  * geaflow.log：进入容器后的shell启动脚本日志。\n* 对进程进行CPU/ALLOC分析，生成火焰图。火焰图分析类型可选择CPU或ALLOC，单次最多分析60秒，最多保留10份历史记录。\n* 对进程进行Thread Dump。保留最新一次dump的结果。\n* 查看进程的所有配置项（仅master拥有此页面）\n\n\n## 其他功能\n### 列表排序与查询\n部分列表的列可以进行排序和查询。\n\n查询时，点击“搜索”标识，输入关键字，点击“搜索”按钮即可。\n\n重置时，点击“重置”按钮，列表会重新刷新。\n\n### 本地化\n页面支持中英文切换，点击右上角的“文A”图标，即可选择语言。\n\n该片段位于作业Dashboard监控文档中的功能介绍部分，详细描述了Dashboard的不同功能模块，包括Overview、Pipeline列表、Cycle列表以及作业组件和组件运行时的详情。这部分内容为用户提供了使用Dashboard进行作业监控的具体操作和功能描述。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_107.md",
        "chunks": [
            {
                "content": "# Console Connector介绍\n\n## 语法\n\n```sql\nCREATE TABLE console_table (\n  id BIGINT,\n  name VARCHAR,\n  age INT\n) WITH (\n\ttype='console',\n    geaflow.dsl.console.skip = true\n)\n```\n## 参数\n\n| 参数名 | 是否必须 | 描述                     |\n| -------- | -------- |------------------------|\n| geaflow.dsl.console.skip     | 否     | 是否跳过日志，即无任何输出，默认为false |\n表格内容描述: 本表格包含三列，分别为“参数名”、“是否必须”和“描述”。 \n\n第一行数据描述为：参数名为“geaflow.dsl.console.skip”，其“是否必须”的值为“否”，表示该参数不是必须的。描述部分指出该参数用于控制是否跳过日志输出，默认值为false，即默认情况下会输出日志。\n\n整体而言，此表格提供了关于“geaflow.dsl.console.skip”参数的基本信息，说明该参数可选，且其默认行为为记录日志。\n\n## 示例\n\n```sql\nCREATE TABLE file_source (\n  id BIGINT,\n  name VARCHAR,\n  age INT\n) WITH (\n\ttype='file',\n    geaflow.dsl.file.path = '/path/to/file'\n);\n\nCREATE TABLE console_sink (\n  id BIGINT,\n  name VARCHAR,\n  age INT\n) WITH (\n\ttype='console'\n);\n\nINSERT INTO console_sink\nSELECT * FROM file_source;\n```\n\n该片段介绍了Console Connector的语法和参数设置，重点说明了如何创建控制台表及其可选参数“geaflow.dsl.console.skip”，并提供了相关示例，展示如何将文件源数据插入到控制台接收器中。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_108.md",
        "chunks": [
            {
                "content": "# With \n## Syntax\nWith语句用于指定图计算的起点和相关参数集合，一般和Match语句配合使用，指定Match语句的起始点。\n```sql\nWITH Identifier AS '(' SubQuery ')'\n```\n\n## Example\n\n```sql\nSELECT\n\ta_id,\n\tb_id,\n\tweight\nFROM (\n  WITH p AS (\n    SELECT * FROM (VALUES(1, 0.4), (4, 0.5)) AS t(id, weight)\n  )\n  MATCH (a:person where a.id = p.id) -[e where weight > p.weight + 0.1]->(b)\n  RETURN a.id as a_id, e.weight as weight, b.id as b_id\n);\n\n\n```\n\n该文档主要介绍了图计算中的SQL语法，重点在于如何使用With语句配合Match语句来指定计算起点和参数设置，通过示例展示了其实际应用。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_109.md",
        "chunks": [
            {
                "content": "# C++客户端\n\n> 此文档主要是TuGraph C++ SDK的使用说明。\n\n## 1.概述\nC++ Client 能够使用 RPC 连接lgraph_server，进行数据导入、执行存储过程、调用Cypher等操作。\n\n## 2.使用示例\n\n### 2.1.实例化client对象\n引入依赖并实例化\n\n#### 2.1.1.实例化单节点client对象\n当以单节点模式启动server时，client按照如下格式进行实例化\n``` C++\nRpcClient client(\"127.0.0.1:19099\", \"admin\", \"73@TuGraph\");\n```\n```\nRpcClient(const std::string& url, const std::string& user, const std::string& password);\n@param url: tugraph host looks like ip:port\n@param user: login user name\n@param password: login password\n```\n\n#### 2.1.2.实例化HA集群直接连接client对象\n当服务器上部署的HA集群可以使用ha_conf中配置的网址直接连接时，client按照如下格式进行实例化\n``` C++\nRpcClient client(\"127.0.0.1:19099\", \"admin\", \"73@TuGraph\");\n```\n```\nRpcClient(const std::string& url, const std::string& user, const std::string& password);\n@param url: tugraph host looks like ip:port\n@param user: login user name \n@param password: login password\n```\n用户只需要传入HA集群中的任意一个节点的url即可，client会根据server端返回的查询信息自动维护连接池，在HA集群横向扩容时\n也不需要手动重启client。\n\n此文档是关于TuGraph C++ SDK的使用说明，主要介绍了如何通过C++ Client与lgraph_server进行连接和操作。该段落详细说明了如何实例化客户端对象，包括单节点、HA集群直接连接和间接连接的方式，为后续的Cypher调用、存储过程执行等操作奠定基础。"
            },
            {
                "content": "#### 2.1.2.实例化HA集群直接连接client对象\n当服务器上部署的HA集群可以使用ha_conf中配置的网址直接连接时，client按照如下格式进行实例化\n``` C++\nRpcClient client(\"127.0.0.1:19099\", \"admin\", \"73@TuGraph\");\n```\n```\nRpcClient(const std::string& url, const std::string& user, const std::string& password);\n@param url: tugraph host looks like ip:port\n@param user: login user name \n@param password: login password\n```\n用户只需要传入HA集群中的任意一个节点的url即可，client会根据server端返回的查询信息自动维护连接池，在HA集群横向扩容时\n也不需要手动重启client。\n\n#### 2.1.3.实例化HA集群间接连接client对象\n当服务器上部署的HA集群不能使用ha_conf中配置的网址直接连接而必须使用间接网址（如阿里云公网网址）连接时，\nclient按照如下格式进行实例化。\n```java\nstd::vector urls = {\"189.33.97.23:9091\", \"189.33.97.24:9091\", \"189.33.97.25:9091\"};\nTuGraphDbRpcClient client = new TuGraphDbRpcClient(urls, \"admin\", \"73@TuGraph\");\n```\n```\nRpcClient(std::vector& urls, std::string user, std::string password)\n@param urls: tugraph host list\n@param user: login user name\n@param password: login password\n```\n因为用户连接的网址和server启动时配置的信息不同，不能通过向集群发请求的方式自动更新client连接池，所以需要在启动\nclient时手动传入所有集群中节点的网址，并在集群节点变更时手动重启client。\n\n该文档介绍了TuGraph C++ SDK的使用说明，其中第2.1节专门说明如何实例化C++客户端对象，涵盖了单节点、HA集群直接连接和HA集群间接连接的不同情况。该chunk位于2.1节的中间部分，具体描述了HA集群直接连接和间接连接client对象的实例化方法及其要求。"
            },
            {
                "content": "### 2.2.调用cypher\n```C++\n    std::string str;\n    bool ret = client.CallCypher(str,\n        \"CALL db.createVertexLabel('actor', 'name', 'name', string, false, 'age', int8, true)\");\n\n```\n```\n    bool CallCypher(std::string& result, const std::string& cypher,\n                    const std::string& graph = \"default\", bool json_format = true,\n                    double timeout = 0, const std::string& url = \"\");\n    @param [out] result      The result.\n    @param [in]  cypher      inquire statement.\n    @param [in]  graph       (Optional) the graph to query.\n    @param [in]  json_format (Optional) Returns the format， true is json，Otherwise, binary\n                             format.\n    @param [in]  timeout     (Optional) Maximum execution time, overruns will be interrupted.\n    @param [in]  url         (Optional) Node address of calling cypher.\n    @returns True if it succeeds, false if it fails.\n```\n本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。\n\n本段落是关于在TuGraph C++ SDK中调用Cypher的具体接口和用法说明，属于文档的操作示例部分，详细介绍了如何使用client对象执行Cypher查询，以及相关参数的定义和功能。"
            },
            {
                "content": "### 2.3.向leader发送cypher请求\n```C++\n    std::string str;\n    bool ret = client.CallCypherToLeader(str,\n        \"CALL db.createVertexLabel('actor', 'name', 'name', string, false, 'age', int8, true)\");\n```\n```\n    bool CallCypherToLeader(std::string& result, const std::string& cypher,\n                    const std::string& graph = \"default\", bool json_format = true,\n                    double timeout = 0);\n    @param [out] result      The result.\n    @param [in]  cypher      inquire statement.\n    @param [in]  graph       (Optional) the graph to query.\n    @param [in]  json_format (Optional) Returns the format， true is json，Otherwise, binary\n                             format.\n    @param [in]  timeout     (Optional) Maximum execution time, overruns will be interrupted.\n    @returns True if it succeeds, false if it fails.\n```\n本接口只支持在HA模式下使用，在HA模式下的client中，为防止向未同步数据的follower发送请求，\n用户可以直接向leader发送请求，leader由集群选出。\n\n该文档是关于TuGraph C++ SDK的使用说明，其中详细介绍了如何通过C++客户端进行RPC连接和各种操作。在第2.3节，文中说明了如何向HA模式下的leader节点发送Cypher请求，以确保请求数据的同步性，这是使用存储过程和调用Cypher语句的重要操作之一。"
            },
            {
                "content": "### 2.4.调用GQL\n```C++\n    std::string str;\n    bool ret = client.CallGql(str,\n        \"CALL db.createVertexLabel('actor', 'name', 'name', string, false, 'age', int8, true)\");\n```\n```\n    bool CallGql(std::string& result, const std::string& gql,\n                    const std::string& graph = \"default\", bool json_format = true,\n                    double timeout = 0, const std::string& url = \"\");\n    @param [out] result      The result.\n    @param [in]  gql         inquire statement.\n    @param [in]  graph       (Optional) the graph to query.\n    @param [in]  json_format (Optional) Returns the format， true is json，Otherwise, binary\n                             format.\n    @param [in]  timeout     (Optional) Maximum execution time, overruns will be interrupted.\n    @param [in]  url         (Optional) Node address of calling gql.\n    @returns True if it succeeds, false if it fails.\n```\n本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。\n\n在文档的第2部分中，详细说明了TuGraph C++ SDK的各种功能和方法。其中，2.4节专门介绍了如何使用C++客户端调用GQL（图查询语言），提供了示例代码及相关方法的参数说明，适用于单机模式和HA模式下的操作。此节旨在帮助用户理解和使用GQL与图数据库交互的方式。"
            },
            {
                "content": "### 2.5.向leader发送GQL请求\n```C++\n    std::string str;\n    bool ret = client.CallGqlToLeader(str,\n        \"CALL db.createVertexLabel('actor', 'name', 'name', string, false, 'age', int8, true)\");\n```\n```\n    bool CallGqlToLeader(std::string& result, const std::string& gql,\n                 const std::string& graph = \"default\", bool json_format = true,\n                 double timeout = 0);\n    @param [out] result      The result.\n    @param [in]  gql         inquire statement.\n    @param [in]  graph       (Optional) the graph to query.\n    @param [in]  json_format (Optional) Returns the format， true is json，Otherwise, binary\n                             format.\n    @param [in]  timeout     (Optional) Maximum execution time, overruns will be interrupted.\n    @returns True if it succeeds, false if it fails.\n```\n本接口只支持在HA模式下使用，在HA模式下的client中，为防止向未同步数据的follower发送请求，\n用户可以直接向leader发送请求，leader由集群选出。\n\n该段落位于文档的“使用示例”部分，主要介绍如何在HA模式下通过C++客户端向leader节点发送GQL请求。它详细说明了调用该接口的代码示例、参数说明以及使用场景，强调了该接口的特定用途和需求。"
            },
            {
                "content": "### 2.6.调用存储过程\n```C++\n    std::string str;\n    bool ret = client.CallProcedure(str, \"CPP\", \"test_plugin1\", \"bcefg\");\n```\n```\n    bool CallProcedure(std::string& result, const std::string& procedure_type,\n                       const std::string& procedure_name, const std::string& param,\n                       double procedure_time_out = 0.0, bool in_process = false,\n                       const std::string& graph = \"default\", bool json_format = true,\n                       const std::string& url = \"\");\n    @param [out] result              The result.\n    @param [in]  procedure_type      the procedure type, currently supported CPP and PY.\n    @param [in]  procedure_name      procedure name.\n    @param [in]  param               the execution parameters.\n    @param [in]  procedure_time_out  (Optional) Maximum execution time, overruns will be\n                                     interrupted.\n    @param [in]  in_process          (Optional) support in future.\n\n此文档是关于TuGraph C++ SDK的使用说明，主要介绍了如何通过C++客户端连接lgraph_server并执行各种操作。在第2.6节中，详细说明了如何调用存储过程，包括相关的代码示例和函数参数说明。这一节是文档中关于调用存储过程功能的具体实现部分。"
            },
            {
                "content": "@param [out] result              The result.\n    @param [in]  procedure_type      the procedure type, currently supported CPP and PY.\n    @param [in]  procedure_name      procedure name.\n    @param [in]  param               the execution parameters.\n    @param [in]  procedure_time_out  (Optional) Maximum execution time, overruns will be\n                                     interrupted.\n    @param [in]  in_process          (Optional) support in future.\n    @param [in]  graph               (Optional) the graph to query.\n    @param [in]  json_format         (Optional) Returns the format， true is json，Otherwise,\n                                     binary format.\n    @param [in]  url                 (Optional) Node address of calling procedure.\n    @returns True if it succeeds, false if it fails.\n```\n本接口支持在单机模式和HA模式下使用，默认以json格式直接返回存储过程的执行结果，指定jsonFormat为false可以返回字符串格式的执行结果。\n其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。\n\n该段落位于文档的“2.6.调用存储过程”小节，详细描述了调用存储过程接口的参数说明，包括返回结果、参数类型、执行超时设置及图数据库查询等选项，并说明该接口支持单机模式和HA模式的使用情况。"
            },
            {
                "content": "### 2.7.向leader调用存储过程\n```C++\n    std::string str;\n    bool ret = client.CallProcedureToLeader(str, \"CPP\", \"test_plugin1\", \"bcefg\");\n```\n```\n    bool CallProcedureToLeader(std::string& result, const std::string& procedure_type,\n                       const std::string& procedure_name, const std::string& param,\n                       double procedure_time_out = 0.0, bool in_process = false,\n                       const std::string& graph = \"default\", bool json_format = true);\n    @param [out] result              The result.\n    @param [in]  procedure_type      the procedure type, currently supported CPP and PY.\n    @param [in]  procedure_name      procedure name.\n    @param [in]  param               the execution parameters.\n    @param [in]  procedure_time_out  (Optional) Maximum execution time, overruns will be\n                                     interrupted.\n    @param [in]  in_process          (Optional) support in future.\n    @param [in]  graph               (Optional) the graph to query.\n\n在文档的第二部分中，介绍了C++客户端的各种功能和使用方法。具体来说，2.7节专注于如何向HA集群中的leader节点调用存储过程，以确保请求仅发送到已同步数据的节点。这一节提供了相关代码示例和函数说明，帮助用户了解如何正确使用该接口。"
            },
            {
                "content": "@param [in]  procedure_type      the procedure type, currently supported CPP and PY.\n    @param [in]  procedure_name      procedure name.\n    @param [in]  param               the execution parameters.\n    @param [in]  procedure_time_out  (Optional) Maximum execution time, overruns will be\n                                     interrupted.\n    @param [in]  in_process          (Optional) support in future.\n    @param [in]  graph               (Optional) the graph to query.\n    @param [in]  json_format         (Optional) Returns the format， true is json，Otherwise,\n                                     binary format.\n    @returns True if it succeeds, false if it fails.\n```\n本接口支持在HA模式下使用，默认以json格式直接返回存储过程的执行结果，指定jsonFormat为false可以返回字符串格式的执行结果。\n\n该段落位于文档的第2.6节，描述了调用存储过程的接口参数及其功能。它详细列出了调用存储过程时需要传入的参数，包括程序类型、程序名称和执行参数等。此外，文中强调了该接口在HA模式下的使用特点和返回格式。"
            },
            {
                "content": "### 2.8.加载存储过程\n```C++\n    std::string str;\n    bool ret = client.LoadProcedure(str, code_sleep, \"PY\", \"python_plugin1\", \"PY\", \"this is a test plugin\", true)\n```\n```\n    bool LoadProcedure(std::string& result, const std::string& source_file,\n                       const std::string& procedure_type, const std::string& procedure_name,\n                       const std::string& code_type, const std::string& procedure_description,\n                       bool read_only, const std::string& version = \"v1\",\n                       const std::string& graph = \"default\");\n    @param [out] result                  The result.\n    @param [in]  source_file             the source_file contain procedure code.\n    @param [in]  procedure_type          the procedure type, currently supported CPP and PY.\n    @param [in]  procedure_name          procedure name.\n    @param [in]  code_type               code type, currently supported PY, SO, CPP, ZIP.\n    @param [in]  procedure_description   procedure description.\n\n在文档的第二部分中，介绍了如何使用TuGraph C++ SDK进行各种操作。其中，第2.8节专门讲述了如何加载存储过程，包括相关的函数调用示例及其参数说明，适用于在单机模式和HA模式下的使用。此节强调了存储过程的类型、代码格式以及加载过程中的参数设定。"
            },
            {
                "content": "const std::string& graph = \"default\");\n    @param [out] result                  The result.\n    @param [in]  source_file             the source_file contain procedure code.\n    @param [in]  procedure_type          the procedure type, currently supported CPP and PY.\n    @param [in]  procedure_name          procedure name.\n    @param [in]  code_type               code type, currently supported PY, SO, CPP, ZIP.\n    @param [in]  procedure_description   procedure description.\n    @param [in]  read_only               procedure is read only or not.\n    @param [in]  version                 (Optional) the version of procedure.\n    @param [in]  graph                   (Optional) the graph to query.\n    @returns True if it succeeds, false if it fails.\n```\n本接口支持在单机模式和HA模式下使用。其中，由于加载存储过程是写请求，HA模式下的client只能向leader发送加载存储过程请求。\n\n此代码块位于文档的第2.8节中，讨论如何在TuGraph C++ SDK中加载存储过程。该部分提供了`LoadProcedure`函数的详细参数说明及其使用场景，强调在HA模式下只能向leader节点发送请求。"
            },
            {
                "content": "### 2.9.列举存储过程\n```C++\n    std::string str;\n    bool ret = client.ListProcedures(str);\n```\n```\n    bool ListProcedures(std::string& result, const std::string& procedure_type,\n                        const std::string& version = \"any\",\n                        const std::string& graph = \"default\", const std::string& url = \"\");\n    @param [out] result          The result.\n    @param [in]  procedure_type  (Optional) the procedure type, \"\" for all procedures,\n                                 CPP and PY for special type.\n    @param [in]  version         (Optional) the version of procedure.\n    @param [in]  graph           (Optional) the graph to query.\n    @param [in]  url             Node address of calling procedure.\n    @returns True if it succeeds, false if it fails.\n```\n本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送请求。\n\n该文档主要介绍TuGraph C++ SDK的使用，包含如何实例化客户端对象、调用Cypher和GQL、执行存储过程等功能。在此背景下，2.9节专门讲解了如何列举存储过程，包括相关的函数定义和参数说明，适用于单机模式与HA模式下的客户端使用。"
            },
            {
                "content": "### 2.10.删除存储过程\n```C++\n    std::string str;\n    bool ret = client.DeleteProcedure(str, \"CPP\", \"test_plugin1\");\n```\n```\n    bool DeleteProcedure(std::string& result, const std::string& procedure_type,\n                         const std::string& procedure_name, const std::string& graph = \"default\");\n    @param [out] result              The result.\n    @param [in]  procedure_type      the procedure type, currently supported CPP and PY.\n    @param [in]  procedure_name      procedure name.\n    @param [in]  graph               (Optional) the graph to query.\n    @returns True if it succeeds, false if it fails.\n```\n本接口支持在单机模式和HA模式下使用。其中，由于删除存储过程是写请求，HA模式下的client只能向leader发送删除存储过程请求。\n\n该章节为文档的第2.10节，介绍了如何在TuGraph C++ SDK中删除存储过程的接口和使用示例，适用于单机模式和HA模式，并强调在HA模式下只能向leader发送请求。此部分位于存储过程相关功能的描述中，紧接着列举存储过程和加载存储过程接口。"
            },
            {
                "content": "### 2.11.从字节流中导入schema\n```C++\n    std::string str;\n    bool ret = client.ImportSchemaFromContent(str, sImportContent[\"schema\"]);\n```\n```\n    bool ImportSchemaFromContent(std::string& result, const std::string& schema,\n                                 const std::string& graph = \"default\", bool json_format = true,\n                                 double timeout = 0);\n    @param [out] result      The result.\n    @param [in]  schema      the schema to be imported.\n    @param [in]  graph       (Optional) the graph to query.\n    @param [in]  json_format (Optional) Returns the format， true is json，Otherwise, binary\n                             format.\n    @param [in]  timeout     (Optional) Maximum execution time, overruns will be interrupted.\n    @returns True if it succeeds, false if it fails.\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入schema是写请求，HA模式下的client只能向leader发送导入schema请求。\n\n该文档是TuGraph C++ SDK的使用说明，主要介绍如何通过C++客户端与lgraph_server进行交互，包括连接配置、Cypher和GQL的调用、存储过程的管理以及数据导入等功能。第2.11节详细描述了如何通过字节流导入schema，并指出该操作在HA模式下的特定要求。"
            },
            {
                "content": "### 2.12.从字节流中导入点边数据\n```C++\n    std::string str;\n    ret = client.ImportDataFromContent(str, sImportContent[\"person_desc\"], sImportContent[\"person\"],\",\");\n```\n```\n    bool ImportDataFromContent(std::string& result, const std::string& desc,\n                               const std::string& data, const std::string& delimiter,\n                               bool continue_on_error = false, int thread_nums = 8,\n                               const std::string& graph = \"default\", bool json_format = true,\n                               double timeout = 0);\n    @param [out] result              The result.\n    @param [in]  desc                data format description.\n    @param [in]  data                the data to be imported.\n    @param [in]  delimiter           data separator.\n    @param [in]  continue_on_error   (Optional) whether to continue when importing data fails.\n    @param [in]  thread_nums         (Optional) maximum number of threads.\n    @param [in]  graph               (Optional) the graph to query.\n\n在文档中，第二部分提供了TuGraph C++ SDK的使用示例，具体描述了如何通过C++客户端进行各种操作，包括数据导入、存储过程调用和Cypher语句执行。第2.12节专注于如何从字节流中导入点边数据，详细介绍了相关的接口及其参数配置。"
            },
            {
                "content": "@param [out] result              The result.\n    @param [in]  desc                data format description.\n    @param [in]  data                the data to be imported.\n    @param [in]  delimiter           data separator.\n    @param [in]  continue_on_error   (Optional) whether to continue when importing data fails.\n    @param [in]  thread_nums         (Optional) maximum number of threads.\n    @param [in]  graph               (Optional) the graph to query.\n    @param [in]  json_format         (Optional) Returns the format， true is json，Otherwise,\n                                     binary format.\n    @param [in]  timeout             (Optional) Maximum execution time, overruns will be\n                                     interrupted.\n    @returns True if it succeeds, false if it fails.\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入点边数据是写请求，HA模式下的client只能向leader发送导入点边数据请求。\n\n该块内容位于文档的\"2.12. 从字节流中导入点边数据\"部分，描述了导入点边数据的方法参数及其含义，包括输入输出参数、可选参数及其功能，强调该接口在单机模式和HA模式下的使用限制。"
            },
            {
                "content": "### 2.13.从文件中导入schema\n```C++\n    std::string conf_file(\"./yago.conf\");\n    std::string str;\n    ret = client.ImportSchemaFromFile(str, conf_file);\n```\n```\n    bool ImportSchemaFromFile(std::string& result, const std::string& schema_file,\n                              const std::string& graph = \"default\", bool json_format = true,\n                              double timeout = 0);\n    @param [out] result      The result.\n    @param [in]  schema_file the schema_file contain schema.\n    @param [in]  graph       (Optional) the graph to query.\n    @param [in]  json_format (Optional) Returns the format， true is json，Otherwise, binary\n                             format.\n    @param [in]  timeout     (Optional) Maximum execution time, overruns will be interrupted.\n    @returns True if it succeeds, false if it fails.\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入schema是写请求，HA模式下的client只能向leader发送导入schema请求。\n\n该段落介绍了C++客户端在TuGraph中如何从文件导入schema的功能，包含示例代码及相关函数的详细说明。此功能是数据导入部分的子章节，属于文档中的操作指南，适用于单机模式和HA模式，强调在HA模式下需向leader发送请求的重要性。"
            },
            {
                "content": "### 2.14.从文件中导入点边数据\n```C++\n    std::string conf_file(\"./yago.conf\");\n    std::string str;\n    ret = client.ImportDataFromFile(str, conf_file, \",\");\n```\n```\n    bool ImportDataFromFile(std::string& result, const std::string& conf_file,\n                            const std::string& delimiter, bool continue_on_error = false,\n                            int thread_nums = 8, int skip_packages = 0,\n                            const std::string& graph = \"default\", bool json_format = true,\n                            double timeout = 0);\n    @param [out] result              The result.\n    @param [in]  conf_file           data file contain format description and data.\n    @param [in]  delimiter           data separator.\n    @param [in]  continue_on_error   (Optional) whether to continue when importing data fails.\n    @param [in]  thread_nums         (Optional) maximum number of threads.\n    @param [in]  skip_packages       (Optional) skip packages number.\n\n在文档的第2部分中，提供了TuGraph C++ SDK的各种操作示例。其中，2.14节详细介绍了如何从文件中导入点边数据。这部分包含代码示例及相关函数的参数说明，适用于用户在单机模式和HA模式下进行数据导入时的操作指导。"
            },
            {
                "content": "double timeout = 0);\n    @param [out] result              The result.\n    @param [in]  conf_file           data file contain format description and data.\n    @param [in]  delimiter           data separator.\n    @param [in]  continue_on_error   (Optional) whether to continue when importing data fails.\n    @param [in]  thread_nums         (Optional) maximum number of threads.\n    @param [in]  skip_packages       (Optional) skip packages number.\n    @param [in]  graph               (Optional) the graph to query.\n    @param [in]  json_format         (Optional) Returns the format， true is json，Otherwise,\n                                     binary format.\n    @param [in]  timeout             (Optional) Maximum execution time, overruns will be\n                                     interrupted.\n    @returns True if it succeeds, false if it fails.\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入点边数据是写请求，HA模式下的client只能向leader发送导入点边数据请求。\n\n该内容片段位于文档的第2.14节，主要描述了通过文件导入点边数据的接口函数和参数说明，强调了该接口在单机模式和HA模式下的使用情况，特别指出在HA模式下请求只能发送给leader节点。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_110.md",
        "chunks": [
            {
                "content": "# 云部署（基于阿里云计算巢快速部署TuGraph）\n\n> 此文档主要介绍 TuGraph 的云部署，也可参见阿里云计算巢部署文档(https://aliyun-computenest.github.io/quickstart-tugraph/)。\n\n## 1.简介\n\nTuGraph（tugraph.antgroup.com）是蚂蚁集团研发的高性能图数据库（Graph Database）。TuGraph在计算巢上提供了社区版服务，您无需自行购置云主机，即可在计算巢上快速部署TuGraph服务、实现运维监控，从而搭建您自己的图应用。本文向您介绍如何开通计算巢上的TuGraph社区版服务，以及部署流程和使用说明。\n\n## 2.实例说明\n\nTuGraph部署的为社区开源版本，源码参考Github Repo，目前可以选择的实例规格如下：\n\n| 规格族         | vCPU与内存                 | 系统盘              | 公网带宽      |\n|----------------|-------------------------|-------------------|-----------|\n| ecs.r7a.xlarge | AMD 内存型 r7a，4vCPU 32GiB | ESSD云盘 200GiB PL0 | 固定带宽1Mbps |\n| ecs.r6.xlarge  | 内存型r6，4vCPU 32GiB       | ESSD云盘 200GiB PL0 | 固定带宽1Mbps |\n表格内容描述: \n该表格包含四列，分别为“规格族”、“vCPU与内存”、“系统盘”和“公网带宽”。\n\n第一行数据为“ecs.r7a.xlarge”，其配置为使用AMD内存型r7a，配备4个vCPU和32GiB内存，系统盘为200GiB的ESSD云盘，带宽为固定1Mbps。\n\n第二行数据为“ecs.r6.xlarge”，该配置为内存型r6，含4个vCPU和32GiB内存，系统盘同样为200GiB的ESSD云盘，带宽也为固定1Mbps。\n\n概要总结: \n该表格列出了两种云服务器规格，均配备4个vCPU、32GiB内存及200GiB的ESSD云盘，且公网带宽均为固定的1Mbps。虽然两种规格在处理器和型号上有所不同，但其他基本配置保持一致。\n\n该文档主要介绍了在阿里云计算巢上快速部署TuGraph图数据库的流程与注意事项，其中包括对TuGraph的基本介绍、可选择的实例规格、部署前的准备工作及具体部署步骤等内容。所提供的实例说明部分详述了可用的云服务器规格，包括vCPU、内存、系统盘和带宽，旨在帮助用户选择合适的资源进行部署。"
            },
            {
                "content": "第一行数据为“ecs.r7a.xlarge”，其配置为使用AMD内存型r7a，配备4个vCPU和32GiB内存，系统盘为200GiB的ESSD云盘，带宽为固定1Mbps。\n\n第二行数据为“ecs.r6.xlarge”，该配置为内存型r6，含4个vCPU和32GiB内存，系统盘同样为200GiB的ESSD云盘，带宽也为固定1Mbps。\n\n概要总结: \n该表格列出了两种云服务器规格，均配备4个vCPU、32GiB内存及200GiB的ESSD云盘，且公网带宽均为固定的1Mbps。虽然两种规格在处理器和型号上有所不同，但其他基本配置保持一致。\n\n预估费用在创建实例时可实时看到（目前为免费）。 如需更多规格、其他服务（如集群高可用性要求、企业级支持服务等），请联系我们 tugraph@service.alipay.com。\n\n## 3.部署流程\n\n### 3.1.准备工作\n\n在正式开始使用前，您需要一个阿里云账号，对ECS、VPC等资源进行访问和创建操作。\n\n- 若您使用个人账号，可以直接创建服务实例\n- 若您使用RAM用户创建服务实例，且是第一次使用阿里云计算巢\n    - 需要在创建服务实例前，对使用的RAM用户的账号添加相应资源的权限。添加RAM权限的详细操作，请参见为 __RAM用户授权__。所需权限如下表所示。\n    - 且需要授权创建关联角色，参考下图，选中 __同意授权并创建关联角色__\n\n该段落位于文档的“实例说明”部分，详细描述了两种TuGraph云服务实例的具体配置参数，包括“ecs.r7a.xlarge”和“ecs.r6.xlarge”的性能指标，以及它们的相似性和预估费用信息。紧接着是“部署流程”部分的开始，说明了在开始使用TuGraph之前的准备工作。"
            },
            {
                "content": "概要总结: \n该表格列出了两种云服务器规格，均配备4个vCPU、32GiB内存及200GiB的ESSD云盘，且公网带宽均为固定的1Mbps。虽然两种规格在处理器和型号上有所不同，但其他基本配置保持一致。\n\n预估费用在创建实例时可实时看到（目前为免费）。 如需更多规格、其他服务（如集群高可用性要求、企业级支持服务等），请联系我们 tugraph@service.alipay.com。\n\n## 3.部署流程\n\n### 3.1.准备工作\n\n在正式开始使用前，您需要一个阿里云账号，对ECS、VPC等资源进行访问和创建操作。\n\n- 若您使用个人账号，可以直接创建服务实例\n- 若您使用RAM用户创建服务实例，且是第一次使用阿里云计算巢\n    - 需要在创建服务实例前，对使用的RAM用户的账号添加相应资源的权限。添加RAM权限的详细操作，请参见为 __RAM用户授权__。所需权限如下表所示。\n    - 且需要授权创建关联角色，参考下图，选中 __同意授权并创建关联角色__\n\n| 权限策略名称                    | 备注                                    |\n|---------------------------------|---------------------------------------|\n| AliyunECSFullAccess             | 管理云服务器服务（ECS）的权限             |\n| AliyunVPCFullAccess             | 管理专有网络（VPC）的权限                 |\n| AliyunROSFullAccess             | 管理资源编排服务（ROS）的权限             |\n| AliyunComputeNestUserFullAccess | 管理计算巢服务（ComputeNest）的用户侧权限 |\n| AliyunCloudMonitorFullAccess    | 管理云监控（CloudMonitor）的权限          |\n表格内容描述：\n该表格包含两列，分别是“权限策略名称”和“备注”。\n\n该chunk位于文档的第2部分和第3部分之间，主要总结了TuGraph的两种云服务器规格及其基本配置，并引入了部署流程的开始，指引用户准备工作和RAM用户权限设置，为后续的服务实例创建提供了必要的前置条件。"
            },
            {
                "content": "1. 第一行数据为 AliyunECSFullAccess，备注说明该权限策略允许管理云服务器服务（ECS）。\n2. 第二行数据为 AliyunVPCFullAccess，备注说明该权限策略允许管理专有网络（VPC）。\n3. 第三行数据为 AliyunROSFullAccess，备注说明该权限策略允许管理资源编排服务（ROS）。\n4. 第四行数据为 AliyunComputeNestUserFullAccess，备注说明该权限策略允许管理计算巢服务（ComputeNest）的用户侧权限。\n5. 第五行数据为 AliyunCloudMonitorFullAccess，备注说明该权限策略允许管理云监控（CloudMonitor）。\n\n总结：该表格列出了五种阿里云权限策略及其对应的功能备注，涵盖了云服务器、专有网络、资源编排、计算巢服务和云监控等多个云服务的管理权限。\n\n\n### 3.2.部署入口\n\n您可以在阿里云计算巢自行搜索，也可以通过下述部署链接快速到达。\n\n部署链接：https://computenest.console.aliyun.com/user/cn-hangzhou/serviceInstanceCreate?ServiceId=service-7b50ea3d20e643da95bf&&isTrial=true\n\n### 3.3.申请试用\n\n在正式试用前，需要申请试用，按照提示填写信息，在审核通过后就可以创建TuGraph服务。\n\n### 3.4.创建TuGraph服务\n\n#### 3.4.1.参数列表\n\n您在创建服务实例的过程中，需要配置服务实例信息的参数列表，具体如下。\n\n该段落位于文档的第3.1节和第3.2节之间，主要介绍了部署TuGraph服务所需的权限策略及其功能备注，为后续用户在部署入口和申请试用的步骤提供了必要的权限信息。"
            },
            {
                "content": "您在创建服务实例的过程中，需要配置服务实例信息的参数列表，具体如下。\n\n| 参数组               | 参数项   | 示例          | 说明                                                           |\n|--------------------|----------|---------------|--------------------------------------------------------------|\n| 服务实例名称         | N/A      | test          | 实例的名称                                                     |\n| 地域                 | N/A      | 华东1（杭州）   | 选中服务实例的地域，建议就近选中，以获取更好的网络延时。          |\n| 付费类型配置         | 付费类型 | 按量付费      | 免费使用请选用按量付费                                         |\n| 可用区配置           | 部署区域 | 可用区I       | 地域下的不同可用区域，确保实例非空                              |\n| 选择已有基础资源配置 | VPC ID   | vpc-xxx       | 按实际情况，选择专有网络的ID。                                   |\n| 选择已有基础资源配置 | 交换机ID | vsw-xxx       | 按实际情况，选择交换机ID。若找不到交换机, 可尝试切换地域和可用区 |\n| ECS实例配置          | 实例类型 | ecs.r6.xlarge | 当前支持ecs.r6.xlarge和ecs.r7a.xlarge规格                      |\n|ECS实例配置|\t实例密码|\t**|\t设置实例密码。长度8~30个字符，必须包含三项（大写字母、小写字母、数字、 ()`~!@#$%^&*_-+={}[]:;'<>,.?/ 中的特殊符号）。|\n表格内容描述：\n\n该段落位于文档的3.4节“创建TuGraph服务”下，具体描述了在创建服务实例过程中需要配置的参数列表，包括服务实例名称、地域、付费类型、可用区、网络配置及ECS实例相关信息，旨在指导用户正确填写创建服务实例所需的各项参数。"
            },
            {
                "content": "该表格包含四列，分别为“参数组”、“参数项”、“示例”和“说明”。\n\n1. 在“服务实例名称”这一行，参数项为“N/A”，示例提供了“test”，说明是实例的名称。\n2. “地域”行中的参数项为“N/A”，示例为“华东1（杭州）”，说明应选择靠近的地域以优化网络延时。\n3. 在“付费类型配置”部分，参数项为“付费类型”，示例为“按量付费”，说明免费使用应选择按量付费。\n4. “可用区配置”行中的参数项为“部署区域”，示例为“可用区I”，“说明”提醒确保实例的可用区非空。\n5. “选择已有基础资源配置”下，针对“VPC ID”参数项，示例为“vpc-xxx”，说明根据实际情况选择专有网络的ID。\n6. 在同一分类中，关于“交换机ID”参数项，示例为“vsw-xxx”，说明应选择适当的交换机ID，若找不到则需切换地域或可用区。\n7. “ECS实例配置”部分的“实例类型”参数项示例为“ecs.r6.xlarge”，说明当前支持的实例规格为ecs.r6.xlarge和ecs.r7a.xlarge。\n8. 在同一组下，“实例密码”参数项示例为“**”，说明设置的密码长度应为8到30个字符，必须包含大写字母、小写字母、数字及特定特殊符号。\n\n整体而言，该表格详细列出了服务实例的各项配置参数，包括命名、地域选择、付费类型、可用区、基础资源配置以及ECS实例相关的要求和说明，旨在指导用户正确配置服务实例。\n\n#### 3.4.2.具体步骤\n\n创建服务按如下步骤进行，参考下图：\n\n- 创建实例名称，如下图中“test”\n- 选择地域，如下图中“华东1（杭州）”\n- 选择实例类型，当前支持ecs.r6.xlarge和ecs.r7a.xlarge规格。如果列表中无机型可选，请尝试选择其他的部署区域\n- 选中机型\n- 配置实例的密码\n- 选择部署区域，如下图中“可用区I”\n- 点击下一步，进入订单确认页面\n- 勾选“权限确认”和“服务条款”中的复选框\n- 点击左下角绿色背景的开始免费试用，即可创建服务实例\n\n### 3.5.启动TuGraph服务\n\n该块内容位于文档的第3.4节，主要介绍创建TuGraph服务实例时需要配置的参数列表及其说明，并详细列出了具体的步骤，以指导用户正确地进行服务实例的创建。"
            },
            {
                "content": "整体而言，该表格详细列出了服务实例的各项配置参数，包括命名、地域选择、付费类型、可用区、基础资源配置以及ECS实例相关的要求和说明，旨在指导用户正确配置服务实例。\n\n#### 3.4.2.具体步骤\n\n创建服务按如下步骤进行，参考下图：\n\n- 创建实例名称，如下图中“test”\n- 选择地域，如下图中“华东1（杭州）”\n- 选择实例类型，当前支持ecs.r6.xlarge和ecs.r7a.xlarge规格。如果列表中无机型可选，请尝试选择其他的部署区域\n- 选中机型\n- 配置实例的密码\n- 选择部署区域，如下图中“可用区I”\n- 点击下一步，进入订单确认页面\n- 勾选“权限确认”和“服务条款”中的复选框\n- 点击左下角绿色背景的开始免费试用，即可创建服务实例\n\n### 3.5.启动TuGraph服务\n\n- 查看服务实例：服务实例创建成功后，部署时间大约需要2分钟。部署完成后，页面上可以看到对应的服务实例，如下图\n- 点击该服务实例访问TuGraph。进入到对应的服务实例后，可以在页面上获取到web、rpc、ssh共3种使用方式，并且页面上展示了admin用户的密码\n- 点击web的链接，即可跳转访问已经部署好的TuGraph Web。建议新手先通过TuGraph Web，快速使用demo上手。\n    - 首先在TuGraph Web的登录页面上，输入默认用户名admin和页面上展示的admin用户的密码进行登录，参考下图\n    - 登录完成后，选择任意一个带有官方图标的图项目，其中内置了demo数据，开启图数据的探索和发现！\n\n## 4.常见FAQ\n\n### 问题一：部署区域无可用资源\n\n有时，所选部署区域（如可用区G）没有所选套餐的可用资源，会报错\n\n__解决办法__：尝试选择其他区域，如可用区I等\n\n### 问题二: 启动后web访问不通\n\nweb的启动需要一点点时间，请稍后刷新页面即可。\n\n### 问题三: 登录时的用户名密码不正确\n\n请注意检查，登录时使用的密码应为详情页面展示的密码。\n\n该文本块位于文档的部署流程部分，具体介绍了如何配置服务实例的参数和创建服务的具体步骤，以及在成功创建服务后如何启动和访问TuGraph服务，包含常见问题的解答。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_111.md",
        "chunks": [
            {
                "content": "# UDF介绍\nUDF（User Defined Function）将标量值映射到标量值。\n## 接口\n\n```java\npublic abstract class UserDefinedFunction implements Serializable {\n\n    /**\n     * Init method for the user defined function.\n     */\n    public void open(FunctionContext context) {\n    }\n\n    /**\n     * Close method for the user defined function.\n     */\n    public void close() {\n    }\n}\n\npublic abstract class UDF extends UserDefinedFunction {\n\n}\n\n```\n## 示例\n\n```java\npublic class ConcatWS extends UDF {\n\n    public String eval(String... args) {\n        String separator = args[0];\n        String[] words = new String[args.length - 1];\n        for (int index = 0; index < d.length; index++) {\n            words[index] = args[index + 1];\n        }\n        return StringUtils.join(words, separator);\n    }\n\n}\n```\n\n```sql\nCreate Function my_cancat as 'com.antgroup.geaflow.dsl.udf.table.string.ConcatWS'; \n\nselect my_cancat(',', '1', '2', '3');\n```\n\n该文档介绍了用户定义函数（UDF）的概念及其接口，提供了一个UDF的具体实现示例（ConcatWS），以及如何在SQL中创建和使用该函数的示例。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_112.md",
        "chunks": [
            {
                "content": "# Procedure API\n\n> 此文档主要讲解 TuGraph 的存储过程使用说明（这个文档描述了新的 Procedure 编程范式以及 POG）\n\n## 1.简介\n\n当用户需要表达的查询/更新逻辑较为复杂（例如 Cypher 无法描述，或是对性能要求较高）时，相比调用多个请求并在客户端完成整个处理流程的方式，TuGraph 提供的存储过程是更简洁和高效的选择。\n\n与传统数据库类似，TuGraph 的存储过程运行在服务器端，用户通过将处理逻辑（即多个操作）封装到一个过程单次调用，并且可以在实现时通过并行处理的方式（例如使用相关的 C++ OLAP 接口以及基于其实现的内置算法）进一步提升性能。\n\n存储过程中有一类特殊的API来进行数据的并行操作，我们叫 Traversal API。\n\n## 2.存储过程的版本支持\n\n目前TuGraph支持两个版本的存储过程，适用于不同的场景，v3.5版本只支持v1，可通过REST或RPC接口直接调用；从v3.5版本开始支持v2，能够在图查询语言（比如Cypher）中嵌入调用，我们称之为POG（Procedure On Graph query language，APOC）。\n\n该文档介绍了TuGraph的存储过程，包括其使用说明、版本支持、编写存储过程的语言和接口等内容。具体地，前两部分讲解了存储过程的基本概念及其版本（Procedure v1和v2），并强调存储过程在处理复杂查询和提高性能方面的优势。"
            },
            {
                "content": "目前TuGraph支持两个版本的存储过程，适用于不同的场景，v3.5版本只支持v1，可通过REST或RPC接口直接调用；从v3.5版本开始支持v2，能够在图查询语言（比如Cypher）中嵌入调用，我们称之为POG（Procedure On Graph query language，APOC）。\n\n|                        | Procedure v1                       | Procedure v2               |\n| ---------------------- | ---------------------------------- | -------------------------- |\n| 适用场景                 | 极致性能，或者复杂的多事务管理情形       | 一般情况，与Cypher高度联动 |\n| 事务                    | 函数内部创建，可自由控制多事务          | 外部传入函数，单一事务     |\n| 签名（参数定义）          | 无                                 | 有                    |\n| 输入输出参数类型          | 不需要指定                           | 需要指定参数类型        |\n| Cypher Standalone Call | 支持                                | 支持                  |\n| Cypher Embeded Call    | 不支持                              | 支持                  |\n| 语言                    | C++/Python/Rust                    | C++                  |\n| 调用模式                 | 直接传字符串，一般为JSON               | 通过Cypher语句中的变量  |\n表格内容描述：\n表格中包含两列，分别为“Procedure v1”和“Procedure v2”。\n\n该chunk位于文档的第二部分“存储过程的版本支持”，主要介绍了TuGraph支持的两个版本的存储过程（v1和v2），并通过表格对这两个版本在适用场景、事务处理、参数定义和调用方式等方面进行比较。此外，还提到了从v3.5版本开始对Procedure v2的支持及其与Cypher的嵌入调用关系。"
            },
            {
                "content": "- 在“适用场景”这一行，Procedure v1适用于极致性能或复杂的多事务管理情形，而Procedure v2则适用于一般情况，与Cypher的联动性较强。\n- 在“事务”一行，Procedure v1中事务在函数内部创建，允许自由控制多事务；相对而言，Procedure v2的事务则是由外部传入函数，且为单一事务。\n- “签名（参数定义）”一行显示，Procedure v1没有必要的参数定义，而Procedure v2则需要明确的参数定义。\n- 在“输入输出参数类型”一行，Procedure v1不需要指定参数类型，而Procedure v2则需要指定。\n- 关于“Cypher Standalone Call”，两种Procedure均支持。\n- 在“Cypher Embeded Call”一行，Procedure v1不支持嵌入式调用，而Procedure v2则支持。\n- 在“语言”一行，Procedure v1可以使用C++、Python或Rust语言，而Procedure v2则只支持C++。\n- 最后在“调用模式”中，Procedure v1直接传入字符串，通常为JSON格式；而Procedure v2则通过Cypher语句中的变量进行调用。\n\n总结来说，该表格对比了Procedure v1和Procedure v2在适用场景、事务处理、参数定义、参数类型、Cypher调用方式、支持语言及调用模式等方面的差异，表明Procedure v1更适合性能优先的复杂事务场景，而Procedure v2更适合与Cypher交互的常规操作。\n\n在TuGraph中，存储过程v1和v2单独管理，支持增删查，但仍不建议重名。\n\n## 3.存储过程语言支持\n\n在 TuGraph 中，用户可以动态的加载，更新和删除存储过程。TuGraph 支持 C++ 语言、 Python 语言和 Rust 语言编写存储过程。在性能上 C++ 语言支持的最完整，性能最优。\n\n注意存储过程是在服务端编译执行的逻辑，和客户端的语言支持无关。\n\n## 4.Procedure v1接口\n\n## 4.1.编写存储过程\n\n### 4.1.1.编写C++存储过程\n\n用户可以通过使用 Procedure API 或者 Traversal API 来编写 C 存储过程。一个简单的 C 存储过程举例如下：\n\n该段落位于文档的第二部分，主要对比了TuGraph存储过程v1和v2在适用场景、事务处理和参数定义等方面的差异，并总结了存储过程的管理方式和语言支持。接下来的内容将详细介绍Procedure v1的接口及其编写方法。"
            },
            {
                "content": "总结来说，该表格对比了Procedure v1和Procedure v2在适用场景、事务处理、参数定义、参数类型、Cypher调用方式、支持语言及调用模式等方面的差异，表明Procedure v1更适合性能优先的复杂事务场景，而Procedure v2更适合与Cypher交互的常规操作。\n\n在TuGraph中，存储过程v1和v2单独管理，支持增删查，但仍不建议重名。\n\n## 3.存储过程语言支持\n\n在 TuGraph 中，用户可以动态的加载，更新和删除存储过程。TuGraph 支持 C++ 语言、 Python 语言和 Rust 语言编写存储过程。在性能上 C++ 语言支持的最完整，性能最优。\n\n注意存储过程是在服务端编译执行的逻辑，和客户端的语言支持无关。\n\n## 4.Procedure v1接口\n\n## 4.1.编写存储过程\n\n### 4.1.1.编写C++存储过程\n\n用户可以通过使用 Procedure API 或者 Traversal API 来编写 C 存储过程。一个简单的 C 存储过程举例如下：\n\n```\n#include \n#include \"lgraph.h\"\nusing namespace lgraph_api;\n\nextern \"C\" LGAPI bool Process(GraphDB& db, const std::string& request, std::string& response) {\n\tauto txn = db.CreateReadTxn();\n\tsize_t n = 0;\n\tfor (auto vit = txn.GetVertexIterator(); vit.IsValid(); vit.Next()) {\n        if (vit.GetLabel() == \"student\") {\n            auto age = vit.GetField(\"age\");\n            if (!age.is_null() && age.integer() == 10) n++; ## 统计所有年龄为10的学生数量\n        }\n\t}\n    output = std::to_string(n);\n    return true;\n}\n```\n\n从代码中我们可以看到，存储过程的入口函数是`Process`函数，它的参数有三个，分别为：\n\n该部分内容位于文档的第二章与第三章之间，主要总结了存储过程v1和v2的不同特点及适用场景，并介绍了TuGraph支持的存储过程编程语言及其性能特点，为后续具体实现部分的内容铺垫。"
            },
            {
                "content": "extern \"C\" LGAPI bool Process(GraphDB& db, const std::string& request, std::string& response) {\n\tauto txn = db.CreateReadTxn();\n\tsize_t n = 0;\n\tfor (auto vit = txn.GetVertexIterator(); vit.IsValid(); vit.Next()) {\n        if (vit.GetLabel() == \"student\") {\n            auto age = vit.GetField(\"age\");\n            if (!age.is_null() && age.integer() == 10) n++; ## 统计所有年龄为10的学生数量\n        }\n\t}\n    output = std::to_string(n);\n    return true;\n}\n```\n\n从代码中我们可以看到，存储过程的入口函数是`Process`函数，它的参数有三个，分别为：\n\n- `db`: 数据库实例\n- `request`: 输入请求数据，可以是二进制字节数组，或者 JSON 串等其它任意格式。\n- `response`: 输出数据，可以是字符串，也可以直接返回二进制数据。\n\n`Process`函数的返回值是一个布尔值。当它返回`true`的时候，表示该请求顺利完成，反之表示这个存储过程在执行过程中发现了错误，此时用户可以通过`response`来返回错误信息以方便调试。\n\nC++存储过程编写完毕后需要编译成动态链接库。TuGraph 提供了`compile.sh`脚本来帮助用户自动编译存储过程。`compile.sh`脚本只有一个参数，是该存储过程的名称，在上面的例子中就是`age_10`。编译调用命令行如下：\n\n```bash\ng++ -fno-gnu-unique -fPIC -g --std=c++14 -I/usr/local/include/lgraph -rdynamic -O3 -fopenmp -o age_10.so age_10.cpp /usr/local/lib64/liblgraph.so -shared\n```\n\n该代码片段位于文档的第4.1.1节，介绍了如何编写C++存储过程的具体示例，展示了存储过程的入口函数`Process`及其参数，包括如何统计特定条件下的结果，并说明了编译存储过程为动态链接库的相关命令。此部分内容旨在帮助用户理解存储过程的编写及其执行流程。"
            },
            {
                "content": "- `db`: 数据库实例\n- `request`: 输入请求数据，可以是二进制字节数组，或者 JSON 串等其它任意格式。\n- `response`: 输出数据，可以是字符串，也可以直接返回二进制数据。\n\n`Process`函数的返回值是一个布尔值。当它返回`true`的时候，表示该请求顺利完成，反之表示这个存储过程在执行过程中发现了错误，此时用户可以通过`response`来返回错误信息以方便调试。\n\nC++存储过程编写完毕后需要编译成动态链接库。TuGraph 提供了`compile.sh`脚本来帮助用户自动编译存储过程。`compile.sh`脚本只有一个参数，是该存储过程的名称，在上面的例子中就是`age_10`。编译调用命令行如下：\n\n```bash\ng++ -fno-gnu-unique -fPIC -g --std=c++14 -I/usr/local/include/lgraph -rdynamic -O3 -fopenmp -o age_10.so age_10.cpp /usr/local/lib64/liblgraph.so -shared\n```\n\n如果编译顺利，会生成 age_10.so，然后用户就可以将它加载到服务器中了。\n\n### 4.1.2.编写Python存储过程\n\n与 C++类似，Python 存储过程也可以调用 core API，一个简单的例子如下：\n\n```python\ndef Process(db, input):\n    txn = db.CreateReadTxn()\n    it = txn.GetVertexIterator()\n    n = 0\n    while it.IsValid():\n        if it.GetLabel() == 'student' and it['age'] and it['age'] == 10:\n            n = n + 1\n        it.Next()\n    return (True, str(nv))\n```\n\nPython 存储过程返回的是一个 tuple，其中第一个元素是一个布尔值，表示该存储过程是否成功执行；第二个元素是一个`str`，里面是需要返回的结果。\n\nPython 存储过程不需要编译，可以直接加载。\n\n## 4.2.如何使用存储过程\n### 4.2.1.加载存储过程\n\n该章节位于文档的第四部分，主要介绍了如何编写和使用存储过程，具体包含C++和Python存储过程的编写示例、参数说明以及如何加载和调用这些存储过程的详细步骤。"
            },
            {
                "content": "### 4.1.2.编写Python存储过程\n\n与 C++类似，Python 存储过程也可以调用 core API，一个简单的例子如下：\n\n```python\ndef Process(db, input):\n    txn = db.CreateReadTxn()\n    it = txn.GetVertexIterator()\n    n = 0\n    while it.IsValid():\n        if it.GetLabel() == 'student' and it['age'] and it['age'] == 10:\n            n = n + 1\n        it.Next()\n    return (True, str(nv))\n```\n\nPython 存储过程返回的是一个 tuple，其中第一个元素是一个布尔值，表示该存储过程是否成功执行；第二个元素是一个`str`，里面是需要返回的结果。\n\nPython 存储过程不需要编译，可以直接加载。\n\n## 4.2.如何使用存储过程\n### 4.2.1.加载存储过程\n\n用户可以通过 REST API 和 RPC 来加载存储过程。以 REST API 为例，加载`age_10.so`的 C++代码如下：\n\n```python\nimport requests\nimport json\nimport base64\n\n该段落位于文档的第四部分，主要介绍了如何编写Python存储过程，包括示例代码及其返回值说明。紧接着介绍了如何使用存储过程的加载方法，包含REST API和RPC的具体操作示例。"
            },
            {
                "content": "Python 存储过程返回的是一个 tuple，其中第一个元素是一个布尔值，表示该存储过程是否成功执行；第二个元素是一个`str`，里面是需要返回的结果。\n\nPython 存储过程不需要编译，可以直接加载。\n\n## 4.2.如何使用存储过程\n### 4.2.1.加载存储过程\n\n用户可以通过 REST API 和 RPC 来加载存储过程。以 REST API 为例，加载`age_10.so`的 C++代码如下：\n\n```python\nimport requests\nimport json\nimport base64\n\ndata = {'name':'age_10'}\nf = open('./age_10.so','rb')\ncontent = f.read()\ndata['code_base64'] = base64.b64encode(content).decode()\ndata['description'] = 'Custom Page Rank Procedure'\ndata['read_only'] = true\ndata['code_type'] = 'so'\njs = json.dumps(data)\nr = requests.post(url='http://127.0.0.1:7071/db/school/cpp_plugin', data=js,\n            headers={'Content-Type':'application/json'})\nprint(r.status_code)    ## 正常时返回200\n```\n\n需要注意的是，这时的`data['code']`是一个经过 base64 处理的字符串，`age_10.so`中的二进制代码是无法通过 JSON 直接传输的。此外，存储过程的加载和删除都只能由具有管理员权限的用户来操作。\n\n存储过程加载之后会被保存在数据库中，在服务器重启后也会被自动加载。此外，如果需要对存储过程进行更新，调用的 REST API 也是同样的。建议用户在更新存储过程时更新相应描述，以便区分不同版本的存储过程。\n\n\n### 4.2.2.列出已加载的存储过程\n\n在服务器运行过程中，用户可以随时获取存储过程列表。其调用如下：\n\n该块内容位于文档的第四部分，重点介绍了如何使用存储过程，包括Python存储过程的特点及其返回值结构，以及如何通过REST API加载、列出已加载的存储过程。这部分内容旨在指导用户在TuGraph中有效地部署和管理存储过程。"
            },
            {
                "content": "需要注意的是，这时的`data['code']`是一个经过 base64 处理的字符串，`age_10.so`中的二进制代码是无法通过 JSON 直接传输的。此外，存储过程的加载和删除都只能由具有管理员权限的用户来操作。\n\n存储过程加载之后会被保存在数据库中，在服务器重启后也会被自动加载。此外，如果需要对存储过程进行更新，调用的 REST API 也是同样的。建议用户在更新存储过程时更新相应描述，以便区分不同版本的存储过程。\n\n\n### 4.2.2.列出已加载的存储过程\n\n在服务器运行过程中，用户可以随时获取存储过程列表。其调用如下：\n\n```python\n>>> r = requests.get('http://127.0.0.1:7071/db/school/cpp_plugin')\n>>> r.status_code\n200\n>>> r.text\n'{\"plugins\":[{\"description\":\"Custom Page Rank Procedure\", \"name\":\"age_10\", \"read_only\":true}]}'\n```\n\n### 4.2.3.获取存储过程详情\n\n在服务器运行过程中，用户可以随时获取单个存储过程的详情，包括代码。其调用如下：\n\n```python\n>>> r = requests.get('http://127.0.0.1:7071/db/school/cpp_plugin/age_10')\n>>> r.status_code\n200\n>>> r.text\n'{\"description\":\"Custom Page Rank Procedure\", \"name\":\"age_10\", \"read_only\":true, \"code_base64\":, \"code_type\":\"so\"}'\n```\n\n### 4.2.4.调用存储过程\n\n调用存储过程的代码示例如下：\n\n```\n>>> r = requests.post(url='http://127.0.0.1:7071/db/school/cpp_plugin/age_10', data='',\n                headers={'Content-Type':'application/json'})\n>>> r.status_code\n200\n>>> r.text\n9\n```\n\n该块内容位于文档的第四部分，描述了如何使用TuGraph的存储过程，包括加载、列出、获取详情、调用和删除存储过程的具体步骤和示例代码，重点强调了存储过程的权限管理和更新策略。"
            },
            {
                "content": "在服务器运行过程中，用户可以随时获取单个存储过程的详情，包括代码。其调用如下：\n\n```python\n>>> r = requests.get('http://127.0.0.1:7071/db/school/cpp_plugin/age_10')\n>>> r.status_code\n200\n>>> r.text\n'{\"description\":\"Custom Page Rank Procedure\", \"name\":\"age_10\", \"read_only\":true, \"code_base64\":, \"code_type\":\"so\"}'\n```\n\n### 4.2.4.调用存储过程\n\n调用存储过程的代码示例如下：\n\n```\n>>> r = requests.post(url='http://127.0.0.1:7071/db/school/cpp_plugin/age_10', data='',\n                headers={'Content-Type':'application/json'})\n>>> r.status_code\n200\n>>> r.text\n9\n```\n\n### 4.2.5.删除存储过程\n\n删除存储过程只需要如下调用：\n\n```python\n>>> r = requests.delete(url='http://127.0.0.1:7071/db/school/cpp_plugin/age_10')\n>>> r.status_code\n200\n```\n\n与加载存储过程类似，只有管理员用户才能删除存储过程。\n\n### 4.2.6.更新存储过程\n\n更新存储过程需要执行如下两个步骤：\n\n1.  删除已存在的存储过程\n2.  安装新的存储过程\n\nTuGraph 较为谨慎地管理存储过程操作的并发性，更新存储过程不会影响现有存储过程的运行。\n\n\n## 5.Procedure v2接口\n\n下面的说明以 REST API 为例，介绍存储过程v2的调用。\n\n### 5.1.编写存储过程\n\n\n用户可以通过使用 lgraph API 来编写 C++ 存储过程。一个简单的 C++ 存储过程举例如下：\n\n该段落位于文档的第四部分，主要介绍了TuGraph存储过程的使用，包括如何获取已加载的存储过程详情、调用存储过程、删除存储过程及更新存储过程的具体步骤。此内容为Procedure v1接口的详细操作说明。"
            },
            {
                "content": "### 4.2.5.删除存储过程\n\n删除存储过程只需要如下调用：\n\n```python\n>>> r = requests.delete(url='http://127.0.0.1:7071/db/school/cpp_plugin/age_10')\n>>> r.status_code\n200\n```\n\n与加载存储过程类似，只有管理员用户才能删除存储过程。\n\n### 4.2.6.更新存储过程\n\n更新存储过程需要执行如下两个步骤：\n\n1.  删除已存在的存储过程\n2.  安装新的存储过程\n\nTuGraph 较为谨慎地管理存储过程操作的并发性，更新存储过程不会影响现有存储过程的运行。\n\n\n## 5.Procedure v2接口\n\n下面的说明以 REST API 为例，介绍存储过程v2的调用。\n\n### 5.1.编写存储过程\n\n\n用户可以通过使用 lgraph API 来编写 C++ 存储过程。一个简单的 C++ 存储过程举例如下：\n\n```c++\n// peek_some_node_salt.cpp\n#include \n#include \"lgraph/lgraph.h\"\n#include \"lgraph/lgraph_types.h\"\n#include \"lgraph/lgraph_result.h\"\n\n#include \"tools/json.hpp\"\n\nusing json = nlohmann::json;\nusing namespace lgraph_api;\n\nextern \"C\" LGAPI bool GetSignature(SigSpec &sig_spec) {\n    sig_spec.input_list = {\n        {.name = \"limit\", .index = 0, .type = LGraphType::INTEGER},\n    };\n    sig_spec.result_list = {\n        {.name = \"node\", .index = 0, .type = LGraphType::NODE},\n        {.name = \"salt\", .index = 1, .type = LGraphType::FLOAT}\n    };\n    return true;\n}\n\n该块内容主要描述了TuGraph中如何删除和更新存储过程的步骤，以及更新存储过程时需要遵循的流程。紧接着，引入了Procedure v2接口的相关内容，具体说明了如何编写存储过程并给出一个示例代码。此部分在文档中位于关于存储过程使用和管理的章节中，帮助用户理解存储过程的动态管理功能。"
            },
            {
                "content": "#include \"tools/json.hpp\"\n\nusing json = nlohmann::json;\nusing namespace lgraph_api;\n\nextern \"C\" LGAPI bool GetSignature(SigSpec &sig_spec) {\n    sig_spec.input_list = {\n        {.name = \"limit\", .index = 0, .type = LGraphType::INTEGER},\n    };\n    sig_spec.result_list = {\n        {.name = \"node\", .index = 0, .type = LGraphType::NODE},\n        {.name = \"salt\", .index = 1, .type = LGraphType::FLOAT}\n    };\n    return true;\n}\n\nextern \"C\" LGAPI bool ProcessInTxn(Transaction &txn,\n                                   const std::string &request,\n                                   Result &response) {\n    int64_t limit;\n    try {\n        json input = json::parse(request);\n        limit = input[\"limit\"].get();\n    } catch (std::exception &e) {\n        response.ResetHeader({\n            {\"errMsg\", LGraphType::STRING}\n        });\n        response.MutableRecord()->Insert(\n            \"errMsg\",\n            FieldData::String(std::string(\"error parsing json: \") + e.what()));\n        return false;\n    }\n\n该代码块位于文档的第5.1节“编写存储过程”中，主要展示了存储过程v2的一个示例，它通过`GetSignature`函数定义输入输出参数的类型，并在`ProcessInTxn`函数中处理输入数据、解析JSON并返回相应的结果。该部分说明了如何在TuGraph中使用C++编写存储过程，以实现与Cypher查询的交互。"
            },
            {
                "content": "response.ResetHeader({\n        {\"node\", LGraphType::NODE},\n        {\"salt\", LGraphType::FLOAT}\n    });\n    for (size_t i = 0; i < limit; i++) {\n        auto r = response.MutableRecord();\n        auto vit = txn.GetVertexIterator(i);\n        r->Insert(\"node\", vit);\n        r->Insert(\"salt\", FieldData::Float(20.23*float(i)));\n    }\n    return true;\n}\n```\n\n从代码中我们可以看到：\n- 存储过程定义了一个获取签名的方法`GetSignature`。该方法返回了存储过程的签名，其中包含输入参数名称及其类型，返回参数及其类型。这使得Cypher查询语句在调用存储过程能够利用签名信息校验输入数据以及返回数据是否合理。\n- 入口函数是`ProcessInTxn`函数，它的参数有三个，分别为：\n\n- `txn`: 存储过程所处的事务，通常来说即调用该存储过程的Cypher语句所处事务。\n- `request`: 输入数据，其内容为`GetSignature`中定义的输入参数类型及其Cypher查询语句中传入的值经过json序列化后的字符串。e.g. `{num_iteration: 10}`\n- `response`: 输出数据，为保证在Cypher语言中能够兼容，用户可以通过往`lgraph_api::Result` 写入存储过程处理后的数据，最后用`lgraph_api::Result::Dump`来序列化成json格式的数据。\n\n`ProcessInTxn`函数的返回值是一个布尔值。当它返回`true`的时候，表示该请求顺利完成，反之表示这个存储过程在执行过程中发现了错误。\n\nC++存储过程编写完毕后需要编译成动态链接库。TuGraph 提供了`compile.sh`脚本来帮助用户自动编译存储过程。`compile.sh`脚本只有一个参数，是该存储过程的名称，在上面的例子中就是`custom_pagerank`。编译调用命令行如下：\n\n该chunk位于文档的“5.1.编写存储过程”部分，介绍了存储过程v2中`ProcessInTxn`函数的具体实现细节，包括如何重置响应头部和插入返回数据的逻辑。同时，该部分还提到存储过程的签名获取函数`GetSignature`及其在Cypher查询中的应用，为用户提供了存储过程的编写和调用的基本框架。"
            },
            {
                "content": "- `txn`: 存储过程所处的事务，通常来说即调用该存储过程的Cypher语句所处事务。\n- `request`: 输入数据，其内容为`GetSignature`中定义的输入参数类型及其Cypher查询语句中传入的值经过json序列化后的字符串。e.g. `{num_iteration: 10}`\n- `response`: 输出数据，为保证在Cypher语言中能够兼容，用户可以通过往`lgraph_api::Result` 写入存储过程处理后的数据，最后用`lgraph_api::Result::Dump`来序列化成json格式的数据。\n\n`ProcessInTxn`函数的返回值是一个布尔值。当它返回`true`的时候，表示该请求顺利完成，反之表示这个存储过程在执行过程中发现了错误。\n\nC++存储过程编写完毕后需要编译成动态链接库。TuGraph 提供了`compile.sh`脚本来帮助用户自动编译存储过程。`compile.sh`脚本只有一个参数，是该存储过程的名称，在上面的例子中就是`custom_pagerank`。编译调用命令行如下：\n\n```bash\ng++ -fno-gnu-unique -fPIC -g --std=c++14 -I/usr/local/include/lgraph -rdynamic -O3 -fopenmp -o custom_pagerank.so custom_pagerank.cpp /usr/local/lib64/liblgraph.so -shared\n```\n\n如果编译顺利，会生成 custom_pagerank.so，然后用户就可以将它加载到服务器中了。\n\n\n### 5.2.加载存储过程\n\n用户可以通过 REST API 和 RPC 来加载存储过程。以 REST API 为例，加载`custom_pagerank.so`的 C++代码如下：\n\n```python\nimport requests\nimport json\nimport base64\n\n该块内容位于文档的第5节“Procedure v2接口”中，具体介绍了存储过程的输入输出参数，以及如何编写和编译C++存储过程的步骤。它紧接着描述存储过程的加载方法，主要讲解如何通过REST API将编译好的动态链接库加载到TuGraph服务器中。"
            },
            {
                "content": "```bash\ng++ -fno-gnu-unique -fPIC -g --std=c++14 -I/usr/local/include/lgraph -rdynamic -O3 -fopenmp -o custom_pagerank.so custom_pagerank.cpp /usr/local/lib64/liblgraph.so -shared\n```\n\n如果编译顺利，会生成 custom_pagerank.so，然后用户就可以将它加载到服务器中了。\n\n\n### 5.2.加载存储过程\n\n用户可以通过 REST API 和 RPC 来加载存储过程。以 REST API 为例，加载`custom_pagerank.so`的 C++代码如下：\n\n```python\nimport requests\nimport json\nimport base64\n\ndata = {'name':'custom_pagerank'}\nf = open('./custom_pagerank.so','rb')\ncontent = f.read()\ndata['code_base64'] = base64.b64encode(content).decode()\ndata['description'] = 'Custom Page Rank Procedure'\ndata['read_only'] = true\ndata['code_type'] = 'so'\njs = json.dumps(data)\nr = requests.post(url='http://127.0.0.1:7071/db/school/cpp_plugin', data=js,\n            headers={'Content-Type':'application/json'})\nprint(r.status_code)    ## 正常时返回200\n```\n\n需要注意的是，这时的`data['code']`是一个经过 base64 处理的字符串，`custom_pagerank.so`中的二进制代码是无法通过 JSON 直接传输的。此外，存储过程的加载和删除都只能由具有管理员权限的用户来操作。\n\n该代码段位于文档的第五部分\"Procedure v2接口\"中，具体介绍了如何编译存储过程并将其加载到TuGraph服务器。它提供了编译命令的示例，以及使用REST API加载存储过程的Python代码示例，说明了在存储过程加载过程中需要注意的事项。"
            },
            {
                "content": "需要注意的是，这时的`data['code']`是一个经过 base64 处理的字符串，`custom_pagerank.so`中的二进制代码是无法通过 JSON 直接传输的。此外，存储过程的加载和删除都只能由具有管理员权限的用户来操作。\n\n存储过程加载之后会被保存在数据库中，在服务器重启后也会被自动加载。此外，如果需要对存储过程进行更新，调用的 REST API 也是同样的。建议用户在更新存储过程时更新相应描述，以便区分不同版本的存储过程。\n\n\n#### 5.2.1.列出已加载的存储过程\n\n在服务器运行过程中，用户可以随时获取存储过程列表。其调用如下：\n\n```python\n>>> r = requests.get('http://127.0.0.1:7071/db/school/cpp_plugin')\n>>> r.status_code\n200\n>>> r.text\n'{\"plugins\":[{\"description\":\"Custom Page Rank Procedure\", \"name\":\"custom_pagerank\", \"read_only\":true}]}'\n```\n\n#### 5.2.2.获取存储过程详情\n\n在服务器运行过程中，用户可以随时获取单个存储过程的详情，包括代码。其调用如下：\n\n```python\n>>> r = requests.get('http://127.0.0.1:7071/db/school/cpp_plugin/custom_pagerank')\n>>> r.status_code\n200\n>>> r.text\n'{\"description\":\"Custom Page Rank Procedure\", \"name\":\"custom_pagerank\", \"read_only\":true, \"code_base64\":, \"code_type\":\"so\"}'\n```\n\n#### 5.2.3.调用存储过程\n\n调用存储过程的代码示例如下：\n\n```Cypher\nCALL plugin.cpp.custom_pagerank(10)\nYIELD node, pr WITH node, pr\nMATCH(node)-[r]->(n) RETURN node, r, n, pr\n```\n\n#### 5.2.4.删除存储过程\n\n删除存储过程只需要如下调用：\n\n该片段位于文档的第5.2节，主要介绍了如何加载、列出、获取详情、调用和删除Procedure v2的存储过程的相关操作。该部分强调了存储过程的加载方式，以及需要管理员权限才能进行的操作，同时提供了具体的代码示例以供参考。"
            },
            {
                "content": "#### 5.2.2.获取存储过程详情\n\n在服务器运行过程中，用户可以随时获取单个存储过程的详情，包括代码。其调用如下：\n\n```python\n>>> r = requests.get('http://127.0.0.1:7071/db/school/cpp_plugin/custom_pagerank')\n>>> r.status_code\n200\n>>> r.text\n'{\"description\":\"Custom Page Rank Procedure\", \"name\":\"custom_pagerank\", \"read_only\":true, \"code_base64\":, \"code_type\":\"so\"}'\n```\n\n#### 5.2.3.调用存储过程\n\n调用存储过程的代码示例如下：\n\n```Cypher\nCALL plugin.cpp.custom_pagerank(10)\nYIELD node, pr WITH node, pr\nMATCH(node)-[r]->(n) RETURN node, r, n, pr\n```\n\n#### 5.2.4.删除存储过程\n\n删除存储过程只需要如下调用：\n\n```python\n>>> r = requests.delete(url='http://127.0.0.1:7071/db/school/cpp_plugin/custom_pagerank')\n>>> r.status_code\n200\n```\n\n与加载存储过程类似，只有管理员用户才能删除存储过程。\n\n#### 5.2.5.更新存储过程\n\n更新存储过程需要执行如下两个步骤：\n\n1.  删除已存在的存储过程\n2.  安装新的存储过程\n\nTuGraph 较为谨慎地管理存储过程操作的并发性，更新存储过程不会影响现有存储过程的运行。\n\n该片段位于TuGraph存储过程v2接口部分，具体介绍了如何获取已加载存储过程的详情、调用存储过程、删除和更新存储过程的操作。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_113.md",
        "chunks": [
            {
                "content": "# 集群管理\n\n> 此文档主要介绍 TuGraph HA 集群的管理工具，主要包括删除节点、leader转移和生成snapshot功能\n\n## 1. 简介\n\nHA集群启动之后，可以使用`lgraph_peer`工具进行集群管理，可以执行删除节点，转移leader和生成snapshot等功能。\n\n## 2. 删除节点\n\n对于TuGraph HA集群中长期离线或者产生网络分区的节点，可以使用`lgraph_peer`的`remove_peer`命令删除节点。命令示例如下所示：\n```shell\n$ lgraph_peer --command remove_peer --peer {peer_id} --conf {group_conf}\n```\n\n其中：\n\n- `--command remove_peer` 指定要执行的操作为remove_peer，即删除节点。\n- `--peer {peer_id}` 指定要删除节点的rpc网络地址，如 `127.0.0.1:9092`。\n- `--conf {group_conf}` 指定HA集群的成员配置（可连通主节点即可），如 `127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094` 。\n\n## 3. leader 转移\n\n当需要对主节点执行停机或重启操作时，为减少集群的不可服务时间，可以使用`lgraph_peer`的`transfer_leader`命令转移主节点。命令示例如下所示：\n\n```shell\n$ lgraph_peer --command transfer_leader --peer {peer_id} --conf {group_conf}\n```\n\n其中：\n\n- `--command transfer_leader` 指定要执行的操作为transfer_leader，即转移主节点。\n- `--peer {peer_id}` 指定要成为主节点的rpc网络地址，如 `127.0.0.1:9092`。\n- `--conf {group_conf}` 指定HA集群的成员配置（可连通主节点即可），如 `127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094` 。\n\n## 4. 生成snapshot\n\n本段落为文档的主体部分，详细介绍了TuGraph HA集群的管理工具`lgraph_peer`的具体使用，包括如何删除节点、转移主节点及生成快照的命令和参数说明。这是集群管理的重要操作指南。"
            },
            {
                "content": "## 3. leader 转移\n\n当需要对主节点执行停机或重启操作时，为减少集群的不可服务时间，可以使用`lgraph_peer`的`transfer_leader`命令转移主节点。命令示例如下所示：\n\n```shell\n$ lgraph_peer --command transfer_leader --peer {peer_id} --conf {group_conf}\n```\n\n其中：\n\n- `--command transfer_leader` 指定要执行的操作为transfer_leader，即转移主节点。\n- `--peer {peer_id}` 指定要成为主节点的rpc网络地址，如 `127.0.0.1:9092`。\n- `--conf {group_conf}` 指定HA集群的成员配置（可连通主节点即可），如 `127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094` 。\n\n## 4. 生成snapshot\n\n出于节点启动时设置ha_snapshot_interval_s为-1以默认不打snapshot或其他原因，\n当需要让某个节点手动生成snapshot时，可以使用`lgraph_peer`的`snapshot`命令。命令示例如下所示：\n\n```shell\n$ lgraph_peer --command snapshot --peer {peer_id}\n```\n\n其中：\n\n- `--command snapshot` 指定要执行的操作为snapshot，即生成快照。\n- `--peer {peer_id}` 指定要生成快照的节点的rpc网络地址，如 `127.0.0.1:9092`。\n\n该文档主要介绍TuGraph HA集群的管理工具，包括节点删除、主节点转移和快照生成等功能。本片段详细描述了如何转移主节点的操作及相关命令，紧接着说明了如何手动生成快照的指令和参数。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_114.md",
        "chunks": [
            {
                "content": "# 多层级接口\n\n\n> 此文档主要介绍 TuGraph 的多层级接口的设计理念。\n\n## 1.简介\n\n多层级接口是 TuGraph 针对多丰富的使用场景，在易用性和高性中作出的平衡。比如描述式图查询语言 Cypher 能够抹去图数据库实现的细节，基于图模型的抽象来进行表达。Cypher 过于高层的表述，无法高效转化成底层的执行，因此提供了 Procedure API 的过程式语言，来发挥图数据库的最佳性能。\n\n接口可以大致分为客户端接口和服务端接口，大部分操作都在服务端完成，客户端只做数据的封装和解析。客户端和服务端通过网络连接，TuGraph 支持更加灵活的短连接 REST 协议，以及更加高效的长链接 RPC 协议，可根据不同的业务场景来选择。\n\n服务端接口均处在计算层，和图数据存储间用一层 Core API 在逻辑上隔开。\n\n\n## 2.客户端接口\n\n客户端接口指在客户端执行的接口，通常用于集成到软件应用中。TuGraph 的客户端的接口比较简单，包括登录登出、数据导入导出、存储过程加载调用、Cypher操作等。其中 Cypher 中集成了大部分的功能，包括数据操作、图模型操作、运维管理、账户管理等。\n\n由于 Cypher 的参数和返回值都是字符串，JAVA OGM 是对 Cypher 的结构化封装，即查询结果能够被封装为一个有类型的对象，方便使用。\n\n## 3.服务端接口\n\n服务端接口包括描述式图查询语言 Cypher、过程式图查询语言 Procedure API、图分析编程框架 OLAP API 和图神经网络编程框架 GNN PI，为图事务引擎、图分析引擎、图神经网络引擎提供服务，下面先展开介绍各个接口的特点。\n\n> __描述式图查询语言__ 是对查询逻辑的抽象描述，而与执行逻辑无关，对图数据库应用者比较友好，类比关系型数据库的 SQL 语言。TuGraph 的 Cypher 语言主要依照 Neo4j 开源的 OpenCypher 查询标准，同时对运维管理等辅助功能进行了扩展，在功能上囊括了 TuGraph 的大部分操作。描述式图查询语言会成为图数据库的主要数据操作方式，但由于描述到执行之间需要生成执行计划（Execution Plan），生成最优执行计划在学术界和工业界均有很长的路要走。\n\n该文档介绍了TuGraph的多层级接口设计理念，重点阐述了客户端接口与服务端接口的组成及其功能，特别是描述式图查询语言Cypher的特点和使用，以及Procedure API、OLAP API和GNN PI在图数据管理和分析中的应用。这一部分内容具体展开了服务端接口的不同类型和相应的功能及优势。"
            },
            {
                "content": "由于 Cypher 的参数和返回值都是字符串，JAVA OGM 是对 Cypher 的结构化封装，即查询结果能够被封装为一个有类型的对象，方便使用。\n\n## 3.服务端接口\n\n服务端接口包括描述式图查询语言 Cypher、过程式图查询语言 Procedure API、图分析编程框架 OLAP API 和图神经网络编程框架 GNN PI，为图事务引擎、图分析引擎、图神经网络引擎提供服务，下面先展开介绍各个接口的特点。\n\n> __描述式图查询语言__ 是对查询逻辑的抽象描述，而与执行逻辑无关，对图数据库应用者比较友好，类比关系型数据库的 SQL 语言。TuGraph 的 Cypher 语言主要依照 Neo4j 开源的 OpenCypher 查询标准，同时对运维管理等辅助功能进行了扩展，在功能上囊括了 TuGraph 的大部分操作。描述式图查询语言会成为图数据库的主要数据操作方式，但由于描述到执行之间需要生成执行计划（Execution Plan），生成最优执行计划在学术界和工业界均有很长的路要走。\n\n> __过程式图查询语言__ 是为了解决描述式图查询语言与最优性能间的鸿沟。TuGraph的 Procedure API 是在 Core API 上做了一层简单的封装，C++ Procedure API的灵活性和高效性能够充分发挥存储的极致性能，也是 Cypher 优化的上限性能。Python Procedure API 是 C++ Procedure API 上的一层跨语言封装，翻译过程中值的拷贝会带来一定的性能损失，优势则主要是 python 语言本身的易用性。raversal API 是并行执行的 Procedure 接口，描述上更接近于集合的操作，比如扩展点集合所有出度邻居，获得一个新的点集。\n\n> __图分析编程框架__ 属于 ‘图计算系统’ 的范畴，会将图数据从支持增删改查的存储中导出快照，以更紧凑的数据存储格式来支持只读的复杂图分析，这里叫做OLAP API。OLAP API 封装了高并发执行的数据结构，包括 Vector、Bitmap等，以及基于 CSR 格式的图快照数据结构，然后提供一套并发的快速点边操作框架。在图分析任务完成后，数据可以通过接口写回图数据库。\n\n该段落位于文档的第三部分“服务端接口”中，介绍了 TuGraph 的多种服务端接口，包括描述式图查询语言 Cypher 和过程式图查询语言 Procedure API，以及图分析编程框架 OLAP API 和图神经网络编程框架 GNN PI，为图事务引擎和分析引擎提供服务，强调 Cypher 的字符串参数与返回值的特点，以及后续各接口的功能与应用。"
            },
            {
                "content": "> __过程式图查询语言__ 是为了解决描述式图查询语言与最优性能间的鸿沟。TuGraph的 Procedure API 是在 Core API 上做了一层简单的封装，C++ Procedure API的灵活性和高效性能够充分发挥存储的极致性能，也是 Cypher 优化的上限性能。Python Procedure API 是 C++ Procedure API 上的一层跨语言封装，翻译过程中值的拷贝会带来一定的性能损失，优势则主要是 python 语言本身的易用性。raversal API 是并行执行的 Procedure 接口，描述上更接近于集合的操作，比如扩展点集合所有出度邻居，获得一个新的点集。\n\n> __图分析编程框架__ 属于 ‘图计算系统’ 的范畴，会将图数据从支持增删改查的存储中导出快照，以更紧凑的数据存储格式来支持只读的复杂图分析，这里叫做OLAP API。OLAP API 封装了高并发执行的数据结构，包括 Vector、Bitmap等，以及基于 CSR 格式的图快照数据结构，然后提供一套并发的快速点边操作框架。在图分析任务完成后，数据可以通过接口写回图数据库。\n\n> __图神经网络编程框架__ 主要提供了图神经网络应用编程所需要的接口，能够对接PyTorch 等机器学习框架。TuGraph 的图神经网络编程框架主要集成了 DGL，在 Python 的语言环境中完成从图存储到图神经网络应用的完整流程。\n\n除了 Cypher 是解释执行外，其余服务端接口都是编译执行，即需要将对应代码传到服务端后，进行编译（可能会有时间开销），再在服务端执行。所以通常需要先加载，然后再已加载的应用列表中找到程序，传输入参数后执行。\n\n该内容位于文档的服务端接口部分，详细介绍了TuGraph中过程式图查询语言（Procedure API）、图分析编程框架（OLAP API）和图神经网络编程框架（GNN API）的功能和特点，以及它们与描述式图查询语言之间的关系。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_115.md",
        "chunks": [
            {
                "content": "# HTAP\n\n> 此文档主要介绍 TuGraph 的HTAP的设计理念。\n\n## 1.简介\n\nHTAP 架构支持同时执行事务操作和分析操作，以满足不同应用场景的需求。\n\nHTAP 主要将不同类型的图操作划分为三类：事务操作、简单图分析操作和复杂图分析操作。每类操作在应用场景、模式、计算、执行方式和存储上各有不同的设计：\n\n1. **事务操作**：主要用于处理 OLTP（在线事务处理），在 TuGraph 中以 **K-Hop**（K阶邻居查找）为例。\n   - **应用**：K-Hop\n   - **模式**：事务模式\n   - **计算**：通过 Cypher 语言进行查询\n   - **执行**：并发执行\n   - **存储**：图存储\n\n2. **简单图分析操作**：适用于一些轻量级的图分析任务，如 **SPSP**（单源最短路径）和 **Jaccard** 相似度计算。\n   - **应用**：SPSP 和 Jaccard\n   - **模式**：通过插件或嵌入式方式来实现\n   - **计算**：使用 Procedure API 来进行处理\n   - **执行**：并行执行\n   - **存储**：图存储\n\n3. **复杂图分析操作**：适用于较重的分析任务，如 **PageRank** 和 **Louvain**（社区发现算法）。\n   - **应用**：PageRank 和 Louvain\n   - **模式**：独立运行\n   - **计算**：使用 OLAP API\n   - **执行**：单独执行\n   - **存储**：外部存储\n\n\nHTAP 的实现在架构上有多种不同的方式：一是用两个不同的副本来分别处理 OLTP 和 OLAP 的任务，核心是数据的一致性同步和额外的资源开销；二是在任何时候都使用同一份数据存储，该实现的数据结构存在内存膨胀，在工业化落地还需要进一步工作。在 TuGraph 的设计中，简单的 OLAP 操作和 OLTP 操作共用一份数据，而复杂的 OLAP 操作则单独导出快照处理。\n\nTuGraph 的设计中强调和确保了 OLTP 和 OLAP 操作的数据一致性和性能隔离，同时支持灵活的存储和执行模式，以适应不同的图数据操作需求。\n## 2.设计\n\n此文档主要介绍 TuGraph 的 HTAP 设计理念，重点阐述了 HTAP 架构的三个主要操作类型：事务操作、简单图分析操作和复杂图分析操作，以及它们在应用场景、模式、计算、执行方式和存储上的不同设计理念。随后，文档进一步讨论了 TuGraph 的设计架构和 OLTP、OLAP 操作的数据一致性及性能隔离问题。"
            },
            {
                "content": "3. **复杂图分析操作**：适用于较重的分析任务，如 **PageRank** 和 **Louvain**（社区发现算法）。\n   - **应用**：PageRank 和 Louvain\n   - **模式**：独立运行\n   - **计算**：使用 OLAP API\n   - **执行**：单独执行\n   - **存储**：外部存储\n\n\nHTAP 的实现在架构上有多种不同的方式：一是用两个不同的副本来分别处理 OLTP 和 OLAP 的任务，核心是数据的一致性同步和额外的资源开销；二是在任何时候都使用同一份数据存储，该实现的数据结构存在内存膨胀，在工业化落地还需要进一步工作。在 TuGraph 的设计中，简单的 OLAP 操作和 OLTP 操作共用一份数据，而复杂的 OLAP 操作则单独导出快照处理。\n\nTuGraph 的设计中强调和确保了 OLTP 和 OLAP 操作的数据一致性和性能隔离，同时支持灵活的存储和执行模式，以适应不同的图数据操作需求。\n## 2.设计\n\n在 TuGraph 中，OLTP 为图事务引擎，在图 4.4对应事务操作；OLAP 为图分析引擎，对应简单图分析操作（比如 SPSP）和复杂图分析操作（比如 PageRank），前者可以直接在图存储上执行，而后者需要额外导出快照执行。\n\n- 事务操作，即图事务引擎测的操作，为局部图的增删查改操作，典型的应用为 K 跳访问 K-Hop。\n- 简单分析操作，是图分析引擎中较为简单的部分，通常也是局部的图分析操作，比如两点间最短路算法 SPSP、Jaccard 算法。\n- 复杂分析操作，是图分析引擎中较为复杂的部分，通常涉及全图的多轮数据迭代操作，比如网页排序算法 PageRank、社区发现算法 Louvain。\n\n如架构图所示，我们在图中增加了外部存储，使得图分析的数据源不局限在图数据库中，可以直接从文本文件读取。\n\n该文档主要介绍 TuGraph 的 HTAP 架构设计，重点讨论了事务操作、简单图分析操作和复杂图分析操作的分类及其实现，特别是复杂图分析操作如 PageRank 和 Louvain 的处理方式，同时阐述了数据一致性、性能隔离和存储模式的设计理念。该块内容专注于复杂图分析操作的概述及其在 TuGraph 中的架构实现。"
            },
            {
                "content": "TuGraph 的设计中强调和确保了 OLTP 和 OLAP 操作的数据一致性和性能隔离，同时支持灵活的存储和执行模式，以适应不同的图数据操作需求。\n## 2.设计\n\n在 TuGraph 中，OLTP 为图事务引擎，在图 4.4对应事务操作；OLAP 为图分析引擎，对应简单图分析操作（比如 SPSP）和复杂图分析操作（比如 PageRank），前者可以直接在图存储上执行，而后者需要额外导出快照执行。\n\n- 事务操作，即图事务引擎测的操作，为局部图的增删查改操作，典型的应用为 K 跳访问 K-Hop。\n- 简单分析操作，是图分析引擎中较为简单的部分，通常也是局部的图分析操作，比如两点间最短路算法 SPSP、Jaccard 算法。\n- 复杂分析操作，是图分析引擎中较为复杂的部分，通常涉及全图的多轮数据迭代操作，比如网页排序算法 PageRank、社区发现算法 Louvain。\n\n如架构图所示，我们在图中增加了外部存储，使得图分析的数据源不局限在图数据库中，可以直接从文本文件读取。\n\n- 图存储，即图数据库中的存储，有精心设计的数据结构，能够完成实时增删查改。\n- 外部存储，可以是 RDBMS 或文本文件，以边表的简单方式存储，仅供一次性批量读取，和批量结果写入。在计算层，和整体架构图中的接口对应。\n- Cypher，描述式图查询语言，可以并发执行。\n- Procedure API，过程式图查询语言，其灵活性能够同时支持事务操作和图分析操作，但效率上不足以完成复杂图分析操作，可以并发执行。\n- OLAP API，针对多轮迭代的复杂图分析。应用需要先将存储中的图数据导出成内存中的一个快照，该快照仅用来快速访问，而不需要考虑 ACID 的写支持，因此可以排布地更加紧凑，CSR 排布的读效率要远高于图存储的数据排布。OLAP API 只能串行执行，每个操作都用满 CPU 资源。\n\nOLAP API 的快照可以从外部存储创建，即将边表数据构成件 CSR 的格式；或者从图存储中创建。需要注意的是，OLAP API 要求点的 ID 是连续的自然数，可能需要额外的 ID 映射，该步骤在创建快照时可以在指定一个属性进行映射，或直接取属性值作为 ID。\n\n与计算接口和存储相对应，有四种运行模式。\n\n该块内容位于文档的第二部分，主要探讨 TuGraph 的设计理念，重点阐述 OLTP 和 OLAP 操作的结构及其在图数据处理中的应用与功能。它详细描述了事务操作、简单和复杂图分析操作的定义、执行方式、存储结构，以及相关的计算接口和四种运行模式。"
            },
            {
                "content": "- 图存储，即图数据库中的存储，有精心设计的数据结构，能够完成实时增删查改。\n- 外部存储，可以是 RDBMS 或文本文件，以边表的简单方式存储，仅供一次性批量读取，和批量结果写入。在计算层，和整体架构图中的接口对应。\n- Cypher，描述式图查询语言，可以并发执行。\n- Procedure API，过程式图查询语言，其灵活性能够同时支持事务操作和图分析操作，但效率上不足以完成复杂图分析操作，可以并发执行。\n- OLAP API，针对多轮迭代的复杂图分析。应用需要先将存储中的图数据导出成内存中的一个快照，该快照仅用来快速访问，而不需要考虑 ACID 的写支持，因此可以排布地更加紧凑，CSR 排布的读效率要远高于图存储的数据排布。OLAP API 只能串行执行，每个操作都用满 CPU 资源。\n\nOLAP API 的快照可以从外部存储创建，即将边表数据构成件 CSR 的格式；或者从图存储中创建。需要注意的是，OLAP API 要求点的 ID 是连续的自然数，可能需要额外的 ID 映射，该步骤在创建快照时可以在指定一个属性进行映射，或直接取属性值作为 ID。\n\n与计算接口和存储相对应，有四种运行模式。\n\n- 事务模式，每个操作对应一条 Cypher 语句，默认是一个事务。\n- Plugin 模式，通过插件的方式，在计算逻辑加载到服务端后调用，也叫存储过程。\n- Embed 模式，和 Plugin 模式的使用接口一致，区别是图数据库服务不需要起来，就可以直接用接口调用数据库中的数据，通常用于调试 Procedure API 和OLAP API 的代码，调试信息和操作步骤比 Plugin 模式更加友好。\n- Standalone 模式，最大程度剥离与图数据库的关系，仅想用图分析引擎做数据分析时，该模式会比较直接。Standalone 模式会直接使用外部存储的数据。\n\n图神经网络引擎的使用方式和 ‘复杂图分析操作’ 类似，会同时调用部分 OLAP API 和 GNN API，不在这里展开。\n\n该段落详细介绍了 TuGraph 中的存储方式、计算接口以及四种运行模式，包括图存储、外部存储、Cypher 语言、Procedure API 和 OLAP API。并且阐述了 OLAP API 快照的创建过程及其要求，最后指出图神经网络引擎的使用方式。此内容属于第二部分“设计”中的关键细节，补充说明了 HTAP 架构的具体实现和操作。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_116.md",
        "chunks": [
            {
                "content": "# K8S集群部署\n## 准备K8S环境\n\n这里以minikube为例，单机模拟K8S集群。如果已有K8S集群可以直接使用，跳过该部分。\n\n创建geaflow服务账号，否则程序无权限新建k8s资源（只有第一次需要）\n```shell\n# 创建服务账号\nkubectl create serviceaccount geaflow\nkubectl create clusterrolebinding geaflow-role-binding --clusterrole=edit --serviceaccount=default:geaflow --namespace=default\n```\n\n最后，为了使docker内的容器可以访问minikube api，需要将minikube代理到${your_local_ip}:8000，使得其他容器可以通过此端口直接访问minikube。\n\n注意不要关闭proxy所属的terminal进程，后续操作请另起终端进行。\n```shell\n# 创建端口号8000的代理\nkubectl proxy --port=8000 --address='${your_local_ip}' --accept-hosts='^.*' &\n```\n\n## 构建镜像\n下载GeaFlow源码，构建GeaFlow引擎镜像和GeaFlow Console平台镜像。\n```shell\ngit clone https://github.com/TuGraph-family/tugraph-analytics.git\ncd tugraph-analytics/\nbash ./build.sh --all\n```\n\n镜像编译成功后，通过以下命令查看镜像：\n```shell\n# check geaflow image\neval $(minikube docker-env)\ndocker images\n\n该文档介绍了K8S集群的部署过程，特别是如何使用minikube进行单机模拟K8S集群的环境准备，包括创建服务账号、设置代理以及构建GeaFlow引擎和控制台的镜像。此部分内容为部署前的准备工作，确保后续操作的顺利进行。"
            },
            {
                "content": "注意不要关闭proxy所属的terminal进程，后续操作请另起终端进行。\n```shell\n# 创建端口号8000的代理\nkubectl proxy --port=8000 --address='${your_local_ip}' --accept-hosts='^.*' &\n```\n\n## 构建镜像\n下载GeaFlow源码，构建GeaFlow引擎镜像和GeaFlow Console平台镜像。\n```shell\ngit clone https://github.com/TuGraph-family/tugraph-analytics.git\ncd tugraph-analytics/\nbash ./build.sh --all\n```\n\n镜像编译成功后，通过以下命令查看镜像：\n```shell\n# check geaflow image\neval $(minikube docker-env)\ndocker images\n\n# check geaflow-console image\neval $(minikube docker-env --unset)\ndocker images\n```\n默认构建的GeaFlow平台镜像名为geaflow-console:0.1，引擎镜像名为geaflow:0.1。平台镜像geaflow-console:0.1启动后可以通过浏览器访问GeaFlow控制台，创建提交GeaFlow作业。GeaFlow作业运行时默认基于构建好的引擎镜像geaflow:1.0。\n\n## 启动容器\n\n本地启动GeaFlow Console平台服务，适用于minikube环境。（需要将${your.host.name}替换为本机对外IP地址）\n\n```shell\ndocker run -d --name geaflow-console -p 8888:8888 -p 3306:3306 -p 6379:6379 -p 8086:8086 -e geaflow.host=${your.host.name} geaflow-console:0.1\n```\n\n该片段位于K8S集群部署文档中，主要介绍了如何创建Kubernetes代理以及构建GeaFlow引擎和控制台的Docker镜像。此部分紧接在环境准备的步骤之后，为后续的容器启动和服务配置奠定基础。"
            },
            {
                "content": "# check geaflow-console image\neval $(minikube docker-env --unset)\ndocker images\n```\n默认构建的GeaFlow平台镜像名为geaflow-console:0.1，引擎镜像名为geaflow:0.1。平台镜像geaflow-console:0.1启动后可以通过浏览器访问GeaFlow控制台，创建提交GeaFlow作业。GeaFlow作业运行时默认基于构建好的引擎镜像geaflow:1.0。\n\n## 启动容器\n\n本地启动GeaFlow Console平台服务，适用于minikube环境。（需要将${your.host.name}替换为本机对外IP地址）\n\n```shell\ndocker run -d --name geaflow-console -p 8888:8888 -p 3306:3306 -p 6379:6379 -p 8086:8086 -e geaflow.host=${your.host.name} geaflow-console:0.1\n```\n\n启动对外GeaFlow Console平台服务，适用于K8S真实集群环境。（需要将${your.host.name}替换为本机内网IP地址，例如172.xx.xxx.xx；${your.public.ip} 替换为外部公网IP地址，才能从外部访问GeaFlow Console）\n```shell\ndocker run -d --name geaflow-console -p 8888:8888 -p 3306:3306 -p 6379:6379 -p 8086:8086 -e geaflow.host=${your.host.name} geaflow-console:0.1\n```\n\n容器默认以本地模式（local）启动，默认拉起本地的MySQL、Redis、InfluxDB。\n```properties\n# /opt/geaflow/config/application.properties\ngeaflow.deploy.mode=local\ngeaflow.host=127.0.0.1\ngeaflow.gateway.port=8888\ngeaflow.gateway.url=http://${geaflow.host}:${geaflow.gateway.port}\n\n该段落位于文档的“构建镜像”和“启动容器”部分之间，主要介绍了如何检查GeaFlow控制台的镜像，及其默认名称和功能。随后提供了本地和K8S环境中启动GeaFlow Console平台服务的命令和配置说明。"
            },
            {
                "content": "容器默认以本地模式（local）启动，默认拉起本地的MySQL、Redis、InfluxDB。\n```properties\n# /opt/geaflow/config/application.properties\ngeaflow.deploy.mode=local\ngeaflow.host=127.0.0.1\ngeaflow.gateway.port=8888\ngeaflow.gateway.url=http://${geaflow.host}:${geaflow.gateway.port}\n\n# Datasource\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.datasource.url=jdbc:mysql://${geaflow.host}:3306/geaflow?useUnicode=true&characterEncoding=utf8\nspring.datasource.username=geaflow\nspring.datasource.password=geaflow\n```\n\n进入容器等待geaflow-web进程启动完成后，访问 http://localhost:8888 进入GeaFlow Console平台页面。\nK8S集群环境这里为访问对外IP地址的8888端口。\n```shell\n> docker exec -it geaflow-console tailf /tmp/logs/geaflow/app-default.log\n\n# wait the logs below and open url http://localhost:8888\nGeaflowApplication:61   - Started GeaflowApplication in 11.437 seconds (JVM running for 13.475)\n```\n\n该段落描述了GeaFlow控制台容器的默认启动模式为本地模式，提供了相关的配置文件内容以及如何访问GeaFlow Console平台。此部分位于\"K8S集群部署\"文档的\"启动容器\"章节中，主要介绍在本地环境中启动服务的配置与访问方式。"
            },
            {
                "content": "进入容器等待geaflow-web进程启动完成后，访问 http://localhost:8888 进入GeaFlow Console平台页面。\nK8S集群环境这里为访问对外IP地址的8888端口。\n```shell\n> docker exec -it geaflow-console tailf /tmp/logs/geaflow/app-default.log\n\n# wait the logs below and open url http://localhost:8888\nGeaflowApplication:61   - Started GeaflowApplication in 11.437 seconds (JVM running for 13.475)\n```\n\n若希望以集群模式（cluster）启动容器，需要调整datasource配置指向外部数据源，并设置对外的统一服务url地址。容器支持环境变量注入数据源配置和服务url，例如：\n```shell\ndocker run -d --name geaflow-console -p 8888:8888 \\\n-e geaflow.deploy.mode=\"cluster\" \\\n-e geaflow.host=${your.host.name} \\\n-e geaflow.gateway.port=8888 \\\n-e geaflow.gateway.url=${your.geaflow.gateway.url} \\\n-e spring.datasource.url=${your.datasource.url} \\\n-e spring.datasource.username=${your.datasource.username} \\\n-e spring.datasource.password=${your.datasource.password} \\\ngeaflow-console:1.0\n```\n\n如果希望Java进程端口号，只需设置geaflow.gateway.port环境变量，并重新映射端口号即可，如：\n```shell\ndocker run -d --name geaflow-console -p 9999:9999 \\\n-e geaflow.gateway.port=9999 \\\ngeaflow-console:1.0\n```\n\n该内容位于文档的“启动容器”部分，主要描述如何在GeaFlow Console平台中等待服务启动并进行访问，同时提供了切换到集群模式所需的环境变量配置示例。"
            },
            {
                "content": "如果希望Java进程端口号，只需设置geaflow.gateway.port环境变量，并重新映射端口号即可，如：\n```shell\ndocker run -d --name geaflow-console -p 9999:9999 \\\n-e geaflow.gateway.port=9999 \\\ngeaflow-console:1.0\n```\n\n## 注册登录\n首位注册用户将默认被设置为管理员，以管理员身份登录，通过一键安装功能开始系统初始化。\n\n## 一键安装\n管理员首次进入GeaFlow系统，会触发一键安装流程，为系统做初始化准备工作。\n\n### 集群配置\n配置GeaFlow作业的运行时集群，推荐使用Kubernates。本地模式下默认为本地的代理地址${your.host.name}:8000，请确保本地已经启动minikube并设置好代理地址。如果设置K8S集群地址，请确保集群地址的连通性正常。\n\nK8S集群模式添加以下配置\n```\n# 存储限制为10Gi\n\"kubernetes.resource.storage.limit.size\":\"10Gi\"\n# 服务API配置为K8S服务地址，一般为6443端口\n\"kubernetes.master.url\":\"https://${your.host.name}:6443\"\n# 在K8S集群找到 /etc/kubernetes/admin.conf 配置文件，从上到下分别配置以下三个字段\n\"kubernetes.ca.data\":\"\"\n\"kubernetes.cert.data\":\"\"\n\"kubernetes.cert.key\":\"\"\n```\n\n### 运行时配置\n配置GeaFlow作业运行时元数据的存储，运行时元数据包含了作业的Pipeline、Cycle、位点、异常等信息，推荐使用MySQL。\n配置GeaFlow作业运行时HA元数据的存储，HA元数据包含Master、Driver、Container等主要组件信息，推荐使用Redis。\n配置GeaFlow作业运行时指标数据存储，用于作业指标监控，推荐使用InfluxDB。\n\n本地模式下，docker容器启动时会默认自动拉起MySQL、Redis和InfluxDB服务。\n\n该块内容位于文档的“启动容器”部分之后，主要介绍了如何在GeaFlow系统中配置Java进程的端口号、用户注册登录流程以及管理员首次进入系统后的初始化一键安装过程。进一步详述了Kubernetes集群配置及运行时配置，涉及到作业的存储和元数据管理。"
            },
            {
                "content": "### 运行时配置\n配置GeaFlow作业运行时元数据的存储，运行时元数据包含了作业的Pipeline、Cycle、位点、异常等信息，推荐使用MySQL。\n配置GeaFlow作业运行时HA元数据的存储，HA元数据包含Master、Driver、Container等主要组件信息，推荐使用Redis。\n配置GeaFlow作业运行时指标数据存储，用于作业指标监控，推荐使用InfluxDB。\n\n本地模式下，docker容器启动时会默认自动拉起MySQL、Redis和InfluxDB服务。\n\nK8S集群模式添加以下配置\n```\n# influshdb.token可配置为随机值\n\"influxdb.token\":\"f5fb50a361f762a0af045c47d98f66e401f1b632b3133b3dc2680110262d1135\"\n```\n\n### 数据存储配置\n配置GeaFlow作业、图、表等数据的持久化存储，推荐使用HDFS。本地模式默认为容器内磁盘。\n\n### 文件存储配置\n配置GeaFlow引擎JAR、用户JAR文件的持久化存储，推荐使用HDFS。本地模式默认为容器内磁盘。\n\n\n安装成功后，**管理员会自动切换到租户默认下的默认实例**，此时可以直接创建发布图计算任务。\n\n## 工作模式\nGeaFlow控制台支持租户隔离，支持系统模式视角和租户模式视角使用产品功能。\n\n**注意：**\n页面右上角用户图标菜单，提供了快捷的模式切换入口。\n\n### 系统模式\n用户以管理员身份登录后，会进入系统模式。此时可以进行系统的一键安装、系统管理等操作。\n\n系统模式下，管理员可以管理集群、GeaFlow引擎版本、文件、用户、租户等信息。\n\n### 租户模式\n用户正常登录后，会进入租户模式。此时可以进行图计算的研发和运维操作。\n\n租户模式下，用户可以创建实例、图、表、图计算任务等研发资源，并可以发布图计算任务，提交图计算作业等操作。\n\n\n## 任务管理\n添加图计算任务，使用SQL+GQL的方式描述图计算的业务逻辑。\n\n任务创建后，点击发布，进入作业运维。\n\n## 作业运维\n作业提交前，还可以调整默认生成的任务参数和集群参数，以方便对作业行为进行调整。\n\n访问作业详情页面的其他标签页，查看作业的运行时、指标、容器、异常、日志等信息。\n\n该块内容位于文档中关于GeaFlow系统运行配置的部分，主要介绍了GeaFlow作业的运行时配置、数据存储配置、文件存储配置，以及成功安装后的管理员初始化设置。此外，还描述了系统模式和租户模式的功能和操作流程，包含任务管理和作业运维的相关信息。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_117.md",
        "chunks": [
            {
                "content": "# Process API介绍\nGeaFlow对外提供了一系列Process API，这些API和通用的流批类似，但不完全相同。我们在Source API中已有介绍，其构建出来的source是带有window的，因此GeaFlow所有的Process API也都带有window语义。\n\n该文档主要介绍GeaFlow的Process API，包括其功能、接口说明及入参说明，并提供了相关的示例代码。文档开头部分的内容解释了Process API的基本概念和窗口语义，为后续具体的API接口及示例提供了背景信息。"
            },
            {
                "content": "## 接口\n| API | 接口说明 | 入参说明 |\n| -------- | -------- | -------- |\n|  PWindowStream map(MapFunction mapFunction)     | 通过实现mapFunction，可以将输入的T转换成R向下游输出。     |mapFunction：用户自定义转换逻辑，T表示输入类型，R表示输出类型|\n| PWindowStream filter(FilterFunction filterFunction)     | 通过实现filterFunction，可以将不符合要求的T进行过滤。     |filterFunction：用户自定义过滤逻辑，T表示输入类型|\n|  PWindowStream flatMap(FlatMapFunction flatMapFunction)     | 通过实现flatMapFunction，可以将输入的一个T，生成n个R向下游输出。     |flatMapFunction：用户自定义实现逻辑，T表示输入类型，R表示输出类型。|\n| PWindowStream union(PStream uStream)     | 用于实现将两个输入流进行合并。     |uStream：输入流，T表示输入流类型|\n| PWindowBroadcastStream broadcast()     | 将数据流进行广播。     |无|\n|  PWindowKeyStream keyBy(KeySelector selectorFunction)     | 对输入的record，按照KEY进行shuffle输出。     |selectorFunction：用户自定义选取KEY的逻辑，T表示输入record类型，KEY表示定义的KEY类型。|\n\n该内容块位于Process API介绍部分，详细列出了GeaFlow提供的多个关键API接口及其功能说明，包括map、filter、flatMap等操作。这些API用于数据流处理中的转换、过滤和合并等操作，旨在帮助用户自定义数据处理逻辑。"
            },
            {
                "content": "|  PWindowStream flatMap(FlatMapFunction flatMapFunction)     | 通过实现flatMapFunction，可以将输入的一个T，生成n个R向下游输出。     |flatMapFunction：用户自定义实现逻辑，T表示输入类型，R表示输出类型。|\n| PWindowStream union(PStream uStream)     | 用于实现将两个输入流进行合并。     |uStream：输入流，T表示输入流类型|\n| PWindowBroadcastStream broadcast()     | 将数据流进行广播。     |无|\n|  PWindowKeyStream keyBy(KeySelector selectorFunction)     | 对输入的record，按照KEY进行shuffle输出。     |selectorFunction：用户自定义选取KEY的逻辑，T表示输入record类型，KEY表示定义的KEY类型。|\n| PWindowStream reduce(ReduceFunction reduceFunction)     | 支持两种模式的reduce，对于批而言，其是基于当前一个window内的reduce聚合计算；而对于流而言，则是基于动态增量的全局reduce聚合计算（等同于flink的流式聚合计算）。GeaFlow默认是流聚合计算语义，如果需要批语义，用户可以通过参数开启。     |reduceFunction：用户自定义reduce聚合逻辑，T表示输入record类型。|\n|  PWindowStream aggregate(AggregateFunction aggregateFunction)     | 支持两种模式的aggregate，对于批而言，其是基于当前一个window内的aggregate聚合计算；而对于流而言，则是基于动态增量的全局aggregate聚合计算（等同于flink的流式聚合计算）。GeaFlow默认是流聚合计算语义，如果需要批语义，用户可以通过参数开启。     |aggregateFunction：用户自定义聚合计算逻辑，T表示输入类型，ACC为聚合值类型，OUT表示输出类型。|\n\n该段落包含了多个Process API的接口说明及其功能，主要聚焦于流数据处理中的转换、合并、广播、键控、聚合等操作。这些接口是GeaFlow框架的一部分，用户可通过自定义逻辑实现相应的数据处理功能。"
            },
            {
                "content": "|  PWindowStream aggregate(AggregateFunction aggregateFunction)     | 支持两种模式的aggregate，对于批而言，其是基于当前一个window内的aggregate聚合计算；而对于流而言，则是基于动态增量的全局aggregate聚合计算（等同于flink的流式聚合计算）。GeaFlow默认是流聚合计算语义，如果需要批语义，用户可以通过参数开启。     |aggregateFunction：用户自定义聚合计算逻辑，T表示输入类型，ACC为聚合值类型，OUT表示输出类型。|\n| PIncStreamView materialize()     | 用于标识聚合计算是基于流还是批，默认无须调用该接口。     |无|\n表格内容描述:\n\n该块内容位于文档的API接口说明部分，详细介绍了两个特定的Process API接口：`aggregate`和`materialize`。前者支持流和批两种聚合计算方式，后者用于指示聚合计算的类型。此部分在整体文档中为数据流处理功能的实现提供了关键的API参考。"
            },
            {
                "content": "该表格包含三列，分别是“API”、“接口说明”和“入参说明”。以下是各行数据的具体描述：\n\n1. **API:** ` PWindowStream map(MapFunction mapFunction)`  \n   **接口说明:** 通过实现mapFunction，可以将输入的T转换成R向下游输出。  \n   **入参说明:** mapFunction：用户自定义转换逻辑，T表示输入类型，R表示输出类型。\n\n2. **API:** `PWindowStream filter(FilterFunction filterFunction)`  \n   **接口说明:** 通过实现filterFunction，可以将不符合要求的T进行过滤。  \n   **入参说明:** filterFunction：用户自定义过滤逻辑，T表示输入类型。\n\n3. **API:** ` PWindowStream flatMap(FlatMapFunction flatMapFunction)`  \n   **接口说明:** 通过实现flatMapFunction，可以将输入的一个T，生成n个R向下游输出。  \n   **入参说明:** flatMapFunction：用户自定义实现逻辑，T表示输入类型，R表示输出类型。\n\n4. **API:** `PWindowStream union(PStream uStream)`  \n   **接口说明:** 用于实现将两个输入流进行合并。  \n   **入参说明:** uStream：输入流，T表示输入流类型。\n\n5. **API:** `PWindowBroadcastStream broadcast()`  \n   **接口说明:** 将数据流进行广播。  \n   **入参说明:** 无。\n\n6. **API:** ` PWindowKeyStream keyBy(KeySelector selectorFunction)`  \n   **接口说明:** 对输入的record，按照KEY进行shuffle输出。  \n   **入参说明:** selectorFunction：用户自定义选取KEY的逻辑，T表示输入record类型，KEY表示定义的KEY类型。\n\n该段落位于文档的“接口”部分，详细描述了GeaFlow提供的各个Process API的功能及其入参说明，重点说明了数据流处理中的常用操作，如map、filter、flatMap等，为用户自定义实现逻辑提供了指导。"
            },
            {
                "content": "4. **API:** `PWindowStream union(PStream uStream)`  \n   **接口说明:** 用于实现将两个输入流进行合并。  \n   **入参说明:** uStream：输入流，T表示输入流类型。\n\n5. **API:** `PWindowBroadcastStream broadcast()`  \n   **接口说明:** 将数据流进行广播。  \n   **入参说明:** 无。\n\n6. **API:** ` PWindowKeyStream keyBy(KeySelector selectorFunction)`  \n   **接口说明:** 对输入的record，按照KEY进行shuffle输出。  \n   **入参说明:** selectorFunction：用户自定义选取KEY的逻辑，T表示输入record类型，KEY表示定义的KEY类型。\n\n7. **API:** `PWindowStream reduce(ReduceFunction reduceFunction)`  \n   **接口说明:** 支持两种模式的reduce，对于批而言，其是基于当前一个window内的reduce聚合计算；而对于流而言，则是基于动态增量的全局reduce聚合计算。GeaFlow默认是流聚合计算语义，如果需要批语义，用户可以通过参数开启。  \n   **入参说明:** reduceFunction：用户自定义reduce聚合逻辑，T表示输入record类型。\n\n8. **API:** ` PWindowStream aggregate(AggregateFunction aggregateFunction)`  \n   **接口说明:** 支持两种模式的aggregate，对于批而言，其是基于当前一个window内的aggregate聚合计算；而对于流而言，则是基于动态增量的全局aggregate聚合计算。GeaFlow默认是流聚合计算语义，如果需要批语义，用户可以通过参数开启。  \n   **入参说明:** aggregateFunction：用户自定义聚合计算逻辑，T表示输入类型，ACC为聚合值类型，OUT表示输出类型。\n\n该块内容位于GeaFlow的Process API介绍部分，主要列举并详细说明了一系列用于处理数据流的API接口，包括流的合并、广播、键控、减少和聚合等操作。这些接口及其入参说明为用户提供了数据处理的具体实施细节，便于理解和使用。"
            },
            {
                "content": "8. **API:** ` PWindowStream aggregate(AggregateFunction aggregateFunction)`  \n   **接口说明:** 支持两种模式的aggregate，对于批而言，其是基于当前一个window内的aggregate聚合计算；而对于流而言，则是基于动态增量的全局aggregate聚合计算。GeaFlow默认是流聚合计算语义，如果需要批语义，用户可以通过参数开启。  \n   **入参说明:** aggregateFunction：用户自定义聚合计算逻辑，T表示输入类型，ACC为聚合值类型，OUT表示输出类型。\n\n9. **API:** `PIncStreamView materialize()`  \n   **接口说明:** 用于标识聚合计算是基于流还是批，默认无须调用该接口。  \n   **入参说明:** 无。\n\n总体来说，该表格总结了多个API接口及其功能，涵盖了数据流处理中的转换、过滤、合并、广播、键控、聚合等操作，每个API都附带了用户需实现的自定义函数说明。\n\n\n\n## 示例\n```java\n\npublic class StreamUnionPipeline implements Serializable {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(StreamUnionPipeline.class);\n\n    public static final String RESULT_FILE_PATH = \"./target/tmp/data/result/union\";\n    public static final String REF_FILE_PATH = \"data/reference/union\";\n    public static final String SPLIT = \",\";\n\n该文档介绍了GeaFlow的Process API，包括多个API接口及其功能，特别是数据流处理中的聚合和操作方式。所选的内容段落重点讲述了aggregate和materialize两个API的具体功能及入参说明，并引入了示例代码，以展示这些API在实际应用中的用法。"
            },
            {
                "content": "总体来说，该表格总结了多个API接口及其功能，涵盖了数据流处理中的转换、过滤、合并、广播、键控、聚合等操作，每个API都附带了用户需实现的自定义函数说明。\n\n\n\n## 示例\n```java\n\npublic class StreamUnionPipeline implements Serializable {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(StreamUnionPipeline.class);\n\n    public static final String RESULT_FILE_PATH = \"./target/tmp/data/result/union\";\n    public static final String REF_FILE_PATH = \"data/reference/union\";\n    public static final String SPLIT = \",\";\n\n    public static void main(String[] args) {\n        // 获取作业执行环境\n        Environment environment = EnvironmentFactory.onLocalEnvironment();\n        // 执行作业提交\n        IPipelineResult result = submit(environment);\n        result.get();\n        // 关闭执行环境\n        environment.shutdown();\n    }\n\n该块内容总结了GeaFlow提供的Process API的功能，并引入了示例代码，展示如何使用这些API进行数据流处理，包括流的合并和数据的聚合计算。"
            },
            {
                "content": "public static IPipelineResult submit(Environment environment) {\n        Pipeline pipeline = PipelineFactory.buildPipeline(environment);\n        Configuration envConfig = ((EnvironmentContext) environment.getEnvironmentContext()).getConfig();\n        envConfig.getConfigMap().put(FileSink.OUTPUT_DIR, RESULT_FILE_PATH);\n        pipeline.submit(new PipelineTask() {\n            @Override\n            public void execute(IPipelineTaskContext pipelineTaskCxt) {\n                Configuration conf = pipelineTaskCxt.getConfig();\n                PWindowSource streamSource =\n                    pipelineTaskCxt.buildSource(new FileSource(\"data/input\"\n                        + \"/email_edge\",\n                        Collections::singletonList) {}, SizeTumblingWindow.of(5000));\n\n该代码块位于示例部分，展示了如何在GeaFlow中提交一个数据处理作业的具体实现，包括创建管道、配置环境、构建数据源和执行处理逻辑。"
            },
            {
                "content": "PWindowSource streamSource2 =\n                    pipelineTaskCxt.buildSource(new FileSource(\"data/input\"\n                        + \"/email_edge\",\n                        Collections::singletonList) {}, SizeTumblingWindow.of(5000));\n\n该代码块位于示例部分，描述了在数据流处理管道中创建第二个数据源`streamSource2`的过程，该数据源与第一个数据源`streamSource`共同用于后续的流合并操作。这一部分展示了如何配置数据源和窗口策略，进而为聚合操作做好准备。"
            },
            {
                "content": "SinkFunction sink = ExampleSinkFunctionFactory.getSinkFunction(conf);\n                streamSource\n                    // 先将streamSource和streamSource2进行union合并。\n                    .union(streamSource2)\n                    // 对每条消息进行按照SPLIT分隔符进行解析，并将每条数据向下游分发。\n                    .flatMap(new FlatMapFunction() {\n                        @Override\n                        public void flatMap(String value, Collector collector) {\n                            String[] records = value.split(SPLIT);\n                            for (String record : records) {\n                                collector.partition(Long.valueOf(record));\n                            }\n                        }\n                    })\n                    // 构建tuple。\n                    .map(p -> Tuple.of(p, p))\n                    // 按照tuple作为key进行shuffle。\n                    .keyBy(p -> p)\n                    // 进行动态流式增量计算。\n                    .aggregate(new AggFunc())\n                    // 指定agg并发。\n\n该代码块位于示例程序`StreamUnionPipeline`中，展示了如何将两个数据流`streamSource`和`streamSource2`进行合并（union），并对合并后的数据进行处理，包括解析、构建元组、根据键进行shuffle和执行动态流式增量计算，最后指定聚合的并发级别。"
            },
            {
                "content": "for (String record : records) {\n                                collector.partition(Long.valueOf(record));\n                            }\n                        }\n                    })\n                    // 构建tuple。\n                    .map(p -> Tuple.of(p, p))\n                    // 按照tuple作为key进行shuffle。\n                    .keyBy(p -> p)\n                    // 进行动态流式增量计算。\n                    .aggregate(new AggFunc())\n                    // 指定agg并发。\n                    .withParallelism(conf.getInteger(AGG_PARALLELISM))\n                    .map(v -> String.format(\"%s\", v))\n                    .sink(sink)\n                    .withParallelism(conf.getInteger(SINK_PARALLELISM));\n            }\n        });\n\n该代码块位于文档的示例部分，用于展示如何在GeaFlow中实现数据流处理管道中的数据解析、构建元组、键控和聚合操作。具体来说，它展示了对每条消息进行处理、生成元组、按照元组进行键控，并执行动态增量计算的过程。"
            },
            {
                "content": "return pipeline.execute();\n    }\n\n    public static class AggFunc implements\n        AggregateFunction, Tuple, Tuple> {\n\n        // 初始化和创建Accumulator。\n        @Override\n        public Tuple createAccumulator() {\n            return Tuple.of(0L, 0L);\n        }\n\n        // 将value add到accumulator中。\n        @Override\n        public void add(Tuple value, Tuple accumulator) {\n            accumulator.setF0(value.f0);\n            accumulator.setF1(value.f1 + accumulator.f1);\n        }\n\n        // 从accumulator中获取tuple2结果。\n        @Override\n        public Tuple getResult(Tuple accumulator) {\n            return Tuple.of(accumulator.f0, accumulator.f1);\n        }\n\n        @Override\n        public Tuple merge(Tuple a, Tuple b) {\n            return null;\n        }\n    }\n}\n\n```\n\n该代码块位于文档末尾，属于一个名为`StreamUnionPipeline`的示例类。它展示了如何在GeaFlow中实现一个数据流的聚合计算功能，特别是自定义的聚合函数`AggFunc`，该函数用于处理输入数据并维护累加器的状态。此代码块是在执行数据流任务的上下文中定义的，标志着作业执行的结束并提供了聚合操作的具体实现细节。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_118.md",
        "chunks": [
            {
                "content": "# OlapOnDB API\n\n> 此文档主要详细介绍了OlapOnDB API的使用说明\n\n\n## 1. 简介\n\n一般用户需要自己实现的只是将需要分析的子图抽取出来的过程。用户也可以通过使用TuGraph中丰富的辅助接口实现自己的图分析算法。\n\n该文档主要介绍Procedure及Embed的接口设计，并介绍部分常用接口，具体的接口信息参见include/lgraph/olap_on_db.h文件。\n\n## 2. 模型\n\nProcedure及Embed使用到的辅助函数主要包含在OlapOnDB类，还有一些使用频率较高的函数都会逐一介绍\n\n在TuGraph中OLAP相关的有以下常用的数据结构：\n\n1. DB图分析类 `OlapOnDB`\n2. 点数组`ParallelVector`\n3. 点集合`ParallelBitset`\n4. 边数据结构`AdjUnit/AdjUnit`\n5. 边集合数据结构`AdjList`\n\n### 2.1 基于快照的存储结构\n\nTuGraph中的OlapOnDB类能够提供数据“快照”，即建立一个对指定数据集的完全可用拷贝，该拷贝包括相应数据在某个时间点（拷贝开始的时间点）的镜像。由于OLAP的操作仅涉及读操作而不涉及写操作，OlapOnDB会以一种更紧凑的方式对数据进行排布，在节省空间的同时，提高数据访问的局部性。\n\n### 2.2 BSP计算模型\n\nTuGraph在计算的过程中使用了BSP（Bulk Synchronous Parallel）模型，使得该过程能够并行执行，极大的提高了程序运行效率。\n\nBSP计算模型的核心思路为超步（Super Step）的提出和使用。在OlapOnDB创建后，在该数据上的计算分为多个超步，比如PageRank，分为多轮迭代，每轮迭代就是一个超步。不同超步之间用存在显式同步，从而保证所有线程在完成同一超步后同时进入下一个超步。在一个超步内部，所有的线程异步执行，利用并行提升计算效率。\n\n利用BSP计算模型能够有效避免死锁，通过障碍同步的方式能够以硬件方式实现粗粒度的全局同步，使得图计算能够并行化执行，而程序员无需在同步互斥上大费周章。\n\n## 3. 算法举例\n\n在这里对PageRank算法分块做解释，大体上分为主函数`Process`和PageRank算法流程`PageRank`函数\n\n### 3.1 主函数\n\n该文档介绍了OlapOnDB API的使用说明，首先简要说明了如何提取子图以便进行图分析，随后详细阐述了该API的模型结构，包括重要的数据结构和计算模型。在这一节中，重点讲解了基于快照的存储结构和BSP计算模型，为后续的算法示例（如PageRank算法）打下基础。上述内容为主函数的具体实现做了铺垫。"
            },
            {
                "content": "### 2.2 BSP计算模型\n\nTuGraph在计算的过程中使用了BSP（Bulk Synchronous Parallel）模型，使得该过程能够并行执行，极大的提高了程序运行效率。\n\nBSP计算模型的核心思路为超步（Super Step）的提出和使用。在OlapOnDB创建后，在该数据上的计算分为多个超步，比如PageRank，分为多轮迭代，每轮迭代就是一个超步。不同超步之间用存在显式同步，从而保证所有线程在完成同一超步后同时进入下一个超步。在一个超步内部，所有的线程异步执行，利用并行提升计算效率。\n\n利用BSP计算模型能够有效避免死锁，通过障碍同步的方式能够以硬件方式实现粗粒度的全局同步，使得图计算能够并行化执行，而程序员无需在同步互斥上大费周章。\n\n## 3. 算法举例\n\n在这里对PageRank算法分块做解释，大体上分为主函数`Process`和PageRank算法流程`PageRank`函数\n\n### 3.1 主函数\n\n主函数输入有三个参数，`TuGraph`数据库参数`db`，从网页端获取的请求`request`，给网页端的返回值`response`，整体流程可以分为一下几步：\n\n1. 相关参数的获取\n2. 快照类的创建\n3. PageRank算法主流程\n4. 网页端返回值的获取和发送\n\n```C++\nextern \"C\" bool Process(GraphDB & db, const std::string & request, std::string & response) {\n    \n    // 从网页端请求中获取迭代次数（num_iterations），\n    int num_iterations = 20;\n    try {\n        json input = json::parse(request);\n        num_iterations = input[\"num_iterations\"].get();\n    } catch (std::exception & e) {\n        throw std::runtime_error(\"json parse error\");\n        return false;\n    }\n\n该文档主要介绍了OlapOnDB API的使用，包括图分析类的设计、BSP计算模型的应用以及具体的算法示例。上述片段位于文档的第二部分“模型”与第三部分“算法举例”之间，详细阐述了BSP计算模型的概念及其在TuGraph中实现的优势，为后续介绍PageRank算法的主函数和流程提供了背景基础。"
            },
            {
                "content": "// 读事务的创建以及快照类的创建\n    auto txn = db.CreateReadTxn();\n    OlapOnDB olapondb(\n        db,\n        txn,\n        SNAPSHOT_PARALLEL\n    );\n\t\n    // 创建pr数组用于存储每个节点的pr值\n    ParallelVector pr = olapondb.AllocVertexArray();\n    // pagerank算法主流程，获取每个节点的pagerank值\n    PageRankCore(olapondb, num_iterations, pr);\n    \n    auto all_vertices = olapondb.AllocVertexSubset();\n    all_vertices.Fill();\n    /*\n        函数用途：从所有节点中获取pagerank值最大的节点编号\n    \n        函数流程描述：该函数对点集合all_vertices中所有为1的位对应的节点vi（又称为活跃点）执行Func A，再将Func A的返回值作为Func B的第二个输入参数，得到局部最大值（因为第一个输入参数为0，因此实际上返回值就是每个节点的pagerank值），最后再将所有线程的返回值汇总，再次 执行Func B得到全局返回值，并存入max_pr_vi变量中\n    */\n    size_t max_pr_vi = olapondb.ProcessVertexActive(\n        \n        //Func A\n        [&](size_t vi) {\n            return vi;\n        },\n        all_vertices,\n        0,\n        \n        //Func B\n        [&](size_t a, size_t b) {\n            return pr[a] > pr[b] ? a : b;\n        }\n    );\n    \n    // 网页端返回值的获取和发送\n    json output;\n\n该代码段位于文档的第3.1节“主函数”中，具体描述了如何在OlapOnDB中创建读事务和快照，分配用于存储每个节点PageRank值的数组，并调用PageRank算法的主要流程，最终获取PageRank值最大的节点编号。此部分是实现PageRank算法的核心步骤之一。"
            },
            {
                "content": "*/\n    size_t max_pr_vi = olapondb.ProcessVertexActive(\n        \n        //Func A\n        [&](size_t vi) {\n            return vi;\n        },\n        all_vertices,\n        0,\n        \n        //Func B\n        [&](size_t a, size_t b) {\n            return pr[a] > pr[b] ? a : b;\n        }\n    );\n    \n    // 网页端返回值的获取和发送\n    json output;\n    output[\"max_pr_vid\"] = olapondb.OriginalVid(max_pr_vi);\n    output[\"max_pr_val\"] = pr[max_pr_vi];\n    response = output.dump();\n    return true;\n}\n```\n\n该代码块位于文档的第3.1节“主函数”中，是PageRank算法主流程的最后部分，主要负责从计算得到的活跃点中获取Pagerank值最大的节点，并将结果返回给网页端。它展示了如何使用`ProcessVertexActive`函数计算最大Pagerank值及其对应节点的编号。"
            },
            {
                "content": "### 3.2 PageRank算法流程\n\n`pagerank`主流程有两个输入参数，快照类（子图）还有迭代次数，整体流程可以分为以下几步：\n\n1. 相关数据结构的初始化\n1. 每个节点pagerank值的初始化\n1. 每个节点pagerank值的计算，活跃点为所有点（意味着所有点都需要计算pagerank值）\n1. 得到每个节点经过`num_iterations`次迭代后的pagerank值\n\n```C++\nvoid PageRankCore(OlapBase& graph, int num_iterations, ParallelVector& curr) {\n    \n    // 相关数据结构的初始化\n    auto all_vertices = olapondb.AllocVertexSubset();\n    all_vertices.Fill();\n    auto curr = olapondb.AllocVertexArray();\n    auto next = olapondb.AllocVertexArray();\n    size_t num_vertices = olapondb.NumVertices();\n    double one_over_n = (double)1 / num_vertices;\n\n    // 每个节点pagerank值的初始化，和该节点的出度成反比\n    double delta = graph.ProcessVertexActive(\n        [&](size_t vi) {\n            curr[vi] = one_over_n;\n            if (olapondb.OutDegree(vi) > 0) {\n                curr[vi] /= olapondb.OutDegree(vi);\n            }\n            return one_over_n;\n        },\n        all_vertices);\n\n该段落位于文档的第三节“算法举例”中，专注于描述PageRank算法的流程，包括其输入参数以及主要的计算步骤与逻辑。在此之前，文档已介绍了OlapOnDB的基本概念和BSP计算模型，因此该段落补充了对具体算法实现的详细分析，特别是在图数据分析中的应用。"
            },
            {
                "content": "// 每个节点pagerank值的初始化，和该节点的出度成反比\n    double delta = graph.ProcessVertexActive(\n        [&](size_t vi) {\n            curr[vi] = one_over_n;\n            if (olapondb.OutDegree(vi) > 0) {\n                curr[vi] /= olapondb.OutDegree(vi);\n            }\n            return one_over_n;\n        },\n        all_vertices);\n\n    // 总迭代过程\n    double d = (double)0.85;\n        for (int ii = 0;ii < num_iterations;ii ++) {\n        printf(\"delta(%d)=%lf\\n\", ii, delta);\n        next.Fill((double)0);\n\n        /*\n            函数用途：计算所有节点的pagerank值\n\n            函数流程描述：该函数用于计算所有节点的pagerank值，对all_vertices中所有为1的位对应的节点vi执行Func C，得到本轮迭代中vi的pagerank值，并返回vi节点的pagerank变化值，最终经过函数内部处理汇总所有活跃节点的总变化值并返回，该值被存储在delta变量中\n        */\n        delta = graph.ProcessVertexActive(\n            // Func C\n            [&](size_t vi) {\n                double sum = 0;\n\n该代码块位于文档的第3.2节“PageRank算法流程”中，具体描述了在PageRank算法中每个节点的pagerank值初始化与计算过程中所用的函数，特别是如何处理节点的出度影响以及迭代过程中的节点值更新。这部分代码是PageRank计算的核心，实现了对节点的活跃性检测和pagerank值的逐步迭代更新。"
            },
            {
                "content": "/*\n            函数用途：计算所有节点的pagerank值\n\n            函数流程描述：该函数用于计算所有节点的pagerank值，对all_vertices中所有为1的位对应的节点vi执行Func C，得到本轮迭代中vi的pagerank值，并返回vi节点的pagerank变化值，最终经过函数内部处理汇总所有活跃节点的总变化值并返回，该值被存储在delta变量中\n        */\n        delta = graph.ProcessVertexActive(\n            // Func C\n            [&](size_t vi) {\n                double sum = 0;\n\n                // 从邻居中获取当前节点的pagerank值\n                for (auto & edge : olapondb.InEdges(vi)) {\n                    size_t src = edge.neighbour;\n                    sum += curr[src];\n                }\n                next[vi] = sum;\n\n该代码块位于第3.2节“PageRank算法流程”中，具体描述了`ProcessVertexActive`函数的用途和流程，用于计算所有节点在一次迭代中的PageRank值，以及通过汇总活跃节点的变化值来更新`delta`变量的过程。"
            },
            {
                "content": "// 从邻居中获取当前节点的pagerank值\n                for (auto & edge : olapondb.InEdges(vi)) {\n                    size_t src = edge.neighbour;\n                    sum += curr[src];\n                }\n                next[vi] = sum;\n\n                // pagerank值计算核心公式\n                next[vi] = (1 - d) * one_over_n + d * next[vi];\n                if (ii == num_iterations - 1) {\n                    return (double)0;\n                } else {\n    \n                    // 相关中间变量统计\n                    if (olapondb.OutDegree(vi) > 0) {\n                        next[vi] /= olapondb.OutDegree(vi);\n                        return fabs(next[vi] - curr[vi]) * olapondb.OutDegree(vi);\n                    } else {\n                        return fabs(next[vi] - curr[vi]);\n                    }\n                }\n            },\n            all_vertices\n        );\n\n        // 将本轮迭代得到的pagerank值输出作为下一轮迭代的输入\n        curr.Swap(next);\n    }\n}\n```\n\n## 4. 其他常用函数功能描述\n\n### 4.1 事务的创建\n\n```C++\n//读事务的创建\nauto txn = db.CreateReadTxn();\n\n此代码块位于文档的第3.2节“PageRank算法流程”中，具体展示了在PageRank算法迭代过程中，如何从邻居节点获取当前节点的pagerank值，并进行核心计算。代码块后续内容介绍了事务的创建，属于对其他常用函数功能的描述。"
            },
            {
                "content": "// 将本轮迭代得到的pagerank值输出作为下一轮迭代的输入\n        curr.Swap(next);\n    }\n}\n```\n\n## 4. 其他常用函数功能描述\n\n### 4.1 事务的创建\n\n```C++\n//读事务的创建\nauto txn = db.CreateReadTxn();\n\n//写事务的创建\nauto txn = db.CreateWriteTxn();\n```\n\n### 4.2 并行化创建有向图\n\n```C++\nOlapOnDB olapondb(\n    db,\n    txn,\n    SNAPSHOT_PARALLEL\n)\n```\n\n### 4.3 并行化创建无向图\n\n```C++\nOlapOnDB olapondb(\n    db,\n    txn,\n    SNAPSHOT_PARALLEL | SNAPSHOT_UNDIRECTED\n)\n```\n\n### 4.4 获取出度\n\n```C++\nsize_t OutDegree(size_t vid)\n```\n\n### 4.5 获取入度\n\n```C++\nsize_t InDegree(size_t vid)\n```\n\n### 4.6 获取出边集合\n\n```C++\n/*\n    函数名称：AdjList OutEdges(size_t vid)\n    数据结构:\n        AdjList 可以理解为类型为AdjUnit结构体的数组\n        AdjUnit 有两个成员变量： 1. size_t neighbour 2. edge_data，其中neighbour表示该出边指向的目标节点编号，如果为有权图，则edge_data数据类型和输入文件中边的权重值相同，否则数据类型为Empty\n\n    使用示例：输出节点vid的所有出度邻居\n*/\nfor (auto & edge : olapondb.OutEdges(vid)) {\n    size_t dst = edge.neighbour;\n    printf(\"src = %lu,dst = %lu\\n\",vid,dst);\n}\n```\n\n### 4.7 获取入边集合\n\n```C++\nAdjList InEdges(size_t vid)\n\n该代码块主要位于文档的第四部分，介绍了OlapOnDB API中的常用函数功能描述。具体而言，这一段开始于PageRank算法中每轮迭代后的处理，涉及到输出当前迭代的pagerank值以及与事务创建、图结构创建、出入度获取等相关的多种函数实现，用于图分析和数据处理的基础操作。"
            },
            {
                "content": "### 4.5 获取入度\n\n```C++\nsize_t InDegree(size_t vid)\n```\n\n### 4.6 获取出边集合\n\n```C++\n/*\n    函数名称：AdjList OutEdges(size_t vid)\n    数据结构:\n        AdjList 可以理解为类型为AdjUnit结构体的数组\n        AdjUnit 有两个成员变量： 1. size_t neighbour 2. edge_data，其中neighbour表示该出边指向的目标节点编号，如果为有权图，则edge_data数据类型和输入文件中边的权重值相同，否则数据类型为Empty\n\n    使用示例：输出节点vid的所有出度邻居\n*/\nfor (auto & edge : olapondb.OutEdges(vid)) {\n    size_t dst = edge.neighbour;\n    printf(\"src = %lu,dst = %lu\\n\",vid,dst);\n}\n```\n\n### 4.7 获取入边集合\n\n```C++\nAdjList InEdges(size_t vid)\n\n// 使用示例：输出节点vid的所有入度邻居\nfor (auto & edge : olapondb.InEdges(vid)) {\n    size_t dst = edge.neighbour;\n    printf(\"src = %lu,dst = %lu\\n\",vid,dst);\n}\n```\n\n### 4.8 获取TuGraph中节点对应OlapOnDB的节点编号\n\n```C++\nsize_t OriginalVid(size_t vid)\n\n// 备注： TuGraph中输入的节点编号可以是非数字，比如人名等，在生成OlapOnDB子图的时候，会将人名等转化为数字进行后续处理，因此该方法可能不适用于某些特定场景\n```\n\n### 4.9 获取OlapOnDB中节点对应TuGraph的节点编号\n\n```C++\nsize_t MappedVid(size_t original_vid)\n```\n\n### 4.10 活跃点的描述\n\n活跃点指的是在批处理函数中需要处理的点，在本例子中只是输出了活跃点的编号，并且汇总活跃点的数量：\n\n该块内容位于文档的第四部分，主要介绍OlapOnDB API中常用函数的功能描述，具体涵盖了获取入度和出边集合、获取节点编号映射以及活跃点的处理等内容，旨在为用户提供具体的函数调用方法与示例。"
            },
            {
                "content": "```C++\nAdjList InEdges(size_t vid)\n\n// 使用示例：输出节点vid的所有入度邻居\nfor (auto & edge : olapondb.InEdges(vid)) {\n    size_t dst = edge.neighbour;\n    printf(\"src = %lu,dst = %lu\\n\",vid,dst);\n}\n```\n\n### 4.8 获取TuGraph中节点对应OlapOnDB的节点编号\n\n```C++\nsize_t OriginalVid(size_t vid)\n\n// 备注： TuGraph中输入的节点编号可以是非数字，比如人名等，在生成OlapOnDB子图的时候，会将人名等转化为数字进行后续处理，因此该方法可能不适用于某些特定场景\n```\n\n### 4.9 获取OlapOnDB中节点对应TuGraph的节点编号\n\n```C++\nsize_t MappedVid(size_t original_vid)\n```\n\n### 4.10 活跃点的描述\n\n活跃点指的是在批处理函数中需要处理的点，在本例子中只是输出了活跃点的编号，并且汇总活跃点的数量：\n\n```C++\nParallelBitset temp = 000111;\t//当前活跃点为3，4，5号点\n\nsize_t delta = ForEachActiveVertex(\n    //void c\n    [&](size_t vi) {\n        printf(\"active_vertexId = %lu\\n\",vi);\n        return 1;\n    },\n    all_vertices\n);\n```\n\n函数的运行结果显而易见，因为多线程的关系，一下输出顺序可能有所变化：\n\n```\nactive_vertexId = 3\nactive_vertexId = 4\nactive_vertexId = 5\n```\n\n局部返回值均为1，该函数会在保证线程安全的情况下将所有的局部返回值累加得到最终的返回值，并存储在`delta`变量中，该值最终为3\n\n该块内容位于文档的第四部分“其他常用函数功能描述”中，具体介绍了如何获取图中节点的入边集合、对应的节点编号以及描述活跃点的相关操作。这部分内容为用户提供常见函数的使用示例，帮助理解OlapOnDB API的具体应用。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_119.md",
        "chunks": [
            {
                "content": "# Aggregate\n\nGeaFlow支持以下聚合函数：\n* count\n* max\n* min\n* sum\n* avg\n\n## count\n**Syntax**\n\n```sql\nlong count([DISTINCT] Expr)\n```\n**Description**\nCOUNT聚合函数返回聚合分组中的计数数值。聚合分组的初始值为0。\n\n**Example**\n\n```sql\nselect id, count(id) from user group by id;\nselect count(distinct id) from user;\nselect count(1) from user;\n```\n\n## max\n**Syntax**\n\n```sql\nint max(int value)\nlong max(long value)\ndouble max(double value)\nvarchar max(varchar value)\n```\n**Description**\nMAX聚合函数返回聚合分组中的最大值。聚合分组的初始值为null。\n\n**Example**\n\n```sql\nselect id, max(age) from user group by id;\nselect max(name) from user;\n```\n\n## min\n**Syntax**\n\n```sql\nint min(int value)\nlong min(long value)\ndouble min(double value)\nvarchar min(varchar value)\n```\n**Description**\nMIN聚合函数返回聚合分组中的最小值。聚合分组的初始值为null。\n\n**Example**\n\n```sql\nselect id, min(age) from user group by id;\nselect min(name) from user;\n```\n\n## sum\n**Syntax**\n\n该文档介绍了GeaFlow支持的聚合函数，包含计数、最大值、最小值、总和和平均值的语法、描述及示例。所提供的代码示例展示了如何使用这些函数进行数据聚合。"
            },
            {
                "content": "**Example**\n\n```sql\nselect id, max(age) from user group by id;\nselect max(name) from user;\n```\n\n## min\n**Syntax**\n\n```sql\nint min(int value)\nlong min(long value)\ndouble min(double value)\nvarchar min(varchar value)\n```\n**Description**\nMIN聚合函数返回聚合分组中的最小值。聚合分组的初始值为null。\n\n**Example**\n\n```sql\nselect id, min(age) from user group by id;\nselect min(name) from user;\n```\n\n## sum\n**Syntax**\n\n```sql\nint sum([DISTINCT] int value)\nlong sum([DISTINCT] long value)\ndouble sum([DISTINCT] double value)\n```\n**Description**\nSUM聚合函数返回聚合分组中的数值总和。对于整数类型，聚合分组的初始值为0；对于浮点数类型，聚合分组的初始值为0.0。\n\n**Example**\n\n```sql\nselect id, sum(age) from user group by id;\nselect sum(DISTINCT age) from user;\nselect sum(1) from user;\n```\n\n## avg\n**Syntax**\n\n```sql\nint avg([DISTINCT] int value)\nlong avg([DISTINCT] long value)\ndouble avg([DISTINCT] double value)\n```\n**Description**\nAVG聚合函数返回聚合分组中的数值平均值。聚合分组的初始值为null。\n\n**Example**\n\n```sql\nselect id, avg(age) from user group by id;\nselect avg(DISTINCT age) from user;\n```\n\n该块内容包括了聚合函数中的最大值（max）、最小值（min）、总和（sum）和平均值（avg）的语法、描述和示例，位于文档聚合函数部分的中间部分。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_120.md",
        "chunks": [
            {
                "content": "# TuGraph-DataX\n\n> 此文档主要介绍 TuGraph DataX 的安装编译和使用示例\n\n## 1.简介\n\nTuGraph 在阿里开源的 DataX 基础上添加了 TuGraph 的写插件以及 TuGraph jsonline 数据格式的支持，其他数据源可以通过 DataX 往 TuGraph 里面写数据。\nTuGraph DataX 介绍 https://github.com/TuGraph-family/DataX ，支持的功能包括：\n\n- 从 MySQL、SQL Server、Oracle、PostgreSQL、HDFS、Hive、HBase、OTS、ODPS、Kafka 等各种异构数据源导入 TuGraph\n- 将 TuGraph 导入相应的目标源 （待开发）\n\nDataX 原始项目介绍参考 https://github.com/alibaba/DataX\n\n## 2.编译安装\n\n```bash\ngit clone https://github.com/TuGraph-family/DataX.git\nyum install maven\nmvn -U clean package assembly:assembly -Dmaven.test.skip=true\n```\n\n编译出来的 DataX 文件在 target 目录下\n\n## 3. 导入TuGraph\n\n### 3.1.文本数据通过DataX导入TuGraph\n\n我们以 TuGraph 手册中导入工具 lgraph_import 章节举的数据为例子，有三个 csv 数据文件，如下：\n`actors.csv`\n\n```\nnm015950,Stephen Chow\nnm0628806,Man-Tat Ng\nnm0156444,Cecilia Cheung\nnm2514879,Yuqi Zhang\n```\n\n`movies.csv`\n\n```\ntt0188766,King of Comedy,1999,7.3\ntt0286112,Shaolin Soccer,2001,7.3\ntt4701660,The Mermaid,2016,6.3\n```\n\n`roles.csv`\n\n该段落介绍了 TuGraph DataX 的基本信息、安装编译过程及其支持的功能，主要聚焦于如何通过 DataX 导入文本数据到 TuGraph，并提供了示例 CSV 数据文件和相应的 DataX 配置文件。"
            },
            {
                "content": "编译出来的 DataX 文件在 target 目录下\n\n## 3. 导入TuGraph\n\n### 3.1.文本数据通过DataX导入TuGraph\n\n我们以 TuGraph 手册中导入工具 lgraph_import 章节举的数据为例子，有三个 csv 数据文件，如下：\n`actors.csv`\n\n```\nnm015950,Stephen Chow\nnm0628806,Man-Tat Ng\nnm0156444,Cecilia Cheung\nnm2514879,Yuqi Zhang\n```\n\n`movies.csv`\n\n```\ntt0188766,King of Comedy,1999,7.3\ntt0286112,Shaolin Soccer,2001,7.3\ntt4701660,The Mermaid,2016,6.3\n```\n\n`roles.csv`\n\n```\nnm015950,Tianchou Yin,tt0188766\nnm015950,Steel Leg,tt0286112\nnm0628806,,tt0188766\nnm0628806,coach,tt0286112\nnm0156444,PiaoPiao Liu,tt0188766\nnm2514879,Ruolan Li,tt4701660\n```\n\n然后建三个 DataX 的 job 配置文件：\n`job_actors.json`\n\n该块内容位于文档的第三部分，介绍了如何将文本数据通过 DataX 导入 TuGraph，包括示例 CSV 数据文件（如 actors.csv、movies.csv 和 roles.csv）以及相应的 DataX 任务配置文件 (job_actors.json)。该部分提供了具体的操作步骤和示例，以帮助用户理解数据导入的过程。"
            },
            {
                "content": "然后建三个 DataX 的 job 配置文件：\n`job_actors.json`\n\n```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"txtfilereader\",\n          \"parameter\": {\n            \"path\": [\"actors.csv\"],\n            \"encoding\": \"UTF-8\",\n            \"column\": [\n              {\n                \"index\": 0,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 1,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\",\n            \"labelName\": \"actor\",\n            \"batchNum\": 1000,\n            \"properties\": [\"aid\", \"name\"]\n          }\n        }\n      }\n    ]\n  }\n}\n```\n\n在文档的第三部分“导入TuGraph”中，介绍了如何通过DataX将文本数据导入TuGraph。该段落具体阐述了使用DataX创建配置文件的过程，首先以 `job_actors.json` 为例，说明如何配置数据读取器和写入器来处理演员数据，设置相关参数以完成数据的导入。"
            },
            {
                "content": "`job_movies.json`\n\n该部分展示了一个名为 `job_movies.json` 的 DataX 配置文件示例，用于将存储在 CSV 文件中的电影数据导入 TuGraph 系统。此配置文件指定了数据读取来源、数据格式以及如何将数据写入 TuGraph 数据库的详细参数。"
            },
            {
                "content": "```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"txtfilereader\",\n          \"parameter\": {\n            \"path\": [\"movies.csv\"],\n            \"encoding\": \"UTF-8\",\n            \"column\": [\n              {\n                \"index\": 0,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 1,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 2,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 3,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\",\n\n该代码块是文档中关于通过DataX导入TuGraph的示例配置的一部分，具体是用于将电影数据从CSV文件（movies.csv）读取并写入TuGraph图数据库的job配置文件。这一部分展示了如何设置读取器和写入器的参数，以便正确地导入电影数据。"
            },
            {
                "content": "\"index\": 2,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 3,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\",\n            \"labelName\": \"movie\",\n            \"batchNum\": 1000,\n            \"properties\": [\"mid\", \"name\", \"year\", \"rate\"]\n          }\n        }\n      }\n    ]\n  }\n}\n```\n\n该块内容是关于通过 DataX 导入电影数据到 TuGraph 的配置文件片段，具体显示了 movies.csv 文件的列定义和数据写入参数，包括目标图数据库的连接信息和属性映射。在文档的第 3.1 小节中，提供了将文本数据导入 TuGraph 的具体示例，展示了如何使用 DataX 进行数据写入操作。"
            },
            {
                "content": "`job_roles.json`\n\n该块内容位于文档的第3.1节，介绍了如何通过DataX将文本数据导入TuGraph，其中具体示例是`job_roles.json`配置文件，用于将角色数据从CSV文件导入TuGraph。"
            },
            {
                "content": "```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"txtfilereader\",\n          \"parameter\": {\n            \"path\": [\"roles.csv\"],\n            \"encoding\": \"UTF-8\",\n            \"column\": [\n              {\n                \"index\": 0,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 1,\n                \"type\": \"string\"\n              },\n              {\n                \"index\": 2,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"EDGE\",\n            \"labelName\": \"play_in\",\n            \"batchNum\": 1000,\n\n该文本数据导入的配置示例是为了通过 DataX 将名为 `roles.csv` 的文件中的数据导入 TuGraph 数据库，具体配置包括读取器和写入器的参数设置，主要用于定义如何从 CSV 文件读取角色数据并在 TuGraph 中创建边（EDGE）标签为 `play_in` 的关系。"
            },
            {
                "content": "{\n                \"index\": 2,\n                \"type\": \"string\"\n              }\n            ],\n            \"fieldDelimiter\": \",\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"EDGE\",\n            \"labelName\": \"play_in\",\n            \"batchNum\": 1000,\n            \"properties\": [\"SRC_ID\", \"role\", \"DST_ID\"],\n            \"startLabel\": {\"type\": \"actor\", \"key\": \"SRC_ID\"},\n            \"endLabel\": {\"type\": \"movie\", \"key\": \"DST_ID\"}\n          }\n        }\n      }\n    ]\n  }\n}\n```\n\n该代码块为 DataX 的一个作业配置文件片段，具体用于将角色数据从 CSV 文件导入 TuGraph 中，定义了数据写入的目标（边的标签及属性）和连接参数，位于文档中关于导入 TuGraph 数据的章节中。"
            },
            {
                "content": "`./lgraph_server -c lgraph_standalone.json -d 'run'` 启动 TuGraph 后依次执行如下三个命令：\n\n```\npython3 datax/bin/datax.py  job_actors.json\n```\n\n```\npython3 datax/bin/datax.py  job_movies.json\n```\n\n```\npython3 datax/bin/datax.py  job_roles.json\n```\n\n### 3.2.MySQL数据通过DataX导入TuGraph\n\n我们在 `test` database 下建立如下电影 `movies` 表\n\n```sql\nCREATE TABLE `movies` (\n  `mid`  varchar(200) NOT NULL,\n  `name` varchar(100) NOT NULL,\n  `year` int(11) NOT NULL,\n  `rate` float(5,2) unsigned NOT NULL,\n  PRIMARY KEY (`mid`)\n);\n```\n\n往表中插入几条数据\n\n```sql\ninsert into\ntest.movies (mid, name, year, rate)\nvalues\n('tt0188766', 'King of Comedy', 1999, 7.3),\n('tt0286112', 'Shaolin Soccer', 2001, 7.3),\n('tt4701660', 'The Mermaid',   2016,  6.3);\n```\n\n建立一个 DataX 的 job 配置文件\n\n`job_mysql_to_tugraph.json`\n\n**配置字段方式**\n\n该块内容位于文档的第三部分，主要介绍如何通过 DataX 将数据导入 TuGraph，包括从文本文件和 MySQL 数据库导入的具体操作步骤和相关配置文件示例。"
            },
            {
                "content": "**配置字段方式**\n\n```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"mysqlreader\",\n          \"parameter\": {\n            \"username\": \"root\",\n            \"password\": \"root\",\n            \"column\": [\"mid\", \"name\", \"year\", \"rate\"],\n            \"splitPk\": \"mid\",\n            \"connection\": [\n              {\n                \"table\": [\"movies\"],\n                \"jdbcUrl\": [\"jdbc:mysql://127.0.0.1:3306/test?useSSL=false\"]\n              }\n            ]\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\",\n            \"labelName\": \"movie\",\n            \"batchNum\": 1000,\n            \"properties\": [\"mid\", \"name\", \"year\", \"rate\"]\n          }\n        }\n      }\n    ]\n  }\n}\n```\n\n**写简单 sql 方式**\n\n此块内容位于文档的第3.2节，介绍了如何通过DataX将MySQL数据导入TuGraph的配置方式，提供了两种不同的配置示例：一种是配置字段方式，另一种是简单SQL查询方式。"
            },
            {
                "content": "**写简单 sql 方式**\n\n```json\n{\n  \"job\": {\n    \"setting\": {\n      \"speed\": {\n        \"channel\": 1\n      }\n    },\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"mysqlreader\",\n          \"parameter\": {\n            \"username\": \"root\",\n            \"password\": \"root\",\n            \"connection\": [\n              {\n                \"querySql\": [\n                  \"select mid, name, year, rate from test.movies where year > 2000;\"\n                ],\n                \"jdbcUrl\": [\"jdbc:mysql://127.0.0.1:3306/test?useSSL=false\"]\n              }\n            ]\n          }\n        },\n        \"writer\": {\n          \"name\": \"tugraphwriter\",\n          \"parameter\": {\n            \"url\": \"bolt://127.0.0.1:27687\",\n            \"username\": \"admin\",\n            \"password\": \"73@TuGraph\",\n            \"graphName\": \"default\",\n            \"labelType\": \"VERTEX\",\n            \"labelName\": \"movie\",\n            \"batchNum\": 1000,\n            \"properties\": [\"mid\", \"name\", \"year\", \"rate\"]\n          }\n        }\n      }\n    ]\n  }\n}\n```\n\n在文档的第三部分（导入TuGraph）中，介绍了如何将MySQL数据通过DataX导入TuGraph，包括两种配置方式：一种是通过配置字段方式，另一种是通过简单SQL方式。该章节提供了具体的JSON格式配置示例，以便用户能够有效执行数据导入。上述内容即是关于简单SQL方式的配置示例。"
            },
            {
                "content": "`./lgraph_server -c lgraph_standalone.json -d 'run'` 启动 TuGraph 后执行如下命令：\n\n```shell\npython3 datax/bin/datax.py  job_mysql_to_tugraph.json\n```\n\n## 4.导出TuGraph\n\n### 4.1.配置样例\n\nTuGraph支持使用DataX导出数据，使用如下配置即可将数据导出到文本数据中\n\n该片段位于文档的第3节和第4节之间，介绍了如何启动TuGraph并执行用于将MySQL数据导入TuGraph的DataX作业，以及接下来导出TuGraph数据的配置示例。"
            },
            {
                "content": "## 4.导出TuGraph\n\n### 4.1.配置样例\n\nTuGraph支持使用DataX导出数据，使用如下配置即可将数据导出到文本数据中\n\n```json\n{\n    \"job\": {\n        \"setting\": {\n            \"speed\": {\n                 \"channel\":1\n            }\n        },\n        \"content\": [\n            {\n                \"reader\": {\n                    \"name\": \"tugraphreader\",\n                    \"parameter\": {\n                        \"username\": \"admin\",\n                        \"password\": \"73@TuGraph\",\n                        \"graphName\": \"Movie_8C5C\",\n                        \"queryCypher\": \"match (n:person) return n.id,n.name,n.born;\",\n                        \"url\": \"bolt://127.0.0.1:27687\"\n                    }\n                },\n                \"writer\": {\n                    \"name\": \"txtfilewriter\",\n                    \"parameter\": {\n                        \"path\": \"./result\",\n                        \"fileName\": \"luohw\",\n                        \"writeMode\": \"truncate\"\n                    }\n                }\n            }\n        ]\n    }\n}\n```\n\n该块内容位于文档的第四部分，主要介绍如何使用TuGraph和DataX导出数据的配置示例和参数说明。具体包括一个JSON配置文件样例，展示从TuGraph导出数据到文本文件的方式，以及各个参数的详细说明。"
            },
            {
                "content": "使用这个配置文件，可以把TuGraph Movie_8C5C子图中person节点的id,name和born属性全部导出出来，\n导出到当前目录下的result目录中，文件名称为luohw+随机后缀。\n\n### 4.2.参数说明\n\n在使用DataX导出TuGraph数据时，需要将reader设置为tugraphreader并配置以下5个参数：\n\n* **url**\n    * 描述：TuGraph的bolt server地址 \n    * 必选：是 \n    * 默认值：无 \n\n* **username**\n    * 描述：TuGraph的用户名 \n    * 必选：是 \n    * 默认值：无 \n\n* **password**\n    * 描述：TuGraph的密码 \n    * 必选：是 \n    * 默认值：无 \n\n* **graphName**\n    * 描述：所选取的需要同步的TuGraph子图 \n    * 必选：是 \n    * 默认值：无 \n\n* **queryCypher**\n    * 描述：通过cypher语句读取TuGraph中的数据 \n    * 必选：否 \n    * 默认值：无\n\n该段落位于文档的第四部分，主要介绍如何使用DataX导出TuGraph中的数据。具体包含了一个配置文件示例以及导出参数的详细说明，以指导用户正确配置和执行数据导出操作。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_121.md",
        "chunks": [
            {
                "content": "# Token使用说明\n\n## 1.Token介绍\nJWT（JSON Web Token）是一种用于认证和授权的开放标准。它基于JSON（JavaScript Object Notation）格式，并被设计用于在网络应用之间安全地传输声明（claims）信息。\n\nJWT由三部分组成：头部（Header）、负载（Payload）和签名（Signature）。头部包含了JWT的类型以及所使用的签名算法，负载包含了需要传输的信息，而签名用于验证JWT的完整性和真实性。\n\n在TuGraph中，JWT用于实现无状态的认证和授权机制。当用户登录成功后，服务端会生成一个JWT并将其返回给客户端。客户端在后续的请求中将这个JWT作为身份凭证传递给服务端。服务端收到JWT后，通过验证签名和解析负载中的信息，判断用户的身份和权限，并决定是否允许该请求的执行。\n\n## 2. Token有效期\n\n### 2.1. 浏览器Token交互逻辑\n1. 用户打开浏览器，输入账号密码，并点击登录。\n2. 前端调用登录接口，向后端输入账号和密码。\n3. 后端接收到账号密码后，进行校验，校验成功后，返回Token。\n4. 前端将Token存储在浏览器缓存中，后续请求都要携带此Token。\n5. 如果前端，主动点击登出和关闭页面，前端应主动调用登出接口，向后端传递Token。\n6. 后端接收后，将Token失效，返回状态码200，以及“等出成功”。前端接收到信息后，清空浏览器内存中的Token，并将页面退至登录页。\n7. Token失效（初始设置为24小时），需要用户重新登录。\n\n### 2.3. Token有效期刷新机制\n\nToken有效期存在刷新机制，默认关闭。如果打开后，Token的安全性会更高，实现上则存在两个时间戳。\n\n第一个时间戳`refresh_time`用于判定Token是否过期（默认24小时）：过期后可以调用刷新接口获取新的Token，可以设置为更短的时间，比如1小时。\n\n第二个时间戳`expire_time`为强制过期时间戳（默认24小时）：过期后必须重新登陆。\n\n### 2.4. Token有效期修改\n为了方便开发者自行开发，TuGraph提供了两种方式修改有效期，均需要admin权限。\n\n* 通过接口调用设置。涉及有效期修改的接口`update_token_time`和有效期查询接口`get_token_time`。\n\n该文档详细介绍了Token的使用说明，主要包括JWT的基本概念、Token的有效期管理（包括浏览器交互逻辑、刷新机制和修改方式）、以及客户端如何发送Token相关请求等内容。此段落专注于Token的定义、有效期、交互逻辑以及管理方式，是整份文档的核心部分。"
            },
            {
                "content": "### 2.3. Token有效期刷新机制\n\nToken有效期存在刷新机制，默认关闭。如果打开后，Token的安全性会更高，实现上则存在两个时间戳。\n\n第一个时间戳`refresh_time`用于判定Token是否过期（默认24小时）：过期后可以调用刷新接口获取新的Token，可以设置为更短的时间，比如1小时。\n\n第二个时间戳`expire_time`为强制过期时间戳（默认24小时）：过期后必须重新登陆。\n\n### 2.4. Token有效期修改\n为了方便开发者自行开发，TuGraph提供了两种方式修改有效期，均需要admin权限。\n\n* 通过接口调用设置。涉及有效期修改的接口`update_token_time`和有效期查询接口`get_token_time`。\n\n* 通过启动参数设置。server端启动时，添加参数`-unlimited_token 1` 参数可以设置为无期限。\n\n## 3. 客户端发送Token相关请求介绍\n\n客户端会两种协议处理相关请求，一种是REST，一种是RPC。\n\n### 3.1. REST\n如果客户端使用REST协议（包括Browser浏览器），由于是短链接，在每一次请求中都需要携带Token，过期后需要获取新的Token。\n\n对于自行开发的客户端，若采用REST协议则需要考虑Token的逻辑。\n\n### 3.2. RPC\n如果客户端使用RPC协议（包括官方的C++/Java/Python），使用长连接保持，登陆后不涉及Token操作。\n\n## 4. Token上限\nToken上限是指一个用户最多可以同时拥有的Token数量。为防止无限登陆，Token上限默认为10000。由于Token生成逻辑和时间强相关，每登录一次会生成一个Token进行存储，Token有效期默认为24小时，因此建议登录后不使用的Token及时登出。\n\n该部分内容主要介绍了JWT的有效期管理，包括Token的刷新机制和修改方法，以及客户端如何处理Token相关请求。此段位于文档的第二部分和第三部分之间，提供了关于Token有效期的重要细节和开发者的操作指南。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_122.md",
        "chunks": [
            {
                "content": "# 社区角色\n\n## 1. 前言\n本文档描述 TuGraph 社区中成员身份的⻆色，对每种⻆色的要求及权限。 \n\n## 2. ⻆色摘要\n\n这是 TuGraph 社区的⻆色划分，描述了每种⻆色的职责，成为某种⻆色并保持该⻆色的要求，以及相应⻆色的权限。\n\nTuGraph 社区参照 Apache 规范划分为以下三种⻆色：\n\n- Contributor \n- Maintainer \n- PMC \n\n以下描述了每种⻆色的要求、职责和权限。 \t\t \t\t\t\t\t\t \t\t\t\t\t\n## 3. Contributor\n### 3.1. 要求\n在 TuGraph 的任何一个正式项目中成功提交一个 PR 并合并。 \n### 3.2. 职责\n\n- 积极响应指派给您的 Issue 或 PR\n- 一起帮忙回复 Issue 或 PR，把 Issue 分配给对应模块的负责人\n### 3.3. 权限\n\n- 加入 TuGraph GitHub 组织，成为 TuGraph 开源社区的一员。 \n## 4. Maintainer\n### 4.1. 要求\n新的 Committer 由已有的 PMC 推荐，并通过 2/3 以上投票通过，Committer 至少满足以下一个条件：\n\n- 成为社区成员时间超过三个月 \n- 超过 10 个 PMC approve 的 PR \n- 完成重大功能 \n- 修复严重 Bug \n- 长期关注项目发展并参与社区讨论\n### 4.2. 职责\n\n- 社区咨询支持\n- 积极响应指派给您的 Issue 或 PR\n- 对于社区重大决定的投票权\n- Review 社区的 PR \n### 4.3. 权限\n\n- Pull Request review 权限 \n## 5. PMC\n### 5.1. 要求\n\n- 暂不开放，如有强烈愿望请联系PMC\n### 5.2. 职责\n\n- 积极参与社区讨论，对社区重大决策给予指导 \n- 负责保证开源项目的社区活动都能运转良好 \n### 5.3. 权限\n\n- Pull Request review 权限 \n- Pull Request approve 权限 \n- 社区角色成员管理\n\n该文档详细描述了 TuGraph 社区中成员的角色划分，包括 Contributor、Maintainer 和 PMC 三种身份的要求、职责和权限，旨在为社区成员提供明确的参与指南和管理框架。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_123.md",
        "chunks": [
            {
                "content": "# DDL\n## 表相关DDL\n### Create Table\n该命令用来创建一张表，GeaFlow将其识别为外部表并将元数据存储在Catalog中。\n\n**Syntax**\n\n```\nCREATE TABLE  \n(\n\t \n\t[ { ,   } ... ]\n) WITH （\n\ttype = \n\t[ { ,  =  } ... ]\n);\n```\n**Example**\n```sql\nCreate Table v_person_table (\n\tid bigint,\n\tname string,\n\tage int\n) WITH (\n\ttype='file',\n\tgeaflow.dsl.file.path = 'resource:///data/persons.txt'\n);\n```\n这个例子创建了一张表**v_person_table**，包含id, name, age三列，表的存储类型为文件，并通过**geaflow.dsl.file.path**参数说明需要访问的文件存放在引擎资源的指定目录中。\n\n#### 数据类型\n\n| 类型 | 说明 |\n| -------- | -------- |\n| BOOLEAN     | 布尔类型    |\n| SHORT     | 短整形类型，范围: -2^15 + 1 ~ 2^15-1     |\n| INT     |整形类型， 范围: -2^31 + 1 ~ 2^31-1     |\n| LONG     | 长整形类型，范围: -2^63 + 1 ~ 2^63-1     |\n| DOUBLE     |双精度浮点类型，范围: -2^1024 ~ +2^1024     |\n| VARCHAR     |字符串类型  |\n| TIMESTAMP   | 时间戳类型 |\n表格内容描述: 本表格包含两列，分别为“类型”和“说明”。\n\n该块内容位于文档的DDL部分，具体是关于表相关DDL的创建表命令，包括语法示例和数据类型说明，用于指导用户如何在GeaFlow中创建外部表并定义表的结构与存储类型。"
            },
            {
                "content": "#### 数据类型\n\n| 类型 | 说明 |\n| -------- | -------- |\n| BOOLEAN     | 布尔类型    |\n| SHORT     | 短整形类型，范围: -2^15 + 1 ~ 2^15-1     |\n| INT     |整形类型， 范围: -2^31 + 1 ~ 2^31-1     |\n| LONG     | 长整形类型，范围: -2^63 + 1 ~ 2^63-1     |\n| DOUBLE     |双精度浮点类型，范围: -2^1024 ~ +2^1024     |\n| VARCHAR     |字符串类型  |\n| TIMESTAMP   | 时间戳类型 |\n表格内容描述: 本表格包含两列，分别为“类型”和“说明”。 \n\n- 第一行数据为“BOOLEAN”，其说明为“布尔类型”。\n- 第二行数据为“SHORT”，其说明为“短整形类型，范围: -2^15 + 1 ~ 2^15-1”。\n- 第三行数据为“INT”，其说明为“整形类型，范围: -2^31 + 1 ~ 2^31-1”。\n- 第四行数据为“LONG”，其说明为“长整形类型，范围: -2^63 + 1 ~ 2^63-1”。\n- 第五行数据为“DOUBLE”，其说明为“双精度浮点类型，范围: -2^1024 ~ +2^1024”。\n- 第六行数据为“VARCHAR”，其说明为“字符串类型”。\n- 第七行数据为“TIMESTAMP”，其说明为“时间戳类型”。\n\n总体来看，该表格详细列出了几种数据类型及其特点，包括布尔类型、不同长度的整型及浮点型、字符串和时间戳类型，提供了清晰的数据类型定义和范围说明。\n\n#### 参数\n创建表的同时，可以使用WITH指定表的参数信息，其中type参数用于指定外部表的存储类型，其他参数为kv类型。\n\n该段落位于文档中关于数据类型的部分，详细列出了支持的几种数据类型及其说明，包括布尔型、整型、浮点型、字符串和时间戳类型，为用户在创建表时提供了必要的数据类型定义和范围说明。之后的段落介绍了创建表时可以使用的参数信息。"
            },
            {
                "content": "- 第一行数据为“BOOLEAN”，其说明为“布尔类型”。\n- 第二行数据为“SHORT”，其说明为“短整形类型，范围: -2^15 + 1 ~ 2^15-1”。\n- 第三行数据为“INT”，其说明为“整形类型，范围: -2^31 + 1 ~ 2^31-1”。\n- 第四行数据为“LONG”，其说明为“长整形类型，范围: -2^63 + 1 ~ 2^63-1”。\n- 第五行数据为“DOUBLE”，其说明为“双精度浮点类型，范围: -2^1024 ~ +2^1024”。\n- 第六行数据为“VARCHAR”，其说明为“字符串类型”。\n- 第七行数据为“TIMESTAMP”，其说明为“时间戳类型”。\n\n总体来看，该表格详细列出了几种数据类型及其特点，包括布尔类型、不同长度的整型及浮点型、字符串和时间戳类型，提供了清晰的数据类型定义和范围说明。\n\n#### 参数\n创建表的同时，可以使用WITH指定表的参数信息，其中type参数用于指定外部表的存储类型，其他参数为kv类型。\n\n**Example**\n```sql\nCREATE TABLE person (\n\tid   VARCHAR,\n\tname VARCHAR,\n\tage INT\n) WITH (\n\ttype ='file',\n\tgeaflow.dsl.file.path = '/path/to/person/',\n\tgeaflow.dsl.column.separator = '|',\n\tgeaflow.dsl.window.size = 5000\n);\n```\n这个例子创建一个文件类型的表，并指定表参数。其中type指定表类型为文件; geaflow.dsl.file.path文件路径;geaflow.dsl.column.separator指定字段分隔列; geaflow.dsl.window.size指定每批次读取文件的行数。\n\n\n### Create View\n\n**Syntax**\n```\nCREATE VIEW  \n(\n\t\n\t[ { , } ... ]\n) AS\n\t\n;\n```\n\n**Example**\n```sql\nCREATE VIEW console_1 (a, b, c) AS\nSELECT id, name, age FROM v_person_table;\n```\n\n## 图相关DDL\n### Create Graph\n\n该片段主要涉及数据类型的定义，包括布尔、整形、浮点、字符串和时间戳类型的说明，以及创建表时使用的参数示例，之后还介绍了创建视图的语法和示例。它位于文档中关于表DDL的部分，作为对表结构和参数配置的详细说明。"
            },
            {
                "content": "### Create View\n\n**Syntax**\n```\nCREATE VIEW  \n(\n\t\n\t[ { , } ... ]\n) AS\n\t\n;\n```\n\n**Example**\n```sql\nCREATE VIEW console_1 (a, b, c) AS\nSELECT id, name, age FROM v_person_table;\n```\n\n## 图相关DDL\n### Create Graph\n\n**Syntax**\n一个图至少包含一对点边，点表必须包含一个id字段作为主键，边表必须包含srcId和targetId作为主键，边表还可以有一个时间戳字段标识时间。\n\n```\nCREATE GRAPH  \n(\n\t\n\t[ { ,  } ... ]\n\t, \n\t[ { ,  } ... ]\n) WITH （\n\tstoreType = \n\t[ { ,  =  } ... ]\n);\n\n  ::=\nVERTEX \n(\n\t  ID\n\t[ {,   } ... ]\n)\n\n  ::=\nEdge \n(\n\t  SOURCE ID\n\t,   DESTINATION ID\n\t[ ,   TIMESTAMP ]\n\t[ {,   } ... ]\n)\n\n```\n\n**Example**\n```sql\nCREATE GRAPH dy_modern (\n\tVertex person (\n\t\tid bigint ID,\n\t\tname varchar,\n\t\tage int\n\t),\n\tVertex software (\n\t\tid bigint ID,\n\t\tname varchar,\n\t\tlang varchar\n\t),\n\tEdge knows (\n\t\tsrcId bigint SOURCE ID,\n\t\ttargetId bigint DESTINATION ID,\n\t\tweight double\n\t),\n\tEdge created (\n\t\tsrcId bigint SOURCE ID,\n\t\ttargetId bigint DESTINATION ID,\n\t\tweight double\n\t)\n) WITH (\n\tstoreType = 'rocksdb',\n\tshardCount = 2\n);\n```\n这个例子创建了一张包含2个点2个边的图，存储类型为rocksdb, 分片数2个。\n\n该文档介绍了GeaFlow中与数据定义语言（DDL）相关的命令，包括创建表、视图、图及自定义函数的语法和示例。该块内容主要集中在创建视图和图的结构定义，以便用户能够理解如何在GeaFlow中定义和创建图形数据模型。"
            },
            {
                "content": "```\n\n**Example**\n```sql\nCREATE GRAPH dy_modern (\n\tVertex person (\n\t\tid bigint ID,\n\t\tname varchar,\n\t\tage int\n\t),\n\tVertex software (\n\t\tid bigint ID,\n\t\tname varchar,\n\t\tlang varchar\n\t),\n\tEdge knows (\n\t\tsrcId bigint SOURCE ID,\n\t\ttargetId bigint DESTINATION ID,\n\t\tweight double\n\t),\n\tEdge created (\n\t\tsrcId bigint SOURCE ID,\n\t\ttargetId bigint DESTINATION ID,\n\t\tweight double\n\t)\n) WITH (\n\tstoreType = 'rocksdb',\n\tshardCount = 2\n);\n```\n这个例子创建了一张包含2个点2个边的图，存储类型为rocksdb, 分片数2个。\n\n### 图存储\n图的存储类型可以在WITH关联的配置列表中使用storeType配置项指定，目前GeaFlow支持Memory, RocksDB作为图存储格式。\n\n图的存储分片数通过shardCount配置项指定，图的存储分片数影响图计算时的并发数，设为更大的值可以利用更多机器并发计算，但所需资源数也将增长。\n\n## 自定义函数\n### Create Function\n这个命令用来引入一个自定义函数。\n\n**Syntax**\n```\nCREATE FUNCTION  AS \n```\n\n**Example**\n```sql\nCREATE FUNCTION mysssp AS 'com.antgroup.geaflow.dsl.udf.graph.SingleSourceShortestPath';\n```\n\n该块内容位于文档中的“图相关DDL”部分，主要介绍了如何使用CREATE GRAPH命令创建一个图的示例，包括点和边的定义，以及图的存储类型和分片数的配置。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_124.md",
        "chunks": [
            {
                "content": "# 业务开发指南\n## 连接tugraph-db\n### 驱动连接\ntugraph-db兼容neo4j的通讯协议，因此可以使用neo4j的驱动连接tugraph-db的server。\n\nbolt driver 使用例子: https://github.com/TuGraph-family/tugraph-db/tree/master/demo/Bolt\n\n### 终端连接\n驱动是业务代码里面使用的，对于服务器上终端访问，可以使用cli客户端。\n\n\n## 子图操作\n### 创建子图\n```\nCALL dbms.graph.createGraph('graph1')\n```\n### 删除子图\n```\nCALL dbms.graph.deleteGraph('graph1')\n```\n### 清空子图\n#### 删除所有的点边数据和图schema\n```\nCALL db.dropDB()\n```\n#### 只删除所有点边数据, 保留图schema\n```\nCALL db.dropAllVertex()\n```\n### 查看图schema\n```\nCALL dbms.graph.getGraphSchema()\n```\n### 列出所有子图\n```\nCALL dbms.graph.listGraphs()\n```\n\n### 刷新子图文件系统缓存数据\n```\nCALL db.flushDB()\n```\n\n该块内容主要介绍了如何连接tugraph-db，包括使用驱动和终端进行连接的方式，并列出了对子图的基本操作，包括创建、删除、清空子图及查看其schema等。"
            },
            {
                "content": "### 终端连接\n驱动是业务代码里面使用的，对于服务器上终端访问，可以使用cli客户端。\n\n\n## 子图操作\n### 创建子图\n```\nCALL dbms.graph.createGraph('graph1')\n```\n### 删除子图\n```\nCALL dbms.graph.deleteGraph('graph1')\n```\n### 清空子图\n#### 删除所有的点边数据和图schema\n```\nCALL db.dropDB()\n```\n#### 只删除所有点边数据, 保留图schema\n```\nCALL db.dropAllVertex()\n```\n### 查看图schema\n```\nCALL dbms.graph.getGraphSchema()\n```\n### 列出所有子图\n```\nCALL dbms.graph.listGraphs()\n```\n\n### 刷新子图文件系统缓存数据\n```\nCALL db.flushDB()\n```\n\n## 点类型操作\n### 创建点类型（TuGraph通过调用 `db.createVertexLabelByJson` 语句创建点类型）\n如下json定义了一个点类型，名字是`node1`。\n```json\n{\n\t\"label\": \"node1\",\n\t\"primary\": \"id\",\n\t\"type\": \"VERTEX\",\n\t\"detach_property\": true,\n\t\"properties\": [{\n\t\t\"name\": \"id\",\n\t\t\"type\": \"INT32\",\n\t\t\"optional\": false\n\t}, {\n\t\t\"name\": \"name\",\n\t\t\"type\": \"STRING\",\n\t\t\"optional\": false,\n\t\t\"index\": true\n\t}, {\n\t\t\"name\": \"num\",\n\t\t\"type\": \"INT32\",\n\t\t\"optional\": false,\n\t\t\"index\": true,\n\t\t\"unique\": true\n\t}, {\n\t\t\"name\": \"desc\",\n\t\t\"type\": \"STRING\",\n\t\t\"optional\": true\n\t}]\n}\n\n此块内容主要介绍了如何通过CLI客户端连接到TuGraph数据库，并进行子图的创建、删除、清空和查看操作，以及点类型的创建和定义。这部分内容是在商业开发指南中关于数据库操作的基本指南，包含了具体的命令和JSON定义示例，适用于开发者在使用TuGraph进行数据建模时的参考。"
            },
            {
                "content": "## 点类型操作\n### 创建点类型（TuGraph通过调用 `db.createVertexLabelByJson` 语句创建点类型）\n如下json定义了一个点类型，名字是`node1`。\n```json\n{\n\t\"label\": \"node1\",\n\t\"primary\": \"id\",\n\t\"type\": \"VERTEX\",\n\t\"detach_property\": true,\n\t\"properties\": [{\n\t\t\"name\": \"id\",\n\t\t\"type\": \"INT32\",\n\t\t\"optional\": false\n\t}, {\n\t\t\"name\": \"name\",\n\t\t\"type\": \"STRING\",\n\t\t\"optional\": false,\n\t\t\"index\": true\n\t}, {\n\t\t\"name\": \"num\",\n\t\t\"type\": \"INT32\",\n\t\t\"optional\": false,\n\t\t\"index\": true,\n\t\t\"unique\": true\n\t}, {\n\t\t\"name\": \"desc\",\n\t\t\"type\": \"STRING\",\n\t\t\"optional\": true\n\t}]\n}\n\n```\n把上面这个json序列化成字符串，作为参数传入，建议使用驱动的参数化特性，避免自己拼接语句。\n```\nCALL db.createVertexLabelByJson($json_data)\n```\n\n### 查看点类型schema\n```\nCALL db.getVertexSchema('node1')\n```\n\n### 删除点类型\n>该操作会同步删除所有该类型的点数据，数据量大的时候，有时间消耗。\n\n如下例子删除点类型`node1`以及该类型的所有点数据。\n```\nCALL db.deleteLabel('vertex', 'node1')\n```\n\n### 点类型添加字段\n>该操作会同步变更所有该类型点的属性数据，数据量大的时候，有时间消耗。\n\n本节主要介绍了点类型的操作，包括如何创建、查看、删除点类型，以及如何添加和删除字段。这些操作涉及到点的属性定义和管理，是进行图数据库建模和数据结构设定的重要环节。"
            },
            {
                "content": "```\n把上面这个json序列化成字符串，作为参数传入，建议使用驱动的参数化特性，避免自己拼接语句。\n```\nCALL db.createVertexLabelByJson($json_data)\n```\n\n### 查看点类型schema\n```\nCALL db.getVertexSchema('node1')\n```\n\n### 删除点类型\n>该操作会同步删除所有该类型的点数据，数据量大的时候，有时间消耗。\n\n如下例子删除点类型`node1`以及该类型的所有点数据。\n```\nCALL db.deleteLabel('vertex', 'node1')\n```\n\n### 点类型添加字段\n>该操作会同步变更所有该类型点的属性数据，数据量大的时候，有时间消耗。\n\n如下例子，对于点类型`node1`，一次添加了两个字段：`field1`，字符串类型，可选，默认值是 `null`; `field2`，`int64`类型，必选，默认值是0.\n```\nCALL db.alterLabelAddFields('vertex', 'node1', ['field1', string, null ,true], ['field2', int64, 0, false])\n```\n\n### 点类型删除字段\n>该操作会同步变更所有该类型点的属性数据，数据量大的时候，有时间消耗。\n\n如下例子，对于点类型`node1`，一次删除了两个字段: `field1` 和 `field2`。\n```\nCALL db.alterLabelDelFields('vertex', 'node1', ['field1', 'field2'])\n```\n\n### 点类型添加索引\n>该操作会同步构建索引数据，数据量大的时候，有时间消耗。\n\n如下例子，对于点类型`node1`，给`field1`字段添加了一个非唯一索引。\n```\nCALL db.addIndex('node1', 'field1', false)\n```\n如下例子，对于点类型`node1`，给`field2`字段添加了一个唯一索引。\n```\nCALL db.addIndex('node1', 'field2', true)\n```\n\n该文档为《业务开发指南》，主要介绍了如何在TuGraph数据库中进行点类型操作，包括创建、查看、删除点类型，以及添加和删除字段、索引的相关操作。上述片段具体涉及到点类型的创建、查看点类型schema、删除点类型、添加和删除字段及索引的相关命令示例。"
            },
            {
                "content": "### 点类型删除字段\n>该操作会同步变更所有该类型点的属性数据，数据量大的时候，有时间消耗。\n\n如下例子，对于点类型`node1`，一次删除了两个字段: `field1` 和 `field2`。\n```\nCALL db.alterLabelDelFields('vertex', 'node1', ['field1', 'field2'])\n```\n\n### 点类型添加索引\n>该操作会同步构建索引数据，数据量大的时候，有时间消耗。\n\n如下例子，对于点类型`node1`，给`field1`字段添加了一个非唯一索引。\n```\nCALL db.addIndex('node1', 'field1', false)\n```\n如下例子，对于点类型`node1`，给`field2`字段添加了一个唯一索引。\n```\nCALL db.addIndex('node1', 'field2', true)\n```\n\n### 点类型删除索引\n如下例子，对于点类型`node1`，删除字段`field1`上的索引。\n```\nCALL db.deleteIndex('node1', 'field1')\n```\n\n该段落属于文档的“点类型操作”部分，具体介绍了在TuGraph中对点类型进行字段删除、索引添加和索引删除的操作及相应示例。这一部分主要涉及图数据库中点类型的结构调整与优化。"
            },
            {
                "content": "如下例子，对于点类型`node1`，给`field1`字段添加了一个非唯一索引。\n```\nCALL db.addIndex('node1', 'field1', false)\n```\n如下例子，对于点类型`node1`，给`field2`字段添加了一个唯一索引。\n```\nCALL db.addIndex('node1', 'field2', true)\n```\n\n### 点类型删除索引\n如下例子，对于点类型`node1`，删除字段`field1`上的索引。\n```\nCALL db.deleteIndex('node1', 'field1')\n```\n\n\n## 边类型操作\n### 创建边类型（TuGraph通过调用 `db.createEdgeLabelByJson` 语句创建点类型）\n如下json定义了一个边的schema，名字是`edge1`。\n```json\n{\n  \"label\": \"edge1\",\n  \"type\": \"EDGE\",\n  \"detach_property\": true,\n  \"constraints\": [\n    [\"node1\", \"node2\"]\n  ],\n  \"properties\": [{\n    \"name\": \"id\",\n    \"type\": \"INT32\",\n    \"optional\": false\n  }, {\n    \"name\": \"name\",\n    \"type\": \"STRING\",\n    \"optional\": false,\n    \"index\": true\n  }, {\n    \"name\": \"num\",\n    \"type\": \"INT32\",\n    \"optional\": false,\n    \"index\": true,\n    \"unique\": true\n  }, {\n    \"name\": \"desc\",\n    \"type\": \"STRING\",\n    \"optional\": true\n  }]\n}\n```\n把上面这个json序列化成字符串，作为参数传入，建议使用驱动的参数化特性，避免自己拼接语句。\n```\nCALL db.createEdgeLabelByJson($json_data)\n```\n### 查看边类型schema\n```\nCALL db.getEdgeSchema('edge1')\n```\n\n该内容片段属于\"边类型操作\"部分，主要介绍了点类型`node1`的索引管理，包括添加非唯一索引和唯一索引的示例，以及删除索引的操作。紧接着，具体内容进入边类型的创建和管理，包括创建边类型的JSON结构和查看边类型Schema的操作。"
            },
            {
                "content": "### 删除边类型\n>该操作会同步删除所有该类型的边，数据量大的时候，有时间消耗。\n\n如下例子，删除边类型`edge1`以及该类型的所有边数据。\n```\nCALL db.deleteLabel('edge', 'edge1')\n```\n\n### 边类型添加字段\n>该操作会同步变更所有该类型边的属性数据，数据量大的时候，有时间消耗。\n\n如下例子，对于边类型`edge1`，一次添加了两个字段: `field1`，字符串类型，可选，默认值是 `null`; `field2`，`int64`类型，必选，默认值是`0`.\n```\nCALL db.alterLabelAddFields('edge', 'edge1', ['field1', string, null ,true], ['field2', int64, 0, false])\n```\n\n### 边类型删除字段\n>该操作会同步变更所有该类型边的属性数据，数据量大的时候，有时间消耗。\n\n如下操作，对于边类型`edge1`，一次删除了两个字段: `field1` 和 `field2`。\n```\nCALL db.alterLabelDelFields('edge', 'edge1', ['field1', 'field2'])\n```\n\n### 边类型添加索引\n>该操作会同步构建索引数据，数据量大的时候，有时间消耗。\n\n如下例子，对于边类型`edge1`，给字段`field1`添加了一个非唯一索引。\n```\nCALL db.addEdgeIndex('edge1', 'field1', false, false)\n```\n如下例子，对于边类型`edge1`，给字段`field2`添加了一个唯一索引。\n```\nCALL db.addEdgeIndex('edge1', 'field2', true, false)\n```\n\n### 边类型删除索引\n如下例子，对于边类型`edge1`，删除字段`field1`上的索引。\n```\nCALL db.deleteEdgeIndex('edge1', 'field1')\n```\n\n## 实时查看当前点边数据量\n如下例子返回所有的点边类型，以及每种类型当前的数据量是多少。\n\n读的是统计数据，轻操作。\n```\nCALL dbms.meta.countDetail()\n```\n\n此块内容属于文档中的“边类型操作”部分，具体涵盖边类型的删除、字段的添加与删除、索引的管理等操作。这些操作与图数据库中的边类型定义和管理密切相关，适用于用户在使用tugraph-db进行边类型相关数据操控时的参考。"
            },
            {
                "content": "### 边类型添加索引\n>该操作会同步构建索引数据，数据量大的时候，有时间消耗。\n\n如下例子，对于边类型`edge1`，给字段`field1`添加了一个非唯一索引。\n```\nCALL db.addEdgeIndex('edge1', 'field1', false, false)\n```\n如下例子，对于边类型`edge1`，给字段`field2`添加了一个唯一索引。\n```\nCALL db.addEdgeIndex('edge1', 'field2', true, false)\n```\n\n### 边类型删除索引\n如下例子，对于边类型`edge1`，删除字段`field1`上的索引。\n```\nCALL db.deleteEdgeIndex('edge1', 'field1')\n```\n\n## 实时查看当前点边数据量\n如下例子返回所有的点边类型，以及每种类型当前的数据量是多少。\n\n读的是统计数据，轻操作。\n```\nCALL dbms.meta.countDetail()\n```\n\n## 导入数据\n### 批量upsert点数据\n如果不存在就插入点，如果存在就更新点的属性，根据点的主键字段值判断是否存在。\n\n第二个参数是一个`list`类型，每个`list`里面的元素是个`map`类型，每个`map`里面是点的字段和对应的值。\n\n推荐使用driver里面的参数化特性，第二个参数直接传入一个 `list`结构体，避免自己构造语句。\n```\nCALL db.upsertVertex('node1', [{id:1, name:'name1'},{id:2, name:'name2'}])\n```\n### 批量upsert边数据\n如果两点之间不存在某条类型的边就插入，如果存在就更新该边的属性，也就是两点之间同类型的边只能有一条。\n\n第四个参数是一个`list`类型，每个数组里面的元素是个`map`类型，每个`map`里面是：边的起点类型主键字段和对应的值、边的终点类型主键字段和对应的值、边类型自身的属性字段和值。每个map里面至少有两个元素。\n\n第二个参数和第三个参数是为第四个参数服务的。分别说明了起点和终点的类型是什么，以及第四个参数中那个字段代表起点主键字段值，那个字段代表终点主键字段值。\n\n该块内容主要涉及边类型的索引管理操作，包括添加索引和删除索引的具体示例，随后介绍了实时查看当前点边数据量的功能，以及批量插入或更新点和边数据的方法，属于数据操作和管理的部分。这一段落是在导入数据之前，提供了对边类型索引及数据更新的基本操作说明。"
            },
            {
                "content": "第二个参数是一个`list`类型，每个`list`里面的元素是个`map`类型，每个`map`里面是点的字段和对应的值。\n\n推荐使用driver里面的参数化特性，第二个参数直接传入一个 `list`结构体，避免自己构造语句。\n```\nCALL db.upsertVertex('node1', [{id:1, name:'name1'},{id:2, name:'name2'}])\n```\n### 批量upsert边数据\n如果两点之间不存在某条类型的边就插入，如果存在就更新该边的属性，也就是两点之间同类型的边只能有一条。\n\n第四个参数是一个`list`类型，每个数组里面的元素是个`map`类型，每个`map`里面是：边的起点类型主键字段和对应的值、边的终点类型主键字段和对应的值、边类型自身的属性字段和值。每个map里面至少有两个元素。\n\n第二个参数和第三个参数是为第四个参数服务的。分别说明了起点和终点的类型是什么，以及第四个参数中那个字段代表起点主键字段值，那个字段代表终点主键字段值。\n\n注：第二个参数和第三个参数中配置的起点和终点的主键字段并不是起点和终点schema中的主键字段名，只是起一个占位和区别的作用，方便识别第四个参数中哪个字段代表起点和终点的主键字段。\n\n推荐使用driver里面的参数化特性，避免自己构造语句。\n```\nCALL db.upsertEdge('edge1',{type:'node1',key:'node1_id'}, {type:'node2',key:'node2_id'}, [{node1_id:1,node2_id:2,score:10},{node1_id:3,node2_id:4,score:20}])\n```\n\n该块内容位于文档的“导入数据”部分，具体介绍了如何批量插入或更新点数据（使用`upsertVertex`方法）以及边数据（使用`upsertEdge`方法）的操作。它详细说明了每个方法的参数结构及使用建议，适用于用户在操作TuGraph数据库时进行数据导入。"
            },
            {
                "content": "第四个参数是一个`list`类型，每个数组里面的元素是个`map`类型，每个`map`里面是：边的起点类型主键字段和对应的值、边的终点类型主键字段和对应的值、边类型自身的属性字段和值。每个map里面至少有两个元素。\n\n第二个参数和第三个参数是为第四个参数服务的。分别说明了起点和终点的类型是什么，以及第四个参数中那个字段代表起点主键字段值，那个字段代表终点主键字段值。\n\n注：第二个参数和第三个参数中配置的起点和终点的主键字段并不是起点和终点schema中的主键字段名，只是起一个占位和区别的作用，方便识别第四个参数中哪个字段代表起点和终点的主键字段。\n\n推荐使用driver里面的参数化特性，避免自己构造语句。\n```\nCALL db.upsertEdge('edge1',{type:'node1',key:'node1_id'}, {type:'node2',key:'node2_id'}, [{node1_id:1,node2_id:2,score:10},{node1_id:3,node2_id:4,score:20}])\n```\n\n### 批量upsert边数据-根据边的属性确定唯一\n上面描述的upsert逻辑是两点之间同类型的边只能有一条，如果要求两点之间同类型的边可以有多条，并且根据边上的某个属性来确定唯一，需要在原来的基础上多加一个字段，如下：\n```\nCALL db.upsertEdge('edge1',{type:'node1',key:'node1_id'}, {type:'node2',key:'node2_id'}, [{node1_id:1,node2_id:2,score:10},{node1_id:3,node2_id:4,score:20}], 'score')\n```\n在最后多了一个字段`score`, 逻辑变成：如果两点之间不存在一条`edge1`类型的边，并且`score`值等于某个值，就插入；否则就更新改边的属性。\n边上的`score`字段需要提前加上一个特殊的`pair unique`索引，如下：\n```\nCALL db.addEdgeIndex('edge1', 'score', false, true)\n```\n\n### DataX\n\n该块内容主要涉及在TuGraph中批量插入或更新边数据的操作，包括如何使用`upsertEdge`方法以及根据边的属性确保边的唯一性。它还提到使用DataX工具进行数据同步的基本信息，整体属于数据导入与管理的相关操作部分。"
            },
            {
                "content": "### 批量upsert边数据-根据边的属性确定唯一\n上面描述的upsert逻辑是两点之间同类型的边只能有一条，如果要求两点之间同类型的边可以有多条，并且根据边上的某个属性来确定唯一，需要在原来的基础上多加一个字段，如下：\n```\nCALL db.upsertEdge('edge1',{type:'node1',key:'node1_id'}, {type:'node2',key:'node2_id'}, [{node1_id:1,node2_id:2,score:10},{node1_id:3,node2_id:4,score:20}], 'score')\n```\n在最后多了一个字段`score`, 逻辑变成：如果两点之间不存在一条`edge1`类型的边，并且`score`值等于某个值，就插入；否则就更新改边的属性。\n边上的`score`字段需要提前加上一个特殊的`pair unique`索引，如下：\n```\nCALL db.addEdgeIndex('edge1', 'score', false, true)\n```\n\n### DataX\n\nDataX 是阿里云 DataWorks数据集成 的开源版本，在阿里巴巴集团内被广泛使用的离线数据同步工具/平台。DataX 实现了包括 MySQL、Oracle、OceanBase、SqlServer、Postgre、HDFS、Hive、ADS、HBase、TableStore(OTS)、MaxCompute(ODPS)、Hologres、DRDS, databend 等各种异构数据源之间高效的数据同步功能。\n\nhttps://github.com/ljcui/DataX/tree/bolt 自行编译。\n\n这个DataX实现的 tugraph writer 内部调用的是上面描述的`db.upsertVertex`和`db.upsertEdge`，\ntugraph reader 内部调用的是TuGraph 的 bolt client，支持流式读取，\n\n### 离线脱机导入数据\n如果你有子图的schema以及子图里面所有的点边数据（csv或者json格式），可以利用`lgraph_import`工具离线将这些数据生成图数据。\n\n该方式适合初始阶段，先灌进去一批全量数据。注意server要停机，导入完再启动server，可以看到生成的子图数据。\n\n## 导出数据\n\n该chunk位于文档的“导入数据”部分，介绍了如何根据边的属性来进行批量upsert边数据的操作，并随后描述了DataX工具的使用及离线导入数据的方法，紧接着是关于导出数据的相关内容。"
            },
            {
                "content": "https://github.com/ljcui/DataX/tree/bolt 自行编译。\n\n这个DataX实现的 tugraph writer 内部调用的是上面描述的`db.upsertVertex`和`db.upsertEdge`，\ntugraph reader 内部调用的是TuGraph 的 bolt client，支持流式读取，\n\n### 离线脱机导入数据\n如果你有子图的schema以及子图里面所有的点边数据（csv或者json格式），可以利用`lgraph_import`工具离线将这些数据生成图数据。\n\n该方式适合初始阶段，先灌进去一批全量数据。注意server要停机，导入完再启动server，可以看到生成的子图数据。\n\n## 导出数据\n\n### 在线远程流式导出数据\n\nCSV 格式\n```\necho \"match(n:person) return n.id, n.name;\" | lgraph_cli --ip 127.0.0.1 --port 7687 --graph default --user admin --password 73@TuGraph --format csv > output.txt\n```\nJSON 格式\n```\necho \"match(n:person) return n.id, n.name;\" | lgraph_cli --ip 127.0.0.1 --port 7687 --graph default --user admin --password 73@TuGraph --format json > output.txt\n\n```\n### 本地导出整个图的所有数据\n\nCSV 格式\n```\nlgraph_export -d your_db_path -e export_data -g default -f json -u admin -p 73@TuGraph\n```\nJSON 格式\n```\nlgraph_export -d your_db_path -e export_data -g default -f json -u admin -p 73@TuGraph\n```\n\n### 跨版本迁移数据\n\n该内容位于文档的“导入数据”部分之后，介绍了使用DataX工具进行数据导入及其实现原理，并紧接着阐述了离线脱机导入数据的方法，随后展开了关于数据导出的相关操作。"
            },
            {
                "content": "```\n### 本地导出整个图的所有数据\n\nCSV 格式\n```\nlgraph_export -d your_db_path -e export_data -g default -f json -u admin -p 73@TuGraph\n```\nJSON 格式\n```\nlgraph_export -d your_db_path -e export_data -g default -f json -u admin -p 73@TuGraph\n```\n\n### 跨版本迁移数据\n\n对于不兼容的版本之间迁移数据，可以使用`lgraph_export`将旧版本server里面的数据全部导出成文本（里面包含图schema以及所有的点边数据），然后再选择合适的方法将这些文本数据导入到新版本。\n\n该段落位于文档的“导出数据”部分，主要介绍了如何本地导出整个图的数据，包括以CSV和JSON格式导出数据的命令示例，以及跨版本迁移数据的策略。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_125.md",
        "chunks": [
            {
                "content": "# Stream Graph\n\n## 基本概念\n\nStreaming Graph指的是流式、动态、变化的图数据，同时在GeaFlow内部Streaming Graph也指对流式图的计算模式，它针对流式变化的图，基于图的变化进行图遍历、图匹配和图计算等操作。\n\n基于GeaFlow框架，可以方便的针对流式变化的图动态计算。在GeaFlow中，我们抽象了Dynamic Graph和Static Graph两个核心的概念。\n* Dynamic Graph 是指流式变化的图，它是图在时间轴上不断变化的切片所组成，可以方便的研究图随着时间推移的演化过程。\n* Static Graph 是图在某个时间点的 Snapshot，相当于 Dynamic Graph 的一个时间切片。\n\n## 功能描述\n\n\nStreaming Graph 主要有以下几个功能：\n\n* 支持流式地处理点、边数据，支持在最新的图做查询。\n* 支持持续不断的更新和查询图结构，支持图结构变化带来的增量数据处理。\n* 支持回溯历史，基于历史快照做查询。\n* 支持图计算的计算逻辑顺序，例如基于边的时间序做计算。\n\n\n## 示例介绍\n\n读取点、边两个无限数据流增量构图，对于每次增量数据构图完成，会触发 traversal 计算，查找 'Bob' 的2度内的朋友随着时间推移的演进过程。\n\nDSL 代码\n```SQL\n\nset geaflow.dsl.window.size = 1;\n\nCREATE TABLE table_knows (\n  personId int,\n  friendId int,\n  weight int\n) WITH (\n  type='file',\n  geaflow.dsl.file.path = 'resource:///data/table_knows.txt'\n);\n\nINSERT INTO social_network.knows\nSELECT personId, friendId, weight\nFROM table_knows;\n\nCREATE TABLE result (\n  personName varchar,\n  friendName varchar,\n  weight int\n) WITH (\n\ttype='console'\n);\n\n该块内容属于文档的前半部分，主要介绍了Streaming Graph的基本概念、功能描述和示例代码，重点阐述了GeaFlow框架下流式图处理的相关机制和应用示例。"
            },
            {
                "content": "## 示例介绍\n\n读取点、边两个无限数据流增量构图，对于每次增量数据构图完成，会触发 traversal 计算，查找 'Bob' 的2度内的朋友随着时间推移的演进过程。\n\nDSL 代码\n```SQL\n\nset geaflow.dsl.window.size = 1;\n\nCREATE TABLE table_knows (\n  personId int,\n  friendId int,\n  weight int\n) WITH (\n  type='file',\n  geaflow.dsl.file.path = 'resource:///data/table_knows.txt'\n);\n\nINSERT INTO social_network.knows\nSELECT personId, friendId, weight\nFROM table_knows;\n\nCREATE TABLE result (\n  personName varchar,\n  friendName varchar,\n  weight int\n) WITH (\n\ttype='console'\n);\n\n-- Graph View Name Defined in Graph View Concept --\nUSE GRAPH social_network;\n-- find person id 3's known persons triggered every window.\nINSERT INTO result\nSELECT\n\tname,\n\tknown_name,\n\tweight\nFROM (\n  MATCH (a:person where a.name = 'Bob') -[e:knows]->{1, 2}(b)\n  RETURN a.name as name, b.name as known_name, e.weight as weight\n)\n```\n\nHLA 代码\n\n该段落位于文档的中部，主要介绍Streaming Graph的示例和代码实现，包含使用DSL和HLA语言进行流式图构建和遍历的具体示例，以查找名为'Bob'的人的朋友关系。前面部分阐述了Streaming Graph的基本概念和功能描述，后续内容将继续探讨更深入的应用和功能。"
            },
            {
                "content": "CREATE TABLE result (\n  personName varchar,\n  friendName varchar,\n  weight int\n) WITH (\n\ttype='console'\n);\n\n-- Graph View Name Defined in Graph View Concept --\nUSE GRAPH social_network;\n-- find person id 3's known persons triggered every window.\nINSERT INTO result\nSELECT\n\tname,\n\tknown_name,\n\tweight\nFROM (\n  MATCH (a:person where a.name = 'Bob') -[e:knows]->{1, 2}(b)\n  RETURN a.name as name, b.name as known_name, e.weight as weight\n)\n```\n\nHLA 代码\n\n```java \n//build graph view.\nfinal String graphName = \"social_network\";\nGraphViewDesc graphViewDesc = GraphViewBuilder.createGraphView(graphName).build();\npipeline.withView(graphName, graphViewDesc);\n\n// submit pipeLine task.\npipeline.submit(new PipelineTask() {\n\t@Override\n\tpublic void execute(IPipelineTaskContext pipelineTaskCxt) {\n\n该代码块展示了在GeaFlow框架中创建结果表并进行图查询的过程，具体实施了从社交网络图中查找名为'Bob'的人的2度内朋友的SQL查询，同时引入了图视图的概念，为后续的增量图计算和遍历提供了基础。"
            },
            {
                "content": "HLA 代码\n\n```java \n//build graph view.\nfinal String graphName = \"social_network\";\nGraphViewDesc graphViewDesc = GraphViewBuilder.createGraphView(graphName).build();\npipeline.withView(graphName, graphViewDesc);\n\n// submit pipeLine task.\npipeline.submit(new PipelineTask() {\n\t@Override\n\tpublic void execute(IPipelineTaskContext pipelineTaskCxt) {\n\n        // build vertices streaming source.\n\t\tPStreamSource> persons =\n\t\t\tpipelineTaskCxt.buildSource(\n\t\t\t\tnew CollectionSource.(getVertices()), SizeTumblingWindow.of(5000));\n\t\t// build edges streaming source.\n\t\tPStreamSource> knows =\n\t\t\tpipelineTaskCxt.buildSource(\n\t\t\t\tnew CollectionSource<>(getEdges()), SizeTumblingWindow.of(5000));\n\t\t// build graphview by graph name.\n\t\tPGraphView socialNetwork =\n\t\t\tpipelineTaskCxt.buildGraphView(graphName);\n\t\t// incremental build graph view.\n\t\tPIncGraphView incSocialNetwor =\n\t\t\tsocialNetwork.appendGraph(vertices, edges);\n\n该代码块属于文档中“示例介绍”部分，展示了如何使用HLA代码构建和更新流式图（Streaming Graph），具体实现了社交网络中点和边的增量构建，并对节点'Bob'进行遍历查询。"
            },
            {
                "content": "// traversal by 'Bob'.\n\t\tincGraphView.incrementalTraversal(new IncGraphTraversalAlgorithms(2))\n\t\t\t.start('Bob')\n\t\t\t.map(res -> String.format(\"%s,%s\", res.getResponseId(), res.getResponse()))\n\t\t\t.sink(new ConsoleSink<>());\n\t}\n});\n```\n\n该代码块位于文档的示例介绍部分，具体描述了如何在GeaFlow框架中对流式变化图进行操作。它展示了如何对名为'Bob'的节点进行增量遍历，以查找其2度内的朋友，并将结果输出到控制台。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_126.md",
        "chunks": [
            {
                "content": "# 从关系型数据库导入TuGraph\n\n> 使用 DataX，待完善\n\n该文档的主题是关于如何将数据从关系型数据库导入TuGraph，特别提到使用DataX工具进行导入过程，内容尚待完善。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_127.md",
        "chunks": [
            {
                "content": "# 命令行工具\n\n> 此文档主要介绍 lgraph_cypher 文档的使用。\n\nTuGraph 发布版本附带名为`lgraph_cypher`的查询客户端，可用于向 TuGraph 服务器提交 OpenCypher 请求。`lgraph_cypher`客户端有两种执行模式：单命令模式和交互式模式。\n\n## 1.单命令模式\n\n在单命令模式下，`lgraph_cypher`可用于提交单个 Cypher 查询并将结果直接打印到终端，打印结果也可以容易地重定向写入指定文件。当用户需要从服务器获取大量结果并将其保存在文件中时，这非常便利。\n在此模式下，`lgraph_cypher`工具具有以下选项：\n\n### 1.1.命令行参数:\n\n该文档介绍了`lgraph_cypher`命令行工具的使用，包括其两种执行模式（单命令模式和交互式模式），并详细列出了单命令模式下的命令行参数及其说明，为用户提供了提交Cypher查询并处理结果的指导。"
            },
            {
                "content": "| 参数     | 类型   | 说明                                                                     |\n| -------- | ------ | ------------------------------------------------------------------------ | ------ | ----------------------------------------------------------------------------------------------------------------------------------------- |\n| --help   | \\\\     | 列出所有参数及说明。                                                     |\n| -example | \\\\     | 列出命令实例。                                                           |\n| -c       | string | 数据库的配置文件，用于获取 ip 与 port 信息。                             |\n| -h       | string | 数据库服务器 ip 地址，如有配置文件则可舍去此参数。默认值为`127.0.0.1` 。 |\n| -p       | string | 数据库服务器端口，如有配置文件则可舍去此参数。默认值为`7071` 。          |\n| -u       | string | 数据库登录用户名。                                                       |\n| -P       | string | 数据库登录密码。                                                         |\n| -f       | string | 包含单条 Cypher 查询单文本文件的路径。                                   |\n\n该文本块位于文档的“单命令模式”部分，具体介绍了`lgraph_cypher`查询客户端可用的命令行参数及其说明，帮助用户配置和执行数据库查询。"
            },
            {
                "content": "| -c       | string | 数据库的配置文件，用于获取 ip 与 port 信息。                             |\n| -h       | string | 数据库服务器 ip 地址，如有配置文件则可舍去此参数。默认值为`127.0.0.1` 。 |\n| -p       | string | 数据库服务器端口，如有配置文件则可舍去此参数。默认值为`7071` 。          |\n| -u       | string | 数据库登录用户名。                                                       |\n| -P       | string | 数据库登录密码。                                                         |\n| -f       | string | 包含单条 Cypher 查询单文本文件的路径。                                   |\n| -s       | string | 单行 cypher 查询命令。以`\"`开头结尾。                                    |\n| -t       | int    | 进行 cypher 查询时服务器的超时阈值。默认值为`150`秒。 -format            | string | 查询结果显示模式。支持`plain`与`table`两种格式。`plain`格式会将查询结果单列打印。`table`格式会将查询结果以表格方式显示。默认值为`table`。 |\n表格内容描述：\n\n该部分内容位于文档的第一节“单命令模式”下，具体描述了`lgraph_cypher`工具在提交Cypher查询时支持的命令行参数及其说明。这些参数的设置对于用户连接数据库、配置查询及输出结果格式至关重要。"
            },
            {
                "content": "该表格包含三个列名：参数（Parameter）、类型（Type）和说明（Description）。 \n\n- **--help**: 该参数没有特定类型，用于列出所有参数及其说明。\n- **-example**: 同样没有特定类型，用于列出命令实例。\n- **-c**: 字符串类型，指定数据库的配置文件，以获取 IP 和端口信息。\n- **-h**: 字符串类型，用于输入数据库服务器的 IP 地址，如果已配置文件则可以此参数。默认值为 `127.0.0.1`。\n- **-p**: 字符串类型，用于输入数据库服务器的端口，如果已配置文件则可忽略此参数。默认值为 `7071`。\n- **-u**: 字符串类型，指定数据库的登录用户名。\n- **-P**: 字符串类型，指定数据库的登录密码。\n- **-f**: 字符串类型，包含单条 Cypher 查询的文本文件路径。\n- **-s**: 字符串类型，单行 Cypher 查询命令，以 `\"` 开头和结尾。\n- **-t**: 整数类型，在进行 Cypher 查询时，指定服务器的超时阈值。默认值为 `150` 秒。\n- **-format**: 字符串类型，指定查询结果的显示模式。支持 `plain` 和 `table` 两种格式；`plain` 格式将查询结果单列打印，`table` 格式将查询结果以表格方式显示，默认值为 `table`。\n\n总体而言，该表格列出了多个命令行参数及其相关信息，旨在帮助用户进行数据库操作的配置与查询，同时提供了默认值及格式细节。\n\n### 1.2.命令示例:\n\n**cypher 命令文件查询：**\n\n```powershell\n$ ./lgraph_cypher.py -c /home/usr/lgraph_standalone.json -u user -P password -f /home/usr/cypher.json\n```\n\n**cypher 命令单句查询：**\n\n```powershell\n$ ./lgraph_cypher.py -c /home/usr/lgraph_standalone.json -u user -P password -s \"MATCH (n) RETURN n\"\n```\n\n## 2.交互模式\n\n该块内容位于文档的第一部分，主要介绍 `lgraph_cypher` 工具在单命令模式下的命令行参数及其说明，包括各参数的类型、用途及默认值，以及提供的命令示例，旨在帮助用户理解和使用该工具进行数据库操作。"
            },
            {
                "content": "总体而言，该表格列出了多个命令行参数及其相关信息，旨在帮助用户进行数据库操作的配置与查询，同时提供了默认值及格式细节。\n\n### 1.2.命令示例:\n\n**cypher 命令文件查询：**\n\n```powershell\n$ ./lgraph_cypher.py -c /home/usr/lgraph_standalone.json -u user -P password -f /home/usr/cypher.json\n```\n\n**cypher 命令单句查询：**\n\n```powershell\n$ ./lgraph_cypher.py -c /home/usr/lgraph_standalone.json -u user -P password -s \"MATCH (n) RETURN n\"\n```\n\n## 2.交互模式\n\n`lgraph_cypher`也可以在交互模式下运行。在交互式模式下，客户端与服务器保持连接，并在读取-评估-打印-循环中与用户进行交互。\n\n### 2.1.进入 lgraph_cypher 交互模式:\n\n如不加`-f`或`-s`命令行选项，运行`lgraph_cypher`时将会进入交互模式。使用方式如下：\n\n```\n$ ./lgraph_cypher.py -c /home/usr/lgraph_standalone.json -u admin -P 73@TuGraph\n```\n\n如成功进入则会显示相应登录成功信息：\n\n该段落位于文档的第一部分，主要介绍了`lgraph_cypher`命令行工具的使用，包括命令行参数及示例，之后进一步引入交互模式的说明。"
            },
            {
                "content": "**cypher 命令单句查询：**\n\n```powershell\n$ ./lgraph_cypher.py -c /home/usr/lgraph_standalone.json -u user -P password -s \"MATCH (n) RETURN n\"\n```\n\n## 2.交互模式\n\n`lgraph_cypher`也可以在交互模式下运行。在交互式模式下，客户端与服务器保持连接，并在读取-评估-打印-循环中与用户进行交互。\n\n### 2.1.进入 lgraph_cypher 交互模式:\n\n如不加`-f`或`-s`命令行选项，运行`lgraph_cypher`时将会进入交互模式。使用方式如下：\n\n```\n$ ./lgraph_cypher.py -c /home/usr/lgraph_standalone.json -u admin -P 73@TuGraph\n```\n\n如成功进入则会显示相应登录成功信息：\n\n```\n**********************************************************************\n*                  TuGraph Graph Database X.Y.Z                      *\n*                                                                    *\n*        Copyright(C) 2023 Ant Group. All rights reserved.           *\n*                                                                    *\n**********************************************************************\nlogin success\n----------------------------------\nHost: 127.0.0.1\nPort: 7071\nUsername: admin\n----------------------------------\ntype \":help\" to see all commands.\n>\n```\n\n该内容片段位于文档的第二部分，介绍了`lgraph_cypher`工具的交互模式，包括如何进入该模式以及在此模式下运行的基本命令和查询方式。前面部分则集中在单命令模式的使用和相关命令行参数。"
            },
            {
                "content": "现在我们也提供一个交互式 shell ，用于用户输入 Cypher 查询语句或使用`:help`命令来检查可用命令。\n\n### 2.2.command种类与说明:\n\n除 Cypher 查询外，`lgraph_cypher` 的 shell 还接受以下命令：\n\n本段落位于文档的交互模式部分，介绍了`lgraph_cypher`客户端在交互模式下的功能，特别是用户可以输入Cypher查询语句以及使用特殊命令来获取帮助和管理查询。接下来详细列出了可用命令及其说明。"
            },
            {
                "content": "| 命令                     | 对应参数                           | 说明                                                                                                |\n| ------------------------ | ---------------------------------- | --------------------------------------------------------------------------------------------------- |\n| :help                    | \\\\                                 | 显示服务器信息与所有 command 对应说明。                                                             |\n| :db_info                 | \\\\                                 | 当前服务器状态查询。对应 REST API 的/db/info。                                                      |\n| :clear                   | \\\\                                 | 清空屏幕。                                                                                          |\n| :use                     | {图的名称}                         | 使用该名称指定的图，默认值为`default` 。                                                            |\n\n该块内容位于文档的“交互模式”部分，具体介绍了`lgraph_cypher`命令行工具在交互模式下可用的命令及其参数说明，用于用户与数据库的实时交互操作。"
            },
            {
                "content": "| :db_info                 | \\\\                                 | 当前服务器状态查询。对应 REST API 的/db/info。                                                      |\n| :clear                   | \\\\                                 | 清空屏幕。                                                                                          |\n| :use                     | {图的名称}                         | 使用该名称指定的图，默认值为`default` 。                                                            |\n| :source                  | `-t {查询timeout值} -f {查询文件}` | 可交互模式下的 cypher 命令文件查询。超时阈值默认值为`150`秒。查询文件格式参考无交互式查询参数。     |\n| :exit                    | \\\\                                 | 退出交互模式并返回原命令行。                                                                        |\n| :format                  | `plain` or `table`                 | 更改 cypher 查询结果的显示模式。支持`plain`与`table`模式。                                          |\n| :save all/command/result | `-f {文件路径}` `{cypher语句}`     | 存储 cypher 命令（command）或查询结果（result）或以上二者（all）。默认存储位置为`/saved_cypher.txt` |\n\n该块内容位于文档的交互模式部分，具体描述了 `lgraph_cypher` 工具在交互模式下可用的命令及其功能，包括查询服务器状态、清除屏幕、指定图、执行命令文件查询、退出交互模式、修改查询结果显示格式及保存命令或结果等功能。这些命令为用户在交互式环境中操作数据库提供了便利。"
            },
            {
                "content": "| :exit                    | \\\\                                 | 退出交互模式并返回原命令行。                                                                        |\n| :format                  | `plain` or `table`                 | 更改 cypher 查询结果的显示模式。支持`plain`与`table`模式。                                          |\n| :save all/command/result | `-f {文件路径}` `{cypher语句}`     | 存储 cypher 命令（command）或查询结果（result）或以上二者（all）。默认存储位置为`/saved_cypher.txt` |\n表格内容描述:\n\n该片段位于文档的交互模式部分，具体介绍了`lgraph_cypher`工具在交互式shell中可用的命令及其参数说明，包括如何退出交互模式、调整查询结果显示格式，以及保存命令和查询结果的功能。"
            },
            {
                "content": "该表格包含三列，分别为“命令”、“对应参数”和“说明”。 \n\n1. 第一行：命令为`:help`，没有对应参数，说明是用于显示服务器信息与所有命令的对应说明。\n2. 第二行：命令为`:db_info`，没有对应参数，说明用于查询当前服务器状态，对应REST API的/db/info。\n3. 第三行：命令为`:clear`，没有对应参数，说明是用来清空屏幕的。\n4. 第四行：命令为`:use`，对应参数为{图的名称}，说明是使用指定名称的图，默认值为`default`。\n5. 第五行：命令为`:source`，对应参数为`-t {查询timeout值} -f {查询文件}`，说明是可以交互模式下的cypher命令文件查询，超时阈值默认值为`150`秒，查询文件格式参考无交互式查询参数。\n6. 第六行：命令为`:exit`，没有对应参数，说明是用于退出交互模式并返回原命令行。\n7. 第七行：命令为`:format`，对应参数为`plain`或`table`，说明是用于更改cypher查询结果的显示模式，支持`plain`与`table`模式。\n8. 第八行：命令为`:save all/command/result`，对应参数为`-f {文件路径}`和`{cypher语句}`，说明是用于存储cypher命令（command）或查询结果（result）或两者（all），默认存储位置为`/saved_cypher.txt`。\n\n总体来说，该表格列出了多种命令及其相关参数，并提供了对应的说明，主要用于管理服务器状态、命令文件查询、结果显示格式以及数据存储等功能。\n\n**注意:**\n\n- 每条命令都应该以冒号开始 `:`.\n\n**:save 命令例子:**\n\n```\n:save all -f /home/usr/saved.txt match (n) where return n, n.name limit 1000\n```\n\n### 2.3.cypher 查询命令:\n\n在交互模式下，用户也可直接输入单句 cypher 命令进行查询，以\"`;`\"结束。输入命令不区分大小写。例子如下：\n\n该内容位于文档的“交互模式”部分，具体介绍了`lgraph_cypher`工具在交互模式下可用的命令及其参数说明，包括如何使用这些命令进行图数据库的管理和查询。"
            },
            {
                "content": "总体来说，该表格列出了多种命令及其相关参数，并提供了对应的说明，主要用于管理服务器状态、命令文件查询、结果显示格式以及数据存储等功能。\n\n**注意:**\n\n- 每条命令都应该以冒号开始 `:`.\n\n**:save 命令例子:**\n\n```\n:save all -f /home/usr/saved.txt match (n) where return n, n.name limit 1000\n```\n\n### 2.3.cypher 查询命令:\n\n在交互模式下，用户也可直接输入单句 cypher 命令进行查询，以\"`;`\"结束。输入命令不区分大小写。例子如下：\n\n```\nlogin success\n>MATCH (n) RETURN n, n.name;\n+---+---+-------------+\n|   | n |n.name       |\n+---+---+-------------+\n| 0 | 0 |david        |\n| 1 | 1 |Ann          |\n| 2 | 2 |first movie  |\n| 3 | 3 |Andres       |\n表格内容描述: 本表格包含三列，分别为第一列、第二列和第三列。第一列和第二列均为数字，从0到3；第三列则包含四个项目名称或人名。\n\n逐行描述如下：\n1. 第一行数据为(0, 0, \"david\")，表示第一列和第二列均为0，第三列为名称\"david\"。\n2. 第二行数据为(1, 1, \"Ann\")，表示第一列和第二列均为1，第三列为名称\"Ann\"。\n3. 第三行数据为(2, 2, \"first movie\")，表示第一列和第二列均为2，第三列为项目名称\"first movie\"。\n4. 第四行数据为(3, 3, \"Andres\")，表示第一列和第二列均为3，第三列为名称\"Andres\"。\n\n总结：该表格记录了四项数据，其中包括两个人名（david和Ann）、一个电影名称（first movie）以及另一人名（Andres），并以递增的方式对每一项进行了编号。\n+---+---+-------------+\ntime spent: 0.000520706176758\nsize of query: 4\n>\n```\n\n该块内容位于文档的交互模式部分，主要介绍了`lgraph_cypher`的命令种类、使用注意事项，以及如何在交互模式下输入和执行Cypher查询命令的示例和结果。"
            },
            {
                "content": "逐行描述如下：\n1. 第一行数据为(0, 0, \"david\")，表示第一列和第二列均为0，第三列为名称\"david\"。\n2. 第二行数据为(1, 1, \"Ann\")，表示第一列和第二列均为1，第三列为名称\"Ann\"。\n3. 第三行数据为(2, 2, \"first movie\")，表示第一列和第二列均为2，第三列为项目名称\"first movie\"。\n4. 第四行数据为(3, 3, \"Andres\")，表示第一列和第二列均为3，第三列为名称\"Andres\"。\n\n总结：该表格记录了四项数据，其中包括两个人名（david和Ann）、一个电影名称（first movie）以及另一人名（Andres），并以递增的方式对每一项进行了编号。\n+---+---+-------------+\ntime spent: 0.000520706176758\nsize of query: 4\n>\n```\n\n`lgraph_cypher`输入命令时支持多行输入，用户可使用`ENTER`键将长查询语句分多行输入。多行输入情况下命令行开头会从`>`变为`=>`，然后用户可以继续输入查询的其余部分。\n\n例子如下：\n\n```\nlogin success\n>MATCH (n)\n=>WHERE n.uid='M11'\n=>RETURN n, n.name;\n```\n\n### 2.4.辅助功能:\n\n**历史查询：** 在交互模式下按上下方向键可查询输入历史。\n\n**自动补全：** lgraph_cypher 会根据输入历史进行自动补全。在补全提示出现的情况下，按下右方向键就会自动补全命令。\n\n该块内容位于文档的第二部分，详细描述了在交互模式下查询返回结果的结构与示例，包括如何读取查询结果、逐行解读结果、总结数据，同时介绍了支持多行输入及辅助功能如历史查询和自动补全的相关信息。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_128.md",
        "chunks": [
            {
                "content": "# Vector index\n## 创建向量索引\n如下json定义了一个点类型，名字是`person`, 里面有个字段是`embedding`，类型是`FLOAT_VECTOR`，用来存储向量数据。\n目前向量数据只能在点上创建。\n\n```json\n{\n\t\"label\": \"person\",\n\t\"primary\": \"id\",\n\t\"type\": \"VERTEX\",\n\t\"properties\": [{\n\t\t\"name\": \"id\",\n\t\t\"type\": \"INT32\",\n\t\t\"optional\": false\n\t}, {\n\t\t\"name\": \"age\",\n\t\t\"type\": \"INT32\",\n\t\t\"optional\": false\n\t}, {\n\t\t\"name\": \"embedding\",\n\t\t\"type\": \"FLOAT_VECTOR\",\n\t\t\"optional\": false\n\t}]\n}\n\n```\n把上面这个json序列化成字符串，作为参数传入，建议使用驱动的参数化特性，避免自己拼接语句。\n```\nCALL db.createVertexLabelByJson($json_data)\n```\n给`embedding`字段添加向量索引，第三个参数是个map，里面可以设置一些向量索引的配置参数，如下，`dimension`设置向量维度是4\n```\nCALL db.addVertexVectorIndex('person','embedding', {dimension: 4});\n```\n\n再定义一个边，用来测试，如下json定义了一个边类型，名字是`like`。\n```json\n{\n  \"label\": \"like\",\n  \"type\": \"EDGE\",\n  \"constraints\": [\n    [\"person\", \"person\"]\n  ],\n  \"properties\": []\n}\n```\n把上面这个json序列化成字符串，作为参数传入。\n```\nCALL db.createEdgeLabelByJson($json_data)\n```\n\n该段落介绍了如何在数据库中创建向量索引，包括定义一个点类型`person`及其属性，并为其添加向量字段`embedding`和边类型`like`。文中提供了相应的JSON结构和数据库调用示例，旨在指导用户进行向量索引的创建和测试数据的写入。"
            },
            {
                "content": "写入几条测试数据\n```\nCREATE (n1:person {id:1, age:10, embedding: [1.0,1.0,1.0,1.0]})\nCREATE (n2:person {id:2, age:20, embedding: [2.0,2.0,2.0,2.0]})\nCREATE (n3:person {id:3, age:30, embedding: [3.0,3.0,3.0,3.0]})\nCREATE (n1)-[r:like]->(n2),\n       (n2)-[r:like]->(n3),\n       (n3)-[r:like]->(n1);\n```\n## 向量查询\n### KnnSearch\n根据向量搜索出点，第四个参数是个map，里面可以指定一些向量搜索的参数。\n```\nCALL db.vertexVectorKnnSearch('person','embedding', [1.0,2.0,3.0,4.0], {top_k:2, hnsw_ef_search:10})\nyield node return node\n```\n根据向量搜索出点，返回`age`小于30的\n```\nCALL db.vertexVectorKnnSearch('person','embedding',[1.0,2.0,3.0,4.0], {top_k:2, hnsw_ef_search:10})\nyield node where node.age < 30 return node\n```\n根据向量搜索出点，返回age小于30的点，然后再查这些点的一度邻居是谁。\n```\nCALL db.vertexVectorKnnSearch('person','embedding',[1.0,2.0,3.0,4.0], {top_k:2, hnsw_ef_search:10})\nyield node where node.age < 30 with node as p\nmatch(p)-[r]->(m) return m\n```\n### RangeSearch\n根据向量搜索出距离小于10的、age小于30的点，然后再查这些点的一度邻居是谁。\n```\n\n该chunk包含了向量数据库中写入测试数据的代码示例，以及如何使用KnnSearch和RangeSearch进行向量查询的具体查询语句。这部分主要介绍了数据的插入和基本的向量检索操作。"
            },
            {
                "content": "yield node return node\n```\n根据向量搜索出点，返回`age`小于30的\n```\nCALL db.vertexVectorKnnSearch('person','embedding',[1.0,2.0,3.0,4.0], {top_k:2, hnsw_ef_search:10})\nyield node where node.age < 30 return node\n```\n根据向量搜索出点，返回age小于30的点，然后再查这些点的一度邻居是谁。\n```\nCALL db.vertexVectorKnnSearch('person','embedding',[1.0,2.0,3.0,4.0], {top_k:2, hnsw_ef_search:10})\nyield node where node.age < 30 with node as p\nmatch(p)-[r]->(m) return m\n```\n### RangeSearch\n根据向量搜索出距离小于10的、age小于30的点，然后再查这些点的一度邻居是谁。\n```\nCALL db.vertexVectorRangeSearch('person','embedding',[1.0,2.0,3.0,4.0], {radius:10.0, hnsw_ef_search:10})\nyield node where node.age < 30 with node as p\nmatch(p)-[r]->(m) return m\n```\n\n这个片段描述了如何使用向量检索来查找图数据库中的节点，包括基于近邻搜索（KnnSearch）和范围搜索（RangeSearch）的示例查询。它强调了如何结合节点属性条件，如年龄，来过滤搜索结果，并进一步查询这些结果的一度邻居。这些内容位于创建向量索引和边的介绍之后，属于向量查询部分。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_129.md",
        "chunks": [
            {
                "content": "# Graph View\n\n## 基本概念\n\nGraphView是Geaflow中最核心的数据抽象，表示基于图结构的虚拟视图。它是图物理存储的一种抽象，可以表示存储和操作在多个节点上图数据。在 Geaflow中，GraphView是一等公民，用户对图的所有操作都是基于GraphView，例如将分布式点、边流作为 GraphView 增量的点/边数据集，对当前 GraphView 生成快照，用户可以基于快照图或者动态的 GraphView 触发计算。\n\n\n## 功能描述\n\nGraphView 主要有以下几个功能：\n* 图操作，GraphView可以添加或删除点和边数据，亦可以进行查询和在基于某个时间点切片快照。\n* 图介质，GraphView可以存储到图数据库或其他存储介质(如文件系统、KV存储、宽表存储、native graph等)。\n* 图切分，GraphView还支持不同图切分方法。\n* 图计算，GraphView可以进行图的迭代遍历或者计算。\n\n## 示例介绍\n定义一个 Social Network 的 GraphView, 描述人际关系。\n\nDSL 代码\n```SQL\nCREATE GRAPH social_network (\n\tVertex person (\n\t  id int ID,\n\t  name varchar\n\t),\n\tEdge knows (\n\t  person1 int SOURCE ID,\n\t  person2 int DESTINATION ID,\n\t  weight int\n\t)\n) WITH (\n\tstoreType='rocksdb',\n\tshardCount = 128\n);\n```\n\n该文档介绍了Geaflow中的GraphView概念，包括其基本定义、功能描述以及如何通过DSL代码定义一个社交网络的GraphView，展示了图数据的组织和操作方式。"
            },
            {
                "content": "## 功能描述\n\nGraphView 主要有以下几个功能：\n* 图操作，GraphView可以添加或删除点和边数据，亦可以进行查询和在基于某个时间点切片快照。\n* 图介质，GraphView可以存储到图数据库或其他存储介质(如文件系统、KV存储、宽表存储、native graph等)。\n* 图切分，GraphView还支持不同图切分方法。\n* 图计算，GraphView可以进行图的迭代遍历或者计算。\n\n## 示例介绍\n定义一个 Social Network 的 GraphView, 描述人际关系。\n\nDSL 代码\n```SQL\nCREATE GRAPH social_network (\n\tVertex person (\n\t  id int ID,\n\t  name varchar\n\t),\n\tEdge knows (\n\t  person1 int SOURCE ID,\n\t  person2 int DESTINATION ID,\n\t  weight int\n\t)\n) WITH (\n\tstoreType='rocksdb',\n\tshardCount = 128\n);\n```\n\n\nHLA 代码\n```java\n//build graph view.\nfinal String graphName = \"social_network\";\nGraphViewDesc graphViewDesc = GraphViewBuilder\n\t.createGraphView(graphName)\n\t.withShardNum(128)\n\t.withBackend(BackendType.RocksDB)\n    .withSchema(new GraphMetaType(IntegerType.INSTANCE, ValueVertex.class,\n                String.class, ValueEdge.class, Integer.class))\n\t.build();\n\n// bind the graphview with pipeline1\npipeline.withView(graphName, graphViewDesc);\npipeline.submit(new PipelineTask());\n\n```\n\n该文档主要介绍了Geaflow中的GraphView概念及其功能，Chunk部分详细描述了GraphView的功能，包括图操作、图介质、图切分和图计算。同时，Chunk还提供了定义社交网络GraphView的示例代码，展示了如何使用DSL和HLA代码创建和绑定GraphView。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_130.md",
        "chunks": [
            {
                "content": "# Java客户端\n\n> 此文档主要是TuGraph Java SDK的使用说明，需要注意的是TuGraph Java SDK将来不再更新维护。\n\n## 1.编译java client代码\n```shell\ncd deps/tugraph-db-client-java\nsh local_build.sh\n```\n## 2.使用示例\n\n### 2.1.实例化client对象\n\n添加maven依赖\n\n```xml\n\ncom.antgroup.tugraph\ntugraph-db-java-rpc-client\n1.4.1\n\n```\n\n引入依赖\n```java\nimport com.antgroup.tugraph.TuGraphDbRpcClient;\n```\n\n#### 2.1.1.实例化单节点client对象\n当以单节点模式启动server时，client按照如下格式进行实例化\n```java\nTuGraphDbRpcClient client = new TuGraphDbRpcClient(\"127.0.0.1:19099\", \"admin\", \"73@TuGraph\");\n```\n```\npublic TuGraphDbRpcClient(String url, String user, String pass)\n@param url: tugraph host looks like ip:port\n@param user: login user name\n@param password: login password\n```\n\n该文档是关于TuGraph Java SDK的使用说明，特别是如何编译和实例化Java客户端对象。文中提供了不同模式下（单节点和HA集群）的客户端对象实例化方法，并附有相关代码示例及说明。"
            },
            {
                "content": "### 2.1.实例化client对象\n\n添加maven依赖\n\n```xml\n\ncom.antgroup.tugraph\ntugraph-db-java-rpc-client\n1.4.1\n\n```\n\n引入依赖\n```java\nimport com.antgroup.tugraph.TuGraphDbRpcClient;\n```\n\n#### 2.1.1.实例化单节点client对象\n当以单节点模式启动server时，client按照如下格式进行实例化\n```java\nTuGraphDbRpcClient client = new TuGraphDbRpcClient(\"127.0.0.1:19099\", \"admin\", \"73@TuGraph\");\n```\n```\npublic TuGraphDbRpcClient(String url, String user, String pass)\n@param url: tugraph host looks like ip:port\n@param user: login user name\n@param password: login password\n```\n\n#### 2.1.2.实例化HA集群直连连接client对象\n当服务器上部署的HA集群可以使用ha_conf中配置的网址直接连接时，client按照如下格式进行实例化。\n```java\nTuGraphDbRpcClient client = new TuGraphDbRpcClient(\"127.0.0.1:19099\", \"admin\", \"73@TuGraph\");\n```\n```\npublic TuGraphDbRpcClient(String url, String user, String pass)\n@param url: tugraph host looks like ip:port\n@param user: login user name \n@param password: login password\n```\n用户只需要传入HA集群中的任意一个节点的url即可，client会根据server端返回的查询信息自动维护连接池，在HA集群横向扩容时\n也不需要手动重启client。\n\n本段落位于文档的第二部分，详细说明了如何实例化TuGraph Java SDK的客户端对象，包括单节点模式和HA集群的连接方式。用户可以通过添加Maven依赖和导入相关类来创建客户端，并根据服务器的配置选择适当的实例化方法。"
            },
            {
                "content": "#### 2.1.3.实例化HA集群间接连接client对象\n当服务器上部署的HA集群不能使用ha_conf中配置的网址直接连接而必须使用间接网址（如阿里云公网网址）连接时，\nclient按照如下格式进行实例化\n```java\nList urls = new ArrayList<>();\nurls.add(\"189.33.97.23:9091\");\nurls.add(\"189.33.97.24:9091\");\nurls.add(\"189.33.97.25:9091\");\nTuGraphDbRpcClient client = new TuGraphDbRpcClient(urls, \"admin\", \"73@TuGraph\");\n```\n```\npublic TuGraphDbRpcClient(List urls, String user, String password)\n@param urls: tugraph host list\n@param user: login user name\n@param password: login password\n```\n因为用户连接的网址和server启动时配置的信息不同，不能通过向集群发请求的方式自动更新client连接池，所以需要在启动\nclient时手动传入所有集群中节点的网址，并在集群节点变更时手动重启client。\n\n该chunk位于文档的第2.1节，介绍了实例化TuGraph Java SDK客户端对象的不同方式。其中，2.1.3小节专门讨论了在HA集群中使用间接连接方式实例化客户端的具体步骤和注意事项。"
            },
            {
                "content": "### 2.2.调用cypher\n```java\n    String res = client.callCypher(\"CALL db.edgeLabels()\", \"default\", 10);\n    log.info(\"db.edgeLabels() : \" + res);\n```\n```\n    @param cypher: inquire statement.\n    @param graph: the graph to query.\n    @param timeout: Maximum execution time, overruns will be interrupted\n    @param url: (Optional) Node address of calling cypher\n    @return: the result of cypher query execution\n    public String callCypher(String cypher, String graph, double timeout, String url)\n```\n本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。\n注：JAVA不支持默认参数，因此，JAVA中的默认参数是使用重载函数实现的。\n\n该文档主要介绍了TuGraph Java SDK的使用，包括如何编译Java客户端代码、实例化客户端对象、调用Cypher和GQL语句以及管理存储过程等功能。本节2.2专注于如何调用Cypher查询，提供了示例代码和方法说明，适用于单机模式和HA模式下的使用。"
            },
            {
                "content": "### 2.3.向leader发送cypher请求\n```java\n    String res = client.callCypherToLeader(\"CALL db.edgeLabels()\", \"default\", 10);\n    log.info(\"db.edgeLabels() : \" + res);\n```\n```\n    @param cypher: inquire statement.\n    @param graph: the graph to query.\n    @param timeout: Maximum execution time, overruns will be interrupted\n    @return: the result of cypher query execution\n    public String callCypherToLeader(String cypher, String graph, double timeout)\n```\n本接口只支持在HA模式下使用，在HA模式下的client中，为防止向未同步数据的follower发送请求，\n用户可以直接向leader发送请求，leader由集群选出。\n\n本段落介绍了如何在HA模式下，使用TuGraph Java SDK向集群的leader节点发送Cypher查询请求。它包含了示例代码、方法说明及其参数，强调了此请求仅在HA模式下有效，以避免向未同步的数据副本发送请求。"
            },
            {
                "content": "### 2.4.调用GQL\n```java\n    String res = client.callGql(\"CALL db.edgeLabels()\", \"default\", 10);\n    log.info(\"db.edgeLabels() : \" + res);\n```\n```\n    @param gql: inquire statement.\n    @param graph: the graph to query.\n    @param timeout: Maximum execution time, overruns will be interrupted\n    @param url: (Optional) Node address of calling GQL\n    @return: the result of GQL query execution\n    public String callGql(String gql, String graph, double timeout, String url)\n```\n本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。\n注：JAVA不支持默认参数，因此，JAVA中的默认参数是使用重载函数实现的。\n\n该文档是关于TuGraph Java SDK的使用说明，涵盖了Java客户端的编译、实例化和具体方法调用等内容。第2.4节专门介绍了如何调用GQL，包括示例代码、参数说明和该接口在单机模式与HA模式下的适用性。"
            },
            {
                "content": "### 2.5.向leader发送GQL请求\n```java\n    String res = client.callGqlToLeader(\"CALL db.edgeLabels()\", \"default\", 10);\n    log.info(\"db.edgeLabels() : \" + res);\n```\n```\n    @param gql: inquire statement.\n    @param graph: the graph to query.\n    @param timeout: Maximum execution time, overruns will be interrupted\n    @return: the result of cypher query execution\n    public String callGqlToLeader(String cypher, String graph, double timeout)\n```\n本接口只支持在HA模式下使用，在HA模式下的client中，为防止向未同步数据的follower发送请求，\n用户可以直接向leader发送请求，leader由集群选出。\n\n该内容位于文档的第二部分，介绍了TuGraph Java SDK的使用示例。具体地，它讲解了如何向HA集群中的leader发送GQL请求的相关方法和代码示例，强调了在HA模式下直接请求leader的重要性，以避免向未同步数据的follower发送请求。"
            },
            {
                "content": "### 2.6.调用存储过程\n```java\n    String result = client.callProcedure(\"CPP\", \"khop\", kHopParamGen(), 1000, false, \"default\");\n    log.info(\"testCallProcedure : \" + result);\n```\n```\n    @param procedureType: the procedure type, currently supported CPP and PY\n    @param procedureName: procedure name\n    @param param: the execution parameters\n    @param procedureTimeOut: Maximum execution time, overruns will be interrupted\n    @param inProcess: Running query or not\n    @param graph: the graph to query\n    @param jsonFormat: (Optional) Return format of calling stored procedure\n    @param url: (Optional) Node address of calling procedure\n    @return: the result of procedure execution\n    public String callProcedure(String procedureType, String procedureName, String param, double procedureTimeOut,\n            boolean inProcess, String graph, String url)\n```\n本接口支持在单机模式和HA模式下使用，默认以字符串格式直接返回存储过程的执行结果，指定jsonFormat为true可以返回json格式的执行结果。\n其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。\n\n该文档主要介绍TuGraph Java SDK的使用方法，包含编译、实例化客户端对象、调用Cypher和GQL、发送请求到HA集群的leader等功能。第2.6节详细说明了如何调用存储过程，包括相关参数以及在单机模式和HA模式下的使用情况。"
            },
            {
                "content": "### 2.7.向leader调用存储过程\n```java\n    String result = client.callProcedureToLeader(\"CPP\", \"khop\", kHopParamGen(), 1000, false, \"default\");\n    log.info(\"testCallProcedureToLeader : \" + result);\n```\n```\n    @param procedureType: the procedure type, currently supported CPP and PY\n    @param procedureName: procedure name\n    @param param: the execution parameters\n    @param procedureTimeOut: Maximum execution time, overruns will be interrupted\n    @param inProcess: Running query or not\n    @param graph: the graph to query\n    @param jsonFormat: (Optional) Return format of calling stored procedure\n    @return: the result of procedure execution\n    public String callProcedureToLeader(String procedureType, String procedureName, String param, double procedureTimeOut,\n            boolean inProcess, String graph)\n```\n本接口支持在HA模式下使用，默认以字符串格式直接返回存储过程的执行结果，指定jsonFormat为true可以返回json格式的执行结果。\n\n该文档是关于TuGraph Java SDK的使用说明，其中包括如何实例化客户端对象、调用Cypher和GQL接口、向leader发送请求、管理存储过程等功能。其中第2.7节专门介绍了如何向HA模式下的leader调用存储过程，并提供了代码示例及相关参数说明。"
            },
            {
                "content": "### 2.8.加载存储过程\n```java\n    boolean result = client.loadProcedure(\"./test/procedure/khop.so\", \"CPP\", \"khop\", \"SO\", \"test loadprocedure\", true, \"v1\", \"default\");\n    log.info(\"loadProcedure : \" + result);\n```\n```\n    @param sourceFile: the source_file contain procedure code\n    @param procedureType: the procedure type, currently supported CPP and PY\n    @param procedureName: procedure name\n    @param codeType: code type, currently supported PY, SO, CPP, ZIP\n    @param procedureDescription: procedure description\n    @param readOnly: procedure is read only or not\n    @param version: The version of procedure\n    @param graph: the graph to query.\n    @return: the result of procedure execution\n    public boolean loadProcedure(String sourceFile, String procedureType, String procedureName, String codeType,\n                              String procedureDescription, boolean readOnly, String version, String graph) throws Exception\n```\n本接口支持在单机模式和HA模式下使用。其中，由于加载存储过程是写请求，HA模式下的client只能向leader发送加载存储过程请求。\n\n此文档为TuGraph Java SDK的使用说明，其中介绍了不同的客户端实例化方式、调用Cypher和GQL的接口以及存储过程的相关操作。第2.8节具体讲述了如何加载存储过程，包括相关的参数说明和使用场景。"
            },
            {
                "content": "### 2.9.列举存储过程\n```java\n    String result = client.listProcedures(\"CPP\", \"any\", \"default\");\n    log.info(\"listProcedures : \" + result);\n```\n```\n    @param procedureType: the procedure type, currently supported CPP and PY\n    @param version: The version of procedure\n    @param graph: the graph to query.\n    @param url: (Optional) Node address of listing procedure\n    @return: the list of procedure\n    public String listProcedures(String procedureType, String version, String graph, String url) throws Exception\n```\n本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。\n\n该文档是关于TuGraph Java SDK的使用说明，其中包含了客户端的编译、实例化、调用Cypher、GQL、存储过程等多个功能的具体示例和说明。第2.9节专门介绍了如何列举存储过程，包括示例代码、参数说明及其适用模式。"
            },
            {
                "content": "### 2.10.删除存储过程\n```java\n    String result = client.deleteProcedure(\"CPP\", \"sortstr\", \"default\");\n    log.info(\"loadProcedure : \" + result);\n```\n```\n    @param procedureType: the procedure type, currently supported CPP and PY\n    @param procedureName: procedure name\n    @param graph: the graph to query.\n    @return: the result of procedure execution\n    public boolean deleteProcedure(String procedureType, String procedureName, String graph) throws Exception\n```\n本接口支持在单机模式和HA模式下使用。其中，由于删除存储过程是写请求，HA模式下的client只能向leader发送删除存储过程请求。\n\n该文档是关于TuGraph Java SDK的使用说明，涵盖了Java客户端的编译、实例化及调用各种接口的示例。其中，2.10节专门介绍了如何删除存储过程，包括代码示例、参数说明及支持模式的描述，强调在HA模式下的操作限制。"
            },
            {
                "content": "### 2.11.从字节流中导入schema\n```java\n    boolean ret = client.importSchemaFromContent(schema, \"default\", 1000);\n    log.info(\"importSchemaFromContent : \" + ret);\n```\n```\n    @param schema: the schema to be imported\n    @param graph: the graph to query.\n    @param timeout: Maximum execution time, overruns will be interrupted\n    @return: the result of import schema\n    public boolean importSchemaFromContent(String schema, String graph, double timeout) throws UnsupportedEncodingException \n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入schema是写请求，HA模式下的client只能向leader发送导入schema请求。\n\n该文档主要介绍TuGraph Java SDK的使用说明，其中包含了Java客户端的编译、实例化以及各种功能调用的方法。在文档的第2.11节中，详细描述了如何从字节流中导入schema，包括示例代码、方法参数说明，以及该接口在单机和HA模式下的使用限制。"
            },
            {
                "content": "### 2.12.从字节流中导入点边数据\n```java\n    boolean ret = client.importDataFromContent(personDesc, person, \",\", true, 16, \"default\", 1000);\n    log.info(\"importDataFromContent : \" + ret);\n```\n```\n    @param desc: data format description\n    @param data: the data to be imported\n    @param delimiter: data separator\n    @param continueOnError: whether to continue when importing data fails\n    @param threadNums: maximum number of threads\n    @param graph: the graph to query.\n    @param timeout: Maximum execution time, overruns will be interrupted\n    @return: the result of import data\n    public boolean importDataFromContent(String desc, String data, String delimiter, boolean continueOnError,\n            int threadNums, String graph, double timeout) throws UnsupportedEncodingException\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入点边数据是写请求，HA模式下的client只能向leader发送导入点边数据请求。\n\n该文档主要介绍TuGraph Java SDK的使用方法，包括如何编译Java客户端代码、实例化客户端对象及其不同连接方式，以及如何调用Cypher和GQL查询、存储过程的操作等。其中，2.12节详细说明了如何从字节流中导入点边数据，包括使用的代码示例和相关参数的说明，适用单机和HA模式。"
            },
            {
                "content": "### 2.13.从文件中导入schema\n```java\n    boolean ret = client.importSchemaFromFile(\"./test/data/yago.conf\", \"default\", 1000);\n    log.info(\"importSchemaFromFile : \" + ret);\n```\n```\n    @param schemaFile: the schema_file contain schema\n    @param graph: the graph to query.\n    @param timeout: Maximum execution time, overruns will be interrupted\n    @return: the result of import schema\n    public boolean importSchemaFromFile(String schemaFile, String graph, double timeout) \n            throws UnsupportedEncodingException, IOException\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入schema是写请求，HA模式下的client只能向leader发送导入schema请求。\n\n该代码块位于文档的第2.14节，介绍了如何从文件中导入schema到TuGraph数据库。该接口同时支持单机模式和HA模式，并强调在HA模式下仅能向leader发送请求。这段内容有助于开发者了解如何处理schema导入操作。"
            },
            {
                "content": "### 2.14.从文件中导入点边数据\n```java\n    boolean ret = client.importDataFromFile(\"./test/data/yago.conf\", \",\", true, 16, 0, \"default\", 1000000000);\n    log.info(\"importDataFromFile : \" + ret);\n```\n```\n    @param confFile: data file contain format description and data\n    @param delimiter: data separator\n    @param continueOnError: whether to continue when importing data fails\n    @param threadNums: maximum number of threads\n    @param skipPackages: skip packages number\n    @param graph: the graph to query.\n    @param timeout: Maximum execution time, overruns will be interrupted\n    @return: the result of import data\n    public boolean importDataFromFile(String confFile, String delimiter, boolean continueOnError, int threadNums,\n            int skipPackages, String graph, double timeout) throws IOException, UnsupportedEncodingException\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入点边数据是写请求，HA模式下的client只能向leader发送导入点边数据请求。\n\n该文档为TuGraph Java SDK的使用说明，其中第2.14节描述了如何从文件中导入点边数据的操作。此部分包含示例代码、方法参数说明以及适用场景，强调了在HA模式下只能向leader发送写请求的重要性。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_131.md",
        "chunks": [
            {
                "content": "# Python Olap API\n\n> 本文档主要介绍 OlapBase OlapOnDB 和 OlapOnDisk 在Python中的API用法。\n\n\n## 1. 概述\n\n本手册将介绍使用TuGraph图计算系统Python接口需要的简单配置，同时结合代码对TuGraph Python API进行解释。关于ParallelBitset、OlapBase各类的作用，详见olap-base-api.md，olap-on-db-api.md和olap-on-disk-api.md\n\n## 2. 配置要求\n\n如果要使用TuGraph图计算编写以及编译自己的应用程序，需要的配置要求为：\n\n- linux操作系统，目前在Ubuntu16.04, Ubuntu18.04, Ubuntu20.04和Centos7, Centos8系统上可成功运行。\n- 支持C++17的编译器，要求GCC版本为8.4.0或更新的版本。\n- Cython，版本要求3.0.0以上，已测试可运行版本为3.0.0a11\n\n## 3. Cython\nCython是一种高效的编程语言，是Python的超集。Cython能将py文件翻译为C/C++代码后编译为Python拓展类，在Python中通过import调用。在TuGraph中，所有的Python plugin都由Cython编译为Python拓展类后使用。\n\nCython的Pure Python模式在保证Python语法的同时具有C/C++的性能，TuGraph Python接口均使用Cython实现。\n\nCython 文档：https://cython.readthedocs.io/en/latest/index.html\n\n## 4. Olap API\n见procedures/algo_cython/olap_base.pxd文件，用法与功能基本与C++接口相同，olap_base.pxd中声明的接口都由C++实现，在py文件中必须通过`from cython.cimports.olap_base import *`的方式导入，由Cython编译py文件后才能运行。\n\n本文档介绍了TuGraph图计算系统在Python中使用的Olap API，包括OlapBase、OlapOnDB和OlapOnDisk的功能和配置要求，重点讲解了如何通过Cython实现高效的图计算，并提供了相关的代码示例。"
            },
            {
                "content": "## 3. Cython\nCython是一种高效的编程语言，是Python的超集。Cython能将py文件翻译为C/C++代码后编译为Python拓展类，在Python中通过import调用。在TuGraph中，所有的Python plugin都由Cython编译为Python拓展类后使用。\n\nCython的Pure Python模式在保证Python语法的同时具有C/C++的性能，TuGraph Python接口均使用Cython实现。\n\nCython 文档：https://cython.readthedocs.io/en/latest/index.html\n\n## 4. Olap API\n见procedures/algo_cython/olap_base.pxd文件，用法与功能基本与C++接口相同，olap_base.pxd中声明的接口都由C++实现，在py文件中必须通过`from cython.cimports.olap_base import *`的方式导入，由Cython编译py文件后才能运行。\n\n### 原子操作\n- `cas[T](ptr: cython.pointer(T), oldv: T, newv: T)-> cython.bint`：如果ptr指向的值等于oldv，则将ptr指向的值赋为newv并返回true，否则返回false\n- `write_min[T](a: cython.pointer(T), b: T)-> cython.bint`：如果b比a指向的值更小，那么将a指向的值赋为b并返回true，否则返回false。\n- `write_max[T](a: cython.pointer(T), b: T)-> cython.bint`：如果b比a指向的值更大，那么将a指向的值赋为b并返回true，否则返回false。\n- `write_add[T](a: cython.pointer(T), b: T)-> cython.bint`：将b的值加到a指向的值上。\n- `write_sub[T](a: cython.pointer(T), b: T)-> cython.bint`：将a指向的值减去b的值。\n\n该文档主要介绍TuGraph图计算系统在Python中的API用法，重点包括配置要求、Cython介绍、Olap API的使用及原子操作。本文中的第三和第四部分详细说明了Cython的特点以及Olap API的功能和接口，提供了多种原子操作的具体说明。"
            },
            {
                "content": "### 原子操作\n- `cas[T](ptr: cython.pointer(T), oldv: T, newv: T)-> cython.bint`：如果ptr指向的值等于oldv，则将ptr指向的值赋为newv并返回true，否则返回false\n- `write_min[T](a: cython.pointer(T), b: T)-> cython.bint`：如果b比a指向的值更小，那么将a指向的值赋为b并返回true，否则返回false。\n- `write_max[T](a: cython.pointer(T), b: T)-> cython.bint`：如果b比a指向的值更大，那么将a指向的值赋为b并返回true，否则返回false。\n- `write_add[T](a: cython.pointer(T), b: T)-> cython.bint`：将b的值加到a指向的值上。\n- `write_sub[T](a: cython.pointer(T), b: T)-> cython.bint`：将a指向的值减去b的值。\n\n### 点集合类ParallelBitset\n- `Size()-> size_t`：表示Bitmap中的点个数。\n- `ParallelBitset(size: size_t)`：初始化size和data，data长度为(size >> 6)+1\n- `Clear()-> cython.void`：清空集合\n- `Fill()-> cython.void`：将所有点加入集合\n- `Has(size_t i)-> cython.bint`：检查点i是否在集合中\n- `Add(size_t i)-> cython.bint`：将点i加入集合中\n- `Swap(ParallelBitset &other)-> cython.void`：和另一组ParallelBitset集合交换元素\n\n该段落位于文档的第四部分“Olap API”中，专门介绍了原子操作和点集合类ParallelBitset的具体方法和功能。这部分内容是OlapBase的基础操作和数据结构的详细描述，对理解和使用TuGraph图计算系统中的并发处理至关重要。"
            },
            {
                "content": "### 点数组类ParallelVector\n- `ParallelVector[T](size_t capacity)` 构建ParallelVector，capacity为点数组的初始容量大小\n- `operator[](i: size_t)-> T`：下标为i的数据\n- `begin()-> cython.pointer(T)`：ParallelVector的起始指针\n- `end()-> cython.pointer(T)`：ParallelVector的结束指针。begin和end的用法类似于vector容器的begin和end指针，可以使用这两个指针对数组进行顺序访问\n- `Back()-> T`：ParallelVector最后一个数据\n- `Data()-> cython.pointer(T)`：表示数组本身数据\n- `Destroy()-> cython.void`：清空ParallelVector数组内数据并删除数组\n- `Size()-> size_t`：表示ParallelVector中的数据个数\n- `Resize(size: size_t)-> cython.void`：更改ParallelVector为size大小，该size应大于等于更改前的大小且小于capacity\n- `Clear()-> cython.void`：清空ParallelVector内数据\n- `ReAlloc(capacity: size_t)-> cython.void`：给ParallelVector分配新的容量大小，若数组有数据则将数据迁移至新内存\n- `Fill(elem: T)-> cython.void`：为ParallelVector的全部数据赋值为elem\n- `Append(elem: T, atomic: cython.bint = true)-> cython.void`：向ParallelVector结尾添加一个数据\n- `Swap(other: ParallelVector[T])-> cython.void`：和其他的ParallelVector交换数据\n- `Copy()-> ParallelVector[T]`：复制当前的ParallelVector数据存至Copy数组中\n\n该段落详细介绍了点数组类ParallelVector的构造和功能，属于文档中“4. Olap API”部分的一个子章节，主要说明ParallelVector的各种操作方法，包括初始化、数据访问、内存管理等，为用户在使用TuGraph图计算系统的Python接口时提供了必要的参考信息。"
            },
            {
                "content": "### 自定义数据结构\n- `Empty`：内容为空的特殊数据类型。\n- `EdgeUnit[EdgeData]`：表示权值类型为EdgeData的边，用于解析输入文件，包含三个成员变量：\n    - `src: size_t`：边的起始点\n    - `dst: size_t`：边的终点\n    - `edge_data: EdgeData`：边的权值\n- `AdjUnit[EdgeData]`：表示权值类型为EdgeData的边，用于批处理计算过程中，包含两个成员变量：\n    - `neighbour: size_t`：边的邻居点\n    - `edge_data: EdgeData`：边的权值\n- `AdjList[EdgeData]`：权值类型为EdgeData的点的邻接表，常用于表示点的入边和出边集合，包含两个成员变量：\n    - `begin()-> cython.pointer(AdjUnit[T])`：列表的起始指针\n    - `end()-> cython.pointer(AdjUnit[T])`：列表的结束指针。\n    - `operator[](i: size_t)-> AdjUnit[EdgeData]`: 下标为i的数据\n\n### 图类OlapBase\n- `NumVertices()-> size_t`：获取点数\n- `NumEdges()-> size_t`：获取边数\n- `OutDegree(size_t vid)-> size_t`：点vid的出度\n- `InDegree(size_t vid)-> size_t`：点vid的入度\n\n该chunk位于文档的第4部分“Olap API”中，主要介绍了在Python中使用TuGraph图计算系统时的自定义数据结构和图类OlapBase的基本功能，包括边和邻接表的定义以及图的基本属性和操作。这部分内容为后续具体算法实现和图操作提供了数据结构基础。"
            },
            {
                "content": "### 图类OlapBase\n- `NumVertices()-> size_t`：获取点数\n- `NumEdges()-> size_t`：获取边数\n- `OutDegree(size_t vid)-> size_t`：点vid的出度\n- `InDegree(size_t vid)-> size_t`：点vid的入度\n\n- `AllocVertexArray[VertexData]() ->ParallelVector[VertexData]`：分配一个类型为VertexData的数组，大小为点个数\n- `AllocVertexSubset()-> ParallelBitset`：分配一个ParallelBitset集合，用于表示所有点的状态是否激活\n- `OutEdges(vid: size_t)-> AdjList[EdgeData]`：获取点v的所有出边集合\n- `InEdges(vid: size_t)-> AdjList[EdgeData]`：获取点v的所有入边集合\n- `Transpose()-> cython.void`：对有向图进行图反转\n- `LoadFromArray(edge_array: cython.p_char, input_vertices: size_t, input_edges: size_t, edge_direction_policy: EdgeDirectionPolicy)`：从数组中加载图数据，包含四个参数，其含义分别表示：\n    - `edge_array`：将该数组中的数据读入图，一般情况下该数组包含多条边。\n    - `input_vertices`：指定数组读入图的点个数。\n    - `input_edges`：指定数组读入图的边的条数。\n    - `edge_direction_policy`：指定图为有向或无向，包含三种模式，分别为DUAL_DIRECTION、MAKE_SYMMETRIC以及INPUT_SYMMETRIC。对应的详细介绍见include/lgraph/olap_base.h文件的`enum EdgeDirectionPolicy`。\n\n该文本块主要描述了图类OlapBase的相关API，包括获取图的基本信息（如点数、边数）、操作点和边的方法（如出度、入度、邻接边等），以及图的加载和反转功能。这些内容在Olap API的章节中，旨在帮助用户理解如何使用OlapBase类对图数据进行管理和操作。"
            },
            {
                "content": "- `AcquireVertexLock(vid: size_t)-> cython.void`：对点vid加锁，禁止其它线程对该锁对应的点数据进行访存\n- `void ReleaseVertexLock(vid: size_t)-> cython.void`：对点vid解锁，所有线程均可访存该锁对应的点数据\n\nTuGraph提供了两个批处理操作来并行地进行以点为中心的批处理过程，在Python中与C++使用方法稍有不同。\n\n```python\n# 函数名称:ProcessVertexInRange[ReducedSum, Algorithm](\n#           work: (algo: Algorithm, vi: size_t)-> ReducedSum,\n#           lower: size_t, upper: size_t,\n#           algo: Algorithm,\n#           zero: ReducedSum = 0,\n#           reduce: (a: ReducedSum, b: ReducedSum)-> ReducedSum = reduce_plus[ReducedSum])\n#\n#     函数用途:对Graph中节点编号介于lower和upper之间的节点执行work函数。第四个参数表示累加的基数，默认为0；\n#     第五个参数表示对每个work处理后的节点返回值进行迭代reduce函数操作，默认为累加操作。\n#     具体实现请参考include/lgraph/olap_base.h中具体代码\n#\n#     使用示例:统计数组parent数组中有出边的点个数\n\nimport cython\nfrom cython.cimports.olap_base import *\n\n\n@cython.cclass\nclass CountCore:\n    graph: cython. pointer(OlapBase[Empty])\n    parent: ParallelVector[size_t]\n\n在文档的第4部分“Olap API”中，介绍了图类OlapBase的相关操作，包括对图中点的加锁与解锁机制，以及如何通过并行批处理操作实现基于点的计算。该段落特别强调了如何在Python中实现这些操作，并提供了示例代码以帮助用户理解具体用法。"
            },
            {
                "content": "import cython\nfrom cython.cimports.olap_base import *\n\n\n@cython.cclass\nclass CountCore:\n    graph: cython. pointer(OlapBase[Empty])\n    parent: ParallelVector[size_t]\n\n    @cython.cfunc\n    @cython.nogil\n    def Work(self, vi: size_t) -> size_t:\n        if self.graph.OutDegree(self.parent[vi]) > 0:\n            return 1\n        return 0\n\n    def run(self, pointer_g: cython. pointer(OlapBase[Empty])):\n        self.graph = pointer_g\n        self.parent = self.graph.AllocVertexArray[size_t]()\n        vertex_num: size_t\n        vertex_num = self.graph.ProcessVertexInRange[size_t, CountCore](self.Work, 0, self.parent.Size(), self)\n        print(\"the number is\", vertex_num)\n\nif __name__ == \"__main__\":\n    count_core = CountCore()\n    count_core.run(cython.address(g))\n```\n其中g为图类OlapBase的实例化对象\n\n该代码块位于文档的“图类OlapBase”部分，展示了如何使用TuGraph图计算系统的Python接口实现一个简单的统计功能，通过访问图的出度来计算并打印具有出边的节点数量。这段代码是对OlapBase类的使用示例，旨在帮助用户理解如何在Python中进行图数据处理。"
            },
            {
                "content": "def run(self, pointer_g: cython. pointer(OlapBase[Empty])):\n        self.graph = pointer_g\n        self.parent = self.graph.AllocVertexArray[size_t]()\n        vertex_num: size_t\n        vertex_num = self.graph.ProcessVertexInRange[size_t, CountCore](self.Work, 0, self.parent.Size(), self)\n        print(\"the number is\", vertex_num)\n\nif __name__ == \"__main__\":\n    count_core = CountCore()\n    count_core.run(cython.address(g))\n```\n其中g为图类OlapBase的实例化对象\n\n```python\n# 函数名称:ProcessVertexActive[ReducedSum, Algorithm](\n#           work: (algo: Algorithm, vi: size_t)-> ReducedSum,\n#           active: ParallelBitset,\n#           algo: Algorithm,\n#           zero: ReducedSum = 0,\n#           reduce: (a: ReducedSum, b: ReducedSum)-> ReducedSum = reduce_plus[ReducedSum])\n#\n#   函数用途:对active_vertices中对应为1的节点执行work函数，第三个参数表示累加的基数，默认为0；\n#   第四个参数表示对每个work处理后的节点返回值进行迭代reduce函数操作，默认为累加操作。\n#   具体实现请参考/include/lgraph/olap_base.h中具体代码\n#\n# 使用示例:输出Graph中节点1，2，3的所有出度邻居，并统计这三个节点的总出度\n\n该代码块位于文档中关于Olap API的部分，具体介绍了如何使用`ProcessVertexInRange`函数对图中的节点进行处理，主要用于统计具有出边的点的数量。它是`CountCore`类的一个方法，展示了在Python中利用TuGraph图计算系统进行图处理的具体实现。此外，紧接着介绍了`ProcessVertexActive`函数的使用示例，表明如何处理活跃节点并输出其出度邻居的信息。"
            },
            {
                "content": "import cython\nfrom cython.cimports.olap_base import *\nfrom cython.cimports.libc.stdio import printf\n\n\n@cython.cclass\nclass NeighborCore:\n    graph: cython.pointer(OlapBase[Empty])\n    active_in: ParallelBitset\n\n    @cython.cfunc\n    @cython.nogil\n    def Work(self, vi: size_t) -> size_t:\n        degree = self.graph.OutDegree(vi)\n        dst: size_t\n        edges = self.graph.OutEdges(vi)\n        local_out_degree: size_t\n        for i in range(degree):\n            dst = edges[i].neighbour\n            printf(\"node %lu has neighbour %lu\\n\", vi, dst)\n            local_out_degree += 1\n        return local_out_degree\n\n该代码块位于文档的“图类OlapBase”部分，具体示例展示了如何使用Python实现邻居节点处理的逻辑。通过定义一个名为NeighborCore的类，该类包含一个Work方法，该方法在多线程中被调用，用于计算图中某个节点的出度并输出其所有邻居。此示例强调了使用Cython和OlapBase类进行图计算的并行处理能力。"
            },
            {
                "content": "@cython.cfunc\n    @cython.nogil\n    def Work(self, vi: size_t) -> size_t:\n        degree = self.graph.OutDegree(vi)\n        dst: size_t\n        edges = self.graph.OutEdges(vi)\n        local_out_degree: size_t\n        for i in range(degree):\n            dst = edges[i].neighbour\n            printf(\"node %lu has neighbour %lu\\n\", vi, dst)\n            local_out_degree += 1\n        return local_out_degree\n\n    def run(self, pointer_g: cython.pointer(OlapBase[Empty])):\n        self.graph = pointer_g\n        self.active_in = self.graph.AllocVertexSubset()\n        self. active_in. Add(1)\n        self. active_in. Add(2)\n        self. active_in. Add(3)\n        total_outdegree = cython.declare(\n            size_t,\n            self.graph.ProcessVertexActive[size_t, CountCore](self.Work, self.active_in, self))\n        printf(\"total outdegree of node1,2,3 is %lu\\n\",total_outdegree)\n\nif __name__ == \"__main__\":\n    neighbor_core = NeighborCore()\n    neighbor_core.run(cython.address(g))\n```\n\n该代码段位于本文档中关于图类OlapBase的算法实现部分，具体展示了如何使用Cython编写邻接节点的输出度统计功能。代码定义了一个名为`NeighborCore`的类，其中包含了一个计算每个节点邻接点的`Work`方法以及一个执行计算的`run`方法，最后通过添加特定节点到活跃节点集合并调用批处理函数来统计总出度。此功能示例展示了如何在并行计算中应用图的基本操作。"
            },
            {
                "content": "if __name__ == \"__main__\":\n    neighbor_core = NeighborCore()\n    neighbor_core.run(cython.address(g))\n```\n\n如上面两个例子所展示，在Python中ProcessVertexActive与ProcessVertexInRange比在C++中额外需要一个算法类指针参数，Work函数一般也作为该算法类的成员函数，满足Work函数访问成员变量的需求（如图graph，点数组parent），在调用批处理函数时将Work函数和算法类的self指针传入批处理函数。\n\n其中Work函数会在多线程中调用，因此加上修饰器`@cython.nogil`释放Python全局解释锁，在多线程执行的代码中（例如批处理函数中的Work函数，`cython.parallel.prange`中），不能包含Python对象，最好通过`dst: type`或者`dst = cython.declare(type)`的方式声明变量为C/C++类型。\n\n### 图类OlapOnDB:\n并行化创建有向图：\n```python\nolapondb = OlapOnDB[Empty](db, txn, SNAPSHOT_PARALLEL)\n```\n并行化创建无向图\n```python\nolapondb = OlapOnDB[Empty](db, txn, SNAPSHOT_PARALLEL | SNAPSHOT_UNDIRECTED)\n```\nID_MAPPING创建有向图\n```python\nolapondb = OlapOnDB[Empty](db, txn, SNAPSHOT_PARALLEL | SNAPSHOT_IDMAPPING)\n```\n\n### 图类OlapOnDisk\n\n#### ConfigBase：\n- `ConfigBase()`: 构造函数\n- `std::string input_dir`: 图边表数据路径\n- `std::string output_dir`: 输出结果路径\n\n\n- `Load(config: ConfigBase[EdgeData], edge_direction_policy: EdgeDirectionPolicy)-> void`: 读入图数据\n\n该代码块位于文档中关于如何使用Python接口进行图算法的部分，具体展示了如何实例化并运行`NeighborCore`类，这是一个实现图的邻居处理的算法。前面的内容对Python中的批处理函数`ProcessVertexActive`和`ProcessVertexInRange`进行了说明，并强调了在多线程环境下使用`@cython.nogil`修饰器的重要性。此块代码的目的在于提供一个具体的使用示例，展示如何在图类`OlapOnDB`中并行处理节点的邻居。"
            },
            {
                "content": "### 图类OlapOnDisk\n\n#### ConfigBase：\n- `ConfigBase()`: 构造函数\n- `std::string input_dir`: 图边表数据路径\n- `std::string output_dir`: 输出结果路径\n\n\n- `Load(config: ConfigBase[EdgeData], edge_direction_policy: EdgeDirectionPolicy)-> void`: 读入图数据\n\n\n## 5. lgraph_db API\n见procedures/algo_cython/lgraph_db.pxd与lgraph_db_python.py文件。\n\nlgraph_db.pxd中接口用法与功能基本与C++接口相同，lgraph_db.pxd中声明的接口都由C++实现，在py文件中必须通过`from cython.cimports.olap_base import *`的方式导入，由Cython编译py文件后才能运行。\n\n### VertexIndexIterator\n- `GetVid()-> int64_t`: 获取点的vid\n\n### Galaxy\n- `Galaxy(dir_path: std::string)`: 构造函数，dir_path为db路径\n- `SetCurrentUser(user: std::string, password: std::string)-> cython.void`: 设置用户\n- `SetUser(user: std::string)-> cython.void`: 设置用户\n- `OpenGraph(graph: std::string, read_only: bint)-> GraphDB`: 创建GraphDB\n\n### GraphDB：\n- `CreateReadTxn()-> Transaction`: 创建只读事务\n- `CreateWriteTxn()-> Transaction`: 创建写事务\n- `ForkTxn(txn: Transaction)-> Transaction`: 复制事务，只能复制读事务\n\n该片段位于文档的第4部分和第5部分之间，主要介绍图类OlapOnDisk的配置和使用方法，包括ConfigBase类及其方法。同时还引入了lgraph_db API的相关内容，包括VertexIndexIterator、Galaxy和GraphDB类的构造函数和基本操作。这部分内容是关于如何在TuGraph中处理图数据及其数据库交互的基础知识，为读者理解后续算法实现奠定基础。"
            },
            {
                "content": "### VertexIndexIterator\n- `GetVid()-> int64_t`: 获取点的vid\n\n### Galaxy\n- `Galaxy(dir_path: std::string)`: 构造函数，dir_path为db路径\n- `SetCurrentUser(user: std::string, password: std::string)-> cython.void`: 设置用户\n- `SetUser(user: std::string)-> cython.void`: 设置用户\n- `OpenGraph(graph: std::string, read_only: bint)-> GraphDB`: 创建GraphDB\n\n### GraphDB：\n- `CreateReadTxn()-> Transaction`: 创建只读事务\n- `CreateWriteTxn()-> Transaction`: 创建写事务\n- `ForkTxn(txn: Transaction)-> Transaction`: 复制事务，只能复制读事务\n\n### Transaction：\n```\nGetVertexIndexIterator(\n                label: std::string,\n                field: std::string,\n                key_start: std::string,\n                key_end: std::string)-> VertexIndexIterator\n```\n获取索引迭代器。迭代器的field值为 [key_start, key_end]。所以在key_start=key_end=v时，返回指向field值为v的点的迭代器\n\nlgraph_db_python.py是lgraph_db.pxd中C++类 Galaxy与GraphDB的包装，将C++类包装为Python类，将lgraph_db_python.py编译为Python拓展后，可以直接在Python文件或Python命令行中`import lgraph_db_python`访问lgraph_db_python.PyGraphDB与PyGraphDB.PyGalaxy。\n\n该块内容位于文档的第5部分，主要介绍lgraph_db API的相关类和方法，包括VertexIndexIterator、Galaxy、GraphDB与Transaction等。这些类和方法用于管理图数据库的操作，如创建事务、获取点的索引迭代器等，构成了TuGraph图计算系统在Python中的数据库交互部分。"
            },
            {
                "content": "### Transaction：\n```\nGetVertexIndexIterator(\n                label: std::string,\n                field: std::string,\n                key_start: std::string,\n                key_end: std::string)-> VertexIndexIterator\n```\n获取索引迭代器。迭代器的field值为 [key_start, key_end]。所以在key_start=key_end=v时，返回指向field值为v的点的迭代器\n\nlgraph_db_python.py是lgraph_db.pxd中C++类 Galaxy与GraphDB的包装，将C++类包装为Python类，将lgraph_db_python.py编译为Python拓展后，可以直接在Python文件或Python命令行中`import lgraph_db_python`访问lgraph_db_python.PyGraphDB与PyGraphDB.PyGalaxy。\n\n### PyGalaxy:\n- `PyGalaxy(self, dir_path: str)`: 构造函数，dir_path为db路径\n- `SetCurrentUser(self, user: str password: str)-> void`: 设置用户\n- `SetUser(self, user: std::string)-> void`: 设置用户\n- `OpenGraph(self, graph: str, read_only: bool)-> PyGraphDB`: 创建PyGraphDB\n\n### PyGraphDB:\n- `get_pointer(self)-> cython.Py_ssize_t`: C++ 类GraphDB的地址\n\n## 6. 算法插件示例\n下面为Python实现的BFS算法的代码示例：\n```python\n# cython: language_level=3, cpp_locals=True, boundscheck=False, wraparound=False, initializedcheck=False\n# distutils: language = c++\n\n该段落位于文档的第5节，主要描述lgraph_db API的相关内容，包括获取索引迭代器的函数以及lgraph_db_python.py的包装类PyGalaxy和PyGraphDB。同时，文档接下来会介绍6节中的算法插件示例，提供基于Python实现的BFS算法代码。"
            },
            {
                "content": "### PyGalaxy:\n- `PyGalaxy(self, dir_path: str)`: 构造函数，dir_path为db路径\n- `SetCurrentUser(self, user: str password: str)-> void`: 设置用户\n- `SetUser(self, user: std::string)-> void`: 设置用户\n- `OpenGraph(self, graph: str, read_only: bool)-> PyGraphDB`: 创建PyGraphDB\n\n### PyGraphDB:\n- `get_pointer(self)-> cython.Py_ssize_t`: C++ 类GraphDB的地址\n\n## 6. 算法插件示例\n下面为Python实现的BFS算法的代码示例：\n```python\n# cython: language_level=3, cpp_locals=True, boundscheck=False, wraparound=False, initializedcheck=False\n# distutils: language = c++\n\n# 注释作用如下：\n# language_level=3: 使用Python3\n# cpp_locals=True: 需要c++17，使用std::optional管理Python代码中的C++对象，可以避免C++对象的拷贝构造\n# boundscheck=False: 关闭索引的边界检查\n# wraparound=False: 关闭负数下标的处理（类似Python List）\n# initializedcheck=False: 关闭检查内存是否初始化，关闭检查后运行性能更快\n# language = c++: 将此py文件翻译为C++而不是C文件，TuGraph使用大量模板函数，所以都应该使用C++\n\nimport json\n\nimport cython\nfrom cython.cimports.olap_base import *\nfrom cython.cimports.lgraph_db import *\n# 从procedures/algo_cython/ 中cimportolap_base.pxd与lgraph_db.pxd, 类似C++中#include \"xxx.h\"\n\n该段落位于文档的第5章，介绍了Python包装的C++类PyGalaxy和PyGraphDB，提供了其构造函数和方法的详细信息，随后转向第6章，展示了用Python实现的BFS算法代码示例。这一部分主要体现了如何在TuGraph中利用该API进行图数据库的操作及算法实现。"
            },
            {
                "content": "# 注释作用如下：\n# language_level=3: 使用Python3\n# cpp_locals=True: 需要c++17，使用std::optional管理Python代码中的C++对象，可以避免C++对象的拷贝构造\n# boundscheck=False: 关闭索引的边界检查\n# wraparound=False: 关闭负数下标的处理（类似Python List）\n# initializedcheck=False: 关闭检查内存是否初始化，关闭检查后运行性能更快\n# language = c++: 将此py文件翻译为C++而不是C文件，TuGraph使用大量模板函数，所以都应该使用C++\n\nimport json\n\nimport cython\nfrom cython.cimports.olap_base import *\nfrom cython.cimports.lgraph_db import *\n# 从procedures/algo_cython/ 中cimportolap_base.pxd与lgraph_db.pxd, 类似C++中#include \"xxx.h\"\n\nfrom cython.cimports.libc.stdio import printf\n# 类似C++中#include \n# 其他常见的还有cython.cimports.libcpp.unordered_map等\n\nimport time\n\n该代码块位于文档的算法插件示例部分，旨在解释Cython编译的Python文件的注释和导入库的作用。具体包括与C++相关的配置选项和导入Cython接口的方式，为后续的BFS算法实现提供基础。"
            },
            {
                "content": "import json\n\nimport cython\nfrom cython.cimports.olap_base import *\nfrom cython.cimports.lgraph_db import *\n# 从procedures/algo_cython/ 中cimportolap_base.pxd与lgraph_db.pxd, 类似C++中#include \"xxx.h\"\n\nfrom cython.cimports.libc.stdio import printf\n# 类似C++中#include \n# 其他常见的还有cython.cimports.libcpp.unordered_map等\n\nimport time\n\n\n@cython.cclass\n# cython.cclass 表示BFSCore为C类型的Class\nclass BFSCore:\n    graph: cython.pointer(OlapBase[Empty])\n    # cython.pointer(OlapBase[Empty])表示OlapBase[Empty]的指针，类似C++中OlapBase[Empty]*\n    # cython提供了常见类型的指针，如cython.p_int, cython.p_char等，表示int*, char*, ...\n    parent: ParallelVector[size_t]\n    active_in: ParallelBitset\n    active_out: ParallelBitset\n    root: size_t\n    # root: size_t 声明root为C++ size_t类型变量，等效于root = cython.declare(size_t)\n    # 不声明类型的变量为Python object类型\n    # 声明变量类型会大幅提高性能，同时在多线程部分，只有C/C++类型的变量可以访问\n\n该代码块位于文档的\"算法插件示例\"部分，具体展示了如何使用Cython实现广度优先搜索（BFS）算法的核心类BFSCore。代码中定义了与图计算相关的成员变量和方法，包括图的指针、活跃节点集合以及算法的执行逻辑，强调了Cython的类型声明对性能的提升。"
            },
            {
                "content": "@cython.cfunc\n    # cython.cfunc 表示Work为C类型的函数，参数与返回值应声明\n    # cfunc性能好，能接受C/C++对象为参数、返回值，但是不能在其他python文件中调用\n    # 类似的有cython.ccall，如Standalone函数，可以在其他python文件中调用\n    @cython.nogil\n    # cython.nogil 表示释放Python全局解释锁，在nogil修饰的部分，不能访问Python对象\n    # 在多线程部分，都应有nogil修饰器\n    @cython.exceptval(check=False)\n    # cython.exceptval(check=False) 表示禁用异常传播，将忽略函数内部引发的Python异常\n    def Work(self, vi: size_t) -> size_t:\n        degree = cython.declare(size_t, self.graph.OutDegree(vi))\n        out_edges = cython.declare(AdjList[Empty], self.graph.OutEdges(vi))\n        i = cython.declare(size_t, 0)\n        local_num_activations = cython.declare(size_t, 0)\n        dst: size_t\n        for i in range(degree):\n            dst = out_edges[i].neighbour\n            if self.parent[dst] == cython.cast(size_t, -1):\n                # parent[dst] == -1 表示dst没有被bfs访问过\n                if self.active_out.Add(dst):\n                    # 将dst设置为为活跃节点；ParallelBitmap.Add为原子操作，防止重复计算\n                    self.parent[dst] = vi\n\n该代码片段位于算法插件示例部分，具体介绍了在TuGraph Python接口中实现BFS算法的工作函数`Work`的定义与功能。此函数是Cython中标记为`cfunc`的函数，涉及多线程操作的实现，并包含了对节点邻居的访问和处理逻辑，用于在图计算中进行广度优先搜索（BFS）。"
            },
            {
                "content": "i = cython.declare(size_t, 0)\n        local_num_activations = cython.declare(size_t, 0)\n        dst: size_t\n        for i in range(degree):\n            dst = out_edges[i].neighbour\n            if self.parent[dst] == cython.cast(size_t, -1):\n                # parent[dst] == -1 表示dst没有被bfs访问过\n                if self.active_out.Add(dst):\n                    # 将dst设置为为活跃节点；ParallelBitmap.Add为原子操作，防止重复计算\n                    self.parent[dst] = vi\n                    local_num_activations += 1\n        return local_num_activations\n\n该代码块位于文档的算法插件示例部分，具体是在BFS算法的实现中。它负责在遍历图的过程中计算活跃节点数量，检查每个邻接点是否已被访问，并将未访问的邻接点标记为活跃节点，以确保算法的正确性和效率。"
            },
            {
                "content": "@cython.cfunc\n    @cython.nogil\n    @cython.exceptval(check=False)\n    def run(self, g: cython.pointer(OlapBase[Empty]), r: size_t) -> cython.size_t:\n        self.graph = g\n        self.root = r\n        self.active_in = g.AllocVertexSubset()\n        self.active_out = g.AllocVertexSubset()\n        self.parent = g.AllocVertexArray[size_t]()\n        self.parent.Fill(-1)\n        num_vertices = cython.declare(size_t, self.graph.NumVertices())\n        printf(\"num_vertices = %lu\\n\", num_vertices)\n        self.parent[self.root] = self.root\n        num_activations = cython.declare(size_t, 1)\n        discovered_vertices = cython.declare(size_t, num_activations)\n        self.active_in.Add(self.root)\n        while num_activations > 0:\n            self.active_out.Clear()\n            num_activations = g.ProcessVertexActive[size_t, BFSCore](self.Work, self.active_in, self)\n            discovered_vertices += num_activations\n            self.active_out.Swap(self.active_in)\n\n该代码块位于文档中关于BFS算法的实现部分，主要是BFSCore类的run方法，用于执行广度优先搜索的核心逻辑。该方法通过管理活跃节点和父节点数组，实现对图的遍历，并统计发现的节点数量。此部分内容旨在展示如何在TuGraph图计算系统中利用Cython进行高效的图算法实现。"
            },
            {
                "content": "self.parent[self.root] = self.root\n        num_activations = cython.declare(size_t, 1)\n        discovered_vertices = cython.declare(size_t, num_activations)\n        self.active_in.Add(self.root)\n        while num_activations > 0:\n            self.active_out.Clear()\n            num_activations = g.ProcessVertexActive[size_t, BFSCore](self.Work, self.active_in, self)\n            discovered_vertices += num_activations\n            self.active_out.Swap(self.active_in)\n            printf(\"num_activations = %lu\\n\", num_activations)\n        return discovered_vertices\n\n该代码块位于实现BFS算法的Python示例中，描述了在图中处理节点激活的过程，通过调用`ProcessVertexActive`函数对当前活跃节点进行处理，并统计发现的节点数量。该部分主要展示了算法的执行逻辑和节点之间的关系更新，适用于理解图算法在TuGraph中的实现。"
            },
            {
                "content": "@cython.cfunc\ndef procedure_process(db: cython.pointer(GraphDB), request: dict, response: dict) -> cython.bint:\n    cost = time.time()\n    root_id = \"0\"\n    label = \"node\"\n    field = \"id\"\n    if \"root\" in request:\n        root_id = request[\"root\"]\n    if \"label\" in request:\n        label = request[\"label\"]\n    if \"field\" in request:\n        field = request[\"field\"]\n\n该代码块位于第6节“算法插件示例”中，作为BFS算法的实现部分，定义了`procedure_process`函数，主要用于处理数据库请求并获取该请求中的根节点信息、标签和字段，随后用于图计算的相关操作。"
            },
            {
                "content": "txn = db.CreateReadTxn()\n    olapondb = OlapOnDB[Empty](db[0], txn, SNAPSHOT_PARALLEL)\n    # 并行创建OlapOnDB\n    # Cython不支持如 *db 的解引用操作，通过db[0]来解引用\n    root_vid = txn.GetVertexIndexIterator(\n        label.encode('utf-8'), field.encode('utf-8'),\n        root_id.encode('utf-8'), root_id.encode('utf-8')\n    ).GetVid()\n    # 通过 GetVertexIndexIterator 根据root节点label名和filed名与filed值（root_id）\n    # 获取root节点的迭代器，通过迭代器获取vid，在无ID_MAPPING时，该vid与OlapOnDB中的id相同\n    cost = time.time() - cost\n    printf(\"prepare_cost = %lf s\\n\", cython.cast(cython.double, cost))\n    a = BFSCore()\n    cost = time.time()\n    count = a.run(cython.address(olapondb), root_vid)\n    cost = time.time() - cost\n    printf(\"core_cost = %lf s\\n\", cython.cast(cython.double, cost))\n    response[\"found_vertices\"] = count\n    response[\"num_vertices\"] = olapondb.NumVertices()\n    response[\"num_edges\"] = olapondb.NumEdges()\n    return True\n\n该代码块位于文档的算法插件示例部分，主要描述了如何在使用TuGraph的数据库中创建读取事务并并行化构建OlapOnDB图对象。它展示了如何通过迭代器获取根节点的顶点ID，并利用BFSCore类进行图的遍历，同时记录和输出相关性能指标。"
            },
            {
                "content": "@cython.ccall\ndef Process(db: lgraph_db_python.PyGraphDB, inp: bytes):\n    # Process为embed模式和procedure模式下插件入口，用cython.ccall修饰\n    # Process函数必须名为Process，参数为lgraph_db_python.PyGraphDB与bytes\n    # 返回值必须为(bool, str)\n    _inp = inp.decode(\"utf-8\")\n    request = json.loads(_inp)\n    response = {}\n    addr = cython.declare(cython.Py_ssize_t, db.get_pointer())\n    # 获取PyGraphDB中GraphDB对象的地址，转换为指针后传递\n    procedure_process(cython.cast(cython.pointer(GraphDB), addr),\n                      request, response)\n    return (True, json.dumps(response))\n\n```\n\n该代码块位于文档的第6部分，介绍了算法插件示例，具体展示了如何使用Cython编写一个名为`Process`的函数。此函数作为嵌入模式和过程模式下的插件入口，负责处理来自GraphDB的请求，并将相应的响应返回。整个部分强调了Cython在性能优化和C++对象交互中的重要性。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_132.md",
        "chunks": [
            {
                "content": "# 环境和版本选择\n\n> 该文档介绍如何选择系统环境，以及部署方式\n\n## 1. 简介\n\nTuGraph为不同需求的用户提供了差异化的系统环境和部署方式，来满足新手、系统开发者、生产运维人员、研究人员等不同用户的需求。\n\n## 2. 环境能力选择\n\n用户可以根据实际使用场景，来选择不同的环境。编译环境的能力最完备，所需的第三方软件也越多。与其相对应的，精简运行环境几乎不需要安装任何依赖库，能运行TuGraph除存储过程外的基础功能。\n\n| 环境     | 用途             | 备注        |\n|--------|----------------|-----------|\n| 编译环境   | 从源码编译TuGraph   | 适用于开发人员   |\n| 运行环境   | 运行TuGraph安装包   | 适用于大部分用户  |\n| 精简运行环境 | 运行精简TuGraph安装包 | 对系运行统依赖较小 |\n表格内容描述：该表格包含三列，分别是“环境”、“用途”和“备注”。\n\n- 第一行描述为：编译环境，主要用途是从源码编译TuGraph，适用于开发人员。\n- 第二行描述为：运行环境，主要用途是运行TuGraph安装包，适用于大部分用户。\n- 第三行描述为：精简运行环境，主要用途是运行精简TuGraph安装包，对系统运行依赖较小。\n\n总体而言，表格总结了不同环境下的用途及其适用人群，提供了从开发人员到普通用户的不同选择，以满足各类使用需求。\n\n\n## 3. 部署方式选择\n\nTuGraph部署仅需一台服务器（高可用模式需要多台），可根据实际资源情况和使用场景，选择适合的部署方式。\n\n该文档介绍了TuGraph系统的环境和版本选择，包括不同环境的能力和适用人群，以及多种部署方式的选择，以满足不同用户的需求。该块内容位于文档的开头部分，涵盖了环境能力的选择以及部署方式的选择，为用户提供了基础信息和指南。"
            },
            {
                "content": "| 环境     | 用途             | 备注        |\n|--------|----------------|-----------|\n| 编译环境   | 从源码编译TuGraph   | 适用于开发人员   |\n| 运行环境   | 运行TuGraph安装包   | 适用于大部分用户  |\n| 精简运行环境 | 运行精简TuGraph安装包 | 对系运行统依赖较小 |\n表格内容描述：该表格包含三列，分别是“环境”、“用途”和“备注”。\n\n- 第一行描述为：编译环境，主要用途是从源码编译TuGraph，适用于开发人员。\n- 第二行描述为：运行环境，主要用途是运行TuGraph安装包，适用于大部分用户。\n- 第三行描述为：精简运行环境，主要用途是运行精简TuGraph安装包，对系统运行依赖较小。\n\n总体而言，表格总结了不同环境下的用途及其适用人群，提供了从开发人员到普通用户的不同选择，以满足各类使用需求。\n\n\n## 3. 部署方式选择\n\nTuGraph部署仅需一台服务器（高可用模式需要多台），可根据实际资源情况和使用场景，选择适合的部署方式。\n\n| 部署方式     | 描述                   | 备注                                                                                   |\n|----------|----------------------|--------------------------------------------------------------------------------------|\n| 云部署      | 阿里云计算巢一键部署，免费试用      | 新手适用            |\n| Docker部署 | 通过预先准备的Docker镜像跨平台部署 | 对硬件有要求的用户，比如性能测试 |\n| 本地部署     | 在现有系统紧耦合部署           | 指定生产环境适用 |\n表格内容描述：\n\n该表格包含三列，分别是“部署方式”、“描述”和“备注”。\n\n该块内容位于文档的第二部分，主要介绍了TuGraph的环境能力选择，包括不同环境（编译环境、运行环境、精简运行环境）的用途及适用人群。在其后的部分，文档继续探讨部署方式选择，提供了云部署、Docker部署和本地部署的描述及适用场景。"
            },
            {
                "content": "## 3. 部署方式选择\n\nTuGraph部署仅需一台服务器（高可用模式需要多台），可根据实际资源情况和使用场景，选择适合的部署方式。\n\n| 部署方式     | 描述                   | 备注                                                                                   |\n|----------|----------------------|--------------------------------------------------------------------------------------|\n| 云部署      | 阿里云计算巢一键部署，免费试用      | 新手适用            |\n| Docker部署 | 通过预先准备的Docker镜像跨平台部署 | 对硬件有要求的用户，比如性能测试 |\n| 本地部署     | 在现有系统紧耦合部署           | 指定生产环境适用 |\n表格内容描述：\n\n该表格包含三列，分别是“部署方式”、“描述”和“备注”。\n\n1. 第一行：部署方式为“云部署”，其描述为“阿里云计算巢一键部署，免费试用”，备注说明这是“新手适用”。\n2. 第二行：部署方式为“Docker部署”，描述为“通过预先准备的Docker镜像跨平台部署”，备注提到这是针对“对硬件有要求的用户，比如性能测试”。\n3. 第三行：部署方式为“本地部署”，描述为“在现有系统紧耦合部署”，备注说明适用于“指定生产环境”。\n\n整体而言，表格提供了三种不同的部署方式及其适用场景，分别为云部署（适合新手）、Docker部署（适合对硬件有要求的用户）以及本地部署（适合特定生产环境）。\n\n## 4. 后续步骤\n\n部署完成后，后续可以进行启动服务、数据导入等操作，也可以通过样例数据来体验整个流程。\n\n该块内容为文档的第三部分，主要介绍TuGraph的部署方式选择，包括云部署、Docker部署和本地部署三种选项，以及各自的适用场景和备注信息。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_133.md",
        "chunks": [
            {
                "content": "# Hbase Connector介绍\nHbase Connector由社区贡献，目前仅支持Sink。\n\n## 语法示例\n\n```sql\nCREATE TABLE hbase_table (\n  id BIGINT,\n  name VARCHAR,\n  age INT\n) WITH (\n\ttype='hbase',\n    geaflow.dsl.hbase.zookeeper.quorum = '127.0.0.1',\n    geaflow.dsl.hbase.tablename = 'GeaFlowBase',\n    geaflow.dsl.hbase.rowkey.column = 'id'\n);\n```\n## 参数\n\n| 参数名 | 是否必须 | 描述 |\n| -------- | -------- | -------- |\n| geaflow.dsl.hbase.zookeeper.quorum     | 是     | HBase zookeeper quorum servers list.     |\n| geaflow.dsl.hbase.namespace     | 否     | HBase namespace.     |\n| geaflow.dsl.hbase.tablename     | 是     | HBase table name.     |\n| geaflow.dsl.hbase.rowkey.column     | 是     | HBase rowkey columns.     |\n| geaflow.dsl.hbase.rowkey.separator     | 否     | HBase rowkey join serapator.     |\n| geaflow.dsl.hbase.familyname.mapping     | 否     | HBase column family name mapping.     |\n| geaflow.dsl.hbase.buffersize     | 否     | HBase writer buffer size.     |\n表格内容描述:\n\n该表格包含三个列名：参数名、是否必须、描述。\n\n此段落介绍Hbase Connector的基本信息，包括其支持的功能和使用语法示例，以及相关的配置参数和说明，为用户提供建立HBase表时所需的具体参数设置和要求。"
            },
            {
                "content": "该表格包含三个列名：参数名、是否必须、描述。\n\n1. 第一行：参数名为 \"geaflow.dsl.hbase.zookeeper.quorum\"，该参数是必须的，描述为 HBase 的 zookeeper quorum 服务器列表。\n2. 第二行：参数名为 \"geaflow.dsl.hbase.namespace\"，该参数不是必须的，描述为 HBase 的命名空间。\n3. 第三行：参数名为 \"geaflow.dsl.hbase.tablename\"，该参数是必须的，描述为 HBase 的表名。\n4. 第四行：参数名为 \"geaflow.dsl.hbase.rowkey.column\"，该参数是必须的，描述为 HBase 的 rowkey 列。\n5. 第五行：参数名为 \"geaflow.dsl.hbase.rowkey.separator\"，该参数不是必须的，描述为 HBase rowkey 的连接分隔符。\n6. 第六行：参数名为 \"geaflow.dsl.hbase.familyname.mapping\"，该参数不是必须的，描述为 HBase 列族名称映射。\n7. 第七行：参数名为 \"geaflow.dsl.hbase.buffersize\"，该参数不是必须的，描述为 HBase 写入缓冲区大小。\n\n整体总结：该表格详细列出了与 HBase 配置相关的参数，其中包含 4 个必须参数和 3 个可选参数，涉及 zookeeper 服务器列表、命名空间、表名、rowkey 配置以及读写缓冲设置，明确了每个参数的功能与必要性。\n\n## 示例\n\n```sql\nCREATE TABLE file_source (\n  id BIGINT,\n  name VARCHAR,\n  age INT\n) WITH (\n\ttype='file',\n    geaflow.dsl.file.path = '/path/to/file'\n);\n\n该段落位于Hbase Connector介绍部分，具体描述了HBase连接器中各个参数的详细信息，包括参数名称、是否必需及其功能，同时总结了这些参数的必要性，并紧接着提供了示例代码。"
            },
            {
                "content": "整体总结：该表格详细列出了与 HBase 配置相关的参数，其中包含 4 个必须参数和 3 个可选参数，涉及 zookeeper 服务器列表、命名空间、表名、rowkey 配置以及读写缓冲设置，明确了每个参数的功能与必要性。\n\n## 示例\n\n```sql\nCREATE TABLE file_source (\n  id BIGINT,\n  name VARCHAR,\n  age INT\n) WITH (\n\ttype='file',\n    geaflow.dsl.file.path = '/path/to/file'\n);\n\nCREATE TABLE hbase_table (\n  id BIGINT,\n  name VARCHAR,\n  age INT\n) WITH (\n\ttype='hbase',\n    geaflow.dsl.hbase.zookeeper.quorum = '127.0.0.1',\n    geaflow.dsl.hbase.tablename = 'GeaFlowBase',\n    geaflow.dsl.hbase.rowkey.column = 'id'\n);\n\nINSERT INTO hbase_table\nSELECT * FROM file_source;\n```\n\n该段落总结了HBase Connector参数的功能与必要性，并提供了示例代码，展示了如何创建HBase表以及如何将数据从文件源插入到HBase表中。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_134.md",
        "chunks": [
            {
                "content": "# 自定义Connector\n\nGeaFlow 支持使用Java SPI方式定义用户自定义Connector。\n## 接口\n### 表Connector\n用户应该实现一个 TableConnector 接口。我们支持使用 TableReadableConnector 用于读取数据，使用 TableWritableConnector 用于写入数据。如果两个接口都实现了，连接器将同时支持读和写操作。\n\n```java\n/**\n * The interface for table connector.\n */\npublic interface TableConnector {\n\n    /**\n     * Return table connector type.\n     */\n    String getType();\n}\n\n/**\n * A readable table connector.\n */\npublic interface TableReadableConnector extends TableConnector {\n\n    TableSource createSource(Configuration conf);\n}\n\n/**\n * A writable table connector.\n */\npublic interface TableWritableConnector extends TableConnector {\n\n    /**\n     * Create the {@link TableSink} for the table connector.\n     */\n    TableSink createSink(Configuration conf);\n}\n```\n\n## TableSource\nTableSource 接口用于从连接器中读取数据。\n\n```java\n/**\n * Interface for table source.\n */\npublic interface TableSource extends Serializable {\n\n    /**\n     * The init method for compile time.\n     */\n    void init(Configuration tableConf, TableSchema tableSchema);\n\n该文档介绍了如何在 GeaFlow 中使用 Java SPI 方式定义自定义 Connector，其中包含接口定义、TableSource 和 TableSink 的实现，以及具体示例。该 chunk 主要集中在表 Connector 接口的定义，说明了如何实现 TableReadableConnector 和 TableWritableConnector 接口以支持数据的读取与写入。"
            },
            {
                "content": "/**\n * A writable table connector.\n */\npublic interface TableWritableConnector extends TableConnector {\n\n    /**\n     * Create the {@link TableSink} for the table connector.\n     */\n    TableSink createSink(Configuration conf);\n}\n```\n\n## TableSource\nTableSource 接口用于从连接器中读取数据。\n\n```java\n/**\n * Interface for table source.\n */\npublic interface TableSource extends Serializable {\n\n    /**\n     * The init method for compile time.\n     */\n    void init(Configuration tableConf, TableSchema tableSchema);\n\n    /**\n     * The init method for runtime.\n     */\n    void open(RuntimeContext context);\n\n    /**\n     * List all the partitions for the source.\n     */\n    List listPartitions();\n\n    /**\n     * Returns the {@link TableDeserializer} for the source to convert data read from\n     * the source to {@link Row}.\n     */\n     TableDeserializer getDeserializer(Configuration conf);\n\n该代码块定义了 `TableWritableConnector` 接口，它是 GeaFlow 自定义Connector的一部分，允许用户实现用于将数据写入连接器的功能。该接口特别强调如何创建与表连接器相关联的 `TableSink`。在文档的上下文中，此部分紧接着表述读取数据的 `TableSource` 接口之前，显示了连接器的读写操作的结构。"
            },
            {
                "content": "/**\n     * The init method for compile time.\n     */\n    void init(Configuration tableConf, TableSchema tableSchema);\n\n    /**\n     * The init method for runtime.\n     */\n    void open(RuntimeContext context);\n\n    /**\n     * List all the partitions for the source.\n     */\n    List listPartitions();\n\n    /**\n     * Returns the {@link TableDeserializer} for the source to convert data read from\n     * the source to {@link Row}.\n     */\n     TableDeserializer getDeserializer(Configuration conf);\n\n    /**\n     * Fetch data for the partition from start offset. if the windowSize is -1, it represents an\n     * all-window which will read all the data from the source, else return widow size for data.\n     */\n     FetchData fetch(Partition partition, Optional startOffset, long windowSize) throws IOException;\n\n    /**\n     * The close callback for the job finish the execution.\n     */\n    void close();\n}\n\n```\n\n## TableSink\nTableSink 接口用于将数据写入连接器。\n\n该代码块属于文档中 TableSource 接口的部分，描述了 TableSource 接口中的方法，这些方法用于从自定义连接器中读取数据。接下来将介绍 TableSink 接口，该接口用于将数据写入连接器。"
            },
            {
                "content": "/**\n     * Fetch data for the partition from start offset. if the windowSize is -1, it represents an\n     * all-window which will read all the data from the source, else return widow size for data.\n     */\n     FetchData fetch(Partition partition, Optional startOffset, long windowSize) throws IOException;\n\n    /**\n     * The close callback for the job finish the execution.\n     */\n    void close();\n}\n\n```\n\n## TableSink\nTableSink 接口用于将数据写入连接器。\n\n```java\n/**\n * Interface for table sink.\n */\npublic interface TableSink extends Serializable {\n\n    /**\n     * The init method for compile time.\n     */\n    void init(Configuration tableConf, StructType schema);\n\n    /**\n     * The init method for runtime.\n     */\n    void open(RuntimeContext context);\n\n    /**\n     * The write method for writing row to the table.\n     */\n    void write(Row row) throws IOException;\n\n    /**\n     * The finish callback for each window finished.\n     */\n    void finish() throws IOException;\n\n该文档介绍了 GeaFlow 平台上自定义连接器的实现，包括表连接器（TableConnector）、可读连接器（TableReadableConnector）和可写连接器（TableWritableConnector）。提到的代码块片段包含了用于从连接器中读取数据的 `TableSource` 接口和用于将数据写入连接器的 `TableSink` 接口的相关方法，具体涉及数据获取和资源关闭的功能。"
            },
            {
                "content": "/**\n     * The init method for compile time.\n     */\n    void init(Configuration tableConf, StructType schema);\n\n    /**\n     * The init method for runtime.\n     */\n    void open(RuntimeContext context);\n\n    /**\n     * The write method for writing row to the table.\n     */\n    void write(Row row) throws IOException;\n\n    /**\n     * The finish callback for each window finished.\n     */\n    void finish() throws IOException;\n\n    /**\n     * The close callback for the job finish the execution.\n     */\n    void close();\n}\n```\n\n## 示例\n下面是一个用于控制台的Table Connector的示例。\n### 实现\n\n```java\npublic class ConsoleTableConnector implements TableWritableConnector {\n\n    @Override\n    public String getType() {\n        return \"CONSOLE\";\n    }\n\n    @Override\n    public TableSink createSink(Configuration conf) {\n        return new ConsoleTableSink();\n    }\n}\n\npublic class ConsoleTableSink implements TableSink {\n\n    private static final Logger LOGGER = \n\t\t\tLoggerFactory.getLogger(ConsoleTableSink.class);\n\n该代码块属于文档中关于 `TableSink` 接口的部分，定义了表数据写入的主要方法，包括初始化、打开、写入数据、完成和关闭等操作。这部分是在示例中实现控制台表连接器的具体细节之前的定义，展示了如何实现一个支持写入数据的连接器。"
            },
            {
                "content": "## 示例\n下面是一个用于控制台的Table Connector的示例。\n### 实现\n\n```java\npublic class ConsoleTableConnector implements TableWritableConnector {\n\n    @Override\n    public String getType() {\n        return \"CONSOLE\";\n    }\n\n    @Override\n    public TableSink createSink(Configuration conf) {\n        return new ConsoleTableSink();\n    }\n}\n\npublic class ConsoleTableSink implements TableSink {\n\n    private static final Logger LOGGER = \n\t\t\tLoggerFactory.getLogger(ConsoleTableSink.class);\n\n    private boolean skip;\n\n    @Override\n    public void init(Configuration tableConf, StructType schema) {\n        skip = tableConf.getBoolean(ConsoleConfigKeys.GEAFLOW_DSL_CONSOLE_SKIP);\n    }\n\n    @Override\n    public void open(RuntimeContext context) {\n\n    }\n\n    @Override\n    public void write(Row row) {\n        if (!skip) {\n            LOGGER.info(row.toString());\n        }\n    }\n\n    @Override\n    public void finish() {\n\n    }\n\n    @Override\n    public void close() {\n\n该块内容为文档中的示例部分，展示了如何实现一个针对控制台的Table Connector，包括具体的代码实现和相关类的设计。它位于文档关于自定义Connector和接口定义的后面部分，帮助用户理解如何创建和使用自定义连接器。"
            },
            {
                "content": "private boolean skip;\n\n    @Override\n    public void init(Configuration tableConf, StructType schema) {\n        skip = tableConf.getBoolean(ConsoleConfigKeys.GEAFLOW_DSL_CONSOLE_SKIP);\n    }\n\n    @Override\n    public void open(RuntimeContext context) {\n\n    }\n\n    @Override\n    public void write(Row row) {\n        if (!skip) {\n            LOGGER.info(row.toString());\n        }\n    }\n\n    @Override\n    public void finish() {\n\n    }\n\n    @Override\n    public void close() {\n\n    }\n}\n```\n在实现了 ConsoleTableConnector 后，您需要将完整的类名添加到 resources/META-INF.services/com.antgroup.geaflow.dsl.connector.api.\nTableConnector 文件中。该文件应列出所有实现了 TableConnector 接口的连接器类的全名，以便 GeaFlow 在启动时能够扫描到这些类，并将它们注册为可用的Connector。\n\n### 用法\n\n```sql\nCREATE TABLE file_source (\n  id BIGINT,\n  name VARCHAR,\n  age INT\n) WITH (\n    type='file',\n    geaflow.dsl.file.path = '/path/to/file'\n);\n\nCREATE TABLE console_sink (\n  id BIGINT,\n  name VARCHAR,\n  age INT\n) WITH (\n    type='console'\n);\n\nINSERT INTO console_sink\nSELECT * FROM file_source;\n```\n\n该代码块包含了 `ConsoleTableSink` 类的主要实现部分，包括成员变量 `skip` 的定义及其在 `init`、`open`、`write`、`finish` 和 `close` 方法中的实现。此部分还说明了如何将自定义的 `ConsoleTableConnector` 类注册到 GeaFlow，并提供了一个 SQL 示例演示如何创建数据表和进行数据插入。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_135.md",
        "chunks": [
            {
                "content": "# 场景：影视（基于tugraph-db的产品内置场景上手体验）\n\n> 此文档主要介绍 影视场景Demo 的使用方法。\n\n## 1.建模和数据导入\n\n完成登录后，点击`新建图项目`，选择movie数据，填写图项目配置，系统会自动完成Movie场景图项目创建。其余场景也可用相同方式创建。\n\nMovie 场景图：\n\n该内容是文档的开头部分，主要介绍了影视场景的Demo使用方法，包括项目的创建和建模的数据结构。"
            },
            {
                "content": "> 此文档主要介绍 影视场景Demo 的使用方法。\n\n## 1.建模和数据导入\n\n完成登录后，点击`新建图项目`，选择movie数据，填写图项目配置，系统会自动完成Movie场景图项目创建。其余场景也可用相同方式创建。\n\nMovie 场景图：\n\n\n\n| 标签          | 类型  | 说明                                  |\n|-------------|-----|-------------------------------------|\n| movie       | 实体  | 表示某一部具体的影片，比如\"阿甘正传\"。                |\n| person      | 实体  | 表示个人，对影片来说可能是演员、导演，或编剧。             |\n| genre       | 实体  | 表示影片的类型，比如剧情片、恐怖片。                  |\n| keyword     | 实体  | 表示与影片相关的一些关键字，比如\"拯救世界\"、\"虚拟现实\"、\"地铁\"。 |\n| user        | 实体  | 表示观影的用户。                            |\n| produce     | 关系  | 表示影片的出品人关系。                         |\n| acted_in    | 关系  | 表示演员出演了哪些影片。                        |\n| direct      | 关系  | 表示影片的导演是谁。                          |\n| write       | 关系  | 表示影片的编剧关系。                          |\n| has_genre   | 关系  | 表示影片的类型分类。                          |\n| has_keyword | 关系  | 表示影片的一些关键字，即更细分类的标签。                |\n| rate        | 关系  | 表示用户对影片的打分。                         |\n表格内容描述:\n该表格包含三列，分别为“标签”、“类型”和“说明”。\n\n该文档介绍了影视场景Demo的使用方法，其中第一部分重点在于建模和数据导入，包含电影场景图的实体和关系定义，以及相关标签的说明。这为后续的查询示例提供了数据结构的基础。"
            },
            {
                "content": "逐行描述数据内容如下：\n1. 标签“movie”是一个实体，表示某一部具体的影片，比如“阿甘正传”。\n2. 标签“person”也是一个实体，表示个人，可能是演员、导演或编剧。\n3. 标签“genre”为实体，表示影片的类型，比如剧情片或恐怖片。\n4. 标签“keyword”为实体，表示与影片相关的一些关键字，例如“拯救世界”、“虚拟现实”或“地铁”。\n5. 标签\"user\"为实体，表示观影的用户。\n6. 标签“produce”是一个关系，表示影片的出品人关系。\n7. 标签“acted_in”也是一个关系，表示演员出演了哪些影片。\n8. 标签“direct”表示影片的导演是谁。\n9. 标签“write”是一个关系，表示影片的编剧关系。\n10. 标签“has_genre”是关系，表示影片的类型分类。\n11. 标签“has_keyword”表示影片的一些关键字，即更细分类的标签。\n12. 标签“rate”是一个关系，表示用户对影片的打分。\n\n整体内容的概要总结是：该表格定义了与影片相关的多种实体（如影片、个人、类型和关键字）及其之间的关系（如出品人、演员、导演、编剧、类型分类、关键字和用户评分）。通过这些标签，可以清晰地描述影片的基本信息和相关的用户交互。\n\n## 2.查询示例\n\n### 2.1.示例一\n\n查询影片 'Forrest Gump' 的所有演员，返回影片和演员构成的子图。\n\n```\nMATCH (m:movie {title: 'Forrest Gump'})<-[:acted_in]-(a:person) RETURN a, m\n```\n\n### 2.2.示例二\n\n查询影片 'Forrest Gump' 的所有演员，列出演员在影片中扮演的角色。\n\n```\nMATCH (m:movie {title: 'Forrest Gump'})<-[r:acted_in]-(a:person) RETURN a.name,r.role\n```\n\n### 2.3.示例三\n\n查询 Michael 所有评分低于 3 分的影片。\n\n```\nMATCH (u:user {login: 'Michael'})-[r:rate]->(m:movie) WHERE r.stars < 3 RETURN m.title, r.stars\n```\n\n### 2.4.示例四\n\n该内容位于文档的第二部分，详细逐行描述了影视场景中涉及的各种实体及关系，包括影片、个人、类型和关键词，以及如何通过这些标签清晰地描述影片信息和用户交互。接下来是针对这些实体和关系的查询示例。"
            },
            {
                "content": "## 2.查询示例\n\n### 2.1.示例一\n\n查询影片 'Forrest Gump' 的所有演员，返回影片和演员构成的子图。\n\n```\nMATCH (m:movie {title: 'Forrest Gump'})<-[:acted_in]-(a:person) RETURN a, m\n```\n\n### 2.2.示例二\n\n查询影片 'Forrest Gump' 的所有演员，列出演员在影片中扮演的角色。\n\n```\nMATCH (m:movie {title: 'Forrest Gump'})<-[r:acted_in]-(a:person) RETURN a.name,r.role\n```\n\n### 2.3.示例三\n\n查询 Michael 所有评分低于 3 分的影片。\n\n```\nMATCH (u:user {login: 'Michael'})-[r:rate]->(m:movie) WHERE r.stars < 3 RETURN m.title, r.stars\n```\n\n### 2.4.示例四\n\n查询和 Michael 有相同讨厌的影片的用户，讨厌标准为评分小于三分。\n\n```\nMATCH (u:user {login: 'Michael'})-[r:rate]->(m:movie)<-[s:rate]-(v) WHERE r.stars < 3 AND s.stars < 3 RETURN u, m, v\n```\n\n### 2.5.示例五\n\n给 Michael 推荐影片，方法为先找出和 Michael 讨厌同样影片的用户，再筛选出这部分用户喜欢的影片。\n\n```\nMATCH (u:user {login: 'Michael'})-[r:rate]->(m:movie)<-[s:rate]-(v)-[r2:rate]->(m2:movie) WHERE r.stars < 3 AND s.stars < 3 AND r2.stars > 3 RETURN u, m, v, m2\n```\n\n### 2.6.示例六\n\n查询 Michael 的好友们喜欢的影片。\n\n```\nMATCH (u:user {login: 'Michael'})-[:is_friend]->(v:user)-[r:rate]->(m:movie) WHERE r.stars > 3 RETURN u, v, m\n```\n\n该段落包含了多个查询示例，演示如何使用图数据库语言查询与特定影片“阿甘正传”和用户Michael相关的信息。这些示例展示了如何提取演员、评分、用户喜好等数据，以便进行分析和推荐。"
            },
            {
                "content": "### 2.5.示例五\n\n给 Michael 推荐影片，方法为先找出和 Michael 讨厌同样影片的用户，再筛选出这部分用户喜欢的影片。\n\n```\nMATCH (u:user {login: 'Michael'})-[r:rate]->(m:movie)<-[s:rate]-(v)-[r2:rate]->(m2:movie) WHERE r.stars < 3 AND s.stars < 3 AND r2.stars > 3 RETURN u, m, v, m2\n```\n\n### 2.6.示例六\n\n查询 Michael 的好友们喜欢的影片。\n\n```\nMATCH (u:user {login: 'Michael'})-[:is_friend]->(v:user)-[r:rate]->(m:movie) WHERE r.stars > 3 RETURN u, v, m\n```\n\n### 2.7.示例七\n\n通过查询给'Forrest Gump'打高分的人也喜欢哪些影片，给喜欢'Forrest Gump'的用户推荐类似的影片。\n\n```\nMATCH (m:movie {title:'Forrest Gump'})<-[r:rate]-(u:user)-[r2:rate]->(m2:movie) WHERE r.stars>3 AND r2.stars>3 RETURN m, u,m2\n```\n\n该块内容位于文档的查询示例部分，具体涵盖了与用户推荐影片相关的查询示例，包括如何基于用户的评分行为推荐影片、查询好友喜好的影片以及根据高评分用户的偏好推荐类似影片。通过这些示例，用户可以了解如何利用图数据库进行个性化推荐。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_136.md",
        "chunks": [
            {
                "content": "# 性能优先\n\n> 此文档主要介绍 TuGraph 性能优先的设计理念。\n\n## 1.简介\n\nTuGraph目前是世界上最快的图数据库，在图数据库标准评测LDBC SNB Interactive位居榜首（2023.3）。TuGraph的设计基于性能优先，致力于打造高性能的单机图数据库。该文档是TuGraph基于性能优先在存储层的核心设计。\n\n## 2.图操作的特性\n\n在属性图上的操作涉及读、写及其属性，对一些特殊的属性比如时间戳也访问模式也会影响到整体性能。这里通过对一些图操作特性的规律总结，来指导最终的性能。\n\n我们观察到很多图应用有类似的数据访问模式。例如，在信贷风险控制中，我们使用递归路径过滤搜索多对一模式，以找到可疑的信用欺诈用户和行为。针对网络赌博，可以通过识别短时间内的多笔资金转移，来发现涉赌的资金账号。股权穿透场景对实体间的股权关系进行递归计算。这些场景具有多跳实体和关系访问、时间窗口约束和读写事务等常见模式。\n更进一步，从介绍中的讨论和图负载的分析中，归纳出以下特征:\n\n**规律一** KHop是图中最典型的操作，它基于点和边的图拓扑的数据访问模式，和关系型数据库有着本质的区别。KHop 的典型性除了表现在数据访问模式不同，它同时也是图数据库最需要关注的性能点。\n\n**规律二** 图负载的数据访问在拓扑上有一定的局部性，同一个点的边通常会被同时访问。当这些边的标签相同时，有更大的概率会被同时访问。\n\n**规律三** 图负载在访问点边时，通常会访问其对应的属性，来作为遍历过滤的条件。\n\n**规律四** 在基于时序的图负载，对点边的过滤通常是在某个时间范围，比如最近的一周。\n\n**规律五** 写操作可能伴随着大量的读操作，需要在单个事务周期里处理。\n\n通过对实际线上图应用的分析，图负载的读写比率大约为 20:1，虽然场景局限在金融场景，集群数也有限，但涉及的数据规模和用户量非常庞大，具有一定代表性。20:1 的图负载读写比率，说明读工作负载对整体性能的影响更大， 而写工作负载的性能也不能忽视。\n\n## 3.存储数据结构\n\nTuGraph底层采用B+树来支持实时的增删查改事务。\n\n该文档介绍了TuGraph图数据库的性能优先设计理念，首先概述了其在图数据库领域的领先地位，接着分析了图操作的特性和负载模式，强调了读写比率对性能的影响，最后说明了在存储数据结构中选择B+树的原因，为后续讨论TuGraph的存储层设计奠定了基础。"
            },
            {
                "content": "**规律一** KHop是图中最典型的操作，它基于点和边的图拓扑的数据访问模式，和关系型数据库有着本质的区别。KHop 的典型性除了表现在数据访问模式不同，它同时也是图数据库最需要关注的性能点。\n\n**规律二** 图负载的数据访问在拓扑上有一定的局部性，同一个点的边通常会被同时访问。当这些边的标签相同时，有更大的概率会被同时访问。\n\n**规律三** 图负载在访问点边时，通常会访问其对应的属性，来作为遍历过滤的条件。\n\n**规律四** 在基于时序的图负载，对点边的过滤通常是在某个时间范围，比如最近的一周。\n\n**规律五** 写操作可能伴随着大量的读操作，需要在单个事务周期里处理。\n\n通过对实际线上图应用的分析，图负载的读写比率大约为 20:1，虽然场景局限在金融场景，集群数也有限，但涉及的数据规模和用户量非常庞大，具有一定代表性。20:1 的图负载读写比率，说明读工作负载对整体性能的影响更大， 而写工作负载的性能也不能忽视。\n\n## 3.存储数据结构\n\nTuGraph底层采用B+树来支持实时的增删查改事务。\n\n在排序树的数据结构中，B+树和LSM树为主要代表。B+树在树节点中使用拆分和合并式来更新排序数据，而 LSM 树在日志中追加更新，以进行延迟数据合并。B+ 早期用在文件系统的实现中，通过将数据保存 在自适应长度的叶子节点中，解决硬盘顺序操作和随机操作性能存在数据量级差别的问题，有较均衡的读写性能。LSM 树的主要优势使用 WAL(Write Ahead Log) 进行更新，将更新操作变成顺序操作，在键值较小时性能优势尤为突出。WAL 意味着将数据的更新合并推迟，批量更新能提升综合效率，也使得系统的调度变得复杂。如果更新合并完成前，恰好对其中的数据继续读取，LSM 树就需要读取几个层级局部合并的日志，会导致读取放大和空间放大，从而影响读效率。\n\n总结来说，B+ 树有较好的顺序读写性能，而 LSM 树在数据随机写方面占优。此外 LSM 树采用后台合并的方式，使得性能的波动难以预期，性能波动和上层存储和计算的关联性较弱，增加了整体设计的成本。综上考虑，TuGraph 选用 B+ 树作为读性能优先的实现。\n\n## 4.数据编码\n\n在文档中，这一段落位于第二部分“图操作的特性”与第三部分“存储数据结构”之间，主要总结了图数据库操作的关键规律，并分析了在实际应用中读写比率对性能的影响，为后续介绍TuGraph采用B+树作为存储结构奠定了基础。"
            },
            {
                "content": "## 3.存储数据结构\n\nTuGraph底层采用B+树来支持实时的增删查改事务。\n\n在排序树的数据结构中，B+树和LSM树为主要代表。B+树在树节点中使用拆分和合并式来更新排序数据，而 LSM 树在日志中追加更新，以进行延迟数据合并。B+ 早期用在文件系统的实现中，通过将数据保存 在自适应长度的叶子节点中，解决硬盘顺序操作和随机操作性能存在数据量级差别的问题，有较均衡的读写性能。LSM 树的主要优势使用 WAL(Write Ahead Log) 进行更新，将更新操作变成顺序操作，在键值较小时性能优势尤为突出。WAL 意味着将数据的更新合并推迟，批量更新能提升综合效率，也使得系统的调度变得复杂。如果更新合并完成前，恰好对其中的数据继续读取，LSM 树就需要读取几个层级局部合并的日志，会导致读取放大和空间放大，从而影响读效率。\n\n总结来说，B+ 树有较好的顺序读写性能，而 LSM 树在数据随机写方面占优。此外 LSM 树采用后台合并的方式，使得性能的波动难以预期，性能波动和上层存储和计算的关联性较弱，增加了整体设计的成本。综上考虑，TuGraph 选用 B+ 树作为读性能优先的实现。\n\n## 4.数据编码\n\n对于属性图模型而言，除了图拓扑编码外，属性数据也会很大程度影响功能和性能，我们先讨论属性数据如何与拓扑数据共存的编码格式。从目前的调研来看，属性编码有两种方式，我们称之为基于指针索引将属性数据单独存储的离散编码，和将属性数据和拓扑数据打包在一起的紧凑编码。离散编码根据程度的不同，可以每个属性都单独存储，或者每条边的属性打包后各自存储，下面的讨论对两种情况都适用。\n\n点查询。属性编码主要针对边，不涉及点查询。\n\n单边查询。离散编码通过指针定位边，紧凑编码则需要二分查找定位边的位置，离散编码有略微的优势。\n\n边遍历。离散编码在边遍历过程需要不断地进行指针跳转进行随机数据访问，而紧凑编码提前把数据排列在一起，顺序访问的特性使得效率大大提升。 由规律三知对边的遍历操作很普遍，紧凑编码在边遍历的优势明显。\n\n单边更新。离散编码对边的更新仅需找到对应的指针位置，插入数据后修改前后指针指向。紧凑编码则需要对紧凑排列的数据进行重编码，对整个边值进行重新写入，开销显著大于离散编码的情形。\n\n该段落主要讨论TuGraph数据库的存储数据结构，强调其采用B+树以优化读写性能，同时与LSM树进行比较。接下来，引入属性数据编码的方式，探讨不同编码形式对图数据库查询和更新性能的影响，从而为后续章节关于数据编码的详细分析奠定基础。"
            },
            {
                "content": "## 4.数据编码\n\n对于属性图模型而言，除了图拓扑编码外，属性数据也会很大程度影响功能和性能，我们先讨论属性数据如何与拓扑数据共存的编码格式。从目前的调研来看，属性编码有两种方式，我们称之为基于指针索引将属性数据单独存储的离散编码，和将属性数据和拓扑数据打包在一起的紧凑编码。离散编码根据程度的不同，可以每个属性都单独存储，或者每条边的属性打包后各自存储，下面的讨论对两种情况都适用。\n\n点查询。属性编码主要针对边，不涉及点查询。\n\n单边查询。离散编码通过指针定位边，紧凑编码则需要二分查找定位边的位置，离散编码有略微的优势。\n\n边遍历。离散编码在边遍历过程需要不断地进行指针跳转进行随机数据访问，而紧凑编码提前把数据排列在一起，顺序访问的特性使得效率大大提升。 由规律三知对边的遍历操作很普遍，紧凑编码在边遍历的优势明显。\n\n单边更新。离散编码对边的更新仅需找到对应的指针位置，插入数据后修改前后指针指向。紧凑编码则需要对紧凑排列的数据进行重编码，对整个边值进行重新写入，开销显著大于离散编码的情形。\n\n批量边更新。批量更新可以在内存中预先构建点的所有边属性，一次性编码写入，离散编码和紧凑编码相当。但紧凑编码不需要存储指针变量，更少的存储空间效率也会更高。\n\n以上离散编码和紧凑编码在某一类的查询的性能问题，可以通过优化的来缓解。整体上说，由于图负载读写 20:1 的特性，读性能在整体性能中占比更高。以及规律三所揭示的对属性访问的特征，TuGraph 更倾向于采用紧凑编码来保证读性能。其主要弱势为单边更新时重编码的开销，可以用自适应映射的技术来解决。\n\n该块内容位于文档的第4章，讨论了在TuGraph图数据库中属性数据的编码方式，包括离散编码和紧凑编码的特点及其对图操作性能的影响，特别强调了读性能在整体性能中的重要性，以及TuGraph如何选择编码方式以优化图数据库的性能。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_137.md",
        "chunks": [
            {
                "content": "# 功能概览\n\n> 此文档主要介绍 TuGraph 的主要功能和特性。\n\n## 1.安装部署\n\n## 1.1.部署方式\n\nTuGraph目前提供云部署、Docker部署以及安装包部署三种部署方式，用户可根据实际情况选择适合的部署方式。\n\n## 1.2.软硬件环境\n\nTuGraph核心是由C++开发，默认使用的编译器为GCC8.4，使用c++17标准。此外，存储过程中额外提供了Python Procedure API，该功能需要Python环境。TuGraph不需要特殊的硬件比如GPU，对RDMA、HBM等高延迟低带宽的通用硬件升级可以天然适配。\n\nTuGraph测试过基于X86和ARM的CPU，包括Intel、AMD、Kunpeng、Hygon、飞腾等，也同时在多个操作系统上运行，包括Ubuntu、CentOS、SUSE、银河麒麟、中标麒麟、UOS的主流版本，对操作系统和CPU没有特殊的要求。\n\n软硬件环境也包括依赖库的环境，由于TuGraph的存储层中默认的KV存储是LMDB，需要文件系统能够支持POSIX接口。在不同的环境下编译和参数配置会略有不同，比如在图存储的点边数据打包中，应和操作系统的页表大小匹配，默认为4KB，建议将系统的页表大小也设置为4KB。\n\n## 2.存储层\n\n在图数据模型上，TuGraph支持属性图模型，按照层次可以分为子图、标签（包括点标签和边标签）、属性。从存储层看，TuGraph使用使用直观的多层的树状模型，没有跨子图的标签，也没有跨标签的属性，仅保留图模型的核心逻辑。\n\n在子图的存储上，TuGraph对多图做了数据的物理隔离，每个图对应一个LMDB的实例。多图的元数据描述信息，保存在meta的特殊的公共LMDB实例中。点边标签及其属性的存储，通过将图数据自适应地映射到KV键值对，最大程度发挥读性能。同时在KV层实现了多线程写，解决了LMDB写性能较低的劣势。主键索引和二级索引，对应LMDB中B+的表，支持基于比较的索引值增删查改。\n\n存储层还保留了一些其他非核心功能的数据，包括权限数据、预编译的插件数据、监控数据等。\n\n## 3.计算层\n\n计算层在功能上分成三个部分，包括TP类的图事务引擎，AP类的图分析引擎和图神经网络引擎。\n\n此内容为TuGraph文档的开头部分，主要介绍该图数据库的功能概览、安装部署及相关软硬件环境，旨在为用户提供基础的系统部署信息和存储层、计算层的结构概述。"
            },
            {
                "content": "## 2.存储层\n\n在图数据模型上，TuGraph支持属性图模型，按照层次可以分为子图、标签（包括点标签和边标签）、属性。从存储层看，TuGraph使用使用直观的多层的树状模型，没有跨子图的标签，也没有跨标签的属性，仅保留图模型的核心逻辑。\n\n在子图的存储上，TuGraph对多图做了数据的物理隔离，每个图对应一个LMDB的实例。多图的元数据描述信息，保存在meta的特殊的公共LMDB实例中。点边标签及其属性的存储，通过将图数据自适应地映射到KV键值对，最大程度发挥读性能。同时在KV层实现了多线程写，解决了LMDB写性能较低的劣势。主键索引和二级索引，对应LMDB中B+的表，支持基于比较的索引值增删查改。\n\n存储层还保留了一些其他非核心功能的数据，包括权限数据、预编译的插件数据、监控数据等。\n\n## 3.计算层\n\n计算层在功能上分成三个部分，包括TP类的图事务引擎，AP类的图分析引擎和图神经网络引擎。\n\n- __图事务引擎__，主要用来处理并发的图操作，包括单点查询、邻居查询、路径遍历。图事务引擎侧重并发操作的ACID事务，确保操作逻辑不会互相干扰，主要性能指标为 QPS，即每秒完成的查询数量。\n\n- __图分析引擎__，操作类型通常为全图迭代。部分简单的分析任务（比如SPSP）可以由图事务引擎完成，复杂的分析任务均由图分析引擎完成，单个任务通常需要数秒至数小时。因此单个图分析任务要并发利用所有的硬件资源，性能指标为任务完成的总时长。\n\n- __图神经网络引擎__，通常也为全图迭代。图神经网络引擎除了基于图拓扑的操作，也需要集成一个机器学习的框架来处理向量操作，比如 PyTorch、MXNet、TenserFlow。\n\n本章节主要介绍了TuGraph的存储层和计算层，在存储层部分强调了其对属性图模型的支持、数据的物理隔离与存储结构设计，以及对其他功能数据的保留。而在计算层部分，详细描述了三种引擎：图事务引擎、图分析引擎和图神经网络引擎的功能及其在并发操作和性能指标上的差异。这些内容是TuGraph功能概览中关于数据存储和计算处理能力的重要组成部分。"
            },
            {
                "content": "存储层还保留了一些其他非核心功能的数据，包括权限数据、预编译的插件数据、监控数据等。\n\n## 3.计算层\n\n计算层在功能上分成三个部分，包括TP类的图事务引擎，AP类的图分析引擎和图神经网络引擎。\n\n- __图事务引擎__，主要用来处理并发的图操作，包括单点查询、邻居查询、路径遍历。图事务引擎侧重并发操作的ACID事务，确保操作逻辑不会互相干扰，主要性能指标为 QPS，即每秒完成的查询数量。\n\n- __图分析引擎__，操作类型通常为全图迭代。部分简单的分析任务（比如SPSP）可以由图事务引擎完成，复杂的分析任务均由图分析引擎完成，单个任务通常需要数秒至数小时。因此单个图分析任务要并发利用所有的硬件资源，性能指标为任务完成的总时长。\n\n- __图神经网络引擎__，通常也为全图迭代。图神经网络引擎除了基于图拓扑的操作，也需要集成一个机器学习的框架来处理向量操作，比如 PyTorch、MXNet、TenserFlow。\n\n三个引擎的操作逻辑不尽相同，独立配置资源池。事图事务引擎基于RPC操作设置了一个线程池，每接受客户端的一个操作，从线程中取一个线程来处理，并发执行的数量等于RPC线程池的容量，通常配置为服务器的核数。图分析引擎有一个分析线程池，每个图分析任务会并发执行，即用所有的线程来执行一个任务，来加速操作的性能。TuGraph图分析操作串行执行的特性会一定程度限制用户的使用体验，并发的图分析的需求可以通过高可用部署的方式，增加机器资源来处理，或者接入外部的任务调度器，将数据传到实时调度的容器来计算。图神经网络操作在图上的操作会复用图事务引擎或图分析引擎的资源，向量的操作会起单独的资源，在机器学习框架中可以使用GPU等单独的加速硬件。\n\n## 4.核心功能\n\n### 4.1.查询语言\n\nTuGraph 提供 Cypher 图查询语言，遵循OpenCypher标准。\n- __支持Procedure嵌入__\n\n- __可插拔优化框架__ 各类优化功能\n\n- __可扩展安全性检查框架__ 对于cypher进行\n\n### 4.2.存储过程\n\n当用户需要表达的查询/更新逻辑较为复杂（例如 Cypher 无法描述，或是对性能要求较高）时，相比调用多个 REST 请求并在客户端完成整个\n处理流程的方式，TuGraph 提供的存储过程（Procedure）是更简洁和高效的选择。\n\n该chunk位于文档的“存储层”和“计算层”之间，主要介绍了存储层的一些非核心功能数据及计算层的三个引擎（图事务引擎、图分析引擎、图神经网络引擎）的详细功能和性能指标，对整体的计算能力和核心功能进行了铺陈， subsequently 讲解了查询语言和存储过程的特点。"
            },
            {
                "content": "## 4.核心功能\n\n### 4.1.查询语言\n\nTuGraph 提供 Cypher 图查询语言，遵循OpenCypher标准。\n- __支持Procedure嵌入__\n\n- __可插拔优化框架__ 各类优化功能\n\n- __可扩展安全性检查框架__ 对于cypher进行\n\n### 4.2.存储过程\n\n当用户需要表达的查询/更新逻辑较为复杂（例如 Cypher 无法描述，或是对性能要求较高）时，相比调用多个 REST 请求并在客户端完成整个\n处理流程的方式，TuGraph 提供的存储过程（Procedure）是更简洁和高效的选择。\n\n从 3.5 版本开始，TuGraph 重新设计了新的存储过程编程范式，支持定义标准的签名和结果，支持POG编程。\n\nTuGraph 支持 POG (Procedres on Graph Query Languages) 编程和 POG 库，其中“Graph Query Languages”包含 Cypher 以及\n制定中的 ISO GQL 等图查询语言。POG 库提供在查询语言中对用户定义的存储过程的访问，打破了查询语言和存储过程之间的界限，扩展了查询\n语言的使用范围。\n\n\n### 4.3.数据导入导出\n\n尽管TuGraph本身支持数据的插入，但批量导入能够大幅提升的效率。导入的功能可以分为空库导入（离线导入）和增量导入，前者指子图是空的时候进行导入，额外的假设能够大幅提升导入的性能，在 TuGraph 中，空库导入和增量导入的吞吐率差了10 倍。在数据导出中，需要考虑导出数据的一致性，即是基于一个快照数据导出的。\n\nTuGraph 可以通过 命令行工具`lgraph_export` 来对已经存放在TuGraph的图数据进行数据导出，导出格式支持CSV和JSON。\n\n### 4.4.备份恢复\n\nTUGraph的备份在功能上可分为主动/定时、离线/在线、全量/增量备份，用尽量小的存储和计算代价来完成备份。恢复功能可以恢复到最新的状态，或者历史标注的时间点，需要保证数据库是一致的状态。\n\n### 4.5 数据预热\n\nTuGraph 是基于磁盘的图数据库，仅当访问数据时，数据才会加载到内存中。因此在服务器刚开启后的一段时间内，系统性能可能会由于频繁的 IO 操作而变差。此时我们可以通过事先进行数据预热来改善这一问题。\n\n### 4.6 高可用\n\n该块内容位于文档的第四部分，主要介绍TuGraph的核心功能，包括查询语言、存储过程、数据导入导出、备份恢复、数据预热和高可用性等特性。这些功能对于使用者在操作图数据库时提升效率和性能具有重要意义。"
            },
            {
                "content": "### 4.3.数据导入导出\n\n尽管TuGraph本身支持数据的插入，但批量导入能够大幅提升的效率。导入的功能可以分为空库导入（离线导入）和增量导入，前者指子图是空的时候进行导入，额外的假设能够大幅提升导入的性能，在 TuGraph 中，空库导入和增量导入的吞吐率差了10 倍。在数据导出中，需要考虑导出数据的一致性，即是基于一个快照数据导出的。\n\nTuGraph 可以通过 命令行工具`lgraph_export` 来对已经存放在TuGraph的图数据进行数据导出，导出格式支持CSV和JSON。\n\n### 4.4.备份恢复\n\nTUGraph的备份在功能上可分为主动/定时、离线/在线、全量/增量备份，用尽量小的存储和计算代价来完成备份。恢复功能可以恢复到最新的状态，或者历史标注的时间点，需要保证数据库是一致的状态。\n\n### 4.5 数据预热\n\nTuGraph 是基于磁盘的图数据库，仅当访问数据时，数据才会加载到内存中。因此在服务器刚开启后的一段时间内，系统性能可能会由于频繁的 IO 操作而变差。此时我们可以通过事先进行数据预热来改善这一问题。\n\n### 4.6 高可用\n\n高可用是指通过通过集群配置，做到实时多副本数据热备，在部分副本不用时，集群仍然能正常提供服务，TuGraph采用 RAFT 协议的多机热备机制，能够将 RPO 降低到接近 0 的程度。TuGraph 选择在计算层进行数据同步，同步的对象是写操作，通过 RPC 接口快速同步。TuGraph 的高可用集群采用主从模式，只有主节点处理写请求，主从节点均能处理读请求。主节点的写请求处理需要同步到多于二分之一的总节点上，多数节点写成功，该写请求才算完成。\n\n## 5.客户端工具\n\n客户端主要分为各种编程语言的SDK，OGM以及命令行工具。\n\n客户端 SDK 主要用于二次开发，可以通过 RPC 或 REST 协议链接服务端。RPC 基于长链接有较好的性能，数据需要通过 protobuf 统一序列化。TuGraph 使用brpc，支持 Java、Python、C++ 的 rpc 客户端。REST 的协议比较宽泛，能够简单适配更加多样的环境，不同的编程语言能够简单对接。TuGraph 给出了 Python 的REST 客户端实例，命令行的交互也是用 REST 实现。\n\n此 chunk 位于文档的第四部分，主要介绍 TuGraph 的核心功能，包括数据导入导出、备份恢复、数据预热和高可用性。这部分详细描述了这些功能的具体实现和优势，为用户提供对 TuGraph 操作的理解和使用指导。"
            },
            {
                "content": "### 4.6 高可用\n\n高可用是指通过通过集群配置，做到实时多副本数据热备，在部分副本不用时，集群仍然能正常提供服务，TuGraph采用 RAFT 协议的多机热备机制，能够将 RPO 降低到接近 0 的程度。TuGraph 选择在计算层进行数据同步，同步的对象是写操作，通过 RPC 接口快速同步。TuGraph 的高可用集群采用主从模式，只有主节点处理写请求，主从节点均能处理读请求。主节点的写请求处理需要同步到多于二分之一的总节点上，多数节点写成功，该写请求才算完成。\n\n## 5.客户端工具\n\n客户端主要分为各种编程语言的SDK，OGM以及命令行工具。\n\n客户端 SDK 主要用于二次开发，可以通过 RPC 或 REST 协议链接服务端。RPC 基于长链接有较好的性能，数据需要通过 protobuf 统一序列化。TuGraph 使用brpc，支持 Java、Python、C++ 的 rpc 客户端。REST 的协议比较宽泛，能够简单适配更加多样的环境，不同的编程语言能够简单对接。TuGraph 给出了 Python 的REST 客户端实例，命令行的交互也是用 REST 实现。\n\nOGM(Object Graph Mapping)为面向 TuGraph 的图对象映射工具，支持将 JAVA 对象（POJO）映射到 TuGraph 中，JAVA 中的类映射为图中的节点、类中的集合映射为边、类的属性映射为图对象的属性，并提供了对应的函数操作图数据库，因此 JAVA 开发人员可以在熟悉的生态中轻松地使用 TuGraph 数据库。\n\n命令行工具`lgraph_cypher`是查询客户端，可用于向 TuGraph 服务器提交 OpenCypher 请求。`lgraph_cypher`客户端有两种执行模式：单命令模式和交互式模式。\n\n\n## 6.生态工具\n\n生态工具是企业级数据库一个非常重要的组成部分，丰富的生态工具能够大大提升图数据库的可用性，稳定性。\n\n### 6.1.TuGraph DataX\n\n该块内容位于文档的第四部分“核心功能”之后，介绍TuGraph的高可用性特性，说明通过集群配置实现实时多副本数据热备的机制，以及如何处理写请求和读请求的同步。接下来进入第五部分“客户端工具”，探讨各种编程语言的SDK、OGM和命令行工具的功能与应用。"
            },
            {
                "content": "OGM(Object Graph Mapping)为面向 TuGraph 的图对象映射工具，支持将 JAVA 对象（POJO）映射到 TuGraph 中，JAVA 中的类映射为图中的节点、类中的集合映射为边、类的属性映射为图对象的属性，并提供了对应的函数操作图数据库，因此 JAVA 开发人员可以在熟悉的生态中轻松地使用 TuGraph 数据库。\n\n命令行工具`lgraph_cypher`是查询客户端，可用于向 TuGraph 服务器提交 OpenCypher 请求。`lgraph_cypher`客户端有两种执行模式：单命令模式和交互式模式。\n\n\n## 6.生态工具\n\n生态工具是企业级数据库一个非常重要的组成部分，丰富的生态工具能够大大提升图数据库的可用性，稳定性。\n\n### 6.1.TuGraph DataX\n\nTuGraph 核心支持 CSV 和 JSON 合适的导入导出，提供空库导入和增量导入的模式。实际中会存在 MySQL、Kafka、Hive 等多数据源导入的需求，TuGraph 通过 DataX 做多数据源的对接。由于关系模型和图模型存在的差异，数据清洗的流程可以使用 SparkSQL 快速处理，TuGraph 本身仅关注 CSV 和 JSON 的简单场景导入可靠性和性能。\n\n### 6.2.可视化交互\n\nTuGraph Browser 是面向图数据库直接使用者的可视化交互界面，功能上覆盖了 TuGraph 的绝大部分能力，包括数据导入、图模型建立、数据增删查改、监控运维等操作链路。\n\n### 6.3.运维监控\n\nTuGraph 使用 Prometheus 加 Grafana 的监控框架，采用松耦合的方式。Prometheus 从 TuGraph 的监控接口获取监控信息，存储在本地时序数据库中，然后通过 Grafana 在网页端交互展示。\n\nTuGraph 提供的监控的状态包括图数据库的状态和服务器的状态，前者包括读写负载、点边数量等数据库端的状态，后者包括内存、CPU、硬盘等服务器的实时状态。如果某些监控状态超过了预期的阈值，就需要主动告警，通常需要对接其他运维管控系统，比如群消息、邮件告警等。\n\n该段落位于文档的第6部分，主要介绍TuGraph的生态工具，包括OGM（对象图映射工具）、命令行客户端lgraph_cypher，以及其他工具如DataX、可视化交互界面TuGraph Browser和运维监控框架Prometheus与Grafana，强调生态工具在提升图数据库可用性和稳定性方面的重要性。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_138.md",
        "chunks": [
            {
                "content": "# 可视化操作手册（旧版）\n\n> 此文档主要介绍 TuGraph Browser 的使用\n\n## 定义\n\nTuGraph Browser 是 TuGraph 提供的可视化开发工具。\n\n## 作用\n\nTuGraph Browser 的主要功能是为使用图数据库的开发人员，提供可视化的图数据开发，图数据管理和维护等功能。\n\n## 操作详情\n\n### 1.连接数据库\n\n当用户完成图数据库的安装后，可以通过浏览器进行访问，TuGraph Browser 工具。用户只需要在浏览器地址栏输入：TuGraph 所在服务器的 IP:Port。默认的端口使用的是 7090。\n\n### 2.登录数据库\n\n- 页面打开成功会，首先进图的是登录页面，用户需要填写账号和密码进行登录。\n- 默认账号：admin\n- 默认密码：73@TuGraph\n- 建议用户登录后，及时修改初始化的密码\n\n### 3.工作台\n\n#### 3.1 快速上手\n\n- 首次登录，系统会默认创建 default 空图\n- 用户点击帮助选项，并选择快速上手\n- 然后点击“一键创建模型”——>\"一键创建数据\"，就可以完成内置的 Movie 数据图谱的构建\n\n#### 3.2 创建子图和示例\n\n##### 3.2.1 创建子图\n\n- 点击新建子图\n- 填写表单信息\n  - 子图名称\n  - 子图描述\n  - 配置信息\n  - 点击确认，提示创建成功\n- 切换子图\n- 点击新建示例\n- 选择示例并点击创建\n\n#### 3.3 查询\n\n##### 3.3.1 页面组成\n\n- cypher 输入框\n- 结果集展示区域\n\n##### 3.3.2 结果集展示区域功能详情\n\n该块内容为可视化操作手册的前言部分，介绍了 TuGraph Browser 的基本定义、作用及操作细节，涵盖连接数据库、登录数据库、快速上手和创建子图等功能的详细说明，属于文档的操作详情章节。"
            },
            {
                "content": "### 3.工作台\n\n#### 3.1 快速上手\n\n- 首次登录，系统会默认创建 default 空图\n- 用户点击帮助选项，并选择快速上手\n- 然后点击“一键创建模型”——>\"一键创建数据\"，就可以完成内置的 Movie 数据图谱的构建\n\n#### 3.2 创建子图和示例\n\n##### 3.2.1 创建子图\n\n- 点击新建子图\n- 填写表单信息\n  - 子图名称\n  - 子图描述\n  - 配置信息\n  - 点击确认，提示创建成功\n- 切换子图\n- 点击新建示例\n- 选择示例并点击创建\n\n#### 3.3 查询\n\n##### 3.3.1 页面组成\n\n- cypher 输入框\n- 结果集展示区域\n\n##### 3.3.2 结果集展示区域功能详情\n\n- 结果集标签展示及功能\n  - 这里展示了结果集的所有类型统计\n  - 点击不同的“label（标签）”，可以进行以下修改操作\n    - 修改展示颜色\n    - 修改节点大小或边的粗细\n    - 修改默认展示属性或系统属性\n    - 布局修改\n      - 力导布局\n      - 网格布局\n      - 树形布局\n      - 环境布局\n    - 边聚合\n      - 相同类型，方向的边可以进行合并\n    - 创建节点\n      - 点击创建节点按钮\n      - 选择节点类型\n      - 添写节点内容\n    - 创建关系\n      - 在画布中选择起点和终点\n      - 选择可以匹配的类型\n      - 填写节点信息\n    - 停止布局\n      - 当数据量过大，导致浏览器页面卡顿时候，可以点击这个停止布局的按钮，能够提高体验的流畅度\n    - 鼠标悬停\n      - 开启此功能，可以高亮显示鼠标悬停节点的一度邻居节点\n    - 结果集导出\n      - 可以将结果集导出为 png，json，csv 三种不同的文件形式\n    - 刷新\n      - 点击刷新按钮，会重新执行当前页面的初始 cypher 语句，并刷新结果集\n    - 最大化\n      - 点击最大化，结果集展示区域将全屏展示\n    - 结果集展示形式切换\n      - 支持图谱、表格、文本三种形式\n\n##### 3.3.3 建模\n\n- 点边模型\n- 点边模型支持实时的、增、删、改、查\n- 点边模型支持导入和导出\n\n该块内容位于可视化操作手册的“工作台”部分，详细介绍了如何快速上手使用 TuGraph Browser，以及创建子图、示例和进行查询的具体操作和功能，帮助用户了解和利用图数据的可视化功能。"
            },
            {
                "content": "##### 3.3.3 建模\n\n- 点边模型\n- 点边模型支持实时的、增、删、改、查\n- 点边模型支持导入和导出\n\n##### 3.3.4 数据导入\n\n- 本地数据导入\n  - 选择文件编码格式\n  - 选择本地 CSV 文件\n  - 选择对应的节点或边的模型\n  - 进行数据映射\n  - 完成数据导入\n  - 单个文件最大支持2GB\n\n##### 3.3.5 插件\n\n- 存储过程的使用\n  - 用户可以上传本地编写的 Plugin 程序，并在可视化页面进行执行，并查看执行结果\n  - 用户可以在可视化对插件进行、卸载、执行、下载等操作\n\n##### 3.3.6 帮助\n\n- 其中记录了 TuGraph-browser 的使用方式\n\n#### 3.4 控制台\n\n##### 3.4.1 数据库基础信息\n\n- 展示数据库相关的基础配置信息\n\n##### 3.4.2 权限管理\n\n- 用来创建用户和角色的功能模块，用户可以在这里进行权限的管理操作\n\n##### 3.4.3 实时状态\n\n- 这里展示了数据库实时状态，包括：CPU 使用率、内存用率、磁盘使用率、数据请求次数、磁盘 IO\n\n##### 3.4.4 任务管理\n\n- 在这里用户可以看到在正在执行中的任务，可以在此进行停止任务的操作\n\n##### 3.4.5 审计日志\n\n- 这里记录的数据库相关的审计日志，用来排查使用遇到的问题\n\n该部分内容位于可视化操作手册的第三章“工作台”下，主要介绍了TuGraph Browser中建模、数据导入、插件使用及帮助文档的相关功能和操作细节，属于用户在使用图数据库进行数据管理和开发时的重要指导信息。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_139.md",
        "chunks": [
            {
                "content": "# Python客户端\n\n> 此文档主要是TuGraph Python SDK的使用说明, 注意TuGraph Python SDK将来不再更新维护。\n\n## 1. 概述\nPython的TuGraph Client有两种，一种是RESTful的Client，使用HTTP方法向server发送请求，另一种是RPC的Client，使用RPC方法调用server远程服务，两者各有优劣。\nRESTful client的使用方式简单，在项目的src/client/python/TuGraphClient目录下可以找到Client的源码文件，直接安装到用户环境中即可使用，但是支持的功能较少，\n性能也不高。RPC Client既支持单机的server，也支持高可用集群和负载均衡，接口较多，功能强大。但是使用方式较为复杂，需要用户自己编译TuGraph项目得到liblgraph_client_python.so，\n或者使用runtime镜像时直接在/usr/local/lib64目录下找到该依赖库，将其引入python项目即可正常使用。接下来将详细介绍这两种Client的使用方式。\n\n## 2. RESTful Client\n\n### 2.1.安装Client\n\nTuGraph的Python RESTful client使用setuptools工具进行打包和分发，用户可以将client直接安装到本地环境中，在使用时即可直接引入。\n```shell\ncd src/client/python/TuGraphClient\npython3 setup.py build\npython3 setup.py install\n```\n注：使用setuptools工具安装python client时会安装httpx等依赖，需要在通外网的环境下执行。\n\n### 2.2.调用Cypher\n\n```python\nfrom TuGraphClient import TuGraphClient, AsyncTuGraphClient\n\nclient = TuGraphClient(\"127.0.0.1:7071\" , \"admin\", \"73@TuGraph\")\ncypher = \"match (n) return properties(n) limit 1\"\nres = client.call_cypher(cypher)\nprint(res)\n\n该文档主要介绍TuGraph Python SDK的使用说明，包括RESTful Client和RPC Client的安装与调用方法。具体内容涵盖了如何安装RESTful Client、调用Cypher语句、以及存储过程的调用等基本操作，旨在为开发者提供清晰的指南。"
            },
            {
                "content": "### 2.1.安装Client\n\nTuGraph的Python RESTful client使用setuptools工具进行打包和分发，用户可以将client直接安装到本地环境中，在使用时即可直接引入。\n```shell\ncd src/client/python/TuGraphClient\npython3 setup.py build\npython3 setup.py install\n```\n注：使用setuptools工具安装python client时会安装httpx等依赖，需要在通外网的环境下执行。\n\n### 2.2.调用Cypher\n\n```python\nfrom TuGraphClient import TuGraphClient, AsyncTuGraphClient\n\nclient = TuGraphClient(\"127.0.0.1:7071\" , \"admin\", \"73@TuGraph\")\ncypher = \"match (n) return properties(n) limit 1\"\nres = client.call_cypher(cypher)\nprint(res)\n\naclient = AsyncTuGraphClient(\"127.0.0.1:7071\" , \"admin\", \"73@TuGraph\")\ncypher = \"match (n) return properties(n) limit 1\"\nres = await aclient.call_cypher(cypher)\nprint(res)\n```\n\n### 2.3.调用存储过程\n\n```python\nfrom TuGraphClient import TuGraphClient, AsyncTuGraphClient\n\nclient = TuGraphClient(\"127.0.0.1:7071\" , \"admin\", \"73@TuGraph\")\nplugin_type = \"cpp\"\nplugin_name = \"khop\"\nplugin_input = \"{\\\"root\\\": 10, \\\"hop\\\": 3}\"\nres = client.call_plugin(plugin_type, plguin_name, plugin_input)\nprint(res)\n\n该块内容位于文档的第二部分，介绍了TuGraph Python RESTful Client的安装和基本使用方法，包括如何安装客户端、执行Cypher查询以及调用存储过程。这部分内容为用户提供了从安装到初步使用的指导，为后续更复杂的操作奠定了基础。"
            },
            {
                "content": "aclient = AsyncTuGraphClient(\"127.0.0.1:7071\" , \"admin\", \"73@TuGraph\")\ncypher = \"match (n) return properties(n) limit 1\"\nres = await aclient.call_cypher(cypher)\nprint(res)\n```\n\n### 2.3.调用存储过程\n\n```python\nfrom TuGraphClient import TuGraphClient, AsyncTuGraphClient\n\nclient = TuGraphClient(\"127.0.0.1:7071\" , \"admin\", \"73@TuGraph\")\nplugin_type = \"cpp\"\nplugin_name = \"khop\"\nplugin_input = \"{\\\"root\\\": 10, \\\"hop\\\": 3}\"\nres = client.call_plugin(plugin_type, plguin_name, plugin_input)\nprint(res)\n\naclient = AsyncTuGraphClient(\"127.0.0.1:7071\" , \"admin\", \"73@TuGraph\")\nres = await aclient.call_plugin(plugin_type, plguin_name, plugin_input)\nprint(res)\n```\n\n## 3.RPC Client\n\nPython的TuGraph Rpc Client是使用pybind11包装的CPP Client SDK，下表列出了Python和CPP Client SDK的对应关系。\n\n该内容片段位于文档的第二部分“RESTful Client”中，主要介绍了如何使用异步客户端（AsyncTuGraphClient）调用Cypher语句和存储过程。它展示了具体的代码示例，说明如何创建异步客户端并执行相应的数据库操作。紧接着，文档将转向第三部分“RPC Client”，讨论Python的TuGraph RPC客户端及其与C++客户端SDK的对应关系。"
            },
            {
                "content": "| Python Client SDK                                                                                                                                                                                                     | CPP Client SDK                                                                                                                                                                                                                                                                              |\n|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n\n该内容块位于文档的第三部分“RPC Client”中，主要介绍Python的TuGraph RPC Client与C++ Client SDK之间的对应关系，详细列出了两者在与数据库交互时的不同方法、输入参数以及返回值。这一对比为用户理解和使用TuGraph的Python和C++客户端提供了清晰的参考。"
            },
            {
                "content": "|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| client(self: liblgraph_client_python.client, url: str, user: str, password: str)                                                                                                                                      | RpcClient(const std::string& url, const std::string& user, const std::string& password)                                                                                                                                                                                                     |\n\n该片段位于文档的\"3.RPC Client\"部分，主要描述了Python的TuGraph RPC Client与C++ Client SDK之间的相应关系，具体针对`client`方法在两种语言中的实现方式和参数。"
            },
            {
                "content": "| client(self: liblgraph_client_python.client, url: str, user: str, password: str)                                                                                                                                      | RpcClient(const std::string& url, const std::string& user, const std::string& password)                                                                                                                                                                                                     |\n| client(self: liblgraph_client_python.client, urls: list, user: str, password: str)                                                                                                                                    | RpcClient(std::vector& urls, std::string user, std::string password)                                                                                                                                                                                                           |\n\n该片段位于文档的第3节“RPC Client”中，主要展示了Python的TuGraph RPC Client SDK与CPP Client SDK之间方法的对应关系，如客户端实例化的方式。此信息为开发者提供了两者在功能调用上的对比，有助于理解如何在不同编程语言中实现相同的操作。"
            },
            {
                "content": "| client(self: liblgraph_client_python.client, urls: list, user: str, password: str)                                                                                                                                    | RpcClient(std::vector& urls, std::string user, std::string password)                                                                                                                                                                                                           |\n| callCypher(self: liblgraph_client_python.client, cypher: str, graph: str, json_format: bool, timeout: float, url: str) -> (bool, str)                                                                                 | bool CallCypher(std::string& result, const std::string& cypher, const std::string& graph, bool json_format, double timeout, const std::string& url)                                                                                                                                         |\n\n该片段位于文档的第三部分“RPC Client”，具体是关于Python和C++客户端SDK的对应关系表的部分。它详细列出了Python RPC客户端中“client”方法及“callCypher”方法与C++客户端中相应方法的名称、参数和返回值类型之间的对比，为开发者在使用这两种语言时提供参考。"
            },
            {
                "content": "| callCypher(self: liblgraph_client_python.client, cypher: str, graph: str, json_format: bool, timeout: float, url: str) -> (bool, str)                                                                                 | bool CallCypher(std::string& result, const std::string& cypher, const std::string& graph, bool json_format, double timeout, const std::string& url)                                                                                                                                         |\n| callCypherToLeader(self: liblgraph_client_python.client, cypher: str, graph: str, json_format: bool, timeout: float) -> (bool, str)                                                                                   | bool CallCypherToLeader(std::string& result, const std::string& cypher, const std::string& graph, bool json_format, double timeout)                                                                                                                                                         |\n\n该块内容位于文档的第三部分“RPC Client”中，具体描述了Python TuGraph RPC客户端中的`callCypher`和`callCypherToLeader`方法的定义及其与C++客户端对应方法的关系，旨在帮助用户理解这些方法如何在Python和C++之间进行操作映射。"
            },
            {
                "content": "| callCypherToLeader(self: liblgraph_client_python.client, cypher: str, graph: str, json_format: bool, timeout: float) -> (bool, str)                                                                                   | bool CallCypherToLeader(std::string& result, const std::string& cypher, const std::string& graph, bool json_format, double timeout)                                                                                                                                                         |\n| callGql(self: liblgraph_client_python.client, gql: str, graph: str, json_format: bool, timeout: float, url: str) -> (bool, str)                                                                                       | bool CallGql(std::string& result, const std::string& gql, const std::string& graph, bool json_format, double timeout, const std::string& url)                                                                                                                                               |\n\n该块内容位于文档的第三部分“RPC Client”中，具体介绍了Python TuGraph RPC Client与C++ Client SDK的对应关系，重点展示了两种语言中与数据库交互的`callCypherToLeader`和`callGql`方法的定义及参数。这部分内容为开发者提供了不同语言间API调用的对比，以便于理解和使用。"
            },
            {
                "content": "| callGql(self: liblgraph_client_python.client, gql: str, graph: str, json_format: bool, timeout: float, url: str) -> (bool, str)                                                                                       | bool CallGql(std::string& result, const std::string& gql, const std::string& graph, bool json_format, double timeout, const std::string& url)                                                                                                                                               |\n| callGqlToLeader(self: liblgraph_client_python.client, gql: str, graph: str, json_format: bool, timeout: float) -> (bool, str)                                                                                         | bool CallGqlToLeader(std::string& result, const std::string& gql, const std::string& graph = \"default\", bool json_format = true, double timeout = 0)                                                                                                                                        |\n\n该片段位于文档的第3节“RPC Client”中，具体阐述了Python与C++ Client SDK在调用GQL（图查询语言）方法方面的对应关系，包括`callGql`和`callGqlToLeader`两个方法的定义及其参数。在此之前，文档介绍了RPC Client的整体结构和用法，为开发者提供了在Python和C++中如何与数据库交互的详细对比与指导。"
            },
            {
                "content": "| callGqlToLeader(self: liblgraph_client_python.client, gql: str, graph: str, json_format: bool, timeout: float) -> (bool, str)                                                                                         | bool CallGqlToLeader(std::string& result, const std::string& gql, const std::string& graph = \"default\", bool json_format = true, double timeout = 0)                                                                                                                                        |\n| callProcedure(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, param: str, procedure_time_out: float, in_process: bool, graph: str, json_format: bool, url: str) -> (bool, str)        | bool CallProcedure(std::string& result, const std::string& procedure_type, const std::string& procedure_name, const std::string& param, double procedure_time_out, bool in_process, const std::string& graph, bool json_format, const std::string& url)                                     |\n\n在文档的第三部分“RPC Client”中，介绍了Python TuGraph RPC客户端的功能和方法，其中列出了Python Client SDK与CPP Client SDK之间的对应关系。该部分详细说明了不同方法的输入参数及返回值，包括`callGqlToLeader`和`callProcedure`等方法，这些方法用于执行GQL查询和调用存储过程。"
            },
            {
                "content": "| callProcedure(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, param: str, procedure_time_out: float, in_process: bool, graph: str, json_format: bool, url: str) -> (bool, str)        | bool CallProcedure(std::string& result, const std::string& procedure_type, const std::string& procedure_name, const std::string& param, double procedure_time_out, bool in_process, const std::string& graph, bool json_format, const std::string& url)                                     |\n| callProcedureToLeader(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, param: str, procedure_time_out: float, in_process: bool, graph: str, json_format: bool) -> (bool, str)          | CallProcedureToLeader(std::string& result, const std::string& procedure_type, const std::string& procedure_name, const std::string& param, double procedure_time_out, bool in_process, const std::string& graph, bool json_format)                                                          |\n\n该chunk位于文档的第3部分“RPC Client”中，专门讨论了Python的TuGraph RPC Client与CPP Client SDK之间的对应关系，具体列出了关于调用存储过程的两个方法及其参数和返回值的详细信息。这部分内容为开发者提供了在不同编程语言中实现存储过程调用的对比，方便用户理解和选择合适的实现方式。"
            },
            {
                "content": "| callProcedureToLeader(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, param: str, procedure_time_out: float, in_process: bool, graph: str, json_format: bool) -> (bool, str)          | CallProcedureToLeader(std::string& result, const std::string& procedure_type, const std::string& procedure_name, const std::string& param, double procedure_time_out, bool in_process, const std::string& graph, bool json_format)                                                          |\n| loadProcedure(self: liblgraph_client_python.client, source_file: str, procedure_type: str, procedure_name: str, code_type: str, procedure_description: str, read_only: bool, version: str, graph: str) -> (bool, str) | bool LoadProcedure(std::string& result, const std::string& source_file, const std::string& procedure_type, const std::string& procedure_name, const std::string& code_type, const std::string& procedure_description, bool read_only, const std::string& version, const std::string& graph) |\n\n该块内容位于文档的第三部分“RPC Client”的表格中，展示了Python和C++ TuGraph客户端SDK在调用存储过程相关方法的对应关系。这部分详细说明了如何通过各自的SDK调用存储过程，包括与领导者节点的交互方式以及加载存储过程的接口。"
            },
            {
                "content": "| loadProcedure(self: liblgraph_client_python.client, source_file: str, procedure_type: str, procedure_name: str, code_type: str, procedure_description: str, read_only: bool, version: str, graph: str) -> (bool, str) | bool LoadProcedure(std::string& result, const std::string& source_file, const std::string& procedure_type, const std::string& procedure_name, const std::string& code_type, const std::string& procedure_description, bool read_only, const std::string& version, const std::string& graph) |\n| listProcedures(self: liblgraph_client_python.client, procedure_type: str, version: str, graph: str, url: str) -> (bool, str)                                                                                          | bool ListProcedures(std::string& result, const std::string& procedure_type, const std::string& version, const std::string& graph, const std::string& url)                                                                                                                                   |\n\n该块内容位于《Python客户端》文档的“3.RPC Client”部分，具体描述了Python和C++ SDK中与存储过程相关的方法及其参数和返回值的对应关系，主要涉及`loadProcedure`和`listProcedures`方法的功能与用法。"
            },
            {
                "content": "| listProcedures(self: liblgraph_client_python.client, procedure_type: str, version: str, graph: str, url: str) -> (bool, str)                                                                                          | bool ListProcedures(std::string& result, const std::string& procedure_type, const std::string& version, const std::string& graph, const std::string& url)                                                                                                                                   |\n| deleteProcedure(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, graph: str) -> (bool, str)                                                                                            | bool DeleteProcedure(std::string& result, const std::string& procedure_type, const std::string& procedure_name, const std::string& graph)                                                                                                                                                   |\n\n该块内容位于文档的第三部分“RPC Client”中的表格中，主要描述了Python TuGraph RPC客户端和C++客户端之间关于存储过程相关方法的对应关系，包括“列举存储过程”和“删除存储过程”的方法签名及参数。此内容有助于开发者理解两种不同编程语言在操作存储过程方面的实现差异。"
            },
            {
                "content": "| deleteProcedure(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, graph: str) -> (bool, str)                                                                                            | bool DeleteProcedure(std::string& result, const std::string& procedure_type, const std::string& procedure_name, const std::string& graph)                                                                                                                                                   |\n| importSchemaFromContent(self: liblgraph_client_python.client, schema: str, graph: str, json_format: bool, timeout: float) -> (bool, str)                                                                              | bool ImportSchemaFromContent(std::string& result, const std::string& schema, const std::string& graph, bool json_format, double timeout)                                                                                                                                                    |\n\n在文档的第三部分“RPC Client”中，包含了Python TuGraph RPC客户端与C++客户端SDK之间不同方法的对比，特别是关于删除存储过程和从字节流中导入模式的接口。这一部分详细列出了每个方法的名称、输入参数及返回值，为开发者提供了清晰的API调用参考。"
            },
            {
                "content": "| importSchemaFromContent(self: liblgraph_client_python.client, schema: str, graph: str, json_format: bool, timeout: float) -> (bool, str)                                                                              | bool ImportSchemaFromContent(std::string& result, const std::string& schema, const std::string& graph, bool json_format, double timeout)                                                                                                                                                    |\n| importDataFromContent(self: liblgraph_client_python.client, desc: str, data: str, delimiter: str, continue_on_error: bool, thread_nums: int, graph: str, json_format: bool, timeout: float) -> (bool, str)            | ImportDataFromContent(std::string& result, const std::string& desc, const std::string& data, const std::string& delimiter, bool continue_on_error, int thread_nums, const std::string& graph, bool json_format, double timeout)                                                             |\n\n该内容片段位于文档的第三部分“RPC Client”下，具体描述了Python和C++客户端SDK中用于从字节流导入schema和点边数据的相关方法，包括方法签名和参数说明。这些接口支持在单机模式和HA模式下使用，强调了在HA模式中请求的处理方式。"
            },
            {
                "content": "| importDataFromContent(self: liblgraph_client_python.client, desc: str, data: str, delimiter: str, continue_on_error: bool, thread_nums: int, graph: str, json_format: bool, timeout: float) -> (bool, str)            | ImportDataFromContent(std::string& result, const std::string& desc, const std::string& data, const std::string& delimiter, bool continue_on_error, int thread_nums, const std::string& graph, bool json_format, double timeout)                                                             |\n| importSchemaFromFile(self: liblgraph_client_python.client, schema_file: str, graph: str, json_format: bool, timeout: float) -> (bool, str)                                                                            | ImportSchemaFromFile(std::string& result, const std::string& schema_file, const std::string& graph, bool json_format, double timeout)                                                                                                                                                       |\n\n在文档的第三部分“RPC Client”中，介绍了Python的TuGraph RPC Client及其与C++ Client SDK之间的对应关系。这一部分详细列出了各种与数据库操作相关的方法及其参数，尤其是“importDataFromContent”和“importSchemaFromFile”方法的Python及C++实现。这段内容集中展示了两种编程语言中相应方法的功能和参数对比。"
            },
            {
                "content": "| importSchemaFromFile(self: liblgraph_client_python.client, schema_file: str, graph: str, json_format: bool, timeout: float) -> (bool, str)                                                                            | ImportSchemaFromFile(std::string& result, const std::string& schema_file, const std::string& graph, bool json_format, double timeout)                                                                                                                                                       |\n| importDataFromFile(self: liblgraph_client_python.client, conf_file: str, delimiter: str, continue_on_error: bool, thread_nums: int, skip_packages: int, graph: str, json_format: bool, timeout: float) -> (bool, str) | ImportDataFromFile(std::string& result, const std::string& conf_file, const std::string& delimiter, bool continue_on_error, int thread_nums, int skip_packages, const std::string& graph, bool json_format, double timeout)                                                                 |\n表格内容描述:\n\n此部分内容位于文档的第三章RPC Client中，具体描述了Python TuGraph RPC Client与C++ Client SDK之间的对应方法。该表格列出了两个方法 `importSchemaFromFile` 和 `importDataFromFile` 的详细信息，包括它们在Python和C++中的参数及返回值，主要用于从文件中导入模式和数据。"
            },
            {
                "content": "该表格包含两个列，分别是“Python Client SDK”和“CPP Client SDK”。表格详细列出了与数据库交互相关的不同方法，并在两种编程语言（Python 和 C++）中进行了对比。每一方法包含方法名称、输入参数及返回值的信息。\n\n该段落位于文档的第三部分，具体介绍了Python TuGraph RPC客户端与C++客户端SDK之间的对应关系，展示了二者在数据库操作方法上的对比，目的是帮助开发者理解并选择合适的编程语言进行数据库交互。"
            },
            {
                "content": "逐行描述如下：\n1. Python SDK的`client`方法接受一个URL、用户名和密码，并返回一个客户端实例；CPP SDK的`RpcClient`构造函数具有相似的功能。\n2. Python SDK的`client`方法也支持多个URL输入；对应的CPP SDK则使用`std::vector`接收多个URL。\n3. Python SDK的`callCypher`方法用于执行Cypher查询，具有多个参数并返回查询结果；CPP SDK的对应方法`CallCypher`使用不同类型的参数传递。\n4. Python SDK的`callCypherToLeader`方法与 `callCypher`类似，但专门用于与数据领导者通信；CPP SDK的`CallCypherToLeader`也具有类似功能。\n5. Python SDK的`callGql`方法和CPP SDK的`CallGql`方法均用于执行GQL查询，输入参数设置类似，返回结果形式一致。\n6. Python SDK的`callGqlToLeader`是针对GQL查询的领导者调用版本；CPP SDK也有对应的`CallGqlToLeader`。\n7. Python SDK的`callProcedure`用于调用特定过程，接受众多参数；CPP SDK的`CallProcedure`方法功能相似。\n8. Python SDK的`callProcedureToLeader`与上一个类似，但更侧重于领导者调用；CPP SDK中有相应的`CallProcedureToLeader`方法。\n9. Python SDK的`loadProcedure`用于加载程序，接受详细参数；CPP SDK中的`LoadProcedure`执行相同操作。\n10. Python SDK的`listProcedures`列出程序；CPP SDK的`ListProcedures`同样功能。\n11. Python SDK的`deleteProcedure`方法用于删除程序；CPP SDK对应的`DeleteProcedure`也有同样功能。\n12. Python SDK的`importSchemaFromContent`方法用于从内容导入模式；CPP SDK使用`ImportSchemaFromContent`实现该功能。\n\n该片段位于文档的第三部分“RPC Client”中，详细比较了Python和C++ SDK在数据库交互方法上的对应关系，逐行描述了两种编程语言中方法的功能、输入参数和返回值的相似性和差异。这为开发者提供了清晰的对比和参考，便于选择适合的编程语言进行开发。"
            },
            {
                "content": "7. Python SDK的`callProcedure`用于调用特定过程，接受众多参数；CPP SDK的`CallProcedure`方法功能相似。\n8. Python SDK的`callProcedureToLeader`与上一个类似，但更侧重于领导者调用；CPP SDK中有相应的`CallProcedureToLeader`方法。\n9. Python SDK的`loadProcedure`用于加载程序，接受详细参数；CPP SDK中的`LoadProcedure`执行相同操作。\n10. Python SDK的`listProcedures`列出程序；CPP SDK的`ListProcedures`同样功能。\n11. Python SDK的`deleteProcedure`方法用于删除程序；CPP SDK对应的`DeleteProcedure`也有同样功能。\n12. Python SDK的`importSchemaFromContent`方法用于从内容导入模式；CPP SDK使用`ImportSchemaFromContent`实现该功能。\n13. Python SDK的`importDataFromContent`方法导入数据，而CPP SDK对应了`ImportDataFromContent`。\n14. Python SDK的`importSchemaFromFile`方法从文件中导入模式；CPP SDK使用`ImportSchemaFromFile`处理类似操作。\n15. Python SDK的`importDataFromFile`处理从文件导入数据，CPP SDK也是通过`ImportDataFromFile`实现同样功能。\n\n该块内容位于第三部分“RPC Client”的相关对比表格中，详细列出了Python SDK与C++ SDK在存储过程调用和数据导入等功能上的对应关系，展示了两者在实现相似功能时的不同方法及参数设置。"
            },
            {
                "content": "整体来说，该表格展示了用于数据库操作的Python和C++ SDK的许多关系和相似点，提供了相应的方法、输入参数及返回值的信息。这为开发者在选择合适的编程语言时提供了清晰的对比和参考。\n\nPython RPC Client的使用方式较为复杂，用户可以在本地环境中编译TuGraph得到liblgraph_client_python.so，也可以使用官方提供的runtime镜像，\n在镜像中的/usr/local/lib64目录下可以直接找到该依赖库，引入用户项目即可使用。\n\n```python\nimport liblgraph_client_python\n```\n\n### 3.1.实例化client对象\n\n#### 3.1.1.实例化单节点client对象\n当以单节点模式启动server时，client按照如下格式进行实例化\n```python\nclient = liblgraph_client_python.client(\"127.0.0.1:19099\", \"admin\", \"73@TuGraph\")\n```\n```\nclient(self: liblgraph_client_python.client, url: str, user: str, password: str)\n```\n\n#### 3.1.2.实例化HA集群直连连接client对象\n当服务器上部署的HA集群可以使用ha_conf中配置的网址直接连接时，client按照如下格式进行实例化。\n```python\nclient = liblgraph_client_python.client(\"127.0.0.1:19099\", \"admin\", \"73@TuGraph\")\n```\n```\nclient(self: liblgraph_client_python.client, url: str, user: str, password: str)\n```\n用户只需要传入HA集群中的任意一个节点的url即可，client会根据server端返回的查询信息自动维护连接池，在HA集群横向扩容时\n也不需要手动重启client。\n\n该块内容位于文档的第三部分，主要介绍Python RPC Client的使用方法，包括如何实例化客户端对象以及不同连接模式的示例代码，旨在帮助开发者理解和使用TuGraph Python SDK与C++ SDK的关系和功能。"
            },
            {
                "content": "#### 3.1.2.实例化HA集群直连连接client对象\n当服务器上部署的HA集群可以使用ha_conf中配置的网址直接连接时，client按照如下格式进行实例化。\n```python\nclient = liblgraph_client_python.client(\"127.0.0.1:19099\", \"admin\", \"73@TuGraph\")\n```\n```\nclient(self: liblgraph_client_python.client, url: str, user: str, password: str)\n```\n用户只需要传入HA集群中的任意一个节点的url即可，client会根据server端返回的查询信息自动维护连接池，在HA集群横向扩容时\n也不需要手动重启client。\n\n#### 3.1.3.实例化HA集群间接连接client对象\n当服务器上部署的HA集群不能使用ha_conf中配置的网址直接连接而必须使用间接网址（如阿里云公网网址）连接时，\nclient按照如下格式进行实例化\n```python\nclient = liblgraph_client_python.client([\"189.33.97.23:9091\",\"189.33.97.24:9091\", \"189.33.97.25:9091\"], \"admin\", \"73@TuGraph\")\n```\n```\nclient(self: liblgraph_client_python.client, urls: list, user: str, password: str)\n```\n因为用户连接的网址和server启动时配置的信息不同，不能通过向集群发请求的方式自动更新client连接池，所以需要在启动\nclient时手动传入所有集群中节点的网址，并在集群节点变更时手动重启client。\n\n该段落位于文档的第三部分，介绍了TuGraph Python RPC Client的使用方法，具体说明了在HA集群环境下如何实例化客户端对象，细分为直接连接和间接连接两种情况，强调了如何配置连接信息以及在不同连接模式下的注意事项。"
            },
            {
                "content": "#### 3.1.3.实例化HA集群间接连接client对象\n当服务器上部署的HA集群不能使用ha_conf中配置的网址直接连接而必须使用间接网址（如阿里云公网网址）连接时，\nclient按照如下格式进行实例化\n```python\nclient = liblgraph_client_python.client([\"189.33.97.23:9091\",\"189.33.97.24:9091\", \"189.33.97.25:9091\"], \"admin\", \"73@TuGraph\")\n```\n```\nclient(self: liblgraph_client_python.client, urls: list, user: str, password: str)\n```\n因为用户连接的网址和server启动时配置的信息不同，不能通过向集群发请求的方式自动更新client连接池，所以需要在启动\nclient时手动传入所有集群中节点的网址，并在集群节点变更时手动重启client。\n\n### 3.2.调用cypher\n```python\nret, res = client.callCypher(\"CALL db.edgeLabels()\", \"default\", 10)\n```\n```\ncallCypher(self: liblgraph_client_python.client, cypher: str, graph: str, json_format: bool, timeout: float, url: str) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。\n\n该段落位于文档的第三部分“RPC Client”中，主要介绍如何实例化HA集群的间接连接client对象。它具体说明了当服务器配置不能直接连接时的实例化方法，以及在这种情况下用户需手动传入所有集群节点的网址的必要性。之后的内容进入了调用cypher的方法示例。"
            },
            {
                "content": "### 3.2.调用cypher\n```python\nret, res = client.callCypher(\"CALL db.edgeLabels()\", \"default\", 10)\n```\n```\ncallCypher(self: liblgraph_client_python.client, cypher: str, graph: str, json_format: bool, timeout: float, url: str) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。\n\n### 3.3.向leader发送cypher请求\n```python\nret, res = client.callCypherToLeader(\"CALL db.edgeLabels()\", \"default\", 10)\n```\n```\ncallCypherToLeader(self: liblgraph_client_python.client, cypher: str, graph: str, json_format: bool, timeout: float) -> (bool, str)\n```\n本接口只支持在HA模式下使用，在HA模式下的client中，为防止向未同步数据的follower发送请求，\n用户可以直接向leader发送请求，leader由集群选出。\n\n### 3.4.调用GQL\n```python\nret, res = client.callGql(\"CALL db.edgeLabels()\", \"default\", 10)\n```\n```\ncallGql(self: liblgraph_client_python.client, gql: str, graph: str, json_format: bool, timeout: float, url: str) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。\n\n该块内容位于文档的第三部分，具体讲解了TuGraph Python RPC Client的使用方法，重点介绍了如何调用Cypher查询和GQL查询，并提供了对应的代码示例和接口说明。这部分内容主要涉及在单机模式和高可用模式下的客户端操作，包括如何向leader发送请求以确保数据一致性。"
            },
            {
                "content": "### 3.4.调用GQL\n```python\nret, res = client.callGql(\"CALL db.edgeLabels()\", \"default\", 10)\n```\n```\ncallGql(self: liblgraph_client_python.client, gql: str, graph: str, json_format: bool, timeout: float, url: str) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。\n\n### 3.5.向leader发送GQL请求\n```python\nret, res = client.callGqlToLeader(\"CALL db.edgeLabels()\", \"default\", 10)\n```\n```\ncallGqlToLeader(self: liblgraph_client_python.client, gql: str, graph: str, json_format: bool, timeout: float) -> (bool, str)\n```\n本接口只支持在HA模式下使用，在HA模式下的client中，为防止向未同步数据的follower发送请求，\n用户可以直接向leader发送请求，leader由集群选出。\n\n此文档介绍了TuGraph Python客户端的使用，包括RESTful和RPC两种Client的安装和调用方式。第3部分重点讲解RPC Client的功能，特别是如何调用GQL查询和向集群的leader发送GQL请求，以确保请求数据的一致性和准确性。在此背景下，3.4和3.5小节具体阐述了如何使用GQL接口以及其在单机和HA模式下的应用。"
            },
            {
                "content": "### 3.5.向leader发送GQL请求\n```python\nret, res = client.callGqlToLeader(\"CALL db.edgeLabels()\", \"default\", 10)\n```\n```\ncallGqlToLeader(self: liblgraph_client_python.client, gql: str, graph: str, json_format: bool, timeout: float) -> (bool, str)\n```\n本接口只支持在HA模式下使用，在HA模式下的client中，为防止向未同步数据的follower发送请求，\n用户可以直接向leader发送请求，leader由集群选出。\n\n### 3.6.调用存储过程\n```python\nret, res = client.callProcedure(\"CPP\", \"test_plugin1\", \"bcefg\", 1000, False, \"default\")\n```\n```\ncallProcedure(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, param: str, procedure_time_out: float, in_process: bool, graph: str, json_format: bool, url: str) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用，默认以字符串格式直接返回存储过程的执行结果，指定jsonFormat为true可以返回json格式的执行结果。\n其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。\n\n该块内容位于文档的第3节，主要介绍了Python RPC Client的相关方法，特别是向leader发送GQL请求和调用存储过程的接口。这部分说明了在HA模式下如何直接向leader发送请求以确保数据同步，并提供了具体的代码示例和接口函数的描述，适用于开发者使用TuGraph进行数据库操作。"
            },
            {
                "content": "### 3.6.调用存储过程\n```python\nret, res = client.callProcedure(\"CPP\", \"test_plugin1\", \"bcefg\", 1000, False, \"default\")\n```\n```\ncallProcedure(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, param: str, procedure_time_out: float, in_process: bool, graph: str, json_format: bool, url: str) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用，默认以字符串格式直接返回存储过程的执行结果，指定jsonFormat为true可以返回json格式的执行结果。\n其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。\n\n### 3.7.向leader调用存储过程\n```python\nret, res = client.callProcedureToLeader(\"CPP\", \"khop\", kHopParamGen(), 1000, false, \"default\")\n```\n```\ncallProcedureToLeader(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, param: str, procedure_time_out: float, in_process: bool, graph: str, json_format: bool) -> (bool, str)\n```\n本接口支持在HA模式下使用，默认以字符串格式直接返回存储过程的执行结果，指定jsonFormat为true可以返回json格式的执行结果。\n\n该段落位于文档的第三部分“RPC Client”中，具体介绍了如何调用存储过程及向领导节点发送存储过程请求的接口及其用法。这些内容适用于支持单机模式和高可用集群（HA模式）的场景，重点说明了请求的格式、执行结果的返回方式以及如何在HA模式下定向请求。"
            },
            {
                "content": "### 3.7.向leader调用存储过程\n```python\nret, res = client.callProcedureToLeader(\"CPP\", \"khop\", kHopParamGen(), 1000, false, \"default\")\n```\n```\ncallProcedureToLeader(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, param: str, procedure_time_out: float, in_process: bool, graph: str, json_format: bool) -> (bool, str)\n```\n本接口支持在HA模式下使用，默认以字符串格式直接返回存储过程的执行结果，指定jsonFormat为true可以返回json格式的执行结果。\n\n### 3.8.加载存储过程\n```python\nret, res = client.loadProcedure(\"./test/procedure/khop.so\", \"CPP\", \"khop\", \"SO\", \"test loadprocedure\", true, \"v1\", \"default\");\n```\n```\nloadProcedure(self: liblgraph_client_python.client, source_file: str, procedure_type: str, procedure_name: str, code_type: str, procedure_description: str, read_only: bool, version: str, graph: str) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，由于加载存储过程是写请求，HA模式下的client只能向leader发送加载存储过程请求。\n\n该文档主要介绍TuGraph Python SDK的使用说明，其中第三部分详细描述了RPC Client的功能和调用方法。第3.7节和第3.8节分别讨论了如何向数据领导者发送存储过程调用和加载存储过程，重点在于HA模式下的使用及注意事项，为开发者在实际应用中提供指导和示例代码。"
            },
            {
                "content": "### 3.8.加载存储过程\n```python\nret, res = client.loadProcedure(\"./test/procedure/khop.so\", \"CPP\", \"khop\", \"SO\", \"test loadprocedure\", true, \"v1\", \"default\");\n```\n```\nloadProcedure(self: liblgraph_client_python.client, source_file: str, procedure_type: str, procedure_name: str, code_type: str, procedure_description: str, read_only: bool, version: str, graph: str) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，由于加载存储过程是写请求，HA模式下的client只能向leader发送加载存储过程请求。\n\n### 3.9.列举存储过程\n```python\nret, res = client.listProcedures(\"CPP\", \"any\", \"default\")\n```\n```\nlistProcedures(self: liblgraph_client_python.client, procedure_type: str, version: str, graph: str, url: str) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。\n\n该块内容位于文档的第三部分“RPC Client”的子部分，主要介绍了加载存储过程和列举存储过程的接口及其用法，适用于单机模式和HA模式下的客户端操作，强调了在HA模式下执行写请求时的注意事项。"
            },
            {
                "content": "### 3.9.列举存储过程\n```python\nret, res = client.listProcedures(\"CPP\", \"any\", \"default\")\n```\n```\nlistProcedures(self: liblgraph_client_python.client, procedure_type: str, version: str, graph: str, url: str) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。\n\n### 3.10.删除存储过程\n```python\nret, res = client.deleteProcedure(\"CPP\", \"sortstr\", \"default\")\n```\n```\ndeleteProcedure(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, graph: str) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，由于删除存储过程是写请求，HA模式下的client只能向leader发送删除存储过程请求。\n\n### 3.11.从字节流中导入schema\n```python\nret, res = client.importSchemaFromContent(schema, \"default\", 1000)\n```\n```\nimportSchemaFromContent(self: liblgraph_client_python.client, schema: str, graph: str, json_format: bool, timeout: float) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入schema是写请求，HA模式下的client只能向leader发送导入schema请求。\n\n该文档详细介绍了TuGraph Python SDK的使用，包括RESTful Client和RPC Client的安装及调用方法。上述片段位于RPC Client部分，具体涵盖了列举存储过程、删除存储过程和从字节流中导入schema的接口说明及示例代码。这些内容帮助用户理解如何在单机模式和HA模式下管理存储过程及导入schema。"
            },
            {
                "content": "### 3.11.从字节流中导入schema\n```python\nret, res = client.importSchemaFromContent(schema, \"default\", 1000)\n```\n```\nimportSchemaFromContent(self: liblgraph_client_python.client, schema: str, graph: str, json_format: bool, timeout: float) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入schema是写请求，HA模式下的client只能向leader发送导入schema请求。\n\n### 3.12.从字节流中导入点边数据\n```python\nret, res = client.importDataFromContent(personDesc, person, \",\", true, 16, \"default\", 1000)\n```\n```\nimportDataFromContent(self: liblgraph_client_python.client, desc: str, data: str, delimiter: str, continue_on_error: bool, thread_nums: int, graph: str, json_format: bool, timeout: float) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入点边数据是写请求，HA模式下的client只能向leader发送导入点边数据请求。\n\n该段落位于文档的第三部分，介绍了Python RPC Client的各种功能，包括从字节流导入模式和点边数据的接口说明。具体内容涵盖了如何通过客户端在单机模式和HA模式下执行导入操作，以及相关的接口调用示例和参数说明。"
            },
            {
                "content": "### 3.12.从字节流中导入点边数据\n```python\nret, res = client.importDataFromContent(personDesc, person, \",\", true, 16, \"default\", 1000)\n```\n```\nimportDataFromContent(self: liblgraph_client_python.client, desc: str, data: str, delimiter: str, continue_on_error: bool, thread_nums: int, graph: str, json_format: bool, timeout: float) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入点边数据是写请求，HA模式下的client只能向leader发送导入点边数据请求。\n\n### 3.13.从文件中导入schema\n```python\nret, res = client.importSchemaFromFile(\"./test/data/yago.conf\", \"default\", 1000)\n```\n```\nimportSchemaFromFile(self: liblgraph_client_python.client, schema_file: str, graph: str, json_format: bool, timeout: float) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入schema是写请求，HA模式下的client只能向leader发送导入schema请求。\n\n在文档的第三部分“RPC Client”中，本段落详细介绍了如何通过Python SDK从字节流导入点边数据和从文件导入模式（schema）。这些接口支持单机和高可用模式，但在HA模式下，所有写请求必须指向leader节点。此信息对于开发者在使用TuGraph进行数据导入时具有重要参考价值。"
            },
            {
                "content": "### 3.13.从文件中导入schema\n```python\nret, res = client.importSchemaFromFile(\"./test/data/yago.conf\", \"default\", 1000)\n```\n```\nimportSchemaFromFile(self: liblgraph_client_python.client, schema_file: str, graph: str, json_format: bool, timeout: float) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入schema是写请求，HA模式下的client只能向leader发送导入schema请求。\n\n### 3.14.从文件中导入点边数据\n```python\nret, res = client.importDataFromFile(\"./test/data/yago.conf\", \",\", true, 16, 0, \"default\", 1000000000)\n```\n```\nimportDataFromFile(self: liblgraph_client_python.client, conf_file: str, delimiter: str, continue_on_error: bool, thread_nums: int, skip_packages: int, graph: str, json_format: bool, timeout: float) -> (bool, str)\n```\n本接口支持在单机模式和HA模式下使用。其中，由于导入点边数据是写请求，HA模式下的client只能向leader发送导入点边数据请求。\n\n该段落位于文档的第三部分，介绍了Python RPC Client的各种功能接口，具体讲解了从文件中导入模式（schema）和点边数据的具体方法及其参数。这些接口支持在单机模式和高可用（HA）模式下使用，并强调在HA模式下的请求限制。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_140.md",
        "chunks": [
            {
                "content": "# 数据预热\n\n> 此文档主要介绍 TuGraph 的数据预热功能。\n\n## 1.简介\n\nTuGraph 是基于磁盘的数据库，仅当访问数据时，数据才会加载到内存中。因此在服务器刚开启后的一段时间内，系统性能可能会由于频繁的 IO 操作而变差。此时我们可以通过事先进行数据预热来改善这一问题。\n\n## 1.数据预热命令\n\n数据预热可以通过工具 `lgraph_warmup` 来进行。它的使用示例如下：\n\n```bash\n$ lgraph_warmup -d {directory} -g {graph_list}\n```\n\n其中：\n\n- `-d {db_dir}` 选项指定了 TuGraph 服务器的数据目录\n\n- `-g {graph_list}` 选项指定需要进行数据预热的图名称，用逗号分隔\n\n根据数据大小和所使用的磁盘类型不同，预热过程运行时间也不同。机械磁盘上预热一个大数据库可能耗时较长，请耐心等待。\n\n该文档主要介绍 TuGraph 数据库的功能，特别是数据预热机制，以提高系统性能并减少服务器启动初期的 IO 操作负担。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_141.md",
        "chunks": [
            {
                "content": "# 内置算法\n\n> 此文档主要详细介绍了TuGraph内置的算法程序，社区版6种算法可参考基础算法报\n\n## 简介\n\nTuGraph目前包含以下6个基础算法28种扩展算法，共34个图算法：\n\n### 基础算法包：\n| 中文算法名 | 英文算法名 | 程序名\n|  :----:  | :----: | :----: |\n| 广度优先搜索 | Breadth-First Search  | bfs \n| 网页排序 | Pagerank | pagerank \n| 单源最短路径 | Single-Source Shortest Path | sssp \n| 弱连通分量 | Weakly Connected Components | wcc \n| 平均集聚系数 | Local Clustering Coefficient  | lcc\n| 标签传播 | Label Propagation Algorithm | lpa\n\n该文档主要介绍TuGraph中的内置算法，分为基础算法和扩展算法。该块内容列出了6个基础算法，包括广度优先搜索、网页排序等，以及它们的英文名称和程序名称。"
            },
            {
                "content": "### 扩展算法包：\n| 中文算法名 | 英文算法名 | 程序名\n| :----: | :----: | :----: |\n| 全对最短路径 | All-Pair Shortest Path  | apsp \n| 介数中心度 | Betweenness Centrality | bc \n| 置信度传播 | Belief Propagation | bp\n| 距离中心度 | Closeness Centrality | clce\n| 共同邻居 | Common Neighborhood | cn \n| 度数关联度 | Degree Correlation  | dc\n| 直径估计 | Dimension Estimation | de \n| EgoNet算法 | EgoNet | en\n| 超链接主题搜索 | Hyperlink-Induced Topic Search | hits\n| 杰卡德系数 | Jaccard Index | ji\n| K核算法 | K-core | kcore\n| 鲁汶社区发现 | Louvain | louvain \n| 多源最短路径 | Multiple-source Shortest Paths | mssp\n| 个性化网页排序 | Personalized PageRank | ppr\n| 强连通分量 | Strongly Connected Components | scc \n| 监听标签传播 | Speaker-listener Label Propagation Algorithm | slpa\n| 两点间最短路径 | Single-Pair Shortest Path | spsp\n| 三角计数 | Triangle Counting | triangle \n| 信任指数排名 | Trustrank | trustrank \n| 带权重的标签传播 | Weighted Label Propagation Algorithm | wlpa \n| 带权重的网页排序 | Weighted Pagerank Algorithm | wpagerank \n| 最大独立集算法 | Maximal independent set | mis \n| sybil检测算法 | Sybil Rank | sybilrank\n\n该块内容位于文档的“扩展算法包”部分，详细列出了TuGraph内置的扩展图算法，包括其中文名、英文名和程序名，强调了在基础算法之外的额外功能和应用。"
            },
            {
                "content": "| 多源最短路径 | Multiple-source Shortest Paths | mssp\n| 个性化网页排序 | Personalized PageRank | ppr\n| 强连通分量 | Strongly Connected Components | scc \n| 监听标签传播 | Speaker-listener Label Propagation Algorithm | slpa\n| 两点间最短路径 | Single-Pair Shortest Path | spsp\n| 三角计数 | Triangle Counting | triangle \n| 信任指数排名 | Trustrank | trustrank \n| 带权重的标签传播 | Weighted Label Propagation Algorithm | wlpa \n| 带权重的网页排序 | Weighted Pagerank Algorithm | wpagerank \n| 最大独立集算法 | Maximal independent set | mis \n| sybil检测算法 | Sybil Rank | sybilrank \n| 子图匹配算法 | Subgraph Isomorphism | subgraph_isomorphism\n| 模式匹配算法 | Motif | motif\n| k阶团计数算法 | Kcliques | kcliques\n| k阶桁架计数算法 | Ktruss | ktruss \n| 莱顿算法 | Leiden | leiden\n\n该片段列出了TuGraph内置的扩展算法包中的算法，涵盖多源最短路径、个性化网页排序、强连通分量等多种图算法，属于整体文档中对扩展算法的详细介绍部分。"
            },
            {
                "content": "## 基础算法包\n\n### 广度优先搜索\n\n广度优先搜索实现了Breadth-first Search算法，从根点开始，沿着图的宽度遍历所有可访问点。返回结果为遍历点个数。算法内容请参考 https://en.wikipedia.org/wiki/Breadth-first_search\n\n### 网页排序\n\n网页排序程序实现了常用的Pagerank算法。该算法根据图中边和边权值计算所有点的重要性排名，PageRank值越高，表示该点在图中的重要性越高。计算时以点数量的倒数为各点初始Rank值，然后将点的Rank值按照出边平均传递到相邻点，重复该传递过程直到满足给定的收敛阈值或达到给定迭代轮数。每轮传递结束后，所有点的Rank值会有一定的的比例随机传递到任意点上。算法内容请参考 https://en.wikipedia.org/wiki/PageRank\n\n### 单源最短路径\n\n单源最短路径实现了Single Source Shortest Path算法，根据给定的源点，计算从该源点出发到其他任意点的最短路径长度。算法内容请参考 https://en.wikipedia.org/wiki/Shortest_path_problem\n\n### 弱连通分量\n\n弱连通分量程序实现了Weakly Connected Components算法，该算法会计算图中所有的弱连通分量。弱连通分量是图的一个子图，子图中任意两点之间均存在可达路径。算法内容请参考 https://en.wikipedia.org/wiki/Connected_component_(graph_theory)\n\n### 平均集聚系数\n\n平均集聚系数程序实现了Local Clustering Coefficient算法，计算图中点之间聚集程度的系数。返回结果包括整体集聚系数和点集聚系数。整体集聚系数反映了图中整体的集聚程度的评估，点集聚系数包括任意点的集聚系数，反映了该点附近的集聚程度。集聚系数越高，表示集聚程度越高。算法内容请参考 https://en.wikipedia.org/wiki/Clustering_coefficient\n\n### 标签传播\n\n该章节介绍了TuGraph内置的基础算法包，包括六种关键图算法的详细实现和应用，涵盖广度优先搜索、网页排序、单源最短路径、弱连通分量、平均集聚系数和标签传播算法。这些算法在图数据分析和网络研究中具有重要作用。"
            },
            {
                "content": "### 弱连通分量\n\n弱连通分量程序实现了Weakly Connected Components算法，该算法会计算图中所有的弱连通分量。弱连通分量是图的一个子图，子图中任意两点之间均存在可达路径。算法内容请参考 https://en.wikipedia.org/wiki/Connected_component_(graph_theory)\n\n### 平均集聚系数\n\n平均集聚系数程序实现了Local Clustering Coefficient算法，计算图中点之间聚集程度的系数。返回结果包括整体集聚系数和点集聚系数。整体集聚系数反映了图中整体的集聚程度的评估，点集聚系数包括任意点的集聚系数，反映了该点附近的集聚程度。集聚系数越高，表示集聚程度越高。算法内容请参考 https://en.wikipedia.org/wiki/Clustering_coefficient\n\n### 标签传播\n\n标签传播算法程序实现了Label Propagation Algorithm算法。该算法是基于标签传播的社区发现算法，计算对象为无权图。在标签传递时，每个点对收到的所有标签进行次数累加，在累加和最高的标签中随机选择一个。迭代收敛或执行到给定轮数后算法终止。最终输出结果为每个点的标签，标签值相同的点视为在同一社区。算法内容请参考 https://en.wikipedia.org/wiki/Label_Propagation_Algorithm\n\n\n## 扩展算法包\n\n### 全对最短路径\n\n全对最短路径程序实现了All-Pair Shortest Path算法，计算图中任意两点间的最短路径。返回结果为任意存在路径的点对之间的最短路径长度。算法内容请参考 https://en.wikipedia.org/wiki/Floyd-Warshall_algorithm\n\n### 介数中心度\n\n介数中心度程序实现了Betweenness Centrality算法，估算图中所有点的介数中心度值。介数中心度值反映了图中任一最短路径经过该点的可能性，值越高表示有越多的最短路径经过了该点。计算时需给定抽样点个数，分别以这些抽样点为中心进行计算。算法内容请参考 https://en.wikipedia.org/wiki/Betweenness_centrality\n\n### 置信度传播\n\n该文档主要介绍TuGraph内置的图算法，包括基础算法和扩展算法。当前的部分涵盖基础算法包中的“弱连通分量”、“平均集聚系数”和“标签传播”算法的具体实现及其原理说明，随后将过渡至扩展算法包中的“全对最短路径”、“介数中心度”和“置信度传播”等算法的介绍。"
            },
            {
                "content": "## 扩展算法包\n\n### 全对最短路径\n\n全对最短路径程序实现了All-Pair Shortest Path算法，计算图中任意两点间的最短路径。返回结果为任意存在路径的点对之间的最短路径长度。算法内容请参考 https://en.wikipedia.org/wiki/Floyd-Warshall_algorithm\n\n### 介数中心度\n\n介数中心度程序实现了Betweenness Centrality算法，估算图中所有点的介数中心度值。介数中心度值反映了图中任一最短路径经过该点的可能性，值越高表示有越多的最短路径经过了该点。计算时需给定抽样点个数，分别以这些抽样点为中心进行计算。算法内容请参考 https://en.wikipedia.org/wiki/Betweenness_centrality\n\n### 置信度传播\n\n置信度传播程序实现了Belief Propagation算法。该算法给定已观测点的边缘分布，利用点之间相互传递消息的机制来估算未观测点的边缘分布。算法内容请参考 https://en.wikipedia.org/wiki/Belief_propagation\n\n### 距离中心度\n\n距离中心度程序实现了Closeness Centrality算法，估算任意点到图中其他点的最短路径的平均长度。距离中心度越小，表示该点到其他点的平均最短距离最小，意味着该点从几何角度看更位于图的中心位置。计算时需要给定抽样点个数，分别以这些抽样点为中心进行计算。算法内容请参考 https://en.wikipedia.org/wiki/Closeness_centrality\n\n### 共同邻居\n\n共同邻居程序实现了Common Neighborhood算法，计算任意给定相邻点对之间的共同邻居数量。计算时给定待查询的若干个点对，返回结果为待查询的任意点对的共同邻居数量。\n\n### 度数关联度\n\n度数关联度程序实现了Degree Correlation算法，通过计算任意相邻点对之间的Pearson关联系数来计算图的度数关联度，可用来表征图中高度数点之间关联程度。度数关联度越高，表示图中高度数点之间的关联程度越高。算法内容请参考 https://en.wikipedia.org/wiki/Pearson_correlation_coefficient\n\n### 直径估计\n\n此 chunk 位于 TuGraph 内置算法文档中的扩展算法包部分，主要介绍六种扩展算法，包括全对最短路径、介数中心度、置信度传播、距离中心度、共同邻居以及度数关联度的实现和算法内容。"
            },
            {
                "content": "### 距离中心度\n\n距离中心度程序实现了Closeness Centrality算法，估算任意点到图中其他点的最短路径的平均长度。距离中心度越小，表示该点到其他点的平均最短距离最小，意味着该点从几何角度看更位于图的中心位置。计算时需要给定抽样点个数，分别以这些抽样点为中心进行计算。算法内容请参考 https://en.wikipedia.org/wiki/Closeness_centrality\n\n### 共同邻居\n\n共同邻居程序实现了Common Neighborhood算法，计算任意给定相邻点对之间的共同邻居数量。计算时给定待查询的若干个点对，返回结果为待查询的任意点对的共同邻居数量。\n\n### 度数关联度\n\n度数关联度程序实现了Degree Correlation算法，通过计算任意相邻点对之间的Pearson关联系数来计算图的度数关联度，可用来表征图中高度数点之间关联程度。度数关联度越高，表示图中高度数点之间的关联程度越高。算法内容请参考 https://en.wikipedia.org/wiki/Pearson_correlation_coefficient\n\n### 直径估计\n\n直径估计程序实现了Dimension Estimation算法。该算法会计算图中最长的最短路径长度，用来表征图的直径大小。算法内容请参考 http://mathworld.wolfram.com/GraphDiameter.html\n\n### EgoNet算法\n\nEgoNet算法需要给定根点和K值，以根点为源点进行宽度优先搜索，找出所有K度以内的邻居组成的子图。找到的子图称为根点的EgoNet。\n\n### 超链接主题搜索\n\n超链接主题搜索算法实现了Hyperlink-Induced Topic Search算法，该算法假定每个点具有权威性Authority和枢纽性Hub两个属性，一个好的枢纽点应该指向许多高权威性的点，而一个良好的权威点应该被许多高枢纽型的点指向。算法将返回每个点的权威性值和枢纽性值。算法内容请参考 https://en.wikipedia.org/wiki/HITS_algorithm\n\n### 杰卡德系数\n\n该chunk位于内置算法的扩展算法包部分，介绍了包括距离中心度、共同邻居、度数关联度、直径估计、EgoNet算法、超链接主题搜索和杰卡德系数在内的多种算法，旨在提供对图数据分析和网络结构特征的深入理解。"
            },
            {
                "content": "### 直径估计\n\n直径估计程序实现了Dimension Estimation算法。该算法会计算图中最长的最短路径长度，用来表征图的直径大小。算法内容请参考 http://mathworld.wolfram.com/GraphDiameter.html\n\n### EgoNet算法\n\nEgoNet算法需要给定根点和K值，以根点为源点进行宽度优先搜索，找出所有K度以内的邻居组成的子图。找到的子图称为根点的EgoNet。\n\n### 超链接主题搜索\n\n超链接主题搜索算法实现了Hyperlink-Induced Topic Search算法，该算法假定每个点具有权威性Authority和枢纽性Hub两个属性，一个好的枢纽点应该指向许多高权威性的点，而一个良好的权威点应该被许多高枢纽型的点指向。算法将返回每个点的权威性值和枢纽性值。算法内容请参考 https://en.wikipedia.org/wiki/HITS_algorithm\n\n### 杰卡德系数\n\n杰卡德系数程序实现了Jaccard Index算法。该算法计算了给定点对之间的Jaccard系数，可用来表示这两个点的相似度。Jaccard系数越高，表示点对之间的相似程度越高。计算时给定带查询的若干点对，返回结果为这些点对的Jaccard系数。算法内容请参考 https://en.wikipedia.org/wiki/Jaccard_index\n\n### k核算法\n\nk核算法实现了k-core算法。该算法计算所有点的核数，或找出图中所有的K核子图。K核子图是一种特殊子图，子图中任意点度数都不小于给定K值。算法内容请参考 https://en.wikipedia.org/wiki/Degeneracy_(graph_theory)\n\n### 鲁汶社区发现\n\n鲁汶社区发现程序实现了Fast-unfolding算法。该算法是基于模块度的社区发现算法，通过不断合并点社区来最大化图的模块度，能够发现层次性的社区结构。算法内容请参考 https://en.wikipedia.org/wiki/Louvain_Modularity\n\n### 多源最短路径\n\n该文档详细介绍了TuGraph内置的图算法，包括基础算法和扩展算法的实现及其功能。其中，<chunk>部分涵盖了一些扩展算法的详细信息，如直径估计、EgoNet算法、超链接主题搜索、杰卡德系数、k核算法、鲁汶社区发现和多源最短路径，提供了各个算法的具体实现方法和应用场景。"
            },
            {
                "content": "### 杰卡德系数\n\n杰卡德系数程序实现了Jaccard Index算法。该算法计算了给定点对之间的Jaccard系数，可用来表示这两个点的相似度。Jaccard系数越高，表示点对之间的相似程度越高。计算时给定带查询的若干点对，返回结果为这些点对的Jaccard系数。算法内容请参考 https://en.wikipedia.org/wiki/Jaccard_index\n\n### k核算法\n\nk核算法实现了k-core算法。该算法计算所有点的核数，或找出图中所有的K核子图。K核子图是一种特殊子图，子图中任意点度数都不小于给定K值。算法内容请参考 https://en.wikipedia.org/wiki/Degeneracy_(graph_theory)\n\n### 鲁汶社区发现\n\n鲁汶社区发现程序实现了Fast-unfolding算法。该算法是基于模块度的社区发现算法，通过不断合并点社区来最大化图的模块度，能够发现层次性的社区结构。算法内容请参考 https://en.wikipedia.org/wiki/Louvain_Modularity\n\n### 多源最短路径\n\n多源最短路径程序实现了Multiple-source Shortest Paths算法，根据给定的多个源点，从这些源点出发，计算到达任意点的最短路径值。其中，多个源点到某一点的最短路径值为分别从每个源点出发到达该点的最短路径的最小值。算法内容请参考 https://en.wikipedia.org/wiki/Shortest_path_problem\n\n### 个性化网页排序\n\n个性化网页排序程序实现了Personalized PageRank算法。该算法根据给定的源点，基于该源点个性化计算所有点对于源点的重要性排名。Rank值越高，表示该点对于源点越重要。与PageRank不同的是，初始化时源点Rank值为1，其余点Rank值为0；并且每轮传递结束后，Rank值会有一定的比例随即传递回源点。算法内容请参考 https://cs.stanford.edu/people/plofgren/Fast-PPR_KDD_Talk.pdf\n\n### 强连通分量\n\n此块内容位于TuGraph内置算法文档的扩展算法包部分，主要介绍了多种图算法，包括杰卡德系数、k核算法、鲁汶社区发现、多源最短路径、个性化网页排序和强连通分量等算法的实现和功能。"
            },
            {
                "content": "### 多源最短路径\n\n多源最短路径程序实现了Multiple-source Shortest Paths算法，根据给定的多个源点，从这些源点出发，计算到达任意点的最短路径值。其中，多个源点到某一点的最短路径值为分别从每个源点出发到达该点的最短路径的最小值。算法内容请参考 https://en.wikipedia.org/wiki/Shortest_path_problem\n\n### 个性化网页排序\n\n个性化网页排序程序实现了Personalized PageRank算法。该算法根据给定的源点，基于该源点个性化计算所有点对于源点的重要性排名。Rank值越高，表示该点对于源点越重要。与PageRank不同的是，初始化时源点Rank值为1，其余点Rank值为0；并且每轮传递结束后，Rank值会有一定的比例随即传递回源点。算法内容请参考 https://cs.stanford.edu/people/plofgren/Fast-PPR_KDD_Talk.pdf\n\n### 强连通分量\n\n强连通分量程序实现了Strongly Connected Components算法。该算法计算了图中所有的强连通分量，强连通分量是图的一个子图，子图中可从任意点出发到达其他任意点。算法内容请参考 https://en.wikipedia.org/wiki/Strongly_connected_component\n\n### 监听标签传播\n\n监听标签传播算法程序实现了Speaker-listener Label Propagation Algorithm算法。该算法是基于标签传播和历史标签记录的社区发现算法，是对标签传播算法的扩展。与标签传播算法不同的是，本算法会对所有点记录其历史标签，在迭代中对标签进行累加时，会将历史标签也计算在内。最终输出结果为每个点的所有历史标签记录。算法内容请参考论文：“SLPA: Uncovering Overlapping Communities in Social Networks via a Speaker-Listener Interaction Dynamic Process”。\n\n### 两点间最短路径\n\n该块内容位于TuGraph内置算法文档的扩展算法包部分，详细介绍了多个高级图算法，如多源最短路径、个性化网页排序、强连通分量、监听标签传播和两点间最短路径。这些算法扩展了基础算法的功能，提供了更复杂的图分析方法。"
            },
            {
                "content": "### 强连通分量\n\n强连通分量程序实现了Strongly Connected Components算法。该算法计算了图中所有的强连通分量，强连通分量是图的一个子图，子图中可从任意点出发到达其他任意点。算法内容请参考 https://en.wikipedia.org/wiki/Strongly_connected_component\n\n### 监听标签传播\n\n监听标签传播算法程序实现了Speaker-listener Label Propagation Algorithm算法。该算法是基于标签传播和历史标签记录的社区发现算法，是对标签传播算法的扩展。与标签传播算法不同的是，本算法会对所有点记录其历史标签，在迭代中对标签进行累加时，会将历史标签也计算在内。最终输出结果为每个点的所有历史标签记录。算法内容请参考论文：“SLPA: Uncovering Overlapping Communities in Social Networks via a Speaker-Listener Interaction Dynamic Process”。\n\n### 两点间最短路径\n\n两点间最短路径程序实现了Bidirectional Breadth-First Search算法，在有向无权图上从起点沿着出边做正向宽度优先搜搜，从终点沿着入边做反向宽度优先搜索，通过起点和终点共同遍历到的点来确定从起点到终点的最短路径长度。算法内容请参考 https://en.wikipedia.org/wiki/Bidirectional_search\n\n### 三角计数\n\n三角计数实现了Triangle-counting算法，计算无向图中的三角形个数，可用来表征图中点的关联程度。三角形数越多，表示图中点的关联程度越高。算法内容请参考论文：“Finding, Counting and Listing All Triangles in Large Graphs, an Experimental Study” 。\n\n### 信任指数排名\n\n信任指数排名算法实现了Trustrank算法，可以根据给定的白名单，计算任意点的信任指数。信任指数越高，表示该点为非法点的可能性越小。算法内容请参考 https://en.wikipedia.org/wiki/TrustRank\n\n### 带权重的标签传播\n\n这个块内容位于文档的扩展算法包部分，详细介绍了强连通分量、监听标签传播、两点间最短路径、三角计数、信任指数排名和带权重的标签传播等多种图算法的具体实现和应用。"
            },
            {
                "content": "两点间最短路径程序实现了Bidirectional Breadth-First Search算法，在有向无权图上从起点沿着出边做正向宽度优先搜搜，从终点沿着入边做反向宽度优先搜索，通过起点和终点共同遍历到的点来确定从起点到终点的最短路径长度。算法内容请参考 https://en.wikipedia.org/wiki/Bidirectional_search\n\n### 三角计数\n\n三角计数实现了Triangle-counting算法，计算无向图中的三角形个数，可用来表征图中点的关联程度。三角形数越多，表示图中点的关联程度越高。算法内容请参考论文：“Finding, Counting and Listing All Triangles in Large Graphs, an Experimental Study” 。\n\n### 信任指数排名\n\n信任指数排名算法实现了Trustrank算法，可以根据给定的白名单，计算任意点的信任指数。信任指数越高，表示该点为非法点的可能性越小。算法内容请参考 https://en.wikipedia.org/wiki/TrustRank\n\n### 带权重的标签传播\n\n带权重的标签传播算法程序实现了Weighted Label Propagation Algorithm算法。=与标签传播算法不同的是，标签的传递跟边的权重相关，在标签传递时，每个点会根据标签的入边进行权重累加，在累加和最高的标签中随机选择一个。算法内容请参考 https://en.wikipedia.org/wiki/Label_Propagation_Algorithm\n\n### 带权重的网页排序\n\n带权重的网页排序算法程序实现了Weighted Pagerank算法。与PageRank算法不同的是，Rank值的传递跟边的权重有关，点的Rank值将按照边权重加权传递到相邻点。算法内容请参考 https://en.wikipedia.org/wiki/PageRank\n\n### 最大独立集算法\n\n该文本块属于TuGraph内置算法文档中的“扩展算法包”部分，主要介绍了“两个点间最短路径”、“三角计数”、“信任指数排名”、“带权重的标签传播”、“带权重的网页排序”和“最大独立集算法”这几个算法的具体实现和功能说明。"
            },
            {
                "content": "### 信任指数排名\n\n信任指数排名算法实现了Trustrank算法，可以根据给定的白名单，计算任意点的信任指数。信任指数越高，表示该点为非法点的可能性越小。算法内容请参考 https://en.wikipedia.org/wiki/TrustRank\n\n### 带权重的标签传播\n\n带权重的标签传播算法程序实现了Weighted Label Propagation Algorithm算法。=与标签传播算法不同的是，标签的传递跟边的权重相关，在标签传递时，每个点会根据标签的入边进行权重累加，在累加和最高的标签中随机选择一个。算法内容请参考 https://en.wikipedia.org/wiki/Label_Propagation_Algorithm\n\n### 带权重的网页排序\n\n带权重的网页排序算法程序实现了Weighted Pagerank算法。与PageRank算法不同的是，Rank值的传递跟边的权重有关，点的Rank值将按照边权重加权传递到相邻点。算法内容请参考 https://en.wikipedia.org/wiki/PageRank\n\n### 最大独立集算法\n\n最大独立集算法实现了Maximal independent set算法。最大独立集是指在这个独立集之外没有可以加入它的点。一个图可能有许多大小差异很大的 MIS，算法找出其中一个。算法内容请参考 https://en.wikipedia.org/wiki/Maximal_independent_set#Sequential_algorithm\n### Sybil检测算法\n\nSybil检测算法实现了Sybil Rank算法。SybilRank算法从非Sybil节点开始进行提前终止的随机游走。算法内容请参考论文：“Aiding the Detection of Fake Accounts in Large Scale Social Online Services”。\n\n### 子图匹配算法\n\n子图匹配算法实现了subgraph_isomorphism算法。subgraph_isomorphism算法对全图所有节点匹配子图，最后输出每个节点被匹配的次数。算法内容参考 https://www.jsjkx.com/CN/article/openArticlePDF.jsp?id=18105\n\n### 模式匹配算法\n\n该块内容位于TuGraph内置算法文档的扩展算法包部分，具体描述了信任指数排名、带权重的标签传播、带权重的网页排序、最大独立集算法、Sybil检测算法、子图匹配算法以及模式匹配算法，详细阐述了每种算法的实现原理及其参考链接。"
            },
            {
                "content": "最大独立集算法实现了Maximal independent set算法。最大独立集是指在这个独立集之外没有可以加入它的点。一个图可能有许多大小差异很大的 MIS，算法找出其中一个。算法内容请参考 https://en.wikipedia.org/wiki/Maximal_independent_set#Sequential_algorithm\n### Sybil检测算法\n\nSybil检测算法实现了Sybil Rank算法。SybilRank算法从非Sybil节点开始进行提前终止的随机游走。算法内容请参考论文：“Aiding the Detection of Fake Accounts in Large Scale Social Online Services”。\n\n### 子图匹配算法\n\n子图匹配算法实现了subgraph_isomorphism算法。subgraph_isomorphism算法对全图所有节点匹配子图，最后输出每个节点被匹配的次数。算法内容参考 https://www.jsjkx.com/CN/article/openArticlePDF.jsp?id=18105\n\n### 模式匹配算法\n\n模式匹配算法实现了motif算法。motif算法对指定的节点匹配k阶子图，最后输出每个指定节点每种k阶子图个数，每个k阶子图用一个64位整数表示，整数的第$i \\times k + j$位为1表示子图中有边i->j。算法内容参考 https://en.wikipedia.org/wiki/Network_motif#mfinder\n\n### k阶团计数算法\n\nk阶团计数算法实现了k-cliques算法。k-cliques算法对计算图中所有的k阶完全子图的个数，最后输出每个节点所在的k阶完全子图个数。算法内容参考 https://en.wikipedia.org/wiki/Clique_problem#Cliques_of_fixed_size\n\n### k阶桁架计数算法\n\nk阶桁架计数算法实现了k-truss算法。k-truss指每条边都至少是k-2个三角形的边的子图。k-truss算法找出图的k-truss子图，最后输出每个节点在子图中的邻居节点列表。算法内容参考 https://louridas.github.io/rwa/assignments/finding-trusses/\n### 莱顿算法\n\n该块内容位于TuGraph内置算法的扩展算法包部分，介绍了多个图算法的实现，包括最大独立集、Sybil检测、子图匹配、模式匹配、k阶团计数、k阶桁架计数和莱顿算法。这些算法主要用于图的结构分析与社区发现，详细描述了每个算法的功能及参考文献。"
            },
            {
                "content": "模式匹配算法实现了motif算法。motif算法对指定的节点匹配k阶子图，最后输出每个指定节点每种k阶子图个数，每个k阶子图用一个64位整数表示，整数的第$i \\times k + j$位为1表示子图中有边i->j。算法内容参考 https://en.wikipedia.org/wiki/Network_motif#mfinder\n\n### k阶团计数算法\n\nk阶团计数算法实现了k-cliques算法。k-cliques算法对计算图中所有的k阶完全子图的个数，最后输出每个节点所在的k阶完全子图个数。算法内容参考 https://en.wikipedia.org/wiki/Clique_problem#Cliques_of_fixed_size\n\n### k阶桁架计数算法\n\nk阶桁架计数算法实现了k-truss算法。k-truss指每条边都至少是k-2个三角形的边的子图。k-truss算法找出图的k-truss子图，最后输出每个节点在子图中的邻居节点列表。算法内容参考 https://louridas.github.io/rwa/assignments/finding-trusses/\n### 莱顿算法\n\n莱顿算法实现了了leiden算法。leiden算法是基于模块度的社区发现算法，与louvain算法优势在于leiden算法检测出社区中的断链，保证每个社区具有良好的连通性。算法内容参考 https://www.nature.com/articles/s41598-019-41695-z#Sec4\n\n该段落位于文档的扩展算法包部分，具体介绍了模式匹配算法、k阶团计数算法、k阶桁架计数算法和莱顿算法，详细阐述了每个算法的实现原理和参考链接。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_142.md",
        "chunks": [
            {
                "content": "# 简介\nGeaFlow API是对高阶用户提供的开发接口，其支持Graph API和Stream API两种类型：\n* Graph API：Graph是GeaFlow框架的一等公民，当前GeaFlow框架提供了一套基于GraphView的图计算编程接口，包含图构建、图计算及遍历。在GeaFlow中支持Static Graph和Dynamic Graph两种类型。\n    * Static Graph API：静态图计算API，基于该类API可以进行全量的图计算或图遍历。\n    * Dynamic Graph API：动态图计算API，GeaFlow中GraphView是动态图的数据抽象，基于GraphView之上，可以进行动态图计算或图遍历。同时支持对Graphview生成Snapshot快照，基于Snapshot可以提供和Static Graph API一样的接口能力。\n* Stream API：GeaFlow提供了一套通用计算的编程接口，包括source构建、流批计算及sink输出。在GeaFlow中支持Batch和Stream两种类型。\n    * Batch API：批计算API，基于该类API可以进行批量计算。\n    * Stream API：流计算API，GeaFlow中StreamView是动态流的数据抽象，基于StreamView之上，可以进行流计算。\n\n通过两种类型API的介绍可以看到，GeaFlow内部通过View统一了图视图和流视图语义。同时为了统一支持动态和静态计算两套API，GeaFlow内部抽象了Window的概念，即从Source API开始就必须带有Window，用以基于Window的方式切分数据窗口。\n* 对于流或动态图API来说，Window可以按照size来切分，每个窗口读取一定size的数据，从而实现流式增量的计算。\n* 对于批或静态图API来说，Window将采用AllWindow模式，一个窗口将读取全量数据，从而实现全量的计算。\n\n\n## Maven依赖\n开发GeaFlow API应用需要添加一下maven依赖：\n```xml\n\ncom.antgroup.tugraph\ngeaflow-api\n0.1\n\n\ncom.antgroup.tugraph\ngeaflow-pdata\n0.1\n\n该文档介绍了GeaFlow API的概述与功能，主要分为Graph API和Stream API两大类，详细描述了静态图和动态图的计算接口，以及流处理的编程接口。此外，文档还列出了开发所需的Maven依赖及关键概念，比如窗口的抽象。该章节是文档的开头部分，提供了GeaFlow API的基础信息和使用前的准备。"
            },
            {
                "content": "通过两种类型API的介绍可以看到，GeaFlow内部通过View统一了图视图和流视图语义。同时为了统一支持动态和静态计算两套API，GeaFlow内部抽象了Window的概念，即从Source API开始就必须带有Window，用以基于Window的方式切分数据窗口。\n* 对于流或动态图API来说，Window可以按照size来切分，每个窗口读取一定size的数据，从而实现流式增量的计算。\n* 对于批或静态图API来说，Window将采用AllWindow模式，一个窗口将读取全量数据，从而实现全量的计算。\n\n\n## Maven依赖\n开发GeaFlow API应用需要添加一下maven依赖：\n```xml\n\ncom.antgroup.tugraph\ngeaflow-api\n0.1\n\n\ncom.antgroup.tugraph\ngeaflow-pdata\n0.1\n\n\ncom.antgroup.tugraph\ngeaflow-cluster\n0.1\n\n\ncom.antgroup.tugraph\ngeaflow-on-local\n0.1\n\n\ncom.antgroup.tugraph\ngeaflow-pipeline\n0.1\n\n```\n\n## 功能概览\n### Graph API\nGraph API是GeaFlow中的一等公民，其提供了一套基于GraphView的图计算编程接口，包含图构建、图计算及遍历。具体的API说明如下表格所示：\n\n\n类型\nAPI\n说明\n\n\n动态图\nPGraphView init(GraphViewDesc graphViewDesc)\n传入graphViewDesc进行初始化\n\n\nPGraphView PIncGraphView appendVertex(PWindowStream> vertexStream)     \n将分布式vertex流作为graphview增量的图点集\n\n\nPIncGraphView appendEdge(PWindowStream> edgeStream)     \n将分布式edge流作为graphview增量的图边集\n\n\nPIncGraphView appendGraph(PWindowStream> vertexStream, PWindowStream> edgeStream)     \n将分布式vertex、edge流作为graphview增量的图点/边集\n\n该段落主要介绍了GeaFlow API中视图的统一性及窗口的概念，强调了在动态与静态计算中，窗口如何影响数据的切分与处理。此外，该部分还引入了Maven依赖和Graph API的功能概览，为后续具体API说明做了铺垫。"
            },
            {
                "content": "```\n\n## 功能概览\n### Graph API\nGraph API是GeaFlow中的一等公民，其提供了一套基于GraphView的图计算编程接口，包含图构建、图计算及遍历。具体的API说明如下表格所示：\n\n\n类型\nAPI\n说明\n\n\n动态图\nPGraphView init(GraphViewDesc graphViewDesc)\n传入graphViewDesc进行初始化\n\n\nPGraphView PIncGraphView appendVertex(PWindowStream> vertexStream)     \n将分布式vertex流作为graphview增量的图点集\n\n\nPIncGraphView appendEdge(PWindowStream> edgeStream)     \n将分布式edge流作为graphview增量的图边集\n\n\nPIncGraphView appendGraph(PWindowStream> vertexStream, PWindowStream> edgeStream)     \n将分布式vertex、edge流作为graphview增量的图点/边集\n\n\n PGraphTraversal incrementalTraversal(IncVertexCentricTraversal incVertexCentricTraversal)     \n在动态graphview上进行增量图遍历\n\n\nPGraphCompute incrementalCompute(IncVertexCentricCompute incVertexCentricCompute)     \n在动态graphview上进行增量图计算 \n\n\nvoid materialize()     \n将动态graphview中增量的点边集合物化存储到state中 \n\n\n静态图\n PGraphCompute compute(VertexCentricCompute vertexCentricCompute)\n在Graph上进行静态图VC计算\n\n\n PGraphWindow compute(ScatterGatherCompute sgAlgorithm, int parallelism)     \n在Graph上进行静态图SG计算\n\n该段落位于文档的功能概览部分，重点介绍了GeaFlow API中的Graph API，包括动态图和静态图的相关功能及其对应的编程接口，适用于图计算和遍历的操作，为开发者提供了详细的API说明和使用示例。"
            },
            {
                "content": "PGraphTraversal incrementalTraversal(IncVertexCentricTraversal incVertexCentricTraversal)     \n在动态graphview上进行增量图遍历\n\n\nPGraphCompute incrementalCompute(IncVertexCentricCompute incVertexCentricCompute)     \n在动态graphview上进行增量图计算 \n\n\nvoid materialize()     \n将动态graphview中增量的点边集合物化存储到state中 \n\n\n静态图\n PGraphCompute compute(VertexCentricCompute vertexCentricCompute)\n在Graph上进行静态图VC计算\n\n\n PGraphWindow compute(ScatterGatherCompute sgAlgorithm, int parallelism)     \n在Graph上进行静态图SG计算\n\n\n PGraphTraversal traversal(VertexCentricTraversal vertexCentricTraversal)     \n在Graph上进行静态图VC遍历\n\n\n PWindowStream> getEdges()     \n返回edge集合\n\n\nPWindowStream> getVertices()     \n返回vertex集合 \n\n\n\n\n### Stream API\nStream API提供了一套通用计算的编程接口，包括source构建、流批计算及sink输出。具体的API说明如下表格所示：\n\n\n类型\nAPI\n说明\n\n\n流\nPStreamView init(IViewDesc viewDesc)\n传入StreamViewDesc进行初始化\n\n\nPIncStreamView append(PWindowStream windowStream)     \n将分布式数据作为streamView增量的数据集\n\n\nPWindowStream reduce(ReduceFunction reduceFunction)     \n在动态streamView上进行增量reduce聚合计算\n\n该内容片段主要介绍了GeaFlow API中的Graph API和Stream API的计算方法，包括动态图和静态图的增量遍历与计算功能，以及流计算的基本操作API。这些方法和功能对于开发使用GeaFlow框架的图计算和流计算应用至关重要。"
            },
            {
                "content": "PWindowStream> getEdges()     \n返回edge集合\n\n\nPWindowStream> getVertices()     \n返回vertex集合 \n\n\n\n\n### Stream API\nStream API提供了一套通用计算的编程接口，包括source构建、流批计算及sink输出。具体的API说明如下表格所示：\n\n\n类型\nAPI\n说明\n\n\n流\nPStreamView init(IViewDesc viewDesc)\n传入StreamViewDesc进行初始化\n\n\nPIncStreamView append(PWindowStream windowStream)     \n将分布式数据作为streamView增量的数据集\n\n\nPWindowStream reduce(ReduceFunction reduceFunction)     \n在动态streamView上进行增量reduce聚合计算\n\n\n PWindowStream aggregate(AggregateFunction aggregateFunction)     \n在动态streamView上进行增量aggregate聚合计算\n\n\n批\nPStreamView  PWindowStream map(MapFunction mapFunction)\n进行map操作\n\n\nPWindowStream filter(FilterFunction filterFunction)     \n进行filter操作\n\n\n PWindowStream flatMap(FlatMapFunction flatMapFunction)      \n进行flatmap操作\n\n\n PWindowStream union(PStream uStream)     \n将两个流进行union合并\n\n\nPWindowBroadcastStream broadcast()     \n将流广播到下游\n\n\n PWindowKeyStream keyBy(KeySelector selectorFunction)     \n按照selectorFunction规则进行keyby\n\n\nPStreamSink sink(SinkFunction sinkFunction)     \n将结果输出\n\n该块内容属于GeaFlow API文档的Stream API部分，具体介绍了与流计算相关的API及其功能，包括流和批处理操作下的不同函数及其用途。这一部分紧接在Graph API的介绍之后，全面展示了GeaFlow在数据处理方面的能力，尤其是在流和动态数据处理的上下文中。"
            },
            {
                "content": "批\nPStreamView  PWindowStream map(MapFunction mapFunction)\n进行map操作\n\n\nPWindowStream filter(FilterFunction filterFunction)     \n进行filter操作\n\n\n PWindowStream flatMap(FlatMapFunction flatMapFunction)      \n进行flatmap操作\n\n\n PWindowStream union(PStream uStream)     \n将两个流进行union合并\n\n\nPWindowBroadcastStream broadcast()     \n将流广播到下游\n\n\n PWindowKeyStream keyBy(KeySelector selectorFunction)     \n按照selectorFunction规则进行keyby\n\n\nPStreamSink sink(SinkFunction sinkFunction)     \n将结果输出\n\n\nPWindowCollect collect()     \n触发数据结果的收集\n\n\nPWindowStream reduce(ReduceFunction reduceFunction)     \n进行一个window内的reduce聚合计算\n\n\n PWindowStream aggregate(AggregateFunction aggregateFunction)     \n进行一个window内的aggregate聚合计算\n\n\n PIncStreamView materialize()     \n将PWindowKeyStream作为动态streamView，默认keyby后生成IncstreamView\n\n该块内容位于文档的“Stream API”部分，具体描述了批计算相关的常用操作和函数，包括对流数据进行map、filter、flatMap、union等操作，以及流的广播、聚合和结果收集等功能。这些API接口用于实现流处理的计算任务。"
            },
            {
                "content": "PWindowBroadcastStream broadcast()     \n将流广播到下游\n\n\n PWindowKeyStream keyBy(KeySelector selectorFunction)     \n按照selectorFunction规则进行keyby\n\n\nPStreamSink sink(SinkFunction sinkFunction)     \n将结果输出\n\n\nPWindowCollect collect()     \n触发数据结果的收集\n\n\nPWindowStream reduce(ReduceFunction reduceFunction)     \n进行一个window内的reduce聚合计算\n\n\n PWindowStream aggregate(AggregateFunction aggregateFunction)     \n进行一个window内的aggregate聚合计算\n\n\n PIncStreamView materialize()     \n将PWindowKeyStream作为动态streamView，默认keyby后生成IncstreamView\n\n\n\n\n## 典型示例\n### PageRank动态图计算示例介绍\n#### PageRank的定义\nPageRank算法最初作为互联网网页重要度的计算方法，1996年由Page和Brin提出，并用于谷歌搜索引擎的网页排序。事实上，PageRank 可以定义在任意有向图上，后来被应用到社会影响力分析、文本摘要等多个问题。\n假设互联网是一个有向图，在其基础上定义随机游走模型，即一阶马尔可夫链，表示网页浏览者在互联网上随机浏览网页的过程。假设浏览者在每个网页依照连接出去的超链接以等概率跳转到下一个网页，并在网上持续不断进行这样的随机跳转，这个过程形成一阶马尔可夫链。PageRank表示这个马尔可夫链的平稳分布。每个网页的PageRank值就是平稳概率。\n算法实现思路：1.假设图中每个点的初始影响值相同；2.计算每个点对其他点的跳转概率，并更新点的影响值；3.进行n次迭代计算，直到各点影响值不再变化，即收敛状态。\n\n#### 实例代码\n\n```java\n\npublic class IncrGraphCompute {\n\n该段落位于文档中对Stream API功能的介绍部分，具体描述了Stream API中几种重要的操作函数，包括广播、聚合、收集和输出等。这些函数在流计算任务中发挥关键作用，后面紧接着的是关于PageRank动态图计算的示例及其实现代码。"
            },
            {
                "content": "## 典型示例\n### PageRank动态图计算示例介绍\n#### PageRank的定义\nPageRank算法最初作为互联网网页重要度的计算方法，1996年由Page和Brin提出，并用于谷歌搜索引擎的网页排序。事实上，PageRank 可以定义在任意有向图上，后来被应用到社会影响力分析、文本摘要等多个问题。\n假设互联网是一个有向图，在其基础上定义随机游走模型，即一阶马尔可夫链，表示网页浏览者在互联网上随机浏览网页的过程。假设浏览者在每个网页依照连接出去的超链接以等概率跳转到下一个网页，并在网上持续不断进行这样的随机跳转，这个过程形成一阶马尔可夫链。PageRank表示这个马尔可夫链的平稳分布。每个网页的PageRank值就是平稳概率。\n算法实现思路：1.假设图中每个点的初始影响值相同；2.计算每个点对其他点的跳转概率，并更新点的影响值；3.进行n次迭代计算，直到各点影响值不再变化，即收敛状态。\n\n#### 实例代码\n\n```java\n\npublic class IncrGraphCompute {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(IncrGraphCompute.class);\n\t// 计算结果路径\n    public static final String RESULT_FILE_PATH = \"./target/tmp/data/result/incr_graph\";\n\t// 结果对比路径\n    public static final String REF_FILE_PATH = \"data/reference/incr_graph\";\n\n    public static void main(String[] args) {\n\t\t// 获取执行环境\n        Environment environment = EnvironmentFactory.onLocalEnvironment();\n\t\t// 执行作业提交\n        IPipelineResult result = submit(environment);\n\t\t// 等待执行完成\n        result.get();\n\t\t// 关闭执行环境\n\t\tenvironment.shutdown();\n    }\n\n该部分介绍了GeaFlow API中的典型示例，重点是PageRank算法的动态图计算示例。通过对PageRank的定义、随机游走模型以及算法实现思路的解释，接着提供了相应的Java示例代码，展示如何在GeaFlow中实现此算法的增量计算。"
            },
            {
                "content": "public static void main(String[] args) {\n\t\t// 获取执行环境\n        Environment environment = EnvironmentFactory.onLocalEnvironment();\n\t\t// 执行作业提交\n        IPipelineResult result = submit(environment);\n\t\t// 等待执行完成\n        result.get();\n\t\t// 关闭执行环境\n\t\tenvironment.shutdown();\n    }\n\n    public static IPipelineResult submit(Environment environment) {\n\t\t// 构建任务执行流\n        final Pipeline pipeline = PipelineFactory.buildPipeline(environment);\n\t\t// 获取作业环境配置\n        Configuration envConfig = ((EnvironmentContext) environment.getEnvironmentContext()).getConfig();\n\t\t// 指定保存计算结果的路径\n        envConfig.put(FileSink.OUTPUT_DIR, RESULT_FILE_PATH);\n\n该代码块位于GeaFlow API文档中的PageRank动态图计算示例部分，主要展示了主方法及作业提交的方法实现。这部分代码负责获取执行环境、提交计算任务并等待结果完成，随后关闭执行环境。"
            },
            {
                "content": "// graphview 名称\n        final String graphName = \"graph_view_name\";\n\t\t// 创建增量图 graphview\n        GraphViewDesc graphViewDesc = GraphViewBuilder\n\t\t\t.createGraphView(graphName)\n\t\t\t// 设置 graphview 分片数, 可从配置中指定\n            .withShardNum(envConfig.getInteger(ExampleConfigKeys.ITERATOR_PARALLELISM))\n\t\t\t// 设置 graphview backend 类型\n            .withBackend(BackendType.RocksDB)\n\t\t\t// 指定 graphview 点边以及属性等schema信息\n            .withSchema(new GraphMetaType(IntegerType.INSTANCE, ValueVertex.class, Integer.class, ValueEdge.class, IntegerType.class))\n            .build();\n\t\t// 将创建好的graphview信息添加到任务执行流\n        pipeline.withView(graphName, graphViewDesc);\n\t\t\n\t\t// 提交任务并执行\n        pipeline.submit(new PipelineTask() {\n            @Override\n            public void execute(IPipelineTaskContext pipelineTaskCxt) {\n                Configuration conf = pipelineTaskCxt.getConfig();\n\t\t\t\t// 1. 构建点数据输入源\n                PWindowSource> vertices =\n                    // extract vertex from edge file\n\n该代码块位于GeaFlow API文档的PageRank动态图计算示例部分，主要展示如何创建增量图（GraphView）并配置其相关参数，包括图名、分片数、后端类型以及点边的 schema 信息，以便于在后续的数据处理任务中使用。"
            },
            {
                "content": ".build();\n\t\t// 将创建好的graphview信息添加到任务执行流\n        pipeline.withView(graphName, graphViewDesc);\n\t\t\n\t\t// 提交任务并执行\n        pipeline.submit(new PipelineTask() {\n            @Override\n            public void execute(IPipelineTaskContext pipelineTaskCxt) {\n                Configuration conf = pipelineTaskCxt.getConfig();\n\t\t\t\t// 1. 构建点数据输入源\n                PWindowSource> vertices =\n                    // extract vertex from edge file\n                    pipelineTaskCxt.buildSource(new RecoverableFileSource<>(\"data/input/email_edge\",\t\t\t\n\t\t\t\t\t\t// 指定每行数据的解析格式\n                        line -> {\n                            String[] fields = line.split(\",\");\n                            IVertex vertex1 = new ValueVertex<>(\n                                Integer.valueOf(fields[0]), 1);\n                            IVertex vertex2 = new ValueVertex<>(\n                                Integer.valueOf(fields[1]), 1);\n                            return Arrays.asList(vertex1, vertex2);\n\n该代码块位于PageRank动态图计算示例的构建任务执行流部分，主要负责将创建好的graphview信息添加到任务中，并定义点数据输入源。此部分代码通过构建输入源从边数据文件中提取顶点数据，以便后续进行图算法的计算。"
            },
            {
                "content": "// 指定每行数据的解析格式\n                        line -> {\n                            String[] fields = line.split(\",\");\n                            IVertex vertex1 = new ValueVertex<>(\n                                Integer.valueOf(fields[0]), 1);\n                            IVertex vertex2 = new ValueVertex<>(\n                                Integer.valueOf(fields[1]), 1);\n                            return Arrays.asList(vertex1, vertex2);\n                        }), SizeTumblingWindow.of(10000))\n\t\t\t\t\t\t// 指定点数据source并发数\n                        .withParallelism(pipelineTaskCxt.getConfig().getInteger(ExampleConfigKeys.SOURCE_PARALLELISM));\n\t\t\t\t\n\t\t\t\t// 2. 构建边数据输入源\n                PWindowSource> edges =\n                    pipelineTaskCxt.buildSource( new RecoverableFileSource<>(\"data/input/email_edge\",\t\t\t\n\t\t\t\t\t\t// 指定每行数据的解析格式\n                        line -> {\n                            String[] fields = line.split(\",\");\n                            IEdge edge = new ValueEdge<>(Integer.valueOf(fields[0]),\n\n该代码片段位于PageRank动态图计算示例的代码实现部分，主要用于解析输入数据文件中的边和点信息。其中，第一部分解析了点数据，每行数据被分割并转换为对应的顶点对象；接下来的部分则是针对边数据的解析，处理相应的输入格式。此代码片段有助于构建增量图，支持动态图计算。"
            },
            {
                "content": ".withParallelism(pipelineTaskCxt.getConfig().getInteger(ExampleConfigKeys.SOURCE_PARALLELISM));\n\t\t\t\t\n\t\t\t\t// 2. 构建边数据输入源\n                PWindowSource> edges =\n                    pipelineTaskCxt.buildSource( new RecoverableFileSource<>(\"data/input/email_edge\",\t\t\t\n\t\t\t\t\t\t// 指定每行数据的解析格式\n                        line -> {\n                            String[] fields = line.split(\",\");\n                            IEdge edge = new ValueEdge<>(Integer.valueOf(fields[0]),\n                                Integer.valueOf(fields[1]), 1);\n                            return Collections.singletonList(edge);\n                        }), SizeTumblingWindow.of(5000))\n\t\t\t\t\t\t// 指定边数据source并发数\n\t\t\t\t\t\t.withParallelism(pipelineTaskCxt.getConfig().getInteger(ExampleConfigKeys.SOURCE_PARALLELISM));\n\t\t\t\t\n\t\t\t\t// 获取定义的graphview, 并构建图数据\n                PGraphView fundGraphView =\n                    pipelineTaskCxt.getGraphView(graphName);\n                PIncGraphView incGraphView =\n\n该代码片段位于PageRank动态图计算示例的实施部分，具体负责构建边数据输入源，并指定每行数据的解析格式以及并发数，以便于将边数据加载到增量图中。因此，这部分代码在整个示例中起到关键作用，确保输入数据的正确构建和处理。"
            },
            {
                "content": "Integer.valueOf(fields[1]), 1);\n                            return Collections.singletonList(edge);\n                        }), SizeTumblingWindow.of(5000))\n\t\t\t\t\t\t// 指定边数据source并发数\n\t\t\t\t\t\t.withParallelism(pipelineTaskCxt.getConfig().getInteger(ExampleConfigKeys.SOURCE_PARALLELISM));\n\t\t\t\t\n\t\t\t\t// 获取定义的graphview, 并构建图数据\n                PGraphView fundGraphView =\n                    pipelineTaskCxt.getGraphView(graphName);\n                PIncGraphView incGraphView =\n                    fundGraphView.appendGraph(vertices, edges);\n\t\t\t\t// 获取作业执行map算子的并发数\n                int mapParallelism = pipelineTaskCxt.getConfig().getInteger(ExampleConfigKeys.MAP_PARALLELISM);\n\t\t\t\t// 获取作业执行sink算子的并发数\n                int sinkParallelism = pipelineTaskCxt.getConfig().getInteger(ExampleConfigKeys.SINK_PARALLELISM);\n\t\t\t\t// 创建sink方法\n                SinkFunction sink = ExampleSinkFunctionFactory.getSinkFunction(conf);\t\t\t\n\t\t\t\t// 基于图算法，执行动态图计算\n\n该代码块位于GeaFlow API的PageRank动态图计算示例中，主要描述了如何从边数据源构建边，并将这些边与顶点数据结合以创建增量图的过程。此段落继续讨论获取作业执行的并发数和创建sink方法，以便执行动态图计算。"
            },
            {
                "content": "PIncGraphView incGraphView =\n                    fundGraphView.appendGraph(vertices, edges);\n\t\t\t\t// 获取作业执行map算子的并发数\n                int mapParallelism = pipelineTaskCxt.getConfig().getInteger(ExampleConfigKeys.MAP_PARALLELISM);\n\t\t\t\t// 获取作业执行sink算子的并发数\n                int sinkParallelism = pipelineTaskCxt.getConfig().getInteger(ExampleConfigKeys.SINK_PARALLELISM);\n\t\t\t\t// 创建sink方法\n                SinkFunction sink = ExampleSinkFunctionFactory.getSinkFunction(conf);\t\t\t\n\t\t\t\t// 基于图算法，执行动态图计算\n                incGraphView.incrementalCompute(new IncGraphAlgorithms(3))\n\t\t\t\t\t// 获取结果点数据并作map操作\n                    .getVertices()\n                    .map(v -> String.format(\"%s,%s\", v.getId(), v.getValue()))\n                    .withParallelism(mapParallelism)\n                    .sink(sink)\n                    .withParallelism(sinkParallelism);\n            }\n        });\n\t\t\n        return pipeline.execute();\n    }\n\t\n\t// 创建Pagerank动态图算法\n\n该代码块位于GeaFlow API文档的“PageRank动态图计算示例介绍”部分，具体描述了如何在增量图视图`PIncGraphView`上执行动态计算（利用Pagerank算法），并设置并发数以及创建结果输出的sink方法，展示如何处理和获取计算结果的过程。"
            },
            {
                "content": "// 基于图算法，执行动态图计算\n                incGraphView.incrementalCompute(new IncGraphAlgorithms(3))\n\t\t\t\t\t// 获取结果点数据并作map操作\n                    .getVertices()\n                    .map(v -> String.format(\"%s,%s\", v.getId(), v.getValue()))\n                    .withParallelism(mapParallelism)\n                    .sink(sink)\n                    .withParallelism(sinkParallelism);\n            }\n        });\n\t\t\n        return pipeline.execute();\n    }\n\t\n\t// 创建Pagerank动态图算法\n    public static class IncGraphAlgorithms extends IncVertexCentricCompute {\n\n该代码块位于GeaFlow API文档中，用于展示如何在动态图（Graph）上执行PageRank算法的增量计算。具体而言，它展示了如何通过`incrementalCompute`方法执行图算法，并获取计算结果点数据进行后续处理。此部分代码是PageRank动态图计算示例的核心实现之一。"
            },
            {
                "content": "public IncGraphAlgorithms(long iterations) {\n\t\t\t// 设置算法最大迭代次数\n            super(iterations);\n        }\n\n        @Override\n        public IncVertexCentricComputeFunction getIncComputeFunction() {\n\t\t\t// 指定Pagerank计算逻辑\n            return new PRVertexCentricComputeFunction();\n        }\n\n        @Override\n        public VertexCentricCombineFunction getCombineFunction() {\n            return null;\n        }\n\n    }\n\n    public static class PRVertexCentricComputeFunction implements\n        IncVertexCentricComputeFunction {\n\n该代码块位于\"PageRank动态图计算示例介绍\"的部分，主要定义了一个名为`IncGraphAlgorithms`的类，用于实现Pagerank算法的增量计算逻辑。该类继承自`IncVertexCentricCompute`，包含对算法最大迭代次数的设置和计算逻辑的指定。代码块后面紧接着定义了`PRVertexCentricComputeFunction`类，用于具体实现Pagerank的计算方法。"
            },
            {
                "content": "}\n\n    public static class PRVertexCentricComputeFunction implements\n        IncVertexCentricComputeFunction {\n\n        private IncGraphComputeContext graphContext;\n\t\t\n\t\t// init方法, 获取graphContext\n        @Override\n        public void init(IncGraphComputeContext graphContext) {\t\n            this.graphContext = graphContext;\n        }\n\t\t\n\t\t// 第一轮迭代evolve方法实现\n        @Override\n        public void evolve(Integer vertexId,\n                           TemporaryGraph temporaryGraph) {\n\t\t\t// 动态图版本指定为0\n            long lastVersionId = 0L;\n\t\t\t// 从增量图中获取id等于 vertexId 的点\n            IVertex vertex = temporaryGraph.getVertex();\n\t\t\t// 获取历史底图\n            HistoricalGraph historicalGraph = graphContext\n                .getHistoricalGraph();\n            if (vertex == null) {\n\t\t\t\t// 如果增量图中不存在id 等于 vertexId 的点, 就从历史图中获取\n                vertex = historicalGraph.getSnapShot(lastVersionId).vertex().get();\n            }\n\n该代码块位于PageRank动态图计算示例中的`PRVertexCentricComputeFunction`类内部，主要实现了增量图计算中的`init`和`evolve`方法，用于初始化图计算上下文以及处理图中点的动态演化逻辑。这个部分是实现PageRank算法的关键，涉及如何从增量图和历史图中获取节点信息并进行处理。"
            },
            {
                "content": "if (vertex != null) {\n\t\t\t\t// 从增量图中获取点对应的所有出边\n                List> newEs = temporaryGraph.getEdges();\n\t\t\t\t// 从历史图中获取点对应的所有出边\n                List> oldEs = historicalGraph.getSnapShot(lastVersionId)\n                    .edges().getOutEdges();\n                if (newEs != null) {\n                    for (IEdge edge : newEs) {\n\t\t\t\t\t\t// 向增量图中所有边的终点，发送消息，内容为vertexId\n                        graphContext.sendMessage(edge.getTargetId(), vertexId);\n                    }\n                }\n                if (oldEs != null) {\n                    for (IEdge edge : oldEs) {\n\t\t\t\t\t\t// 向历史图中所有边的终点，发送消息，内容为vertexId\n                        graphContext.sendMessage(edge.getTargetId(), vertexId);\n                    }\n                }\n            }\n\n        }\n\n该代码块位于PageRank动态图计算示例中的`PRVertexCentricComputeFunction`类的`evolve`方法内。它负责从增量图和历史图中获取当前节点的出边，并向每个出边的目标节点发送消息，内容为当前节点的ID。在动态图计算中，这一过程用于更新节点之间的关系和影响值。"
            },
            {
                "content": "@Override\n        public void compute(Integer vertexId, Iterator messageIterator) {\n            int max = 0;\n\t\t\t// 迭代vertexId收到的所有消息, 并取其中的最大值\n            while (messageIterator.hasNext()) {\n                int value = messageIterator.next();\n                max = max > value ? max : value;\n            }\n\t\t\t// 从增量图中获取id 等于vertexId的点\n            IVertex vertex = graphContext.getTemporaryGraph().getVertex();\t\t\n\t\t\t// 从历史图中获取id等于 vertexId 的点\n            IVertex historyVertex = graphContext.getHistoricalGraph().getSnapShot(0).vertex().get();\n\t\t\t// 将增量图中的点属性值和消息的最大值，两者取最大\n            if (vertex != null && max < vertex.getValue()) {\n                max = vertex.getValue();\n            }\n\t\t\t// 将历史图中的点属性值和消息的最大值，两者取最大\n            if (historyVertex != null && max < historyVertex.getValue()) {\n                max = historyVertex.getValue();\n            }\n\t\t\t// 更新增量图中点的属性值\n            graphContext.getTemporaryGraph().updateVertexValue(max);\n        }\n\t\t\n\t\t\n        @Override\n\n该代码块位于PageRank动态图计算示例中的`PRVertexCentricComputeFunction`类的`compute`方法内，主要负责处理接收到的消息并计算与顶点相关的最大值，以更新增量图中顶点的属性值。这部分逻辑是实现PageRank算法的重要步骤之一。"
            },
            {
                "content": "// 将增量图中的点属性值和消息的最大值，两者取最大\n            if (vertex != null && max < vertex.getValue()) {\n                max = vertex.getValue();\n            }\n\t\t\t// 将历史图中的点属性值和消息的最大值，两者取最大\n            if (historyVertex != null && max < historyVertex.getValue()) {\n                max = historyVertex.getValue();\n            }\n\t\t\t// 更新增量图中点的属性值\n            graphContext.getTemporaryGraph().updateVertexValue(max);\n        }\n\t\t\n\t\t\n        @Override\n        public void finish(Integer vertexId, MutableGraph mutableGraph) {\n\t\t\t// 从增量图中获取vertexId相关的点边\n            IVertex vertex = graphContext.getTemporaryGraph().getVertex();\n            List> edges = graphContext.getTemporaryGraph().getEdges();\n            if (vertex != null) {\n\t\t\t\t// 将增量图中的点添加到图数据中。\n                mutableGraph.addVertex(0, vertex);\n                graphContext.collect(vertex);\n            } else {\n                LOGGER.info(\"not found vertex {} in temporaryGraph \", vertexId);\n            }\n            if (edges != null) {\n\t\t\t\t// 将增量中的边添加到图数据中。\n\n该代码块位于PageRank动态图计算示例中的`PRVertexCentricComputeFunction`类内，主要实现了在增量图计算过程中更新点的属性值的逻辑。具体而言，它通过比较增量图和历史图中点的属性值，选择更大的值进行更新，并在计算完成后将更新的点和相关边添加到图数据中。这个过程是PageRank算法中的关键部分，确保算法能够正确反映图中节点的影响力。"
            },
            {
                "content": "// 从增量图中获取vertexId相关的点边\n            IVertex vertex = graphContext.getTemporaryGraph().getVertex();\n            List> edges = graphContext.getTemporaryGraph().getEdges();\n            if (vertex != null) {\n\t\t\t\t// 将增量图中的点添加到图数据中。\n                mutableGraph.addVertex(0, vertex);\n                graphContext.collect(vertex);\n            } else {\n                LOGGER.info(\"not found vertex {} in temporaryGraph \", vertexId);\n            }\n            if (edges != null) {\n\t\t\t\t// 将增量中的边添加到图数据中。\n                edges.stream().forEach(edge -> {\n                    mutableGraph.addEdge(0, edge);\n                });\n            }\n        }\n    }\n\n该代码块位于PageRank动态图计算示例中的`PRVertexCentricComputeFunction`类的`finish`方法中，负责将增量图中的点和边添加到图数据中，并在完成后收集结果。它是实现PageRank算法的核心部分，处理动态图的增量更新和结果的输出。"
            },
            {
                "content": "}\n\n```\n\n### PageRank静态图计算示例介绍\n#### 实例代码\n\n```java\n\npublic class PageRank {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(PageRank.class);\n\t\n\t// 计算结果路径\n    public static final String RESULT_FILE_PATH = \"./target/tmp/data/result/pagerank\";\n\t\n\t// 结果对比路径\n    public static final String REF_FILE_PATH = \"data/reference/pagerank\";\n\n    public static void main(String[] args) {\n\t\t// 获取作业执行环境\n        Environment environment = EnvironmentFactory.onLocalEnvironment();\n\t\t// 执行作业提交\n        IPipelineResult result = submit(environment);\n        result.get();\n\t\t// 关闭执行环境\n        environment.shutdown();\n    }\n\n该代码块属于GeaFlow API文档中的\"PageRank静态图计算示例介绍\"部分，提供了PageRank算法的静态图实现示例，包括计算结果的路径设置、作业执行环境的获取和提交。这部分示例旨在展示如何利用GeaFlow框架进行静态图的PageRank计算。"
            },
            {
                "content": "public static IPipelineResult submit(Environment environment) {\n\t\t// 构建任务执行流\n        Pipeline pipeline = PipelineFactory.buildPipeline(environment);\n\t\t// 获取作业相关配置\n        Configuration envConfig = environment.getEnvironmentContext().getConfig();\n\t\t// 指定结果输出路径\n        envConfig.put(FileSink.OUTPUT_DIR, RESULT_FILE_PATH);\n\t\t\n\t\t// 提交任务并执行\n        pipeline.submit((PipelineTask) pipelineTaskCxt -> {\n            Configuration conf = pipelineTaskCxt.getConfig();\n\t\t\t// 1. 构建图中点的输入数据\n            PWindowSource> prVertices =\n                pipelineTaskCxt.buildSource(new FileSource<>(\"data/input/email_vertex\",\n\t\t\t\t\t// 定义每行数据解析成点的格式\n                    line -> {\n                        String[] fields = line.split(\",\");\n                        IVertex vertex = new ValueVertex<>(\n                            Integer.valueOf(fields[0]), Double.valueOf(fields[1]));\n                        return Collections.singletonList(vertex);\n                    }), AllWindow.getInstance())\n\t\t\t\t\t// 设定并发数\n\n该代码块位于GeaFlow API文档中的“PageRank静态图计算示例介绍”部分，主要涉及在作业环境中构建任务执行流，并定义图中点的数据输入源，用于读取和解析输入文件中的顶点数据。"
            },
            {
                "content": "PWindowSource> prVertices =\n                pipelineTaskCxt.buildSource(new FileSource<>(\"data/input/email_vertex\",\n\t\t\t\t\t// 定义每行数据解析成点的格式\n                    line -> {\n                        String[] fields = line.split(\",\");\n                        IVertex vertex = new ValueVertex<>(\n                            Integer.valueOf(fields[0]), Double.valueOf(fields[1]));\n                        return Collections.singletonList(vertex);\n                    }), AllWindow.getInstance())\n\t\t\t\t\t// 设定并发数\n                    .withParallelism(conf.getInteger(ExampleConfigKeys.SOURCE_PARALLELISM));\n\t\t\t// 2. 构建图中边的输入数据\n            PWindowSource> prEdges = pipelineTaskCxt.buildSource(new FileSource<>(\"data/input/email_edge\",\n\t\t\t\t// 定义每行数据解析成边的格式\n                line -> {\n                    String[] fields = line.split(\",\");\n                    IEdge edge = new ValueEdge<>(Integer.valueOf(fields[0]), Integer.valueOf(fields[1]), 1);\n                    return Collections.singletonList(edge);\n\n该代码段位于\"PageRank静态图计算示例介绍\"部分，主要描述了如何构建静态图中的点和边的数据输入源。通过定义输入数据的解析格式，将文件中的数据转换为图的顶点和边，供后续的静态图计算使用。"
            },
            {
                "content": "// 设定并发数\n                    .withParallelism(conf.getInteger(ExampleConfigKeys.SOURCE_PARALLELISM));\n\t\t\t// 2. 构建图中边的输入数据\n            PWindowSource> prEdges = pipelineTaskCxt.buildSource(new FileSource<>(\"data/input/email_edge\",\n\t\t\t\t// 定义每行数据解析成边的格式\n                line -> {\n                    String[] fields = line.split(\",\");\n                    IEdge edge = new ValueEdge<>(Integer.valueOf(fields[0]), Integer.valueOf(fields[1]), 1);\n                    return Collections.singletonList(edge);\n                }), AllWindow.getInstance())\n\t\t\t\t// 设定并发数\n                .withParallelism(conf.getInteger(ExampleConfigKeys.SOURCE_PARALLELISM));\n\t\t\t\n\t\t\t// 迭代计算并发数\n            int iterationParallelism = conf.getInteger(ExampleConfigKeys.ITERATOR_PARALLELISM);\t\t\n\t\t\t// 定义graphview\n            GraphViewDesc graphViewDesc = GraphViewBuilder\n                .createGraphView(GraphViewBuilder.DEFAULT_GRAPH)\n\t\t\t\t// 指定分片数为2\n                .withShardNum(2)\n\t\t\t\t// 指定backend类型为memory\n\n该代码块位于“PageRank静态图计算示例介绍”部分，用于构建图中边的输入源数据，在图计算过程中设定并发数和定义图视图（GraphView）。具体地，它展示了如何读取边的数据并解析为图的边对象，同时配置相关的并行执行参数。"
            },
            {
                "content": "}), AllWindow.getInstance())\n\t\t\t\t// 设定并发数\n                .withParallelism(conf.getInteger(ExampleConfigKeys.SOURCE_PARALLELISM));\n\t\t\t\n\t\t\t// 迭代计算并发数\n            int iterationParallelism = conf.getInteger(ExampleConfigKeys.ITERATOR_PARALLELISM);\t\t\n\t\t\t// 定义graphview\n            GraphViewDesc graphViewDesc = GraphViewBuilder\n                .createGraphView(GraphViewBuilder.DEFAULT_GRAPH)\n\t\t\t\t// 指定分片数为2\n                .withShardNum(2)\n\t\t\t\t// 指定backend类型为memory\n                .withBackend(BackendType.Memory)\n                .build();\n\t\t\t\n\t\t\t// 基于点边数据和定义的graphview, 构建静态图\n            PGraphWindow graphWindow =\n                pipelineTaskCxt.buildWindowStreamGraph(prVertices, prEdges, graphViewDesc);\n\t\t\t// 获取sink函数\n            SinkFunction> sink = ExampleSinkFunctionFactory.getSinkFunction(conf);\n\t\t\t// 指定计算并发数，执行静态计算方法\n            graphWindow.compute(new PRAlgorithms(3))\n                .compute(iterationParallelism)\n\t\t\t\t// 获取计算结果点，按照定义的sink函数输出\n                .getVertices()\n\n该代码块位于GeaFlow API文档的PageRank静态图计算示例部分，具体描述了如何定义图视图（GraphView）并构建静态图的数据输入源。该部分包括对并发数的设定、图视图的配置，以及最终执行静态计算和输出结果的过程。"
            },
            {
                "content": ".build();\n\t\t\t\n\t\t\t// 基于点边数据和定义的graphview, 构建静态图\n            PGraphWindow graphWindow =\n                pipelineTaskCxt.buildWindowStreamGraph(prVertices, prEdges, graphViewDesc);\n\t\t\t// 获取sink函数\n            SinkFunction> sink = ExampleSinkFunctionFactory.getSinkFunction(conf);\n\t\t\t// 指定计算并发数，执行静态计算方法\n            graphWindow.compute(new PRAlgorithms(3))\n                .compute(iterationParallelism)\n\t\t\t\t// 获取计算结果点，按照定义的sink函数输出\n                .getVertices()\n                .sink(sink)\n                .withParallelism(conf.getInteger(ExampleConfigKeys.SINK_PARALLELISM));\n        });\n\n该代码块位于文档中介绍PageRank静态图计算示例的部分，具体描述了如何基于输入的点和边数据以及定义的graphview构建静态图，并通过指定的sink函数输出计算结果。这一过程是静态图计算的关键步骤，体现了GeaFlow中Graph API的应用。"
            },
            {
                "content": "return pipeline.execute();\n    }\n\n    public static void validateResult() throws IOException {\n        ResultValidator.validateResult(REF_FILE_PATH, RESULT_FILE_PATH);\n    }\n\n    public static class PRAlgorithms extends VertexCentricCompute {\n\n        public PRAlgorithms(long iterations) {\n\t\t\t// 指定静态图计算的迭代次数\n            super(iterations);\n        }\n\n        @Override\n        public VertexCentricComputeFunction getComputeFunction() {\n            return new PRVertexCentricComputeFunction();\n        }\n\n        @Override\n        public VertexCentricCombineFunction getCombineFunction() {\n            return null;\n        }\n\n    }\n\n该代码片段位于文档中关于PageRank静态图计算示例的实现部分，主要定义了PageRank算法的迭代计算逻辑，包括算法的迭代次数设置和计算功能的实现。它紧接着`pipeline.execute()`方法后面，作为静态图计算的核心逻辑部分。"
            },
            {
                "content": "@Override\n        public VertexCentricCombineFunction getCombineFunction() {\n            return null;\n        }\n\n    }\n\n    public static class PRVertexCentricComputeFunction extends AbstractVcFunc {\n\t\t// 静态图计算方法实现\n        @Override\n        public void compute(Integer vertexId,\n                            Iterator messageIterator) {\n\t\t\t// 从静态图中获取点id等于vertexId的点\n            IVertex vertex = this.context.vertex().get();\n            if (this.context.getIterationId() == 1) {\n\t\t\t\t// 第一轮迭代向邻居节点发送消息，消息内容为vertexId点的属性值\n                this.context.sendMessageToNeighbors(vertex.getValue());\n            } else {\n                double sum = 0;\n                while (messageIterator.hasNext()) {\n                    double value = messageIterator.next();\n                    sum += value;\n                }\n\t\t\t\t// 累积消息之和，并设置为当前点的属性值\n                this.context.setNewVertexValue(sum);\n            }\n        }\n\n    }\n}\n\n```\n\n### WordCount批计算示例介绍\n#### 实例代码\n\n```java\n\npublic class WordCountStream {\n\n该代码块位于GeaFlow API文档中的PageRank静态图计算示例介绍部分，具体描述了静态图计算算法的实现，包含了一个关于VertexCentricCombineFunction的重写和PRVertexCentricComputeFunction类的计算逻辑实现。这部分代码主要用于说明在静态图中如何进行点的属性值计算和消息传递。紧接着该部分后面则是WordCount批计算示例的代码。"
            },
            {
                "content": "}\n}\n\n```\n\n### WordCount批计算示例介绍\n#### 实例代码\n\n```java\n\npublic class WordCountStream {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(WordCountStream.class);\n\t\n\t// 计算结果路径\n    public static final String RESULT_FILE_PATH = \"./target/tmp/data/result/wordcount\";\n\t\n\t// 结果对比路径\n    public static final String REF_FILE_PATH = \"data/reference/wordcount\";\n\n    public static void main(String[] args) {\n\t\t// 获取作业执行环境\n        Environment environment = EnvironmentUtil.loadEnvironment(args);\n\t\t// 执行作业提交\n        IPipelineResult result = submit(environment);\n        result.get();\n\t\t// 关闭执行环境\n        environment.shutdown();\n    }\n\n    public static IPipelineResult submit(Environment environment) {\n\t\t// 构建任务执行流\n        Pipeline pipeline = PipelineFactory.buildPipeline(environment);\n\t\t// 获取作业环境配置\n        Configuration envConfig = ((EnvironmentContext) environment.getEnvironmentContext()).getConfig();\n\t\t// 指定保存计算结果的路径\n        envConfig.getConfigMap().put(FileSink.OUTPUT_DIR, RESULT_FILE_PATH);\n\n该块代码属于文档中的“WordCount批计算示例介绍”部分，展示了如何使用GeaFlow API实现一个简单的单词计数功能的批处理示例，包含了代码的主要逻辑和执行环境的设置。"
            },
            {
                "content": "public static IPipelineResult submit(Environment environment) {\n\t\t// 构建任务执行流\n        Pipeline pipeline = PipelineFactory.buildPipeline(environment);\n\t\t// 获取作业环境配置\n        Configuration envConfig = ((EnvironmentContext) environment.getEnvironmentContext()).getConfig();\n\t\t// 指定保存计算结果的路径\n        envConfig.getConfigMap().put(FileSink.OUTPUT_DIR, RESULT_FILE_PATH);\n\n        pipeline.submit(new PipelineTask() {\n            @Override\n            public void execute(IPipelineTaskContext pipelineTaskCxt) {\n                Configuration conf = pipelineTaskCxt.getConfig();\n\n该代码块位于GeaFlow API中的一个示例程序中，负责提交任务执行流和配置作业环境，包括设置计算结果的输出路径。它是PageRank算法示例的一部分，用于执行增量图的计算。"
            },
            {
                "content": "pipeline.submit(new PipelineTask() {\n            @Override\n            public void execute(IPipelineTaskContext pipelineTaskCxt) {\n                Configuration conf = pipelineTaskCxt.getConfig();\n\n\t\t\t\t// 获取输入数据流\n                PWindowSource streamSource = pipelineTaskCxt.buildSource(\n                    new FileSource(\"data/input/email_edge\",\n\t\t\t\t\t\t// 定义每行数据的解析格式\n                        line -> {\n                            String[] fields = line.split(\",\");\n                            return Collections.singletonList(fields[0]);\n\t\t\t\t\t\t\t\t// 定义数据窗口大小\n                        }) {}, SizeTumblingWindow.of(5000))\n\t\t\t\t\t// 定义输入数据流的并发数\n                    .withParallelism(conf.getInteger(ExampleConfigKeys.SOURCE_PARALLELISM));\n\n该代码块位于WordCount流计算示例的提交任务中，主要用于构建输入数据流，解析每行数据并定义数据窗口大小及并发数，以便于后续的数据处理和聚合计算。"
            },
            {
                "content": "SinkFunction sink = ExampleSinkFunctionFactory.getSinkFunction(conf);\t\t\t\n                streamSource\n\t\t\t\t\t// 对流中的数据作map操作\n                    .map(e -> Tuple.of(e, 1))\n\t\t\t\t\t// key by\n                    .keyBy(new KeySelectorFunc())\n\t\t\t\t\t// reduce 聚合统计相同数据的个数\n                    .reduce(new CountFunc())\n\t\t\t\t\t// 指定算子并发数\n                    .withParallelism(conf.getInteger(ExampleConfigKeys.REDUCE_PARALLELISM))\n                    .map(v -> String.format(\"(%s,%s)\", ((Tuple) v).f0, ((Tuple) v).f1))\n                    .sink(sink)\n                    .withParallelism(conf.getInteger(ExampleConfigKeys.SINK_PARALLELISM));\n            }\n        });\n\n        return pipeline.execute();\n    }\n\n    public static void validateResult() throws IOException {\n        ResultValidator.validateResult(REF_FILE_PATH, RESULT_FILE_PATH);\n    }\n\n该代码块位于GeaFlow API文档中的WordCount批计算示例部分，展示了如何构建一个数据流，通过map操作对流中的数据进行处理，使用keyBy和reduce方法统计相同数据出现的次数，并最终输出结果。该示例演示了如何使用GeaFlow的流计算API进行简单的数据聚合操作。"
            },
            {
                "content": "return pipeline.execute();\n    }\n\n    public static void validateResult() throws IOException {\n        ResultValidator.validateResult(REF_FILE_PATH, RESULT_FILE_PATH);\n    }\n\n\n    public static class MapFunc implements MapFunction> {\n\t\t// map方法实现, 将每个输入单词转换为Tuple\n        @Override\n        public Tuple map(String value) {\n            LOGGER.info(\"MapFunc process value: {}\", value);\n            return Tuple.of(value, 1);\n        }\n    }\n\n    public static class KeySelectorFunc implements KeySelector, Object> {\n\n        @Override\n        public Object getKey(Tuple value) {\n            return value.f0;\n        }\n    }\n\n    public static class CountFunc implements ReduceFunction> {\n\n        @Override\n        public Tuple reduce(Tuple oldValue, Tuple newValue) {\n            return Tuple.of(oldValue.f0, oldValue.f1 + newValue.f1);\n        }\n    }\n}\n\n```\n\n\n### KeyAgg流计算示例介绍\n#### 实例代码\n\n```java\n\npublic class WindowStreamKeyAgg implements Serializable {\n\n该代码块位于文档中关于\"WordCount批计算示例\"部分的结尾，包含了处理映射函数、键选择函数和减少函数的类定义。这些类主要用于实现单词计数的MapReduce操作，紧接着是\"KeyAgg流计算示例\"部分的开头。"
            },
            {
                "content": "@Override\n        public Object getKey(Tuple value) {\n            return value.f0;\n        }\n    }\n\n    public static class CountFunc implements ReduceFunction> {\n\n        @Override\n        public Tuple reduce(Tuple oldValue, Tuple newValue) {\n            return Tuple.of(oldValue.f0, oldValue.f1 + newValue.f1);\n        }\n    }\n}\n\n```\n\n\n### KeyAgg流计算示例介绍\n#### 实例代码\n\n```java\n\npublic class WindowStreamKeyAgg implements Serializable {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(WindowStreamKeyAgg.class);\n    // 计算结果路径\n    public static final String RESULT_FILE_PATH = \"./target/tmp/data/result/wordcount\";\n\n    // 结果对比路径\n    public static final String REF_FILE_PATH = \"data/reference/wordcount\";\n\n    public static void main(String[] args) {\n        // 获取作业执行环境\n        Environment environment = EnvironmentUtil.loadEnvironment(args);\n        // 执行作业提交\n        IPipelineResult result = submit(environment);\n        result.get();\n        // 关闭执行环境\n        environment.shutdown();\n    }\n\n该代码块位于\"KeyAgg流计算示例介绍\"部分，展示了在流计算中如何实现基于键的聚合功能。具体包括一个键选择器的实现和一个用于统计词频的归约函数，后续将进一步演示如何使用这些函数进行窗口流处理和结果输出。"
            },
            {
                "content": "public static IPipelineResult submit(Environment environment) {\n        // 构建执行流\n        Pipeline pipeline = PipelineFactory.buildPipeline(environment);\n        // 获取作业环境配置\n        Configuration envConfig = ((EnvironmentContext) environment.getEnvironmentContext()).getConfig();\n        // 指定作业结果输出路径\n        envConfig.getConfigMap().put(FileSink.OUTPUT_DIR, RESULT_FILE_PATH);\n        // 开启动态流图materialize开关\n        envConfig.getConfigMap().put(FrameworkConfigKeys.INC_STREAM_MATERIALIZE_DISABLE.getKey(), Boolean.TRUE.toString());\n        ResultValidator.cleanResult(RESULT_FILE_PATH);\n        pipeline.submit(new PipelineTask() {\n            @Override\n            public void execute(IPipelineTaskContext pipelineTaskCxt) {\n                Configuration conf = pipelineTaskCxt.getConfig();\n\n该代码段位于文档中关于\"KeyAgg流计算示例\"的部分，展示了如何在GeaFlow框架中构建和提交一个执行流，包括配置执行环境、设置输出路径以及开启动态流图的物化开关。此部分的内容主要说明了如何初始化和执行数据处理任务。"
            },
            {
                "content": "// 窗口大小定义为5000, 构建输入数据流\n                PWindowSource streamSource =\n                    pipelineTaskCxt.buildSource(new FileSource(\"data/input\"\n                        + \"/email_edge\", Collections::singletonList) {}, SizeTumblingWindow.of(5000));\n\n该代码块位于\"KeyAgg流计算示例介绍\"中，用于定义窗口大小为5000的输入数据流构建过程。此部分主要展示如何通过构建流源来处理数据，实现动态流计算的功能。"
            },
            {
                "content": "SinkFunction sink = ExampleSinkFunctionFactory.getSinkFunction(conf);\n                streamSource\n                    .flatMap(new FlatMapFunction() {\n                        @Override\n                        public void flatMap(String value, Collector collector) {\n                            // flatmap方法实现\n                            String[] records = value.split(SPLIT);\n                            for (String record : records) {\n                                // 将每行数据切分并获取\n                                collector.partition(Long.valueOf(record));\n                            }\n                        }\n                    })\n                    // map算子\n                    .map(p -> Tuple.of(p, p))\n                    // 定义特定条件的key by算子\n                    .keyBy(p -> ((long) ((Tuple) p).f0) % 7)\n                    .aggregate(new AggFunc())\n                    .withParallelism(conf.getInteger(AGG_PARALLELISM))\n\n该代码块位于文档的\"KeyAgg流计算示例介绍\"部分，展示了如何在流计算中使用flatMap算子对输入数据进行切分，并随后进行map、keyBy和aggregate操作，以实现特定条件下的聚合计算。这些操作是为动态流图的计算逻辑构建一部分。"
            },
            {
                "content": "// 将每行数据切分并获取\n                                collector.partition(Long.valueOf(record));\n                            }\n                        }\n                    })\n                    // map算子\n                    .map(p -> Tuple.of(p, p))\n                    // 定义特定条件的key by算子\n                    .keyBy(p -> ((long) ((Tuple) p).f0) % 7)\n                    .aggregate(new AggFunc())\n                    .withParallelism(conf.getInteger(AGG_PARALLELISM))\n                    .map(v -> String.format(\"%s,%s\", ((Tuple) v).f0, ((Tuple) v).f1))\n                    .sink(sink).withParallelism(conf.getInteger(SINK_PARALLELISM));\n            }\n        });\n\n该代码片段位于《KeyAgg流计算示例介绍》部分，描述了在流计算中如何处理输入数据，通过flatMap将数据切分并提取出来，然后进行map操作、key by操作，最后使用aggregate函数对相同键的数据进行聚合计算并输出结果。"
            },
            {
                "content": "return pipeline.execute();\n    }\n\n    public static void validateResult() throws IOException {\n        ResultValidator.validateMapResult(REF_FILE_PATH, RESULT_FILE_PATH, String::compareTo);\n    }\n\n\n    public static class AggFunc implements\n        AggregateFunction, Tuple, Tuple> {\n\n        // 定义累加器实现\n        @Override\n        public Tuple createAccumulator() {\n            return Tuple.of(0L, 0L);\n        }\n\n        @Override\n        public void add(Tuple value, Tuple accumulator) {\n            // 对相同key的两个value，累加value的f1值\n            accumulator.setF0(value.f0);\n            accumulator.setF1(value.f1 + accumulator.f1);\n        }\n\n        @Override\n        public Tuple getResult(Tuple accumulator) {\n            // 返回累加后的结果\n            return Tuple.of(accumulator.f0, accumulator.f1);\n        }\n\n        @Override\n        public Tuple merge(Tuple a, Tuple b) {\n            return null;\n        }\n    }\n\n}\n\n\n```\n\n该代码块位于GeaFlow文档的流计算示例部分，具体是名为`WindowStreamKeyAgg`的类实现中。它定义了一个用于聚合计算的累加器（`AggFunc`）及其相关方法，用于处理输入数据流的聚合逻辑，并最终返回聚合结果。该类展示了如何在动态流计算中应用聚合函数。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_143.md",
        "chunks": [
            {
                "content": "# Hudi Connector介绍\nGeaFlow Hudi 目前支持从文件中读取数据。\n## 语法\n\n```sql\nCREATE TABLE IF NOT EXISTS hudi_person (\n  id BIGINT,\n  name VARCHAR\n) WITH (\n  type='hudi', \n  geaflow.file.persistent.config.json = '{\\'fs.defaultFS\\':\\'namenode:9000\\'}',\n  geaflow.dsl.file.path='/path/to/hudi_person'\n);\n```\n## 参数\n\n| 参数名 | 是否必须 | 描述 |\n| -------- | -------- | -------- |\n| geaflow.dsl.file.path     | 是     | 读取或写入的文件或文件夹的路径     |\n| geaflow.file.persistent.config.json     | 否    | JSON格式的DFS配置，会覆盖系统环境配置。      |\n表格内容描述: \n该表格包含三列，分别为“参数名”、“是否必须”和“描述”。 \n\n第一行数据是“geaflow.dsl.file.path”，其“是否必须”为“是”，描述为“读取或写入的文件或文件夹的路径”。 \n第二行数据是“geaflow.file.persistent.config.json”，其“是否必须”为“否”，描述为“JSON格式的DFS配置，会覆盖系统环境配置”。 \n\n总体来看，该表格列出了两个参数的相关信息，其中“geaflow.dsl.file.path”是必需的参数，而“geaflow.file.persistent.config.json”则是可选的参数。\n\n## 示例\n\n```sql\nset geaflow.dsl.window.size = -1;\n\n该文档介绍了GeaFlow Hudi连接器的基本用法，包括创建表的语法、必须和可选参数的详细说明，以及相关的SQL示例，主要用于从文件中读取和写入数据。"
            },
            {
                "content": "第一行数据是“geaflow.dsl.file.path”，其“是否必须”为“是”，描述为“读取或写入的文件或文件夹的路径”。 \n第二行数据是“geaflow.file.persistent.config.json”，其“是否必须”为“否”，描述为“JSON格式的DFS配置，会覆盖系统环境配置”。 \n\n总体来看，该表格列出了两个参数的相关信息，其中“geaflow.dsl.file.path”是必需的参数，而“geaflow.file.persistent.config.json”则是可选的参数。\n\n## 示例\n\n```sql\nset geaflow.dsl.window.size = -1;\n\nCREATE TABLE IF NOT EXISTS hudi_person (\n  id BIGINT,\n  name VARCHAR\n) WITH (\n   type='hudi', -- hdfs 配置，也可通过HADOOP_HOME环境变量获取\n  `geaflow.file.persistent.config.json` = '{\\'fs.defaultFS\\':\\'namenode:9000\\'}',\n\tgeaflow.dsl.file.path='/path/to/hudi_person'\n);\n\nCREATE TABLE IF NOT EXISTS hudi_sink (\n  id BIGINT,\n  name VARCHAR\n) WITH (\n  type='hudi', -- hdfs 配置，也可通过HADOOP_HOME环境变量获取\n  `geaflow.file.persistent.config.json` = '{\\'fs.defaultFS\\':\\'namenode:9000\\'}',\n\tgeaflow.dsl.file.path='/path/to/hudi_sink'\n);\n\nINSERT INTO hudi_sink\nSELECT * FROM hudi_person;\n```\n\n该chunk位于Hudi Connector介绍的部分，主要讨论了参数表中的内容，并提供了示例代码，以展示如何创建Hudi表和进行数据插入操作。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_144.md",
        "chunks": [
            {
                "content": "# JDBC Connector介绍\nJDBC Connector由社区贡献，支持读和写。\n## 语法\n\n```sql\nCREATE TABLE jdbc_table (\n  id BIGINT,\n  name VARCHAR,\n  age INT\n) WITH (\n\ttype='jdbc',\n    geaflow.dsl.jdbc.driver = 'org.h2.Driver',\n    geaflow.dsl.jdbc.url = 'jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1',\n    geaflow.dsl.jdbc.username = 'h2_user',\n    geaflow.dsl.jdbc.password = 'h2_pwd',\n    geaflow.dsl.jdbc.table.name = 'source_table'\n);\n```\n## 参数\n\n该文档介绍了JDBC Connector的基本信息，包括其语法和参数配置，提供了创建JDBC表的示例以及可用参数的详细说明。这一部分为读者理解如何使用JDBC Connector进行数据连接和操作奠定基础。"
            },
            {
                "content": "| 参数名 | 是否必须 | 描述                                                |\n| -------- |------|---------------------------------------------------|\n| geaflow.dsl.jdbc.driver     | 是    | The JDBC driver.                                  |\n| geaflow.dsl.jdbc.url     | 是    | The database URL.                                 |\n| geaflow.dsl.jdbc.username     | 是    | The database username.                            |\n| geaflow.dsl.jdbc.password     | 是    | The database password.                            |\n| geaflow.dsl.jdbc.table.name     | 是    | The table name.                                   |\n| geaflow.dsl.jdbc.partition.num     | 否    | The JDBC partition number, default 1.             |\n| geaflow.dsl.jdbc.partition.column     | 否    | The JDBC partition column. Default value is 'id'. |\n| geaflow.dsl.jdbc.partition.lowerbound     | 否    | The lowerbound of JDBC partition, just used to decide the partition stride, not for filtering the rows in table.                                 |\n\n该表格列出了JDBC Connector的参数设置，包括必需和可选参数的名称、是否必须以及具体描述，确保用户能够正确配置连接信息以实现数据读写。"
            },
            {
                "content": "| geaflow.dsl.jdbc.table.name     | 是    | The table name.                                   |\n| geaflow.dsl.jdbc.partition.num     | 否    | The JDBC partition number, default 1.             |\n| geaflow.dsl.jdbc.partition.column     | 否    | The JDBC partition column. Default value is 'id'. |\n| geaflow.dsl.jdbc.partition.lowerbound     | 否    | The lowerbound of JDBC partition, just used to decide the partition stride, not for filtering the rows in table.                                 |\n| geaflow.dsl.jdbc.partition.upperbound     | 否    | The upperbound of JDBC partition, just used to decide the partition stride, not for filtering the rows in table.                            |\n表格内容描述: 表格列名包括“参数名”、“是否必须”和“描述”。逐行描述如下：  \n1. \"geaflow.dsl.jdbc.driver\" 是必须参数，表示 JDBC 驱动程序。  \n2. \"geaflow.dsl.jdbc.url\" 是必须参数，表示数据库的 URL。  \n3. \"geaflow.dsl.jdbc.username\" 是必须参数，表示数据库用户名。  \n4. \"geaflow.dsl.jdbc.password\" 是必须参数，表示数据库密码。  \n5. \"geaflow.dsl.jdbc.table.name\" 是必须参数，表示数据表的名称。\n\n该块内容位于文档的参数部分，具体列出了与 JDBC 连接器相关的可配置参数，包括必需和可选参数的详细描述，帮助用户理解如何设置和使用 JDBC 连接器。"
            },
            {
                "content": "| geaflow.dsl.jdbc.partition.upperbound     | 否    | The upperbound of JDBC partition, just used to decide the partition stride, not for filtering the rows in table.                            |\n表格内容描述: 表格列名包括“参数名”、“是否必须”和“描述”。逐行描述如下：  \n1. \"geaflow.dsl.jdbc.driver\" 是必须参数，表示 JDBC 驱动程序。  \n2. \"geaflow.dsl.jdbc.url\" 是必须参数，表示数据库的 URL。  \n3. \"geaflow.dsl.jdbc.username\" 是必须参数，表示数据库用户名。  \n4. \"geaflow.dsl.jdbc.password\" 是必须参数，表示数据库密码。  \n5. \"geaflow.dsl.jdbc.table.name\" 是必须参数，表示数据表的名称。  \n6. \"geaflow.dsl.jdbc.partition.num\" 不是必须参数，表示 JDBC 分区数量，默认值为 1。  \n7. \"geaflow.dsl.jdbc.partition.column\" 不是必须参数，表示 JDBC 分区列，默认值为 'id'。  \n8. \"geaflow.dsl.jdbc.partition.lowerbound\" 不是必须参数，表示 JDBC 分区的下界，用于决定分区步幅，并不用于过滤表中的行。  \n9. \"geaflow.dsl.jdbc.partition.upperbound\" 不是必须参数，表示 JDBC 分区的上界，同样用于决定分区步幅，而非过滤表中的行。\n\n该块内容位于文档的参数说明部分，详细描述了与JDBC连接器相关的配置参数，包括必需和可选参数的名称、是否必须以及具体描述，帮助用户理解如何有效设置JDBC连接。"
            },
            {
                "content": "总体而言，该表格列出了与 JDBC 相关的参数设置，其中包括多项必需参数和一些可选参数，确保用户在进行数据连接和分区时能有效地配置相关信息。\n\n\n## 示例\n\n```sql\nset geaflow.dsl.jdbc.driver = 'org.h2.Driver';\nset geaflow.dsl.jdbc.url = 'jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1';\nset geaflow.dsl.jdbc.username = 'h2_user';\nset geaflow.dsl.jdbc.password = 'h2_pwd'; \n\nCREATE TABLE jdbc_source_table (\n  id BIGINT,\n  name VARCHAR,\n  age INT\n) WITH (\n\ttype='jdbc',\n    geaflow.dsl.jdbc.table.name = 'source_table',\n);\n\nCREATE TABLE jdbc_sink_table (\n  id BIGINT,\n  name VARCHAR,\n  age INT\n) WITH (\n\ttype='jdbc',\n    geaflow.dsl.jdbc.table.name = 'sink_table'\n);\n\nINSERT INTO jdbc_sink_table\nSELECT * FROM jdbc_source_table;\n```\n\n该块内容位于文档的示例部分，展示了如何使用 JDBC Connector 进行数据库连接和数据操作，包括设置 JDBC 驱动程序、连接信息，以及创建源和目标表的 SQL 语句和插入数据的示例。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_145.md",
        "chunks": [
            {
                "content": "# 简介\nGeaFlow 支持从各类connector中读写数据，GeaFlow将它们都识别为外部表，并将元数据存储在Catalog中。\n\n## 语法\n\n```sql\nCREATE [TEMPORARY] TABLE [IF NOT EXISTS] table (\n  id BIGINT,\n  name VARCHAR,\n  age INT\n) WITH (\n\ttype='file',\n    geaflow.dsl.file.path = '/path/to/file',\n    geaflow.dsl.window.size = 1000\n)\n```\n\n声明一张表来使用Connector，具体使用Source/Sink由读写行为决定。\n\nTEMPORARY 用于创建临时表，临时表不写入Catalog。如果不指定 IF NOT EXISTS 则会在存在同名表时报错。\n\nWITH子句用于指定Connector的配置信息，其中的type字段必须，用来指定使用Connector类型，例如file表示使用文件。\n\n同时我们可以在WITH中添加表的参数，这些参数会覆盖掉外部(SQL文件中、作业参数中)的配置项，具有最高优先级。\n\n## 主要参数\n\n该文档介绍了GeaFlow的基本功能及语法，包括如何创建外部表以便从连接器中读写数据，并详细说明了表的配置参数及其重要性，为用户提供了有关使用连接器的操作指导。"
            },
            {
                "content": "声明一张表来使用Connector，具体使用Source/Sink由读写行为决定。\n\nTEMPORARY 用于创建临时表，临时表不写入Catalog。如果不指定 IF NOT EXISTS 则会在存在同名表时报错。\n\nWITH子句用于指定Connector的配置信息，其中的type字段必须，用来指定使用Connector类型，例如file表示使用文件。\n\n同时我们可以在WITH中添加表的参数，这些参数会覆盖掉外部(SQL文件中、作业参数中)的配置项，具有最高优先级。\n\n## 主要参数\n\n| 参数名                          | 是否必须 | 描述                                                                                                            |\n|------------------------------| -------- |---------------------------------------------------------------------------------------------------------------|\n| type                         | 是     | 指定使用的Connector类型                                                                                              |\n| geaflow.dsl.window.size | 否     | 重要，-1表示读取所有数据为一个窗口，属于批式处理。正数表示若干条数据为一个窗口，为流式处理。                                                               |\n| geaflow.dsl.partitions.per.source.parallelism | 否     | 将Source的分片若干个编为一组，减少并发数关联的资源使用量。      |\n表格内容描述: \n\n该表格包含三个列名：参数名、是否必须和描述。\n\n该块内容位于文档的中间部分，介绍了如何声明表以使用Connector，包括临时表的创建与配置参数的说明，并包括一个参数表，详细解释了各个参数的必要性和功能，为用户提供了关于使用Connector的具体指导。"
            },
            {
                "content": "该表格包含三个列名：参数名、是否必须和描述。 \n\n1. 参数名为\"type\"，其重要性标记为\"是\"，描述为指定使用的Connector类型。\n2. 参数名为\"geaflow.dsl.window.size\"，其重要性标记为\"否\"，描述为重要参数，其中-1表示读取所有数据为一个窗口，属于批式处理；正数表示若干条数据为一个窗口，属于流式处理。\n3. 参数名为\"geaflow.dsl.partitions.per.source.parallelism\"，其重要性标记为\"否\"，描述为将Source的分片若干个编为一组，以减少并发数关联的资源使用量。\n\n总体而言，该表格提供了关于配置参数的详细信息，指出了哪些参数是必需的以及它们的具体功能描述，帮助用户了解如何有效地配置和使用Connector。\n\n\n## 示例\n\n```sql\nCREATE TABLE console_sink (\n  id BIGINT,\n  name VARCHAR,\n  age INT\n) WITH (\n\ttype='console'\n);\n\n-- Write one row to the log\nINSERT INTO console_sink\nSELECT 1, 'a', 2;\n```\n\n该块内容位于文档的主要参数部分，详细描述了GeaFlow中 connector 配置参数的具体信息，包括必需性和功能，旨在帮助用户有效配置和使用连接器。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_146.md",
        "chunks": [
            {
                "content": "# Compute API介绍\nGeaFlow对外提供了实现图计算算法的接口，通过实现相应接口可进行静态图计算或动态图计算，用户可在compute算法中定义具体的计算逻辑及迭代最大次数。\n\n## 动态图\n### 接口\n| API | 接口说明 | 入参说明 |\n| --- | --- | --- |\n| void init(IncGraphComputeContext incGraphContext) | 图计算初始化接口 | incGraphContext： 增量动态图计算的上下文，K表示vertex id的类型，VV表示vertex value类型，EV表示edge value类型，M表示发送消息的类型。 |\n| void evolve(K vertexId, TemporaryGraph temporaryGraph) | 首轮迭代对增量图实现处理逻辑 | vertexId：当前计算点的id，其中K表示vertex id的类型。temporaryGraph：临时增量图，其中K表示vertexId的类型，VV表示vertex value类型，EV表示edge value类型。 |\n| void compute(K vertexId, Iterator messageIterator) | 迭代计算接口 | vertexId：当前计算点的id，其中K表示vertex id的类型。 |\n| void finish(K vertexId, MutableGraph mutableGraph) | 迭代计算完成接口 | vertexId：当前计算点的id，其中K表示vertex id的类型。mutableGraph：可变图，其中K表示vertexId的类型，VV表示vertex value类型，EV表示edge value类型 |\n表格内容描述：该表格包含三列，分别是“API”、“接口说明”和“入参说明”。\n\n该文档介绍了GeaFlow的Compute API，包括静态图和动态图的计算接口及其实现。文中详细描述了动态图的计算接口、入参说明以及具体的API功能，旨在为用户提供图计算的接口和实现方法。<chunk>部分具体列出了动态图的接口及其详细说明。"
            },
            {
                "content": "1. 第一行数据描述了“init”接口，该接口用于图计算的初始化，其入参数为“incGraphContext”，表示增量动态图计算的上下文，其中K表示vertex id的类型，VV表示vertex value类型，EV表示edge value类型，M表示发送消息的类型。\n2. 第二行数据描述了“evolve”接口，其功能是在首轮迭代中对增量图进行处理。入参数包括“vertexId”，即当前计算点的id（类型为K），以及“temporaryGraph”，表示临时增量图，其中K表示vertexId的类型，VV表示vertex value类型，EV表示edge value类型。\n3. 第三行数据描述了“compute”接口，这是一个迭代计算接口，入参数“vertexId”表示当前计算点的id（类型为K），并且有一个“messageIterator”用于处理消息。\n4. 第四行数据描述了“finish”接口，其功能是标志迭代计算的完成。入参数包括“vertexId”，即当前计算点的id（类型为K），以及“mutableGraph”，表示可变图，其中K表示vertexId的类型，VV表示vertex value类型，EV表示edge value类型。\n\n总体总结：该表格列出了四个API接口及其说明，主要用于增量图计算的初始化、处理、计算及完成。每个接口都有明确的入参说明，说明了参数所代表的类型和用途，适用于图计算相关的程序设计与实现。\n\n\n- 详细接口\n\n```java\npublic interface IncVertexCentricFunction extends Function {\n\n   void evolve(K vertexId, TemporaryGraph temporaryGraph);\n\n   void compute(K vertexId, Iterator messageIterator);\n\n   void finish(K vertexId, MutableGraph mutableGraph);\n\n   interface IncGraphContext {\n       /** 获取job id */\n       long getJobId();\n\n该段落位于“动态图”部分，详细描述了四个主要API接口的功能及其入参说明，包括“init”、“evolve”、“compute”和“finish”，并提供了对这些接口在增量图计算过程中作用的总结。此外，还引入了相关的详细接口定义，为后续的编程实现提供基础。"
            },
            {
                "content": "总体总结：该表格列出了四个API接口及其说明，主要用于增量图计算的初始化、处理、计算及完成。每个接口都有明确的入参说明，说明了参数所代表的类型和用途，适用于图计算相关的程序设计与实现。\n\n\n- 详细接口\n\n```java\npublic interface IncVertexCentricFunction extends Function {\n\n   void evolve(K vertexId, TemporaryGraph temporaryGraph);\n\n   void compute(K vertexId, Iterator messageIterator);\n\n   void finish(K vertexId, MutableGraph mutableGraph);\n\n   interface IncGraphContext {\n       /** 获取job id */\n       long getJobId();\n\n        /** 获取当前迭代 id */\n        long getIterationId();\n        \n        /** 获取运行时上下文 */\n        RuntimeContext getRuntimeContext();\n\n        /** 获取可变图 */\n        MutableGraph getMutableGraph();\n\n    \t/** 获取增量图 */\n        TemporaryGraph getTemporaryGraph();\n\n        /** 获取图存储上的历史图 */\n        HistoricalGraph getHistoricalGraph();\n\n        /** 给指定vertex发送消息 */\n        void sendMessage(K vertexId, M message);\n\n        /** 给当前vertex邻居节点发送消息 */\n        void sendMessageToNeighbors(M message);\n\n   }\n\n   interface TemporaryGraph {\n   /** 从增量图中获取vertex */\n   IVertex getVertex();\n\n该段落位于文档的“动态图”部分，主要总结了增量图计算相关的API接口，包括初始化、处理、计算和完成的详细说明，以及其相关的接口定义，适用于图计算相关的程序设计与实现。这为后续的详细接口定义提供了背景和前提。"
            },
            {
                "content": "/** 获取可变图 */\n        MutableGraph getMutableGraph();\n\n    \t/** 获取增量图 */\n        TemporaryGraph getTemporaryGraph();\n\n        /** 获取图存储上的历史图 */\n        HistoricalGraph getHistoricalGraph();\n\n        /** 给指定vertex发送消息 */\n        void sendMessage(K vertexId, M message);\n\n        /** 给当前vertex邻居节点发送消息 */\n        void sendMessageToNeighbors(M message);\n\n   }\n\n   interface TemporaryGraph {\n   /** 从增量图中获取vertex */\n   IVertex getVertex();\n\n        /** 从增量图中获取edges */\n        List> getEdges();\n\n        /** 更新vertex value */\n        void updateVertexValue(VV value);\n\n   }\n\n   interface HistoricalGraph {\n   /** 获取图数据最新版本id */\n   Long getLatestVersionId();\n\n        /** 获取图数据所有版本 */\n        List getAllVersionIds();\n\n        /** 获取图数据所有vertex */\n        Map> getAllVertex();\n\n        /** 获取图数据指定版本的vertex */\n        Map> getAllVertex(List versions);\n\n        /** 获取图数据指定版本并满足过滤条件的vertex */\n        Map> getAllVertex(List versions, IVertexFilter vertexFilter);\n\n该代码块位于文档的\"动态图\"部分，具体描述了接口`IncGraphContext`中的方法，包括获取可变图、增量图和历史图的功能，以及发送消息的相关操作。这些方法是实现动态图计算时的关键接口，用于支持增量图计算的上下文管理和消息传递机制。"
            },
            {
                "content": "/** 更新vertex value */\n        void updateVertexValue(VV value);\n\n   }\n\n   interface HistoricalGraph {\n   /** 获取图数据最新版本id */\n   Long getLatestVersionId();\n\n        /** 获取图数据所有版本 */\n        List getAllVersionIds();\n\n        /** 获取图数据所有vertex */\n        Map> getAllVertex();\n\n        /** 获取图数据指定版本的vertex */\n        Map> getAllVertex(List versions);\n\n        /** 获取图数据指定版本并满足过滤条件的vertex */\n        Map> getAllVertex(List versions, IVertexFilter vertexFilter);\n\n        /** 获取图数据指定版本的快照 */\n        GraphSnapShot getSnapShot(long version);\n\n   }\n\n   interface GraphSnapShot {\n   /** 获取当前版本id */\n   long getVersion();\n   /** 获取vertex */\n   VertexQuery vertex();\n   /** 获取edges */\n   EdgeQuery edges();\n\n   }\n\n   interface MutableGraph {\n   /** 向图中添加vertex，并指定其版本id */\n   void addVertex(long version, IVertex vertex);\n   /** 向图中添加edge，并指定其版本id */\n   void addEdge(long version, IEdge edge);\n\n   }\n\n\n}\n\npublic interface IncVertexCentricComputeFunction extends\n        IncVertexCentricFunction {\n\n该块内容位于文档中关于动态图计算的详细接口部分，主要描述了与增量图计算相关的接口，包括更新顶点值的功能、获取历史图数据版本及快照等相关操作。这些接口为实现动态图处理提供了基础，适用于增量计算任务中的数据管理和查询。"
            },
            {
                "content": "}\n\n   interface GraphSnapShot {\n   /** 获取当前版本id */\n   long getVersion();\n   /** 获取vertex */\n   VertexQuery vertex();\n   /** 获取edges */\n   EdgeQuery edges();\n\n   }\n\n   interface MutableGraph {\n   /** 向图中添加vertex，并指定其版本id */\n   void addVertex(long version, IVertex vertex);\n   /** 向图中添加edge，并指定其版本id */\n   void addEdge(long version, IEdge edge);\n\n   }\n\n\n}\n\npublic interface IncVertexCentricComputeFunction extends\n        IncVertexCentricFunction {\n\n    void init(IncGraphComputeContext incGraphContext);\n\n    interface IncGraphComputeContext extends IncGraphContext {\n        void collect(IVertex vertex);\n    }\n\n}\n```\n\n### 示例\n\n```java\npublic class IncrGraphCompute {\n\n   private static final Logger LOGGER = LoggerFactory.getLogger(IncrGraphCompute.class);\n\n   public static void main(String[] args) {\n      Environment environment = EnvironmentFactory.onLocalEnvironment();\n      IPipelineResult result = submit(environment);\n      result.get();\n      environment.shutdown();\n   }\n\n该段落包含了多个接口的定义，包括`GraphSnapShot`和`MutableGraph`接口，以及`IncVertexCentricComputeFunction`接口的声明，后者继承自`IncVertexCentricFunction`接口。从文档结构来看，这部分主要涉及增量图计算的相关接口，提供了图数据的快照管理和可变图的操作方法，紧接着是关于增量图计算的示例代码。"
            },
            {
                "content": "public static IPipelineResult submit(Environment environment) {\n      final Pipeline pipeline = PipelineFactory.buildPipeline(environment);\n      final String graphName = \"graph_view_name\";\n      GraphViewDesc graphViewDesc = GraphViewBuilder.createGraphView(graphName)\n              .withShardNum(4)\n              .withBackend(BackendType.RocksDB)\n              .withSchema(new GraphMetaType(IntegerType.INSTANCE, ValueVertex.class, Integer.class, ValueEdge.class, IntegerType.class))\n              .build();\n      pipeline.withView(graphName, graphViewDesc);\n      pipeline.submit(new PipelineTask() {\n         @Override\n         public void execute(IPipelineTaskContext pipelineTaskCxt) {\n            Configuration conf = pipelineTaskCxt.getConfig();\n            PWindowSource> vertices =\n                    // extract vertex from edge file\n                    pipelineTaskCxt.buildSource(new RecoverableFileSource<>(\"data/input/email_edge\",\n                            line -> {\n\n该代码块位于文档的静态图计算部分，具体是在提交图计算任务的过程中。它展示了如何构建一个新的图视图，包括设置分片数量、后端类型和图的模式，然后将其注册到管道中。此代码块是用于环境初始化和图视图配置的重要步骤。"
            },
            {
                "content": ".build();\n      pipeline.withView(graphName, graphViewDesc);\n      pipeline.submit(new PipelineTask() {\n         @Override\n         public void execute(IPipelineTaskContext pipelineTaskCxt) {\n            Configuration conf = pipelineTaskCxt.getConfig();\n            PWindowSource> vertices =\n                    // extract vertex from edge file\n                    pipelineTaskCxt.buildSource(new RecoverableFileSource<>(\"data/input/email_edge\",\n                            line -> {\n                               String[] fields = line.split(\",\");\n                               IVertex vertex1 = new ValueVertex<>(\n                                       Integer.valueOf(fields[0]), 1);\n                               IVertex vertex2 = new ValueVertex<>(\n                                       Integer.valueOf(fields[1]), 1);\n                               return Arrays.asList(vertex1, vertex2);\n                            }), SizeTumblingWindow.of(10000));\n\n该段落位于“动态图”部分的“示例”代码中，具体是在构建一个图计算的管道时，设置了图的视图并提交了一个管道任务。在这个任务中，代码从边文件中提取顶点信息，并将其用于后续的增量图计算，实现了对图数据的读取和处理。"
            },
            {
                "content": "PWindowSource> edges =\n                    pipelineTaskCxt.buildSource( new RecoverableFileSource<>(\"data/input/email_edge\",\n                            line -> {\n                               String[] fields = line.split(\",\");\n                               IEdge edge = new ValueEdge<>(Integer.valueOf(fields[0]),\n                                       Integer.valueOf(fields[1]), 1);\n                               return Collections.singletonList(edge);\n                            }), SizeTumblingWindow.of(5000));\n\n            PGraphView fundGraphView = pipelineTaskCxt.getGraphView(graphName);\n\n该代码块位于静态图计算的示例部分中，具体负责构建图的边数据源。它使用`RecoverableFileSource`读取“data/input/email_edge”文件，并将解析出的每一条边生成`ValueEdge`对象，随后将其传递给图视图`fundGraphView`进行后续计算。该部分主要演示如何从输入文件中提取图的边信息，以便后续的图算法执行。"
            },
            {
                "content": "PGraphView fundGraphView = pipelineTaskCxt.getGraphView(graphName);\n\n            PIncGraphView incGraphView = fundGraphView.appendGraph(vertices, edges);\n            incGraphView.incrementalCompute(new IncGraphAlgorithms(3))\n                    .getVertices()\n                    .map(v -> String.format(\"%s,%s\", v.getId(), v.getValue()))\n                    .sink(v -> {\n                       LOGGER.info(\"result: {}\", v);\n                    });\n         }\n      });\n      return pipeline.execute();\n   }\n\n\n   public static class IncGraphAlgorithms extends IncVertexCentricCompute {\n      public IncGraphAlgorithms(long iterations) {\n         super(iterations);\n      }\n\n      @Override\n      public IncVertexCentricComputeFunction getIncComputeFunction() {\n         return new IncVertexCentricComputeFunction() {\n            private IncGraphComputeContext graphContext;\n\n该代码块位于“动态图”部分的示例中，展示了如何在增量图计算环境中创建并提交增量计算的操作。具体实现中，首先获取图视图，然后追加顶点和边，接着调用增量计算算法并处理计算结果，最终输出每个顶点的ID及其值。"
            },
            {
                "content": "@Override\n      public IncVertexCentricComputeFunction getIncComputeFunction() {\n         return new IncVertexCentricComputeFunction() {\n            private IncGraphComputeContext graphContext;\n\n            @Override\n            public void init(IncGraphComputeContext graphContext) {\n               this.graphContext = graphContext;\n            }\n            @Override\n            public void evolve(Integer vertexId,\n                               TemporaryGraph temporaryGraph) {\n               IVertex vertex = temporaryGraph.getVertex();\n               if (vertex != null) {\n                  if (temporaryGraph.getEdges() != null) {\n                     for (IEdge edge : temporaryGraph.getEdges()) {\n                        graphContext.sendMessage(edge.getTargetId(), vertexId);\n                     }\n                  }\n               }\n            }\n\n该代码块位于文档中关于增量图计算的实现部分，具体是在`IncGraphAlgorithms`类的`getIncComputeFunction`方法中。它定义了增量图计算函数的初始化和演化逻辑，特别是在处理图中的顶点和边时如何发送消息给其他顶点的逻辑。"
            },
            {
                "content": "@Override\n            public void compute(Integer vertexId, Iterator messageIterator) {\n               int max = 0;\n               while (messageIterator.hasNext()) {\n                  int value = messageIterator.next();\n                  max = Math.max(max, value);\n               }\n               graphContext.getTemporaryGraph().updateVertexValue(max);\n            }\n\n            @Override\n            public void finish(Integer vertexId, MutableGraph mutableGraph) {\n               IVertex vertex = graphContext.getTemporaryGraph().getVertex();\n               graphContext.collect(vertex);\n            }\n         };\n      }\n      @Override\n      public VertexCentricCombineFunction getCombineFunction() {\n         return null;\n      }\n\n   }\n}\n```\n\n## 静态图\n\n该代码片段位于文档中关于动态图计算的部分，具体是实现了`IncVertexCentricComputeFunction`接口的`compute`和`finish`方法。这些方法负责处理在图计算迭代中接收到的消息，并更新顶点值或完成计算任务，为增量图计算提供具体的逻辑实现。"
            },
            {
                "content": "@Override\n            public void finish(Integer vertexId, MutableGraph mutableGraph) {\n               IVertex vertex = graphContext.getTemporaryGraph().getVertex();\n               graphContext.collect(vertex);\n            }\n         };\n      }\n      @Override\n      public VertexCentricCombineFunction getCombineFunction() {\n         return null;\n      }\n\n   }\n}\n```\n\n## 静态图\n\n### 接口\n| API | 接口说明 | 入参说明 |\n| --- | --- | --- |\n| void init(VertexCentricComputeFuncContext vertexCentricFuncContext) | 迭代计算初始化接口 | vertexCentricFuncContext：静态图计算的上下文，K表示vertex id的类型，VV表示vertex value类型，EV表示edge value类型，M表示发送消息的类型。 |\n| void compute(K vertexId, Iterator messageIterator) | 迭代计算接口 | vertexId：当前计算点的id，其中K表示vertex id的类型。messageIterator：迭代过程中所有发送给当前vertex的消息，其中M表示迭代计算过程中定义的发送消息类型。 |\n| void finish() | 迭代计算完成接口 | 无 |\n表格内容描述：\n\n该表格包含三列，分别是API、接口说明和入参说明。\n\n该代码块位于文档的动态图计算部分，具体是在`IncVertexCentricComputeFunction`接口的实现中，定义了迭代计算完成时的逻辑。紧接着，是静态图计算部分的接口总结，定义了静态图相关的初始化、计算和完成接口及其入参说明。"
            },
            {
                "content": "}\n}\n```\n\n## 静态图\n\n### 接口\n| API | 接口说明 | 入参说明 |\n| --- | --- | --- |\n| void init(VertexCentricComputeFuncContext vertexCentricFuncContext) | 迭代计算初始化接口 | vertexCentricFuncContext：静态图计算的上下文，K表示vertex id的类型，VV表示vertex value类型，EV表示edge value类型，M表示发送消息的类型。 |\n| void compute(K vertexId, Iterator messageIterator) | 迭代计算接口 | vertexId：当前计算点的id，其中K表示vertex id的类型。messageIterator：迭代过程中所有发送给当前vertex的消息，其中M表示迭代计算过程中定义的发送消息类型。 |\n| void finish() | 迭代计算完成接口 | 无 |\n表格内容描述：\n\n该表格包含三列，分别是API、接口说明和入参说明。\n\n1. 第一行描述了“void init(VertexCentricComputeFuncContext vertexCentricFuncContext)”这一API，说明其功能为迭代计算初始化接口。入参说明中提到，`vertexCentricFuncContext`是静态图计算的上下文，K表示顶点ID的类型，VV表示顶点值的类型，EV表示边值的类型，而M则是发送消息的类型。\n  \n2. 第二行描述了“void compute(K vertexId, Iterator messageIterator)”这一API，说明其功能为迭代计算接口。入参说明中指出，`vertexId`是当前计算点的ID，其类型为K；`messageIterator`则是在迭代过程中所有发送给当前顶点的消息，其中M表示定义的发送消息类型。\n\n3. 第三行描述了“void finish()”这一API，说明其功能为迭代计算完成接口，且无入参。\n\n总体来看，该表格详细介绍了用于迭代计算的三个API，包括初始化计算、执行计算和完成计算的相关信息，提供了各个API的功能和参数要求，有助于理解静态图计算的流程及其上下文。\n\n\n- 详细接口\n\n该段落位于文档的“静态图”部分，具体介绍了静态图计算的相关接口，包括API功能说明和入参要求，旨在帮助用户理解静态图的初始化、计算及完成流程。"
            },
            {
                "content": "1. 第一行描述了“void init(VertexCentricComputeFuncContext vertexCentricFuncContext)”这一API，说明其功能为迭代计算初始化接口。入参说明中提到，`vertexCentricFuncContext`是静态图计算的上下文，K表示顶点ID的类型，VV表示顶点值的类型，EV表示边值的类型，而M则是发送消息的类型。\n  \n2. 第二行描述了“void compute(K vertexId, Iterator messageIterator)”这一API，说明其功能为迭代计算接口。入参说明中指出，`vertexId`是当前计算点的ID，其类型为K；`messageIterator`则是在迭代过程中所有发送给当前顶点的消息，其中M表示定义的发送消息类型。\n\n3. 第三行描述了“void finish()”这一API，说明其功能为迭代计算完成接口，且无入参。\n\n总体来看，该表格详细介绍了用于迭代计算的三个API，包括初始化计算、执行计算和完成计算的相关信息，提供了各个API的功能和参数要求，有助于理解静态图计算的流程及其上下文。\n\n\n- 详细接口\n\n```java\npublic interface VertexCentricComputeFunction extends VertexCentricFunction {\n\n    void init(VertexCentricComputeFuncContext vertexCentricFuncContext);\n\n    void compute(K vertex, Iterator messageIterator);\n\n    void finish();\n\n    interface VertexCentricComputeFuncContext extends VertexCentricFuncContext {\n    \t/** 设置vertex value */\n        void setNewVertexValue(VV value);\n\n    }\n\n}\n```\n\n### 示例\n\n该段落位于文档中的静态图部分，详细描述了静态图计算的三个主要API接口，包括初始化、迭代计算和完成计算的功能与入参说明。此外，还提供了接口的详细定义和示例代码，帮助用户理解静态图计算的工作原理和实现方式。"
            },
            {
                "content": "总体来看，该表格详细介绍了用于迭代计算的三个API，包括初始化计算、执行计算和完成计算的相关信息，提供了各个API的功能和参数要求，有助于理解静态图计算的流程及其上下文。\n\n\n- 详细接口\n\n```java\npublic interface VertexCentricComputeFunction extends VertexCentricFunction {\n\n    void init(VertexCentricComputeFuncContext vertexCentricFuncContext);\n\n    void compute(K vertex, Iterator messageIterator);\n\n    void finish();\n\n    interface VertexCentricComputeFuncContext extends VertexCentricFuncContext {\n    \t/** 设置vertex value */\n        void setNewVertexValue(VV value);\n\n    }\n\n}\n```\n\n### 示例\n\n```java\npublic class StaticsGraphCompute {\n    \n    public static void main(String[] args) {\n      \tEnvironment environment = EnvironmentFactory.onLocalEnvironment();\n        IPipelineResult result = submit(environment);\n        result.get();\n        environment.shutdown();\n    }\n\n    public static IPipelineResult submit(Environment environment) {\n        Pipeline pipeline = PipelineFactory.buildPipeline(environment);\n\n该段内容位于文档的静态图部分，详细介绍了用于迭代计算的三个API及其功能，包括初始化、执行和完成计算的相关信息，并附有相关接口的详细定义和示例代码，旨在帮助读者理解静态图计算的流程及其上下文。"
            },
            {
                "content": "}\n\n}\n```\n\n### 示例\n\n```java\npublic class StaticsGraphCompute {\n    \n    public static void main(String[] args) {\n      \tEnvironment environment = EnvironmentFactory.onLocalEnvironment();\n        IPipelineResult result = submit(environment);\n        result.get();\n        environment.shutdown();\n    }\n\n    public static IPipelineResult submit(Environment environment) {\n        Pipeline pipeline = PipelineFactory.buildPipeline(environment);\n\n        pipeline.submit((PipelineTask) pipelineTaskCxt -> {\n            PWindowSource> prVertices =\n                pipelineTaskCxt.buildSource(new FileSource<>(\"data/input/email_vertex\",\n                    line -> {\n                        String[] fields = line.split(\",\");\n                        IVertex vertex = new ValueVertex<>(\n                            Integer.valueOf(fields[0]), Integer.valueOf(fields[1]));\n                        return Collections.singletonList(vertex);\n                    }), AllWindow.getInstance())\n                    .withParallelism(2);\n\n该代码片段位于文档的静态图计算部分，展示了静态图计算的示例实现，包括顶点和边的读取、图的构建以及计算算法的执行。该部分主要围绕`StaticsGraphCompute`类的定义，讲解如何在静态图环境中进行数据处理与计算。"
            },
            {
                "content": "PWindowSource> prEdges = pipelineTaskCxt.buildSource(new FileSource<>(\n                \"data/input/email_edge\", line -> {\n                String[] fields = line.split(\",\");\n                IEdge edge = new ValueEdge<>(Integer.valueOf(fields[0]), Integer.valueOf(fields[1]), 1);\n                return Collections.singletonList(edge);\n            }), AllWindow.getInstance()).withParallelism(2);\n\n该代码块位于“静态图”部分的示例代码中，具体是在`submit`方法内，负责构建边数据源`prEdges`，从指定的文件中读取边数据并创建`IEdge`对象，随后为图计算提供必要的边信息。"
            },
            {
                "content": "GraphViewDesc graphViewDesc = GraphViewBuilder\n                .createGraphView(GraphViewBuilder.DEFAULT_GRAPH)\n                .withShardNum(2)\n                .withBackend(BackendType.Memory)\n                .build();\n            \n            PGraphWindow graphWindow =\n                pipelineTaskCxt.buildWindowStreamGraph(prVertices, prEdges, graphViewDesc);\n            graphWindow.compute(new SSSPAlgorithm(1, 10))\n                .compute(2)\n                .getVertices()\n                .sink(v -> {});\n        });\n        return pipeline.execute();\n    }\n    \n    public static class SSSPAlgorithm extends VertexCentricCompute {\n\n        private final int srcId;\n        public SSSPAlgorithm(int srcId, long iterations) {\n            super(iterations);\n            this.srcId = srcId;\n        }\n\n该代码块位于文档的“静态图”示例部分，主要展示如何构建一个图视图（`GraphViewDesc`）并创建一个图窗口（`PGraphWindow`），接着使用`SSSPAlgorithm`（单源最短路径算法）对图进行计算，最后执行计算并获取顶点结果。"
            },
            {
                "content": "private final int srcId;\n        public SSSPAlgorithm(int srcId, long iterations) {\n            super(iterations);\n            this.srcId = srcId;\n        }\n\n        @Override\n        public VertexCentricComputeFunction getComputeFunction() {\n            return new VertexCentricComputeFunction() {\n                \n                private VertexCentricComputeFuncContext context;\n                @Override\n                public void init(VertexCentricComputeFuncContext vertexCentricFuncContext) {\n                    this.context = vertexCentricFuncContext;\n                }\n\n该代码块位于\"静态图\"部分的\"SSSPAlgorithm\"类中，定义了单源最短路径算法的构造函数和计算函数的初始化方法。"
            },
            {
                "content": "@Override\n                public void compute(Integer vertex, Iterator messageIterator) {\n                    int minDistance = vertex == srcId ? 0 : Integer.MAX_VALUE;\n                    if (messageIterator != null) {\n                        while (messageIterator.hasNext()) {\n                            Integer value = messageIterator.next();\n                            minDistance = Math.min(minDistance, value);\n                        }\n                    }\n                    IVertex iVertex = this.context.vertex().get();\n                    if (minDistance < iVertex.getValue()) {\n                        this.context.setNewVertexValue(minDistance);\n                        for (IEdge edge : this.context.edges().getOutEdges()) {\n                            this.context.sendMessage(edge.getTargetId(), minDistance + edge.getValue());\n                        }\n                    }\n                }\n                @Override\n                public void finish() {\n\n该代码块位于文档中的“静态图”部分，具体是在介绍算法实现中的`SSSPAlgorithm`类的`compute`方法，主要用于计算图中最短路径的逻辑，包括处理传入的消息和更新当前顶点的值。同时，块后续还有一个`finish`方法的定义。"
            },
            {
                "content": "if (minDistance < iVertex.getValue()) {\n                        this.context.setNewVertexValue(minDistance);\n                        for (IEdge edge : this.context.edges().getOutEdges()) {\n                            this.context.sendMessage(edge.getTargetId(), minDistance + edge.getValue());\n                        }\n                    }\n                }\n                @Override\n                public void finish() {\n                    \n                }\n            };\n        }\n        @Override\n        public VertexCentricCombineFunction getCombineFunction() {\n            return null;\n        }\n    }\n}\n```\n\n该代码块位于文档的静态图计算部分，具体是在`SSSPAlgorithm`类的`compute`方法中。代码逻辑用于计算最短路径，在每次迭代中检查当前顶点的最短距离是否小于已存储的值，如果是，则更新顶点的值并向相邻边发送更新后的距离信息。该段代码展示了如何在图计算中实现松弛操作，是一个经典的图算法实现示例。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_147.md",
        "chunks": [
            {
                "content": "# Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升10倍！\n\n最近，TuGraph团队开展了一项令人振奋的优化工作，成功将Antlr4 C++ target的并发性能提升超过10倍！这一优化方案已被Antlr4开源社区热情接纳，将给全球的Antlr C++生态开发者带来更好的使用体验。PR地址：[https://github.com/antlr/antlr4/pull/4237](https://github.com/antlr/antlr4/pull/4237)\n\n图查询引擎是一种用于查询图数据库的工具，它使用特定的查询语言（如Cypher或ISO GQL）来执行和操作图数据库。这些查询语言允许用户描述图模式并查询图数据，例如查找特定节点或查找节点之间的路径。\n\n## 关于Antlr4\n\nAntlr4是一款备受欢迎的开源解析器生成器，能够根据语法规则快速生成自定义解析器。其支持LL(*)解析，拥有更强大的错误处理能力和更快的解析速度。不仅如此，Antlr4还支持Java、Python、C++、JavaScript、Go等10种目标语言，广泛应用于多种开发语言生态中。简单易用的API和文档使得开发人员能够快速上手。无论是编程语言、数据格式、编译器还是解释器等领域，Antlr4都发挥着重要作用。\n\n著名的开源项目如Apache Spark、Eclipse IDE和MongoDB等都选择了Antlr4。对于语言工具开发者而言，Antlr4是不可或缺的工具，能大幅提高开发效率和代码质量。\n\n## 当TuGraph遇见Antlr4\n\nISO GQL（ISO/IEC 39075）是一种标准化的图数据库查询语言，蚂蚁集团是其主要贡献者之一。因此，Antlr4作为一种强大的解析器生成器，成为了蚂蚁图数据库TuGraph生成GQL解释器的理想选择。Antlr4能够帮助团队更快、更准确地构建图数据库的查询语言，从而提高产品性能和用户体验。\n\n然而，当我们从开发场景来到生产场景，超高的并发量带来一个严重问题：Antlr4 C++ target的并发性能不足以支持所需的超高并发GQL请求。经过调研并与Antlr开源社区讨论，我们发现并发性能这个问题普遍存在，并且在过去5年中持续困扰着C++生态的开发者。我们决定解决这个问题。\n\n## 我们做了哪些工作\n\n该文本块介绍了TuGraph团队在Antlr4开源社区中的重要贡献，即成功优化C++ Target的并发性能，提升超过10倍。块中还简要概述了Antlr4的背景及其在图数据库查询中的应用与意义，接着提到团队面临的并发性能挑战，以及为何决定进行优化工作，作为后续具体优化措施的引入。"
            },
            {
                "content": "著名的开源项目如Apache Spark、Eclipse IDE和MongoDB等都选择了Antlr4。对于语言工具开发者而言，Antlr4是不可或缺的工具，能大幅提高开发效率和代码质量。\n\n## 当TuGraph遇见Antlr4\n\nISO GQL（ISO/IEC 39075）是一种标准化的图数据库查询语言，蚂蚁集团是其主要贡献者之一。因此，Antlr4作为一种强大的解析器生成器，成为了蚂蚁图数据库TuGraph生成GQL解释器的理想选择。Antlr4能够帮助团队更快、更准确地构建图数据库的查询语言，从而提高产品性能和用户体验。\n\n然而，当我们从开发场景来到生产场景，超高的并发量带来一个严重问题：Antlr4 C++ target的并发性能不足以支持所需的超高并发GQL请求。经过调研并与Antlr开源社区讨论，我们发现并发性能这个问题普遍存在，并且在过去5年中持续困扰着C++生态的开发者。我们决定解决这个问题。\n\n## 我们做了哪些工作\n\n在调研讨论的过程中我们发现，多位开发者在论坛提出其耗时甚至多于Java target数倍之多，见文末参考【1，2，3，4】。因此，我们决定从问题和开源代码出发，来定位、解决问题。\n\n这是一个典型的并发程序优化问题，根据以往的程序优化经验，我们分步推进该问题的解决：\n\n1. **识别问题**\n\n   通过对程序运行时的性能数据进行收集和分析，我们找到了程序运行瓶颈所在，通过调用分析，初步将问题定位为数据竞争导致的并发问题。\n\n2. **深入阅读Antlr4开源代码**\n\n   接下来，我们对Antlr4的源代码进行仔细的阅读和理解，掌握其内部的结构和核心逻辑，找出了核心的数据结构和关键的调用链路。为我们破解性能难题和分析修改的正确性做好了准备。\n\n3. **梳理数据竞争链路**\n\n   根据上述分析，我们判断问题的症结极大概率是数据竞争造成的。形成数据竞争至少有两个条件：一是线程之间共享内存数据，二是至少存在两个线程去读写某个共享内存。\n\n   进一步地，我们通过分析程序中的并发访问情况，找到了可能引发数据竞争的所有代码段和共享变量（主要为DFA、ATN等结构），拼接出了数据竞争的完整链路。\n\n4. **破解数据竞争问题**\n\n该段落介绍了Antlr4作为一个重要的开源解析器生成器，在图数据库领域的应用，特别是与TuGraph项目结合的背景。同时，强调了在高并发请求下，Antlr4 C++ target的性能问题以及TuGraph团队为解决这一问题所做的深入调研和优化工作。这为后续关于具体优化措施的讨论奠定了基础。"
            },
            {
                "content": "这是一个典型的并发程序优化问题，根据以往的程序优化经验，我们分步推进该问题的解决：\n\n1. **识别问题**\n\n   通过对程序运行时的性能数据进行收集和分析，我们找到了程序运行瓶颈所在，通过调用分析，初步将问题定位为数据竞争导致的并发问题。\n\n2. **深入阅读Antlr4开源代码**\n\n   接下来，我们对Antlr4的源代码进行仔细的阅读和理解，掌握其内部的结构和核心逻辑，找出了核心的数据结构和关键的调用链路。为我们破解性能难题和分析修改的正确性做好了准备。\n\n3. **梳理数据竞争链路**\n\n   根据上述分析，我们判断问题的症结极大概率是数据竞争造成的。形成数据竞争至少有两个条件：一是线程之间共享内存数据，二是至少存在两个线程去读写某个共享内存。\n\n   进一步地，我们通过分析程序中的并发访问情况，找到了可能引发数据竞争的所有代码段和共享变量（主要为DFA、ATN等结构），拼接出了数据竞争的完整链路。\n\n4. **破解数据竞争问题**\n\n   数据竞争问题是多线程程序中常见而又复杂的问题，可以考虑通过破解多种竞争条件来解决。就本文问题来说，也存在多种破解方案选择，如何制定最优的解决方案是一项极具挑战的工作，主要难点有两个：\n\n   - 保证修改后程序的正确性/稳定性\n   - 保证方案的有效性（低成本）\n\n   反复推演后，我们选择了提交给社区的优化方案（PR地址见参考【6】），即通过改变关键数据的ownership接触对锁的依赖。针对上述两个难点的分析如下：\n\n   经过源码分析并与开源社区讨论，我们确认关键数据结构的初始化构建是非常耗时的，但可以通过“只调用一次”（`call_once`）手段将成本均摊，而后续的增量构建相对开销较低，并且也可均摊。因此该优化方案的低时间成本是可以保证的。\n\n   关于程序正确性的保证，我们通过双重验证来保证。首先在设计之初我们已经从源代码角度，推断出共享数据仍然是安全的，其次我们也设计了实验对此进行了验证，验证结果与我们的分析一致（见下图）。\n\n## 贡献和成果\n\n优化的效果十分显著，32线程的并发性能提升超过18倍，如下图所示（16核心CPU测试平台，性能测试代码仓库见【5】）。考虑到实际生产服务器性能远高于测试机型，实际的性能提升效果将比测试结果更高，优化后GQL解析能力已能完全满足企业业务的需要。\n\n## 充满收获的社区互动\n\n该文本块详细描述了TuGraph团队在优化Antlr4 C++ target并发性能过程中所采取的具体步骤和方法，包括问题识别、代码分析、数据竞争链路梳理及解决方案制定，最终展示了优化成果和社区互动的经验。这部分内容位于文章的“我们做了哪些工作”章节，紧接在对并发性能问题的背景介绍之后。"
            },
            {
                "content": "- 保证修改后程序的正确性/稳定性\n   - 保证方案的有效性（低成本）\n\n   反复推演后，我们选择了提交给社区的优化方案（PR地址见参考【6】），即通过改变关键数据的ownership接触对锁的依赖。针对上述两个难点的分析如下：\n\n   经过源码分析并与开源社区讨论，我们确认关键数据结构的初始化构建是非常耗时的，但可以通过“只调用一次”（`call_once`）手段将成本均摊，而后续的增量构建相对开销较低，并且也可均摊。因此该优化方案的低时间成本是可以保证的。\n\n   关于程序正确性的保证，我们通过双重验证来保证。首先在设计之初我们已经从源代码角度，推断出共享数据仍然是安全的，其次我们也设计了实验对此进行了验证，验证结果与我们的分析一致（见下图）。\n\n## 贡献和成果\n\n优化的效果十分显著，32线程的并发性能提升超过18倍，如下图所示（16核心CPU测试平台，性能测试代码仓库见【5】）。考虑到实际生产服务器性能远高于测试机型，实际的性能提升效果将比测试结果更高，优化后GQL解析能力已能完全满足企业业务的需要。\n\n## 充满收获的社区互动\n\n提案的互动过程曲折也充满乐趣。当涉及到多线程代码的修改时，官方开发团队会格外谨慎，因为这涉及到系统的稳定性和性能。他们会进行仔细的测试和评估，确保修改不会引入新的问题或降低系统的性能。为此社区引入了多达7名评审专家（一般提案的评审人多为1~2人），长达60多次的反复讨论不仅是评审专家理解提案的过程，也让我们了解了很多Antlr4代码背后深层的设计理念，可以更好地利用它来构建高性能、可维护的语法分析器。\n\n通过此项优化工作，我们收获了更多与其他社区贡献者协作的经验，多位Antlr4社区成员也对TuGraph团队的工作表达了感谢，Antlr4负责人评价该提案为“一个重大的贡献”（a major contribution）。\n\n## 参考文献\n\n该块内容位于文档的中部，主要讨论TuGraph团队在优化Antlr4 C++目标并发性能过程中的关键挑战，包括如何确保程序的正确性与稳定性，以及保证方案的有效性。接着，描述了优化的显著效果和与开源社区的互动与合作，强调了该优化工作对Antlr4项目的重要贡献。"
            },
            {
                "content": "## 充满收获的社区互动\n\n提案的互动过程曲折也充满乐趣。当涉及到多线程代码的修改时，官方开发团队会格外谨慎，因为这涉及到系统的稳定性和性能。他们会进行仔细的测试和评估，确保修改不会引入新的问题或降低系统的性能。为此社区引入了多达7名评审专家（一般提案的评审人多为1~2人），长达60多次的反复讨论不仅是评审专家理解提案的过程，也让我们了解了很多Antlr4代码背后深层的设计理念，可以更好地利用它来构建高性能、可维护的语法分析器。\n\n通过此项优化工作，我们收获了更多与其他社区贡献者协作的经验，多位Antlr4社区成员也对TuGraph团队的工作表达了感谢，Antlr4负责人评价该提案为“一个重大的贡献”（a major contribution）。\n\n## 参考文献\n\n- 【1】[antlr4 doesn't scale on a computer with 8 or more cores](https://github.com/antlr/antlr4/issues/2454)\n- 【2】[Parsing with C++ target 5x slower than Java](https://github.com/antlr/antlr4/issues/2584)\n- 【3】[Performance Issues Running Cpp Runtime on Many Threads](https://github.com/antlr/antlr4/issues/3938)\n- 【4】[Why the C++ target is 6X slower than the Java target](https://stackoverflow.com/questions/52528982/why-the-c-target-is-6x-slower-than-the-java-target)\n- 【5】[The test repo](https://github.com/wangtao9/antlr4-perfopt-test)\n- 【6】[Optimize the concurrent performance of Cpp target by more than 10 times](https://github.com/antlr/antlr4/pull/4237)\n\n欢迎关注TuGraph！\n\n这段内容主要描述了TuGraph团队在优化Antlr4 C++目标的并发性能过程中，与Antlr4社区的互动和合作。强调了在多线程代码修改中的谨慎性，评审过程的复杂性，以及最终获得的肯定与感谢，突出团队之间的协作和贡献的重要性。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_148.md",
        "chunks": [
            {
                "content": "# 推动图数据库查询语言标准化进程，TuGraph 开源 ISO GQL Antlr4 语法文件\n\nTuGraph 团队开源了基于最新的图数据库标准查询语言 ISO GQL（草案）实现的 Antlr4 语法文件，并对表达式等语法定义进行了大量重构，大幅提升了 Antlr4 解析阶段的性能。使用者可以通过 Antlr4 快速接入到现有的图数据库产品之中，快速适配和体验 ISO GQL 最新的语法能力。\n\nGitHub代码仓库：[https://github.com/TuGraph-family/gql-grammar](https://github.com/TuGraph-family/gql-grammar)\n\n在图数据库领域，通常使用 Antlr4 将不同开发语言的语法结构映射到图数据库中的节点和边，转化为图数据。我们基于2023年3月版本草案中的语法规范，编写了 ISO GQL 的 Antlr4 语法文件，并进行了大量的优化工作，提高了 Antlr4 解析 ISO GQL 语句的性能。Antlr4已在蚂蚁集团内部系统和业务中实际投入使用，平均可以提升解析速度数十倍，在一些复杂查询语句场景下，甚至可以提升至上百倍。\n\n为了降低现有的图数据库快速接入图数据库标准查询语言 ISO GQL 的门槛，推进共建 ISO GQL 标准化的进程，TuGraph 团队于近期开源了最新版本 ISO GQL（2023.3版本）的 Antlr4 语法文件。现有的图数据库及其他系统能以此开源语法文件为基础，更快、更准确地在查询引擎中增加对 ISO GQL 语句的解析与支持。我们期待越来越多的图数据库接入 ISO GQL，共同促进图数据库查询语言的应用与发展。\n\n未来，我们会持续跟进 ISO GQL 的发展，及时更新迭代我们的语法文件，发布更多关于 ISO GQL 的实际使用案例和文档，推动 ISO GQL 在更多产品和业务场景中的使用。\n\n## 关于 Antlr4\n\n该文档主要介绍了TuGraph团队开源的基于ISO GQL标准查询语言的Antlr4语法文件，强调了其性能优化和在图数据库中的应用。文中还提到ISO GQL作为一种新兴的标准化图数据库查询语言，和Antlr4的相关特性，为推动图数据库查询语言标准化进程提供支持。"
            },
            {
                "content": "为了降低现有的图数据库快速接入图数据库标准查询语言 ISO GQL 的门槛，推进共建 ISO GQL 标准化的进程，TuGraph 团队于近期开源了最新版本 ISO GQL（2023.3版本）的 Antlr4 语法文件。现有的图数据库及其他系统能以此开源语法文件为基础，更快、更准确地在查询引擎中增加对 ISO GQL 语句的解析与支持。我们期待越来越多的图数据库接入 ISO GQL，共同促进图数据库查询语言的应用与发展。\n\n未来，我们会持续跟进 ISO GQL 的发展，及时更新迭代我们的语法文件，发布更多关于 ISO GQL 的实际使用案例和文档，推动 ISO GQL 在更多产品和业务场景中的使用。\n\n## 关于 Antlr4\n\nAntlr4 是一款备受欢迎的语法分析器生成工具，能够根据语法规则快速生成自定义解析器。其支持 LL(*) 解析，拥有更强大的错误处理能力和更快的解析速度。不仅如此，Antlr4 还支持 Java、Python、C++、JavaScript、Go 等10种目标语言，广泛应用于多种开发语言生态中。简单易用的 API 和文档使得开发人员能够快速上手。无论是编程语言、数据格式、编译器还是解释器等领域，Antlr4 都发挥着重要作用。著名的开源项目如 Apache Spark、Eclipse IDE 和 MongoDB 等都使用了 Antlr4 进行语法分析。\n\n## 关于ISO GQL\n\nISO GQL（ISO/IEC 39075）是一种标准化的图数据库查询语言，由监管 SQL 标准的同一个国际工作组开发和维护，同时也是自 SQL 之后的第一个 ISO/IEC 国际标准数据库语言项目。ISO GQL 图查询语言将结构化数据建模为图，并在图数据库或其他图存储中存储、查询和修改这些数据。目前 ISO GQL 处于草案阶段，蚂蚁集团也是其主要贡献者之一。\n\n该文档主要介绍了TuGraph团队开源的基于ISO GQL标准的Antlr4语法文件，包括其性能优化及应用前景。文中提到为了降低图数据库接入ISO GQL的门槛，TuGraph团队发布了最新版本的Antlr4语法文件，并期待更多图数据库能接入ISO GQL，促进标准化进程。随后，文档详细介绍了Antlr4工具的特点以及ISO GQL的背景和发展。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_149.md",
        "chunks": [
            {
                "content": "# 演讲回顾｜TuGraph-DB兼容Neo4j客户端：Bolt 协议设计与实现\n\n今天要和大家分享的是关于TuGraph-DB近期新添加的一个功能——兼容Neo4j客户端。这个兼容性工作本质上是实现了Neo4j客户端与服务器之间的通讯协议，即Bolt协议。首先介绍下Bolt协议的基本情况，之后阐述下我们是如何实现这一协议的，然后展示下使用Bolt协议客户端连接TuGraph-DB的效果，最后会说明下目前还有哪些功能尚未实现。\n\n## 背景\n\nBolt协议是在Neo4j 3.0版本中引入的，时间大约是2016年。在此之前，Neo4j使用的通讯方式主要是HTTP和WebSocket。自从引入Bolt协议后，已经过去了7到8年，目前它已经成为了Neo4j应用与服务器之间通信的首选方式。\n\nBolt协议在设计上具有以下几个特点：首先，它是二进制的，与之对应的HTTP协议是基于文本的；其次，Bolt协议支持事务、会话以及集群模式，并且提供了用户身份验证和数据加密功能；最后，Bolt协议中所有的数据传输都是基于流式传输的。\n\nTuGraph-DB的客户端也经历了不断的演进和发展。最初我们仅支持HTTP方式，后来开发了自己的RPC客户端，现在我们开始支持兼容Neo4j的客户端。\n\n兼容Neo4j客户端的最大好处在于生态系统的兼容。单就客户端而言，Neo4j官方开发了五种语言的客户端，加上社区开发的两种，总共有七种语言的客户端可供使用。这些客户端可以直接拿来使用，同时还有一些对接上下游生态系统的组件，比如访问Apache Spark或Apache Kafka，这些都有现成的代码。此外，还有一些开源项目，比如DataX，对Neo4j的适配的代码也是现成的。另外，还有一些编程框架相关的，特别是在Java领域，例如OGM、Spring等开发框架，这些相关的代码也无需重写，可以直接使用。这样就节约了大量的研发资源，周围组件直接用生态内的，我们可以将更多精力投入到数据库自身能力的提升上去。\n\n## Bolt协议介绍\n\n该文档主要回顾了TuGraph-DB新增的兼容Neo4j客户端功能，重点介绍了Bolt协议的设计与实现。文档首先概述了Bolt协议的背景、特点以及其在Neo4j生态系统中的重要性，接着深入探讨了Bolt协议的结构，包括数据编解码、消息类型和服务端状态，并最终提及了在TuGraph-DB中实现Bolt协议的具体过程和当前的兼容性问题。"
            },
            {
                "content": "TuGraph-DB的客户端也经历了不断的演进和发展。最初我们仅支持HTTP方式，后来开发了自己的RPC客户端，现在我们开始支持兼容Neo4j的客户端。\n\n兼容Neo4j客户端的最大好处在于生态系统的兼容。单就客户端而言，Neo4j官方开发了五种语言的客户端，加上社区开发的两种，总共有七种语言的客户端可供使用。这些客户端可以直接拿来使用，同时还有一些对接上下游生态系统的组件，比如访问Apache Spark或Apache Kafka，这些都有现成的代码。此外，还有一些开源项目，比如DataX，对Neo4j的适配的代码也是现成的。另外，还有一些编程框架相关的，特别是在Java领域，例如OGM、Spring等开发框架，这些相关的代码也无需重写，可以直接使用。这样就节约了大量的研发资源，周围组件直接用生态内的，我们可以将更多精力投入到数据库自身能力的提升上去。\n\n## Bolt协议介绍\n\nBolt协议主要由三大部分构成。首先是数据结构的编码和解码，它作为一种通信协议，核心功能就是数据传输。传输过程中，数据首先需要被编码，然后在网络上进行传输，接收端再对数据进行解码。其次是消息类型，这个比较常规，每个通讯协议都会定义自己的消息类型集合，主要用于控制和管理通讯过程。最后是消息处理机制，即以状态机的运作方式来处理Bolt协议中的消息，它不是简单的Ping-Pong模式。\n\n### 数据编解码\n\n在Bolt协议的数据编解码部分，有一个关键词是PackStream。它是Bolt协议中的一种数据序列化方式，源自于MessagePack。MessagePack也是一种数据序列化方案，类似于我们常用的Protobuf。\n\nMessagePack在Redis里面有被使用到，大家都知道Redis是一种内存数据库，它对性能的要求非常高，所以MessagePack有一个特点是序列化和反序列化速度很快。但Bolt协议并没有直接使用MessagePack，而是根据其需求在MessagePack基础上定制了一套名为PackStream的序列化方式。在PackStream序列化方式中，包含几种核心的数据类型，如常用的布尔、整型、浮点型、二进制数组，和类似于字典（dictionary或map structure）的结构体。\n\n这段文字介绍了TuGraph-DB客户端的发展历程，强调了兼容Neo4j客户端带来的生态系统兼容性，以及与Bolt协议相关的基本概念，包括数据编解码与PackStream序列化方式的细节。这部分内容位于演讲回顾的初始段落，旨在阐述TuGraph-DB对于Neo4j客户端兼容性的意义和Bolt协议的结构。"
            },
            {
                "content": "### 数据编解码\n\n在Bolt协议的数据编解码部分，有一个关键词是PackStream。它是Bolt协议中的一种数据序列化方式，源自于MessagePack。MessagePack也是一种数据序列化方案，类似于我们常用的Protobuf。\n\nMessagePack在Redis里面有被使用到，大家都知道Redis是一种内存数据库，它对性能的要求非常高，所以MessagePack有一个特点是序列化和反序列化速度很快。但Bolt协议并没有直接使用MessagePack，而是根据其需求在MessagePack基础上定制了一套名为PackStream的序列化方式。在PackStream序列化方式中，包含几种核心的数据类型，如常用的布尔、整型、浮点型、二进制数组，和类似于字典（dictionary或map structure）的结构体。\n\n由于Bolt协议主要用于传输Cypher查询语句及其响应结果的，所以Cypher的数据类型必然是构建在上述基础数据类型之上的。例如，Cypher数据类型中的节点（Node）、关系（Relationship）和路径（Path），都属于PackStream中的结构体，空间类型和时间类型也是。\n\n左下角的小图解释了PackStream的序列化方式：数据序列化完成后，它的大致结构是。第一个字节表示数据类型，用以标记当前数据是哪种类型。紧接着是size字段，表示数据大小，然后是数据内容本身。这只是一个通用的表示方法，大部分数据序列化后形态都类似，但许多场景下是可以进行优化的。例如，某些数据类型在编码后仅为一个字节，因为它与前面的标识字节合并在一起了。对于一些数值小的整数，如只需一个字节就可以表示的数字，虽然数据类型本身占8个字节，但最终编码完成同样只有一个字节大小，它们的类型和数据本身均被压缩在一个字节中。\n\n### 消息类型\n\nBolt协议中的消息主要分为三大类。第一类是Request消息，这类消息是由客户端发送给服务端的；第二类是Summary消息，这是服务端发给客户端的消息；第三类是Detail消息，目前只有一个Record消息，Record消息就是服务端返回给客户端的一行行数据，接下来简要介绍下每种消息。\n\n该段落位于关于TuGraph-DB兼容Neo4j客户端的演讲回顾中，专门讨论了Bolt协议的数据编解码和消息类型。这部分内容详细介绍了PackStream序列化方式及其核心数据类型，同时分类描述了Bolt协议中的不同消息类型及其功能，为理解TuGraph-DB如何实现与Neo4j客户端的通信提供了技术基础。"
            },
            {
                "content": "左下角的小图解释了PackStream的序列化方式：数据序列化完成后，它的大致结构是。第一个字节表示数据类型，用以标记当前数据是哪种类型。紧接着是size字段，表示数据大小，然后是数据内容本身。这只是一个通用的表示方法，大部分数据序列化后形态都类似，但许多场景下是可以进行优化的。例如，某些数据类型在编码后仅为一个字节，因为它与前面的标识字节合并在一起了。对于一些数值小的整数，如只需一个字节就可以表示的数字，虽然数据类型本身占8个字节，但最终编码完成同样只有一个字节大小，它们的类型和数据本身均被压缩在一个字节中。\n\n### 消息类型\n\nBolt协议中的消息主要分为三大类。第一类是Request消息，这类消息是由客户端发送给服务端的；第二类是Summary消息，这是服务端发给客户端的消息；第三类是Detail消息，目前只有一个Record消息，Record消息就是服务端返回给客户端的一行行数据，接下来简要介绍下每种消息。\n\nHello消息是TCP连接建立后需要发送的第一条消息，它会携带客户端自身的信息，比如客户端是什么语言的，版本号是多少，以及运行平台是什么，还有进行身份验证所需的用户名和密码。Reset消息用于重置会话状态，因为Bolt协议是有会话的，会话就有会话状态，有时候会话会处于失败状态，这时候就需要用Reset消息来复位一下。\n\nRun消息用于执行Cypher查询语句，它携带了查询语句的具体内容。Pull消息是客户端请求服务端拉取数据，一般后面会跟个数字，例如Pull 1000，代表客户端希望拉取1000条数据。服务端接收到这个请求后，会返回不多于1000条数据。如果服务端在返回数据后发现还有更多数据可供返回，它会发送个Success消息，Success消息里面的has_more字段会置1，提示客户端还有更多的数据待发送。客户端收到后会继续发送Pull消息，如此循环，直到服务端返回的Success消息中has_more字段不为1，表示所有数据都拉取完了。Discard消息用于告诉服务端忽略后续特定数量的数据。\n\n在介绍Bolt协议的过程中，此段落详细阐述了PackStream的序列化方式及其数据结构，随后紧接着讨论了Bolt协议中消息类型的分类，包括Request消息、Summary消息和Detail消息，并具体介绍了不同类型消息的用途和功能。这一部分内容是对Bolt协议的核心机制进行深入解读，为理解后续协议实现提供了基础。"
            },
            {
                "content": "Hello消息是TCP连接建立后需要发送的第一条消息，它会携带客户端自身的信息，比如客户端是什么语言的，版本号是多少，以及运行平台是什么，还有进行身份验证所需的用户名和密码。Reset消息用于重置会话状态，因为Bolt协议是有会话的，会话就有会话状态，有时候会话会处于失败状态，这时候就需要用Reset消息来复位一下。\n\nRun消息用于执行Cypher查询语句，它携带了查询语句的具体内容。Pull消息是客户端请求服务端拉取数据，一般后面会跟个数字，例如Pull 1000，代表客户端希望拉取1000条数据。服务端接收到这个请求后，会返回不多于1000条数据。如果服务端在返回数据后发现还有更多数据可供返回，它会发送个Success消息，Success消息里面的has_more字段会置1，提示客户端还有更多的数据待发送。客户端收到后会继续发送Pull消息，如此循环，直到服务端返回的Success消息中has_more字段不为1，表示所有数据都拉取完了。Discard消息用于告诉服务端忽略后续特定数量的数据。\n\nPull和Discard消息可以交替使用，例如客户端可以轮流提取和忽略1000条数据。Begin、Commit和Rollback消息用于显示事务，而Route消息则用于获取集群的路由信息。Goodbye消息用于断开当前的连接。Ignore消息在服务端无法处理任何请求时使用，这时候服务端将回复一个Ignore消息，表示上一个请求没处理，直接丢掉了。Failed消息表示标准的失败响应，而Record消息则用于传输真实数据，例如传输1000行数据时，就会连续发送1000个Record消息给客户端。\n\n### 服务端状态\n\nBolt协议消息是按照状态机的方式进行处理的，状态机就涉及到有哪些状态以及这些状态是怎么转换的。右侧的图表是从官方协议文档中摘录的，描述了状态转换的过程。由于图表较长，只截取了一部分，这里仅简要介绍几个最常用的状态。\n\n首先是Connect状态，这是当TCP连接刚建立后的初始状态。随后，客户端发送Hello消息，一旦服务端处理成功，会话进入Ready状态。如果客户端发送Run消息，即执行Cypher语句，服务端随后会进入Streaming状态，此时会话涉及到数据传输。如果服务端的数据尚未发送完毕，它将持续保持在Streaming状态，直至数据完全发送完成后回到Ready状态。\n\n在本文件中，该段落主要介绍了Bolt协议的消息类型及其处理机制，包括Hello、Reset、Run、Pull、Discard等消息的功能和作用。此外，还阐述了Bolt协议消息的处理方式，特别是服务端的状态机机制，如何通过不同的状态转换来管理会话及数据传输。这部分内容属于Bolt协议的核心功能和交互细节，紧接着前面对Bolt协议的基本介绍和数据结构的讨论。"
            },
            {
                "content": "### 服务端状态\n\nBolt协议消息是按照状态机的方式进行处理的，状态机就涉及到有哪些状态以及这些状态是怎么转换的。右侧的图表是从官方协议文档中摘录的，描述了状态转换的过程。由于图表较长，只截取了一部分，这里仅简要介绍几个最常用的状态。\n\n首先是Connect状态，这是当TCP连接刚建立后的初始状态。随后，客户端发送Hello消息，一旦服务端处理成功，会话进入Ready状态。如果客户端发送Run消息，即执行Cypher语句，服务端随后会进入Streaming状态，此时会话涉及到数据传输。如果服务端的数据尚未发送完毕，它将持续保持在Streaming状态，直至数据完全发送完成后回到Ready状态。\n\nTx_Ready和Tx_Streaming状态是处理显式事务时使用的。其中，Tx Ready是在客户端发送Begin请求开启显式事务后达到的状态；Tx Streaming与上面的Streaming类似，只不过它发生在显式事务中。Failed状态则意味着当前会话处于失败状态，这种情况很容易发生，例如客户端不小心发送了一个有语法错误的Cypher语句，服务端报错后，会话将进入Failed状态。根据协议的状态机规则，在Failed状态下，服务端无法处理任何消息，如果客户端继续发送语句，服务端会直接忽略并回复Ignore消息。为了继续使用当前会话，客户端需要发送Reset消息，以重置失败状态并让会话回到Ready状态，继续提供服务。\n\n\n## 交互举例\n\n以执行一条Cypher语句为例，下面列出了相关的Bolt消息。首先，TCP连接建立后，客户端会发送固定四个字节的数据，这是Bolt协议的标识。紧随其后是发送16个字节的版本号数据，总共4个版本，这是因为Bolt协议存在多个版本。客户端发送支持的版本号给服务端，服务端选择一个共同支持的版本后回复给客户端，这个过程称为版本协商。成功后，客户端和服务端间的通信将在选定的协议版本下进行。\n\n接着客户端发送Hello消息，包含其身份信息以及用户名和密码。服务端验证成功后返回Success消息，并且会提供服务器的信息以及分配的连接ID。然后客户端发送Begin消息来请求开启一个显式事务，其中包括多个参数，如事务模式和数据库名称等。服务端确认后发送Success消息，客户端随后开始发送Run消息执行Cypher查询，并接收由服务端返回的结果。\n\n该段落主要介绍了Bolt协议中服务器状态的处理机制以及相关的状态转换过程，随后通过一个Cypher语句的执行示例详细阐述了客户端与服务器之间的交互流程。这部分内容位于演讲回顾文档中，着重于Bolt协议的工作原理和实际应用示例，承接了前面的协议介绍和数据编解码部分。"
            },
            {
                "content": "## 交互举例\n\n以执行一条Cypher语句为例，下面列出了相关的Bolt消息。首先，TCP连接建立后，客户端会发送固定四个字节的数据，这是Bolt协议的标识。紧随其后是发送16个字节的版本号数据，总共4个版本，这是因为Bolt协议存在多个版本。客户端发送支持的版本号给服务端，服务端选择一个共同支持的版本后回复给客户端，这个过程称为版本协商。成功后，客户端和服务端间的通信将在选定的协议版本下进行。\n\n接着客户端发送Hello消息，包含其身份信息以及用户名和密码。服务端验证成功后返回Success消息，并且会提供服务器的信息以及分配的连接ID。然后客户端发送Begin消息来请求开启一个显式事务，其中包括多个参数，如事务模式和数据库名称等。服务端确认后发送Success消息，客户端随后开始发送Run消息执行Cypher查询，并接收由服务端返回的结果。\n\n这里，客户端请求只读取两条数据，那么服务端接着连续发送两个Record消息。随后服务端发送附带has_more字段的Success消息提醒客户端还有未发送的数据，但是客户端选择发送Discard消息来告诉服务端忽略余下数据并继续处理。\n\n最后，客户端提交事务，如果成功，服务端会返回Success消息。\n\n另一个例子说明了Bolt协议的另一个特性，即pipeline流水式处理。客户端可以连续发送多条Cypher查询语句，而不需要等待前一条语句执行完成。例如，客户端连续发送两条“Run”消息，然后使用Pull消息来指定拉取某个特定查询语句的结果，这需要在消息中明确指出语句的ID，以便服务端知道客户端希望获取哪一条查询的结果，但这也要求服务端也必须具备相应的能力，即在一个会话中可以同时执行多条语句。\n\n## Bolt协议实现\n\n接下来，我将简要描述TuGraph-DB是如何实现Bolt协议的。起初我们当然会进行搜索，看是否已经有现成的开源实现可以利用。是有一个C语言版本的，但这个C语言实现版本相当陈旧，已经很多年未更新，这个是社区贡献的，并且只支持到Bolt协议的3.0版本，而目前Bolt协议已经发展到了5.0版本，3.0版本可能很快就会被淘汰。因此，我们没有采用这个版本，Neo4j自己是没有没有开发C++版本的客户端的。\n\n这段内容主要介绍了在TuGraph-DB中使用Bolt协议执行Cypher语句的交互过程和实现细节。它首先通过实例展示了TCP连接建立与消息交互的步骤，包括版本协商、发送Hello消息、开启事务、执行查询及处理返回数据的过程。接着，说明了TuGraph-DB如何实现Bolt协议，指出目前没有适用的成熟开源版本，强调了选择的标准和设计考量。"
            },
            {
                "content": "最后，客户端提交事务，如果成功，服务端会返回Success消息。\n\n另一个例子说明了Bolt协议的另一个特性，即pipeline流水式处理。客户端可以连续发送多条Cypher查询语句，而不需要等待前一条语句执行完成。例如，客户端连续发送两条“Run”消息，然后使用Pull消息来指定拉取某个特定查询语句的结果，这需要在消息中明确指出语句的ID，以便服务端知道客户端希望获取哪一条查询的结果，但这也要求服务端也必须具备相应的能力，即在一个会话中可以同时执行多条语句。\n\n## Bolt协议实现\n\n接下来，我将简要描述TuGraph-DB是如何实现Bolt协议的。起初我们当然会进行搜索，看是否已经有现成的开源实现可以利用。是有一个C语言版本的，但这个C语言实现版本相当陈旧，已经很多年未更新，这个是社区贡献的，并且只支持到Bolt协议的3.0版本，而目前Bolt协议已经发展到了5.0版本，3.0版本可能很快就会被淘汰。因此，我们没有采用这个版本，Neo4j自己是没有没有开发C++版本的客户端的。\n\n后来我们研究了官方的Bolt Golang语言的驱动代码。经过阅读后，我们发现Golang驱动里面Bolt协议这块代码写得比较清晰，于是决定以此为参考，使用C++语言来实现Bolt协议。\n\n在网络框架方面，因为Neo4j是使用Java编写的，Neo4j自己在实现Bolt Server的时候用的是Java里面的Netty框架，Netty是一个NIO网络编程框架，在C++中则可以使用有类似功能的Boost.Asio网络框架来实现。至于消息处理部分，我们严格按照官方文档中描述的状态机规则来构建。\n\n在线程模型的设计上，核心理念是每个连接对应一个线程。主要是因为会话是有状态的，将每个会话绑定在一个固定的线程上，处理起来比较方便。类似地，MySQL也是采用这种方式，为每个连接直接启动一个线程来处理。\n\n关于协议的版本，我们目前采用的是Bolt的4.4版本。Bolt协议有多个主要版本，包括1.0、2.0、3.0、4.0和5.0，每个大版本下还有多个子版本号。而4.4版本是官方的长期支持版本，支持到2026年。\n\n## 数据编解码\n\n该段落位于演讲回顾文档的中间部分，紧接在对Bolt协议交互举例的介绍之后，主要讲述了TuGraph-DB如何实现Bolt协议的过程，包括对现有开源实现的考察、网络框架选择、消息处理和线程模型设计等技术细节。"
            },
            {
                "content": "后来我们研究了官方的Bolt Golang语言的驱动代码。经过阅读后，我们发现Golang驱动里面Bolt协议这块代码写得比较清晰，于是决定以此为参考，使用C++语言来实现Bolt协议。\n\n在网络框架方面，因为Neo4j是使用Java编写的，Neo4j自己在实现Bolt Server的时候用的是Java里面的Netty框架，Netty是一个NIO网络编程框架，在C++中则可以使用有类似功能的Boost.Asio网络框架来实现。至于消息处理部分，我们严格按照官方文档中描述的状态机规则来构建。\n\n在线程模型的设计上，核心理念是每个连接对应一个线程。主要是因为会话是有状态的，将每个会话绑定在一个固定的线程上，处理起来比较方便。类似地，MySQL也是采用这种方式，为每个连接直接启动一个线程来处理。\n\n关于协议的版本，我们目前采用的是Bolt的4.4版本。Bolt协议有多个主要版本，包括1.0、2.0、3.0、4.0和5.0，每个大版本下还有多个子版本号。而4.4版本是官方的长期支持版本，支持到2026年。\n\n## 数据编解码\n\n数据编解码这块的实现，主要方法是参考官方Bolt Golang驱动的代码，然后用C++进行翻译。这里举了个例子：Bolt协议里面int64数字的编码实现，左边是Go版本的，右边是C++版本的，可以看到几乎是逐行把Go的语法转换成了C++的语法。\n\n数据编解码它是纯粹的计算逻辑，也可以选择参考官方的协议文档自己编写，但这样效率相对较低，而且枯燥，并且出错的概率也大，对着已有的版本翻译是最快的。但是相应的测试代码也得翻译过来，并且跑通，确保逻辑正确。\n\n## Bolt Server 网络模型\n\n这张图是Bolt server的网络模型，最左边是监听线程，中间是一堆的Bolt IO线程，每个线程处理一些Bolt连接的IO读写，每个连接固定对应右边的一个状态机线程。当消息从Bolt连接里面读出来后，会放到状态机线程的消息队列里面去，然后发个信号唤醒状态机去处理消息。消息的处理是按顺序的，如果没有消息。状态机线程处于休眠状态。\n\n## 不兼容的点\n\n在演讲的中后部分，讲者详细介绍了TuGraph-DB如何实现Bolt协议的具体技术细节，包括对官方Bolt Golang驱动代码的参考、网络框架的选择（Boost.Asio）、线程模型设计，以及协议版本的采用。紧接着，讲者还讨论了数据编解码的实现方法，并提供了Bolt Server的网络模型示意图，最后引入了Bolt协议与Neo4j客户端不兼容的特性。"
            },
            {
                "content": "## 数据编解码\n\n数据编解码这块的实现，主要方法是参考官方Bolt Golang驱动的代码，然后用C++进行翻译。这里举了个例子：Bolt协议里面int64数字的编码实现，左边是Go版本的，右边是C++版本的，可以看到几乎是逐行把Go的语法转换成了C++的语法。\n\n数据编解码它是纯粹的计算逻辑，也可以选择参考官方的协议文档自己编写，但这样效率相对较低，而且枯燥，并且出错的概率也大，对着已有的版本翻译是最快的。但是相应的测试代码也得翻译过来，并且跑通，确保逻辑正确。\n\n## Bolt Server 网络模型\n\n这张图是Bolt server的网络模型，最左边是监听线程，中间是一堆的Bolt IO线程，每个线程处理一些Bolt连接的IO读写，每个连接固定对应右边的一个状态机线程。当消息从Bolt连接里面读出来后，会放到状态机线程的消息队列里面去，然后发个信号唤醒状态机去处理消息。消息的处理是按顺序的，如果没有消息。状态机线程处于休眠状态。\n\n## 不兼容的点\n\n我们也注意到了一些与官方Neo4j客户端的兼容性问题。Bolt协议是Neo4j自己设计的，服务与自家的产品，并不是一个通用的标准，所以Bolt协议里面不可避免的会有一些Neo4j独有的特性。比如在新版本Neo4j中点的结构体中有一个element_id的字段，是字符串类型，这个在TuGraph-DB中没有这个东西，如用Neo4j客户端连TuGraph-DB，在客户端代码中去获取这个字段，目前返回是空的，而上面的三个字段是有的。同理，右边RUN消息里面红框标出来的都是目前TuGraph-DB没有的。\n\n## 使用效果\n\n该段落位于关于TuGraph-DB兼容Neo4j客户端的演讲回顾中，主要讨论了Bolt协议的数据编解码实现、Bolt Server的网络模型，以及与官方Neo4j客户端的兼容问题，旨在深入解析在实现该协议过程中遇到的技术细节和挑战。"
            },
            {
                "content": "## Bolt Server 网络模型\n\n这张图是Bolt server的网络模型，最左边是监听线程，中间是一堆的Bolt IO线程，每个线程处理一些Bolt连接的IO读写，每个连接固定对应右边的一个状态机线程。当消息从Bolt连接里面读出来后，会放到状态机线程的消息队列里面去，然后发个信号唤醒状态机去处理消息。消息的处理是按顺序的，如果没有消息。状态机线程处于休眠状态。\n\n## 不兼容的点\n\n我们也注意到了一些与官方Neo4j客户端的兼容性问题。Bolt协议是Neo4j自己设计的，服务与自家的产品，并不是一个通用的标准，所以Bolt协议里面不可避免的会有一些Neo4j独有的特性。比如在新版本Neo4j中点的结构体中有一个element_id的字段，是字符串类型，这个在TuGraph-DB中没有这个东西，如用Neo4j客户端连TuGraph-DB，在客户端代码中去获取这个字段，目前返回是空的，而上面的三个字段是有的。同理，右边RUN消息里面红框标出来的都是目前TuGraph-DB没有的。\n\n## 使用效果\n\n我们编写了一段简单的Java代码来展示使用Bolt客户端连TuGraph-DB的效果，与关系型数据库里面的JDBC非常类似，整体的使用体验很好。此外，我们还开发了一个Console 客户端，通过Bolt协议与服务端通信，也可以用这个CLI客户端实现在线流式导出数据。在性能对比方面，我们发现新实现的Bolt客户端在性能上略优于我们之前自己编写的RPC客户端，原因可能有多方面，例如编码方式的不同或是PackStream的序列化速度更快。暂未实现的功能目前尚未实现的功能包括显式事务、集群模式、加密传输和高级身份认证。尽管官方Bolt协议支持这些功能，但由于支持它们需要一些改造，且成本与收益比并不高，因此我们当前只支持基本的事务和身份认证。不过，我们计划在今年适配集群模式。\n\n该段落位于关于TuGraph-DB兼容Neo4j客户端的演讲回顾中，主要讨论了Bolt协议服务器的网络模型以及与官方Neo4j客户端的兼容性问题，最后展示了使用Bolt客户端连接TuGraph-DB的效果和当前未实现的功能。这部分内容是对Bolt协议实现细节的深入分析和实际应用效果的验证。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_150.md",
        "chunks": [
            {
                "content": "# TuGraph开源JAVA客户端工具 TuGraph-OGM\n\n## 无缝对接JAVA开发生态\n\nTuGraph 图数据库提供了 JAVA、C++、Python 等多种语言的 SDK 支持，方便客户在各种场景下使用。用户使用 SDK 向 TuGraph 服务器发送 Cypher 请求，服务器则以 JSON 形式返回数据。近日，TuGraph 推出了一款面向 JAVA 客户端用户的开发工具 TuGraph-OGM (Object Graph Mapping)，为用户提供了对象操作接口，相较于 Cypher/JSON 接口应用起来更加便捷。\n\nOGM 类似于关系数据库中的 ORM（Object Relational Model），可以将数据库返回的数据自动映射成 JAVA 中的对象，方便用户读取。而用户对这些对象的更新操作也可以被自动翻译成 Cypher 语句发送给服务器。这样，即便是完全不懂 Cypher 的用户，也可以通过操作对象与数据库进行交互，大大降低了图数据库的使用门槛。\n\nTuGraph-OGM 同时也兼容其他开源产品 OGM 工具如 Neo4j-OGM，方便用户将工程在不同数据库与 TuGraph 数据库间无缝迁移。本文将对 TuGraph-OGM 进行全面的介绍。\n\n## 0 映射原理\n\nTuGraph-OGM 将 JAVA 对象映射为图的对象，类映射为点，类的属性映射为图中的属性，类中的方法映射为操作 TuGraph 的查询语句。\n\n以电影场景为例，对演员、电影、导演之间的关系进行数据化，就形成了非常典型的图数据。举一个简单的示例，演员 Alice 在 1990 年和 2019 年分别出演了两部电影《Jokes》和《Speed》，其中《Jokes》的导演是 Frank Darabont。以图的思维来看，演员、导演、电影可以被映射为三种不同的节点，而出演、执导可以被映射为两种边，映射结果如上图所示。将数据存入图数据库后，相关的开发人员就可以使用各类图查询语言对数据进行查询。但对非图数据库相关的开发人员来说，这个例子中的演员、导演、电影作为实体，同样可以映射为类中的对象，而与实体相关联的对象可以通过集合存储，这是大多数开发人员熟悉的领域。\n\n## 1 TuGraph-OGM架构\n\n该文档介绍了 TuGraph-OGM（对象图映射）这一开源 JAVA 客户端工具，旨在帮助开发者更便捷地与 TuGraph 图数据库交互。文档首先概述了 TuGraph-OGM 的基本功能和与其他 SDK 的兼容性，然后详细解释了该工具的映射原理和架构，最后提供了使用示例，包括如何构建图对象、建立与 TuGraph 的连接以及执行 CRUD 操作。"
            },
            {
                "content": "## 0 映射原理\n\nTuGraph-OGM 将 JAVA 对象映射为图的对象，类映射为点，类的属性映射为图中的属性，类中的方法映射为操作 TuGraph 的查询语句。\n\n以电影场景为例，对演员、电影、导演之间的关系进行数据化，就形成了非常典型的图数据。举一个简单的示例，演员 Alice 在 1990 年和 2019 年分别出演了两部电影《Jokes》和《Speed》，其中《Jokes》的导演是 Frank Darabont。以图的思维来看，演员、导演、电影可以被映射为三种不同的节点，而出演、执导可以被映射为两种边，映射结果如上图所示。将数据存入图数据库后，相关的开发人员就可以使用各类图查询语言对数据进行查询。但对非图数据库相关的开发人员来说，这个例子中的演员、导演、电影作为实体，同样可以映射为类中的对象，而与实体相关联的对象可以通过集合存储，这是大多数开发人员熟悉的领域。\n\n## 1 TuGraph-OGM架构\n\nTuGraph-OGM 可被看做一个 \"翻译器\"，主要功能是将开发人员对 JAVA 对象的一些操作翻译为 TuGraph 可理解的图查询语言 Cypher 请求，并将该操作返回的结果，再次翻译为 JAVA 对象。架构图如下所示：\n\n## 3 使用示例\n\n详细示例请参考 tugraph-ogm-integration-tests 在 pom.xml 中引入依赖。\n\n### 3.1 构建图对象\n\n首先需要通过注解标明图中的实体。\n\n- `@NodeEntity`：该注解标明的类为节点类。\n- `@Relationship`：用于标明边，同时 @Relationship 中可指定 label 与边的指向。\n- `@Id`：用于标明 identity，是 OGM 中数据的唯一标识。\n\n### 3.2 与 TuGraph 建立连接\n\n当前 TuGraph-OGM 提供了 RPC driver 用于连接 TuGraph，具体配置如下所示：\n\n### 3.3 通过 OGM 进行增删改查\n\nOGM 支持对 TuGraph 的实体执行 CRUD 操作，同时支持发送任意 TuGraph 支持的 Cypher 语句，包括通过 CALL 调用存储过程。\n\n#### CREATE\n\n本文介绍了 TuGraph-OGM 作为一种开源 JAVA 客户端工具，主要用于将 JAVA 对象与图数据库的对象进行映射和操作。该工具简化了与 TuGraph 的交互，方便开发人员执行 CRUD 操作，并提供了对图数据库查询的支持。此部分涉及 OGM 的映射原理、架构以及使用示例，帮助用户理解如何构建图对象及与 TuGraph 建立连接。"
            },
            {
                "content": "## 3 使用示例\n\n详细示例请参考 tugraph-ogm-integration-tests 在 pom.xml 中引入依赖。\n\n### 3.1 构建图对象\n\n首先需要通过注解标明图中的实体。\n\n- `@NodeEntity`：该注解标明的类为节点类。\n- `@Relationship`：用于标明边，同时 @Relationship 中可指定 label 与边的指向。\n- `@Id`：用于标明 identity，是 OGM 中数据的唯一标识。\n\n### 3.2 与 TuGraph 建立连接\n\n当前 TuGraph-OGM 提供了 RPC driver 用于连接 TuGraph，具体配置如下所示：\n\n### 3.3 通过 OGM 进行增删改查\n\nOGM 支持对 TuGraph 的实体执行 CRUD 操作，同时支持发送任意 TuGraph 支持的 Cypher 语句，包括通过 CALL 调用存储过程。\n\n#### CREATE\n\n在完成图对象的构建后，即可通过类的实例化创建节点。当两个节点互相存储在对方的集合（该集合在构建时被标注为边）中，就形成了一条边。最后使用 `session.save` 方法将数据存入数据库。注意：TuGraph 数据库为强 schema 类型数据库，在创建实体前需要该数据的 label 已经存在，且新建过程中需要提供唯一的主键。\n\n#### DELETE\n\n使用 `session.delete` 方法删除节点，同时会删除与节点相关联的所有边。\n\n#### UPDATE\n\n修改已创建的节点的属性，再次调用 `session.save` 方法会对节点进行更新。\n\n#### MATCH\n\n`session.load` 方法用于根据节点 ID 查找节点。`session.loadAll` 方法用于批量查找节点，支持通过多个节点 ID 查找节点、查找某一类型的所有节点、带有 filter 的查询。filter 查询需要新建 Filter，传入参数 ComparisonOperator，可选为：EQUALS、GREATER_THAN、LESS_THAN。\n\n#### QUERY WITH CYPHER\n\nOGM 支持通过 `queryForObject`、`query` 方法向 TuGraph 发送 Cypher 查询，由于 Cypher 查询的灵活性，需要用户自行指定返回结果格式。\n\n该片段位于文档的第三部分，介绍了 TuGraph-OGM 的使用示例，包括如何构建图对象、与 TuGraph 建立连接以及执行增删改查（CRUD）操作的具体方法和注意事项。"
            },
            {
                "content": "#### DELETE\n\n使用 `session.delete` 方法删除节点，同时会删除与节点相关联的所有边。\n\n#### UPDATE\n\n修改已创建的节点的属性，再次调用 `session.save` 方法会对节点进行更新。\n\n#### MATCH\n\n`session.load` 方法用于根据节点 ID 查找节点。`session.loadAll` 方法用于批量查找节点，支持通过多个节点 ID 查找节点、查找某一类型的所有节点、带有 filter 的查询。filter 查询需要新建 Filter，传入参数 ComparisonOperator，可选为：EQUALS、GREATER_THAN、LESS_THAN。\n\n#### QUERY WITH CYPHER\n\nOGM 支持通过 `queryForObject`、`query` 方法向 TuGraph 发送 Cypher 查询，由于 Cypher 查询的灵活性，需要用户自行指定返回结果格式。\n\n- `session.queryForObject` 方法：需要在方法第一个参数处指定返回类型，可设定为某一实体类或数字类型。\n- `session.query` 方法：Cypher 查询的返回结果被存储为 Result 类型，其内部数据需要用户自行解析。以下方代码为例，传入数据库的 Cypher 为 CREATE 查询，返回结果 `createResult` 可被解析为 `QueryStatistics`，可获取到此次查询被创建的节点与边的数目。\n\n该块内容位于文档的使用示例部分，主要阐述了如何通过 TuGraph-OGM 进行节点的删除（DELETE）、更新（UPDATE）、查找（MATCH）以及使用 Cypher 查询（QUERY WITH CYPHER）的方法和相关操作。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_151.md",
        "chunks": [
            {
                "content": "# 一张图读懂 TuGraph Analytics 开源技术架构\n\nTuGraph Analytics（内部项目名GeaFlow）是蚂蚁集团开源的分布式实时图计算引擎，即流式图计算。通过SQL+GQL融合分析语言对表模型和图模型进行统一处理，实现了流、批、图一体化计算，并支持了Exactly Once语义、高可用以及一站式图研发平台等生产化能力。\n\n开源项目代码目前托管在GitHub，欢迎业界同仁、大数据/图计算技术爱好者关注我们的项目并参与共建。\n\n## 概览\n\n本文希望通过一张图描述清楚TuGraph Analytics的整体架构脉络和关键设计思路，以帮助大家快速对TuGraph Analytics项目的轮廓有个整体的认识。闲言少叙，直接上图。\n\nTuGraph Analytics开源技术架构一共分为五个部分：\n\n- **DSL层**：即语言层。TuGraph Analytics设计了SQL+GQL的融合分析语言，支持对表模型和图模型统一处理。\n- **Framework层**：即框架层。TuGraph Analytics设计了面向Graph和Stream的两套API支持流、批、图融合计算，并实现了基于Cycle的统一分布式调度模型。\n- **State层**：即存储层。TuGraph Analytics设计了面向Graph和KV的两套API支持表数据和图数据的混合存储，整体采用了Sharing Nothing的设计，并支持将数据持久化到远程存储。\n- **Console平台**：TuGraph Analytics提供了一站式图研发平台，实现了图数据的建模、加工、分析能力，并提供了图作业的运维管控支持。\n- **执行环境**：TuGraph Analytics可以运行在多种异构执行环境，如K8S、Ray以及本地模式。\n\n## DSL层\n\nDSL层是一个典型的编译器技术架构，即语法分析、语义分析、中间代码生成(IR)、代码优化、目标代码生成（OBJ）的流程。\n\n该段落介绍了TuGraph Analytics开源技术架构的整体框架及关键组件，包含对其背景、目标及五个主要部分的概述，旨在帮助读者快速理解该项目的设计思路和结构布局。"
            },
            {
                "content": "## DSL层\n\nDSL层是一个典型的编译器技术架构，即语法分析、语义分析、中间代码生成(IR)、代码优化、目标代码生成（OBJ）的流程。\n\n- **语言设计**：TuGraph Analytics设计了SQL+GQL的融合语法，解决了图+表一体化分析的诉求。具体语法设计可以参考DSL语法文档[2]\n- **语法分析**：通过扩展Calcite的SqlNode和SqlOperator，实现SQL+GQL的语法解析器，生成统一的语法树信息。\n- **语义分析**：通过扩展Calcite的Scope和Namespace，实现自定义Validator，对语法树进行约束语义检查。\n- **中间代码生成**：通过扩展Calcite的RelNode，实现图上的Logical RelNode，用于GQL语法的中间表示。\n- **代码优化**：优化器实现了大量的优化规则（RBO）用于提升执行性能，未来也会引入CBO。\n- **目标代码生成**：代码生成器Converter负责将Logical RelNode转换为Physical RelNode，即目标代码。Physical RelNode可以直接翻译为Graph/Table上的API调用。\n- **自定义函数**: TuGraph Analytics提供了大量的内置系统函数，用户也可以根据需要注册自定义函数。\n- **自定义插件**: TuGraph Analytics允许用户扩展自己的Connector类型，以支持不同的数据源和数据格式。\n\n## Framework层\n\nFramework层设计与Flink/Spark等同类大数据计算引擎有一定的相似性，即提供了类FlumeJava（FlumeJava: Easy, Efficient Data-Parallel Pipelines[3]）的统一高阶API（简称HLA），用户调用高阶API的过程会被转换为逻辑执行计划，逻辑执行计划执行一定的优化（如ChainCombine、UnionPushUp等）后，被转换为物理执行计划，物理执行计划会被调度器分发到分布式Worker上执行，最终Worker会回调用户传递的高阶API函数逻辑，实现整个分布式计算链路的执行。\n\n该段落介绍了TuGraph Analytics的DSL层， detailing其编译器架构，包括语言设计、语法分析、语义分析等关键技术环节，以及支持自定义函数和插件的功能。这部分内容是整体架构的核心组成部分，为后续的Framework层提供基础与支持。"
            },
            {
                "content": "- **高阶API**：TuGraph Analytics通过Environment接口适配异构的分布式执行环境（K8S、Ray、Local），使用Pipeline封装了用户的数据处理流程，使用Window抽象统一了流处理（无界Window）和批处理（有界Window）。Graph接口提供了静态图和动态图（流图）上的计算API，如append/snapshot/compute/traversal等，Stream接口提供了统一流批处理API，如map/reduce/join/keyBy等。\n- **逻辑执行计划**：逻辑执行计划信息统一封装在PipelineGraph对象内，将高阶API对应的算子（Operator）组织在DAG中，算子一共分为5大类：SourceOperator对应数据源加载、OneInputOperator/TwoInputOperator对应传统的数据处理、IteratorOperator对应静态/动态图计算。DAG中的点（PipelineVertex）记录了算子（Operator）的关键信息，如类型、并发度、算子函数等信息，边（PipelineEdge）则记录了数据shuffle的关键信息，如Partition规则（forward/broadcast/key等）、编解码器等。\n- **物理执行计划**：物理执行计划信息统一封装在ExecutionGraph对象内，并支持二级嵌套结构，以尽可能将可以流水线执行的子图（ExecutionVertexGroup）结构统一调度。图中示例的物理执行计划DAG被划分为三部分子图结构分别执行。\n- **调度器**：TuGraph Analytics设计了基于Cycle的调度器（CycleScheduler）实现对流、批、图的统一调度，调度过程通过事件驱动模型触发。物理执行计划中的每部分子图都会被转换为一个ExecutionCycle对象，调度器会向Cycle的头结点（Head）发送Event，并接收Cycle尾结点（Tail）的发回的Event，形成一个完整的调度闭环。对于流处理，每一轮Cycle调度会完成一个Window的数据的处理，并会一直不停地执行下去。对于批处理，整个Cycle调度仅执行一轮。对于图处理，每一轮Cycle调度会完成一次图计算迭代。\n\n该chunk位于TuGraph Analytics文档的Framework层部分，详细介绍了高阶API、逻辑执行计划、物理执行计划及调度器的设计和实现，阐述了如何通过这些组件支持流、批、图的统一计算与调度。"
            },
            {
                "content": "- **物理执行计划**：物理执行计划信息统一封装在ExecutionGraph对象内，并支持二级嵌套结构，以尽可能将可以流水线执行的子图（ExecutionVertexGroup）结构统一调度。图中示例的物理执行计划DAG被划分为三部分子图结构分别执行。\n- **调度器**：TuGraph Analytics设计了基于Cycle的调度器（CycleScheduler）实现对流、批、图的统一调度，调度过程通过事件驱动模型触发。物理执行计划中的每部分子图都会被转换为一个ExecutionCycle对象，调度器会向Cycle的头结点（Head）发送Event，并接收Cycle尾结点（Tail）的发回的Event，形成一个完整的调度闭环。对于流处理，每一轮Cycle调度会完成一个Window的数据的处理，并会一直不停地执行下去。对于批处理，整个Cycle调度仅执行一轮。对于图处理，每一轮Cycle调度会完成一次图计算迭代。\n- **运行时组件**：TuGraph Analytics运行时会拉起Client、Master、Driver、Container组件。当Client提交Pipeline给Driver后，会触发执行计划构建、分配Task（ResourceManagement提供资源）和调度。每个Container内可以运行多个Worker组件，不同Worker组件之间通过Shuffle模块交换数据，所有的Worker都需要定期向Master上报心跳（HeartbeatManagement），并向时序数据库上报运行时指标信息。另外TuGraph Analytics运行时也提供了故障容忍机制（FailOver），以便在异常/中断后能继续执行。\n\n该块内容位于TuGraph Analytics的Framework层部分，详细介绍了物理执行计划的结构、Cycle调度器的工作机制以及运行时组件的配置与协作。这些信息对于理解TuGraph Analytics在分布式图计算中的执行流程和资源管理至关重要。"
            },
            {
                "content": "## State层\n\nState层设计相比于传统的大数据计算引擎，除了提供面向表数据的KV存储抽象，也支持了面向图数据的Graph存储抽象，以更好地支持面向图模型的IO性能优化。\n\n- **State API**：提供了面向KV存储API，如get/put/delete等。以及面向图存储的API，如V/E/VE，以及点/边的add/update/delete等。\n- **State执行层**：通过KeyGroup的设计实现数据的Sharding和扩缩容能力，Accessor提供了面向不同读写策略和数据模型的IO抽象，StateOperator抽象了存储层SPI，如finish（刷盘）、archive（Checkpoint）、compact（压缩）、recover（恢复）等。另外，State提供了多种PushDown优化以加速IO访问效率。通过自定义内存管理和面向属性的二级索引也会提供大量的存储访问优化手段。\n- **Store层**：TuGraph Analytics支持了多种存储系统类型，并通过StoreContext封装了Schema、序列化器，以及数据版本信息。\n- **持久化层**：State的数据支持持久化到远程存储系统，如HDFS、OSS、S3等。\n\n## Console平台\n\nConsole平台提供了一站式图研发、运维的平台能力，同时为引擎运行时提供元数据（Catalog）服务。\n\n该段落位于文章的中部，介绍了TuGraph Analytics的State层设计，强调其为图数据和表数据提供的存储抽象和性能优化。同时，后续部分将讨论Console平台的功能，进一步展示TuGraph Analytics的整体架构及其研发和运维能力。"
            },
            {
                "content": "## Console平台\n\nConsole平台提供了一站式图研发、运维的平台能力，同时为引擎运行时提供元数据（Catalog）服务。\n\n- **标准化API**：平台提供了标准化的RESTful API和认证机制，同时支持了页面端和应用端的统一API服务能力。\n- **任务研发**：平台支持“关系-实体-属性”的图数据建模。基于字段映射配置，可以定义图数据传输任务，包括数据集成（Import）和数据分发（Export）。基于图表模型的图数据加工任务支持多样化的计算场景，如Traversal、Compute、Mining等。基于数据加速器的图数据服务，提供了多协议的实时分析能力，支持BI、可视化分析工具的接入集成。\n- **构建提交**：平台通过任务和作业的独立抽象，实现研发态与运维态的分离。任务开发完成后执行发布动作，会自动触发构建流水线（Release Builder），生成发布版本。任务提交器（Task Submitter）负责将发布版本的内容提交到执行环境，生成计算作业。\n- **作业运维**：作业属于任务的运行态，平台提供了作业的操纵（启停、重置）、监控（指标、告警、审计）、调优（诊断、伸缩、调参）、调度等运维能力。作业的运行时资源会由资源池统一分配和管理。\n- **元数据服务**：平台同时承载了引擎运行时的元数据服务能力，以实现研发与运维的自动化。元数据以实例维度进行隔离，实例内的研发资源可以根据名字直接访问，如点、边、图、表、视图、函数等。\n- **系统管理**：平台提供了多租户隔离机制、细粒度用户权限控制，以及系统资源的管理能力。\n\n## 执行环境\n\nTuGraph Analytics支持多种异构环境执行，以常见的K8S部署环境为例，其物理部署架构如下：\n\n在TuGraph Analytics作业的全生命周期过程中，涉及的关键数据流程有：\n\n该段落介绍了TuGraph Analytics的Console平台，涵盖其提供的一站式图数据研发和运维能力，包括标准化API、任务研发、构建提交、作业运维、元数据服务和系统管理等功能。这是文档中阐述TuGraph Analytics技术架构的重要组成部分，属于技术架构的五个部分之一。"
            },
            {
                "content": "## 执行环境\n\nTuGraph Analytics支持多种异构环境执行，以常见的K8S部署环境为例，其物理部署架构如下：\n\n在TuGraph Analytics作业的全生命周期过程中，涉及的关键数据流程有：\n\n- **研发阶段**：Console平台提供了实例下所有的研发资源的管理，用户可以在创建任务前，提前准备所需的研发资源信息，并存储在Catalog。\n- **构建阶段**：任务创建完成后，通过发布动作触发构建流水线，用户的JAR包、任务的ZIP包等会上传到RemoteFileStore。\n- **提交阶段**：作业提交时，Console会根据作业的参数配置、运行时环境信息，以及远程文件地址等创建KubernetesJobClient，既而会拉起Client Pod，Client会拉起Master Pod，Master会拉起Container Pods和Driver Pod。所有的Pod拉起后，Client会把作业的Pipeline发送给Driver执行，Driver最终通过Cycle调度的Events与Containers交互。所有的Pod启动时都会从RemoteFileStore下载版本JAR包、用户JAR包、作业ZIP包等信息。Driver对DSL代码编译时，也需要通过Console提供的Catalog API操作Schema信息。\n- **运行阶段**：作业运行时，各个组件会上报不同的数据和信息。Master会上报作业的心跳汇总信息，Driver会上报作业的Pipeline/Cycle指标以及错误信息，Container会上报作业的Offset、指标定义以及错误信息等。RuntimeMetaStore存储作业的Pipeline/Cycle指标、Offset、心跳汇总、错误等信息。HAMetaStore存储各个运行组件的地址信息。DataStore存储State数据和作业FailOver时所需的元数据信息。MetricStore存储运行时指标信息。\n- **监控阶段**：Console会主要查询RuntimeMetaStore和MetricStore存储的信息用于作业的运行时监控。\n- **清理阶段**：作业重置/删除时，Console会对作业的RuntimeMeta、HAMeta以及部分Data做清理操作。\n\n## 总结\n\n该段落主要介绍TuGraph Analytics的执行环境，包括在K8S等异构环境中作业的全生命周期流程，涵盖了研发、构建、提交、运行、监控和清理各个阶段的关键数据流程，为读者提供对系统运行和资源管理的全面理解。"
            },
            {
                "content": "## 总结\n\n希望通过以上的介绍，可以让大家对TuGraph Analytics开源技术架构有个比较清晰的了解，我们非常欢迎开源社区的技术爱好者参与到项目的建设中来。如果您对TuGraph Analytics项目比较感兴趣，欢迎动动手指扫码直达GitHub仓库，为我们的项目加一颗Star。（网络不畅可以尝试使用VPN访问）\n\n本文主要介绍了TuGraph Analytics的开源技术架构，包括其各个层次的设计思想和功能实现。在文章的最后一部分，总结了整体架构的特点，并欢迎开源社区的技术爱好者参与到项目中，鼓励读者关注项目并给与支持。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_152.md",
        "chunks": [
            {
                "content": "# 蚂蚁图数据库再获LDBC权威测试世界第一\n\n近日，国际权威图数据库测试机构国际关联数据基准委员会（LDBC）公布了行业通用的社交网络基准测试（LDBC SNB）最新结果。蚂蚁集团图数据库TuGraph打破官方审计测试纪录，再次拿到世界第一，这一纪录较LDBC早前公布的最高纪录吞吐量提升了52%，也超过了两年前由TuGraph保持的世界纪录1倍以上。\n\n据LDBC官方发布的报告，在本次测试中，TuGraph在不同规模的数据集下均表现优异，在最大数据规模300G的数据集（8亿个结点，53亿条边）上，TuGraph的吞吐率较上一次官方纪录提升了52%，在系统事务性、可恢复性、正确性、稳定性等方面均达到官方标准，体现了TuGraph高并发低延迟的强大性能优势。\n\n为了更加贴近真实场景使测试更加严谨，TuGraph还采用了Client/Server部署，将客户端和服务器分别部署在两台服务器上，在更严苛的条件下（固有网络延迟与网络波动）完成了本次测试。\n\n蚂蚁集团也是LDBC最新的金融图数据测试基准Finbench的发起人和主要建设者。\n\n## 关于LDBC和SNB测试\n\nLDBC，即“关联数据基准测评委员会”（Linked Data Benchmark Council），是全球公认的图数据库领域基准指南制定者与测试机构，与TPC并称为国际数据库行业两大权威技术组织。\n\nSNB，即社交网络基准测试（Social Network Benchmark），是由LDBC开发的面向图数据库的基准测试（Benchmark）之一。SNB测试由于更贴近现实系统，同时包含了读写任务，简单和复杂查询，规定了系统的响应时间，更能体现系统的综合性能，是目前图数据行业最成熟和通用的性能测试。\n\nLDBC SNB测试由指定的第三方机构进行，从数据导入到结果验证均由第三方在云平台上执行，最终结果由LDBC执行委员会进行审计并公布，最大限度的保证了结果的可信性。同时，SNB还公布了测试过程所用的程序和脚本，以及测试过程中产生的详细结果，进一步确保了测试的可复现性。\n\n## 关于TuGraph\n\n蚂蚁集团图数据库TuGraph是基于图模型的一站式数据存储和分析系统，擅长处理大规模关联数据的管理和分析，如社交关系、物流服务、设备管网、金融交易等场景，数千倍优化分析性能，天然具备数据可视化展示。\n\n该文档主要介绍蚂蚁集团的图数据库TuGraph在国际关联数据基准委员会（LDBC）进行的社交网络基准测试中获得世界第一的成就，以及测试的相关细节和TuGraph的特性。"
            },
            {
                "content": "LDBC，即“关联数据基准测评委员会”（Linked Data Benchmark Council），是全球公认的图数据库领域基准指南制定者与测试机构，与TPC并称为国际数据库行业两大权威技术组织。\n\nSNB，即社交网络基准测试（Social Network Benchmark），是由LDBC开发的面向图数据库的基准测试（Benchmark）之一。SNB测试由于更贴近现实系统，同时包含了读写任务，简单和复杂查询，规定了系统的响应时间，更能体现系统的综合性能，是目前图数据行业最成熟和通用的性能测试。\n\nLDBC SNB测试由指定的第三方机构进行，从数据导入到结果验证均由第三方在云平台上执行，最终结果由LDBC执行委员会进行审计并公布，最大限度的保证了结果的可信性。同时，SNB还公布了测试过程所用的程序和脚本，以及测试过程中产生的详细结果，进一步确保了测试的可复现性。\n\n## 关于TuGraph\n\n蚂蚁集团图数据库TuGraph是基于图模型的一站式数据存储和分析系统，擅长处理大规模关联数据的管理和分析，如社交关系、物流服务、设备管网、金融交易等场景，数千倍优化分析性能，天然具备数据可视化展示。\n\nTuGraph拥有业界领先的集群规模和性能，是蚂蚁集团金融风控能力的重要基础设施，显著提升了欺诈洗钱等金融风险的实时识别能力和审理分析效率，提供了稳定的决策支持能力，其中，支撑支付宝的重要风险识别能力提升了近10倍，风险审理分析效率提升90%。TuGraph已被成熟应用于安全风控、信贷风控、知识图谱、数据血缘、资金分析、流量归因分析、会员关系等场景，并面向金融、工业、政务服务等行业客户。\n\n本文主要介绍了蚂蚁集团图数据库TuGraph在LDBC社交网络基准测试中取得的世界第一成绩，强调了其卓越性能和应用场景。该部分内容中对LDBC及其SNB测试进行了详细解释，为读者提供了该测试的背景和信任基础，进一步展示了TuGraph的实力和在行业中的重要地位。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_153.md",
        "chunks": [
            {
                "content": "# TuGraph：从清华到蚂蚁\n\n蚂蚁集团图计算TuGraph（原名GeaGraph），是蚂蚁集团与清华大学联合研发的大规模图计算系统，构建了一套包含图存储、图计算、图学习、图研发平台的完善的图技术体系，拥有业界领先规模的图集群，是图数据库基准性能测试LDBC-SNB世界纪录保持者。TuGraph是蚂蚁集团金融风控能力的重要基础设施，显著提升了欺诈洗钱等金融风险的实时识别能力和审理分析效率，并面向金融、工业、政务服务等行业客户。\n\n## 清华时期\n\n早在2010年前后，清华大学计算机系高性能所就开始图计算相关技术及系统研究。于2016年成功研发的双子星图计算系统比业界常用的开源图计算引擎GraphX性能提高了约100倍，获得了业界的广泛关注。\n\n## 费马时期\n\n为了推动技术的广泛应用，2016年从事图计算研究的清华师生成立了费马科技有限公司。费马科技在推进双子星系统应用的同时，进一步开发出了具有国际领先性能的图数据库产品TuGraph，能够支持完整的图数据库事务，服务了搜狗搜索、京东金融、以及大型国有银行、国家级能源企业在内的不同行业用户，并在2020年通过了国际图数据库标准组织LDBC的认证测试，认证成绩是第二名的7.6倍。\n\n## 蚂蚁时期\n\n蚂蚁集团在很多领域具有科技领先能力，国内乃至全球最大的用户量和峰值交易量使得蚂蚁集团对图计算有着丰富的应用需求，利用图计算技术处理支付宝的反欺诈、反套现等难题，可以比传统技术更加适用。从2015年起，蚂蚁集团开始自主研发分布式图数据库、流式图计算等图计算技术系统，并在内部应用中获得了良好的效果。\n\n2020年，蚂蚁集团进一步整合了自有的图计算技术系统GeaBase，以及清华大学和费马科技的产品和技术，升级形成了一套完整的图计算系统GeaGraph（后统一采用TuGraph命名）。这套系统集成了各方原有优势，经过多年技术积累和大规模实战打磨，无论从功能的完整性，还是吞吐率、响应时间等性能指标，都达到了世界领先水平。\n\n该文档介绍了蚂蚁集团与清华大学联合研发的大规模图计算系统TuGraph的历史和技术演进过程，包括清华时期的研究开发、费马科技的成立与技术推广，以及蚂蚁集团如何整合这些技术形成先进的图数据库系统，重点突出其在金融风控等领域的应用。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_154.md",
        "chunks": [
            {
                "content": "# 关于TuGraph\n\n高性能图数据库 TuGraph（https://github.com/TuGraph-family/tugraph-db) 由蚂蚁集团和清华大学共同研发，经国际图数据库基准性能权威测试，是 LDBC-SNB 世界纪录保持者，在功能完整性、吞吐率、响应时间等技术指标均达到全球领先水平，为用户管理和分析复杂关联数据提供了高效易用可靠的平台。\n\n历经蚂蚁万亿级业务的实际场景锤炼，TuGraph 已应用于蚂蚁内部150多个场景，助力支付宝2021年资产损失率小于亿分之0.98。关联数据爆炸性增长对图计算高效处理提出迫切需求，TuGraph 已被成熟应用于金融风控、设备管理等内外部应用，适用于金融、工业、互联网、社交、电信、政务等领域的关系数据管理和分析挖掘。\n\n2022年9月，TuGraph 单机版开源，提供了完备的图数据库基础功能和成熟的产品设计，拥有完整的事务支持和丰富的系统特性，单机可部署，使用成本低，支持TB级别的数据规模。\n\n## 蚂蚁高性能图数据库 TuGraph-DB 的技术思考与实践\n\n在近日举行的 DTCC 2022 第十三届中国数据库技术大会-图数据技术与应用创新专场，蚂蚁集团图数据库负责人洪春涛博士分享了蚂蚁高性能图数据库 TuGraph-DB 的技术思考和实践，以下为演讲内容要点回顾。\n\n### 图计算的优势\n\n图计算是一种高效的抽象计算方法，可以方便地处理复杂的多维数据。我们将员工和公司之间的关系画成图，这样可以快速查询员工的信息，例如员工的工作情况、与其他员工的关系以及与哪些公司有联系。相比之下，在关系数据库中，我们需要分别建立员工信息表、公司信息表以及员工和公司之间的关系表。这就把整个数据切成了很多张二维表，在实际应用系统中经常能够看到几百上千张表。这样会使得系统变得更加复杂，需要基于多张表去做推断，对人或机器来说都会带来挑战。\n\n对比来看什么是简单查询和复杂查询：\n\n图中表格的前两行属于比较简单的查询，比如某个员工的工龄，直接找到对应的那一行然后取出来就可以；比如找出所有的雇员数大于 5 的公司，可能在雇佣关系表中就能找出来，在关系数据库里这些都属于常规的操作。\n\n该块内容介绍了高性能图数据库TuGraph的基本信息、技术背景及优势，具体阐述了图计算作为一种处理复杂多维数据的有效方法，并对比了图数据库与传统关系数据库在查询复杂性上的差异。内容来源于蚂蚁集团对TuGraph的研究及应用成果总结，意在展示TuGraph的性能及适用场景。"
            },
            {
                "content": "## 蚂蚁高性能图数据库 TuGraph-DB 的技术思考与实践\n\n在近日举行的 DTCC 2022 第十三届中国数据库技术大会-图数据技术与应用创新专场，蚂蚁集团图数据库负责人洪春涛博士分享了蚂蚁高性能图数据库 TuGraph-DB 的技术思考和实践，以下为演讲内容要点回顾。\n\n### 图计算的优势\n\n图计算是一种高效的抽象计算方法，可以方便地处理复杂的多维数据。我们将员工和公司之间的关系画成图，这样可以快速查询员工的信息，例如员工的工作情况、与其他员工的关系以及与哪些公司有联系。相比之下，在关系数据库中，我们需要分别建立员工信息表、公司信息表以及员工和公司之间的关系表。这就把整个数据切成了很多张二维表，在实际应用系统中经常能够看到几百上千张表。这样会使得系统变得更加复杂，需要基于多张表去做推断，对人或机器来说都会带来挑战。\n\n对比来看什么是简单查询和复杂查询：\n\n图中表格的前两行属于比较简单的查询，比如某个员工的工龄，直接找到对应的那一行然后取出来就可以；比如找出所有的雇员数大于 5 的公司，可能在雇佣关系表中就能找出来，在关系数据库里这些都属于常规的操作。\n\n但如果查询再复杂一点，我想知道员工 A 和员工 C 之间有什么关系，不一定是一跳的关系，可能包含在同一家公司工作，也可能包含参与了同一个项目，甚至还包含他们有一个共同好友，这些关系就是多种多样的，想用 SQL 列举所有可能的关系其实就没有那么容易了。如果确定知道这里可能有几种关系，还能靠 SQL 穷举出来，但随着表越来越多，里面的关系可能有几百上千的时候，再想去穷举就非常难了。\n\n最后还有一种更复杂的查询，比如想找员工 A 和员工 E 的所有关系，可能包括 A 认识 B，B 认识 C，C 认识 E，相当于在做一个不定长跳数的查询，在 SQL 里面就非常难写了，相信绝大多数人都难以写出这种查询。\n\n业界有句话，所谓的关系数据库实际上并不擅长处理关系。例如，员工 A 和 E 之间的所有关系实际上就是我们要查询的关系，但在关系数据库中处理这种关系查询实际上是不够友好的。这是图数据库的优势所在，它们更擅长处理复杂的关系数据。我们发现，大部分浅显的数据信息都可以比较容易地挖掘出来，但要想更深入地利用数据产生更多的价值，就必须挖掘更深层次的信息，这时就一定会遇到这些复杂的关系，这也是为什么图数据库越来越受欢迎的原因。\n\n### 为什么图数据库开始流行\n\n该块内容属于文档中的一部分，介绍蚂蚁集团在 DTCC 2022 中国数据库技术大会上分享的关于高性能图数据库 TuGraph-DB 的技术思考与实践，重点阐述图计算的优势以及为何图数据库在数据管理与分析中日益流行。"
            },
            {
                "content": "最后还有一种更复杂的查询，比如想找员工 A 和员工 E 的所有关系，可能包括 A 认识 B，B 认识 C，C 认识 E，相当于在做一个不定长跳数的查询，在 SQL 里面就非常难写了，相信绝大多数人都难以写出这种查询。\n\n业界有句话，所谓的关系数据库实际上并不擅长处理关系。例如，员工 A 和 E 之间的所有关系实际上就是我们要查询的关系，但在关系数据库中处理这种关系查询实际上是不够友好的。这是图数据库的优势所在，它们更擅长处理复杂的关系数据。我们发现，大部分浅显的数据信息都可以比较容易地挖掘出来，但要想更深入地利用数据产生更多的价值，就必须挖掘更深层次的信息，这时就一定会遇到这些复杂的关系，这也是为什么图数据库越来越受欢迎的原因。\n\n### 为什么图数据库开始流行\n\n图数据库的概念最早出现在七八十年代初期，但当时为什么人们没有选择使用图数据库，而是选择了关系数据库呢？我认为主要原因是，当时的计算机并不那么强大，使用二维表格形式的关系数据库对计算机来说更友好。我们知道，计算机最擅长的事情就是重复的劳动，重复的任务。如果我们要在一张二维表中找一行数据，我们可以一行一行查找，或者使用二分查找（如果数据是树状有序的）。每一层都是重复的算法在运行，这对计算机来说是一个非常规整的数据，容易处理。但如果把数据抽象成一张图，那么难度就会大很多，对计算机来说会更难处理。\n\n举个例子，一个员工可能与其他人有各种不同的关系，比如朋友关系、雇佣关系、参与项目关系，每种关系的类型都不同，对应的数据也都不同。此外，一个点上的边数也非常不规律，有的人可能只有几个好友，而在微博上，一个普通人可能有两三百个粉丝，而大 V 账号可能有数百万甚至上亿的粉丝。这样一来，存储数据时，普通人和大 V 之间的差距就非常大了，对计算机来说，处理这两种数据的差异也会很大。\n\n我们知道，在七八十年代，计算机相对来说很弱，如果那个时候使用图来表示数据，整个处理和查询的难度就会大很多。所以，人们选择使用关系数据表的形式表示数据。事实上，那个时候有人做过图数据库，但并没有流行起来，原因就是性能相对关系数据库来说差得太多了。\n\n该段落位于关于TuGraph的技术思考与实践的部分，具体讨论了图计算的优势以及图数据库相较于关系数据库的优越性，尤其是在处理复杂关系查询方面的能力，同时还回顾了图数据库发展初期为何未能流行的原因。"
            },
            {
                "content": "举个例子，一个员工可能与其他人有各种不同的关系，比如朋友关系、雇佣关系、参与项目关系，每种关系的类型都不同，对应的数据也都不同。此外，一个点上的边数也非常不规律，有的人可能只有几个好友，而在微博上，一个普通人可能有两三百个粉丝，而大 V 账号可能有数百万甚至上亿的粉丝。这样一来，存储数据时，普通人和大 V 之间的差距就非常大了，对计算机来说，处理这两种数据的差异也会很大。\n\n我们知道，在七八十年代，计算机相对来说很弱，如果那个时候使用图来表示数据，整个处理和查询的难度就会大很多。所以，人们选择使用关系数据表的形式表示数据。事实上，那个时候有人做过图数据库，但并没有流行起来，原因就是性能相对关系数据库来说差得太多了。\n\n我们知道，所有的事物，尤其是电脑，一直在不断进步。这包括硬件和软件方面的改进。如今的硬件和几十年前的硬件完全不是一个概念，而现在的软件优化也大不相同。随着这些改进，我们会发现对当前的电脑和计算机系统来说，使用图数据库带来的额外开销可能不是很大的问题。\n\n举个例子，我们会发现，过去人们都使用低级编程语言编写程序，但随着时间的推移，有了高级语言。比如最开始、最原始的电脑可能是用纸袋和机器码写程序，后来有了汇编，再后来有 C 语言、C++，现在很多人都直接写 Python。虽然 Python 程序的执行速度可能较慢，但是写的很快，而用 C++或者汇编去写得写半天，对于编写程序到最终得出结果的整个过程来说，使用 Python 会更方便。\n\n计算机编程语言的发展是从低级向高级演变的，数据抽象也是一样。我们认为，未来的数据抽象一定会对人更友好一些，而不是专注于对机器更友好。如图所示，编程语言的发展是从低级语言向高级语言转变的，我们也认为数据抽象层次也会慢慢从低层次表格抽象向高层次图表抽象发展。\n\n### 图计算在蚂蚁的应用\n\n自 2015 年开始，蚂蚁实际上投入了大量资源来研究图计算，研究如何在蚂蚁的业务中使用图计算。例如数据血缘应用。在对业务的处理过程中，我们需要较好地追踪这些数据的流转路径，如果修改了一份源数据会对下游数据产生什么影响，会对最终业务产生什么影响。为了更好地追踪，我们使用图数据库来存储数据。\n\n该段落位于关于图计算的优势与发展背景部分，讨论了图数据库相较于关系数据库在处理多种关系和数据复杂性方面的有效性，以及计算机技术的发展如何影响数据表示与存储的选择。接下来引入蚂蚁集团在图计算领域的应用实践与研究投入。"
            },
            {
                "content": "举个例子，我们会发现，过去人们都使用低级编程语言编写程序，但随着时间的推移，有了高级语言。比如最开始、最原始的电脑可能是用纸袋和机器码写程序，后来有了汇编，再后来有 C 语言、C++，现在很多人都直接写 Python。虽然 Python 程序的执行速度可能较慢，但是写的很快，而用 C++或者汇编去写得写半天，对于编写程序到最终得出结果的整个过程来说，使用 Python 会更方便。\n\n计算机编程语言的发展是从低级向高级演变的，数据抽象也是一样。我们认为，未来的数据抽象一定会对人更友好一些，而不是专注于对机器更友好。如图所示，编程语言的发展是从低级语言向高级语言转变的，我们也认为数据抽象层次也会慢慢从低层次表格抽象向高层次图表抽象发展。\n\n### 图计算在蚂蚁的应用\n\n自 2015 年开始，蚂蚁实际上投入了大量资源来研究图计算，研究如何在蚂蚁的业务中使用图计算。例如数据血缘应用。在对业务的处理过程中，我们需要较好地追踪这些数据的流转路径，如果修改了一份源数据会对下游数据产生什么影响，会对最终业务产生什么影响。为了更好地追踪，我们使用图数据库来存储数据。\n\n另一个比较有趣的应用场景就是程序分析。相信几乎所有互联网公司内部都有大量的程序，因此，我们需要管理这些程序，并在每次提交代码时了解将会对哪些内容产生影响。为此，蚂蚁负责程序分析的团队会分析这里的图数据。例如，定义一个变量 A，然后使用变量 A，“定义”与“使用”之间就会有一条边，使用关系会存储在图数据库中。目前我们的图中已经有超过 200 亿条边，这是一个非常大的数据量。我们需要对这些数据进行存储、查询和分析，这是蚂蚁公司内部非常多的图数据场景之一。\n\n举个例子来说明优惠券反套现的场景：满额返券是一种比较常见的促销方式，比如购物满 2000 元就可以享受 100 元的优惠。这种情况下，如果正常消费，用户花费 2000 元，通过返券省下 100 元。但是有些人会想办法注册假商铺，进行虚假交易，目的是把平台补贴的优惠券套出来。因此当用户去买东西，平台要去付补贴的过程，我们需要去实时检测一下会不会有可疑的资金交易情况。\n\n该段落讨论了编程语言和数据抽象的发展，强调了高级语言对用户友好的优势，并引入蚂蚁集团在图计算中的应用，包括数据血缘追踪和程序分析等场景，展示图数据库在复杂数据处理中的重要性和实用性。"
            },
            {
                "content": "另一个比较有趣的应用场景就是程序分析。相信几乎所有互联网公司内部都有大量的程序，因此，我们需要管理这些程序，并在每次提交代码时了解将会对哪些内容产生影响。为此，蚂蚁负责程序分析的团队会分析这里的图数据。例如，定义一个变量 A，然后使用变量 A，“定义”与“使用”之间就会有一条边，使用关系会存储在图数据库中。目前我们的图中已经有超过 200 亿条边，这是一个非常大的数据量。我们需要对这些数据进行存储、查询和分析，这是蚂蚁公司内部非常多的图数据场景之一。\n\n举个例子来说明优惠券反套现的场景：满额返券是一种比较常见的促销方式，比如购物满 2000 元就可以享受 100 元的优惠。这种情况下，如果正常消费，用户花费 2000 元，通过返券省下 100 元。但是有些人会想办法注册假商铺，进行虚假交易，目的是把平台补贴的优惠券套出来。因此当用户去买东西，平台要去付补贴的过程，我们需要去实时检测一下会不会有可疑的资金交易情况。\n\n蚂蚁有很多业务需要研究图计算系统和图数据库等技术来满足需求，因为这些业务需要对大量的点边进行分析，数据量超过了 100TB，基本上已经达到了 PB 级别。我们需要对这些图进行实时查询，吞吐率大约在百万级别，延迟要求在 20 毫秒以内。如果我们无法做到实时计算，那么整个业务的流转就会非常缓慢。\n\n随着技术的发展，未来对图计算的需求会越来越高。正是因为这种背景，我们才在 2015 年开始投入大量资源进行研究。\n\n### 图计算系统建设中的问题与挑战\n\n在建立蚂蚁图计算系统的过程中，我们遇到很多问题，也希望与学术界共同合作，在这个过程中，我们合作发表了多篇论文。实际上，图计算仍然处于早期阶段，标准尚未成形，市场也有碎片化的现象，导致现阶段很难形成统一的标准。\n\n我们在图计算的过程中发现，图计算的常见问题有很多。首先，图计算算法的选择非常重要，比如在对图进行切分时，我们如何选择切分点，切分的比例会影响图的计算性能。此外，图计算的下游场景比较复杂，可能包括离线计算、实时计算等不同场景。我们发现大多数的算法对图的流量非常敏感。\n\n### TuGraph 技术优势\n\n该内容位于关于TuGraph的文档中，讨论了图计算在蚂蚁集团内部的应用场景，特别是程序分析和优惠券反套现的案例，以及面对的数据量和实时查询需求。同时，文中也提到在图计算系统建设中遇到的问题与挑战，并引出了TuGraph的技术优势。"
            },
            {
                "content": "蚂蚁有很多业务需要研究图计算系统和图数据库等技术来满足需求，因为这些业务需要对大量的点边进行分析，数据量超过了 100TB，基本上已经达到了 PB 级别。我们需要对这些图进行实时查询，吞吐率大约在百万级别，延迟要求在 20 毫秒以内。如果我们无法做到实时计算，那么整个业务的流转就会非常缓慢。\n\n随着技术的发展，未来对图计算的需求会越来越高。正是因为这种背景，我们才在 2015 年开始投入大量资源进行研究。\n\n### 图计算系统建设中的问题与挑战\n\n在建立蚂蚁图计算系统的过程中，我们遇到很多问题，也希望与学术界共同合作，在这个过程中，我们合作发表了多篇论文。实际上，图计算仍然处于早期阶段，标准尚未成形，市场也有碎片化的现象，导致现阶段很难形成统一的标准。\n\n我们在图计算的过程中发现，图计算的常见问题有很多。首先，图计算算法的选择非常重要，比如在对图进行切分时，我们如何选择切分点，切分的比例会影响图的计算性能。此外，图计算的下游场景比较复杂，可能包括离线计算、实时计算等不同场景。我们发现大多数的算法对图的流量非常敏感。\n\n### TuGraph 技术优势\n\n蚂蚁开发的 TuGraph 系统解决了图数据的存储、流式计算、离线计算和图学习的问题，目前已在超过 100 个业务线和 300 多个场景中应用。图数据是最适合存储在图数据库里的，关系明确且常常能给出一个清晰的图谱，而不同的数据之间的相互关系能在图数据库中很清楚地体现出来。\n\nTuGraph 在 LDBC-SNB 标准测试中仍是世界纪录保持者，支持 TB 级别数据的存储与计算，能够有效帮助用户在复杂数据关系中提取有价值的信息。\n\n## 开源开放，共建发展\n\n我们于 2023 年 9 月在 GitHub 上开源了 TuGraph 中的单机版图数据库和离线图分析引擎 TuGraph Compute，分布式图数据库和流式图计算包含在商业化版本中。\n\n## TuGraph 开源版特色\n\n- **处理能力**：支持 TB 级别的数据，单机版易于部署。\n- **性能**：经过大量优化，LDBC-SNB 测试世界第一。\n- **易用性**：完整系统，提供导入导出工具和查询语言。\n\n## 开源版本的目标\n\n1. 提供免费图数据库产品，让更多人使用。\n2. 促进图数据库标准形成，降低学习成本。\n3. 优化基础研究性问题，为研究提供比较基线。\n\n## TuGraph 企业版特色\n\n该文本块讨论了蚂蚁集团在图计算系统建设中的需求与挑战，特别是涉及数据量和实时查询性能的要求，以及图计算的常见问题和TuGraph技术的优势。它还提到TuGraph在多个业务场景中的应用和开源计划，旨在提升图数据库的易用性和性能。"
            },
            {
                "content": "TuGraph 在 LDBC-SNB 标准测试中仍是世界纪录保持者，支持 TB 级别数据的存储与计算，能够有效帮助用户在复杂数据关系中提取有价值的信息。\n\n## 开源开放，共建发展\n\n我们于 2023 年 9 月在 GitHub 上开源了 TuGraph 中的单机版图数据库和离线图分析引擎 TuGraph Compute，分布式图数据库和流式图计算包含在商业化版本中。\n\n## TuGraph 开源版特色\n\n- **处理能力**：支持 TB 级别的数据，单机版易于部署。\n- **性能**：经过大量优化，LDBC-SNB 测试世界第一。\n- **易用性**：完整系统，提供导入导出工具和查询语言。\n\n## 开源版本的目标\n\n1. 提供免费图数据库产品，让更多人使用。\n2. 促进图数据库标准形成，降低学习成本。\n3. 优化基础研究性问题，为研究提供比较基线。\n\n## TuGraph 企业版特色\n\n商业版本包含分布式图数据库、离线计算引擎和流式图计算功能。提供私有化部署和云上部署方案。\n\n## 总结\n\n蚂蚁在图计算方面投入了大量资源，已在众多业务场景中磨练出完整的体系。我们已在 GitHub 上开源了单机版（https://github.com/TuGraph-family), 同时提供企业版以满足不同用户需求。\n\n该内容段落位于文档的结尾部分，概述了TuGraph的技术优势、开源情况及特点，包括LDBC-SNB测试的世界纪录、开源版本的目标和企业版特色，总结了蚂蚁在图计算领域的投入及产品可供用户选择的多样性。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_155.md",
        "chunks": [
            {
                "content": "# 蚂蚁开源图数据库 TuGraph-DB 升级到 v4.0，全新支持 GQL 国际标准查询语言\n\n在2022年9月的世界人工智能大会上，蚂蚁自研图数据库TuGraph-DB正式开源。正值开源一周年之际，迎来了开源TuGraph-DB v4.0版，期间经历了10次重要迭代，重大更新的功能包括云上部署、POG（Procedure On Graph query language）、Python算法接口、图学习引擎、高可用、ISO GQL等，在功能完备性、上手易用性、设计先进性等方面做了大量的工作。\n\nTuGraph-DB v4.0主要支持了ISO GQL国际标准查询语言、企业级高可用能力以及图学习引擎。\n\n## TuGraph-DB v4.0 核心新功能介绍\n\n1. **ISO GQL**\n\n   关系型图数据库之所以能够顺利发展，一个重要的原因是标准化查询语言SQL的广泛使用，既降低了数据库用户的操作门槛，同时抹平了不同数据库间的实现细节，形成了分工合作的生态。\n\n   GQL（Graph Query Language）是一种用于图查询语言的国际标准，是图数据库领域的“SQL”，参与方包括国际标准机构、高校、图数据库厂商、非盈利组织等，是图生态中非常重要的一环。\n\n   新版本遵循GQL的最新标准，在查询引擎进行了支持，为用户提供了丰富多样的查询语言选择，也对图数据库领域查询语言的标准化起到了推动作用。\n\n2. **企业级高可用**\n\n   TuGraph-DB开源了企业级高可用能力，能够实现多活热备。支持用户便捷使用客户端来操作高可用功能，自动负载均衡，数据库不需要额外配置就可以支持更高的读负载。\n\n   在TuGraph-DB高可用集群模式中，服务器中有一个leader和多个follower，可以并发提供读写能力。在任一单个节点故障时，基于RAFT协议可以秒级切换leader，持续为业务提供读写服务，RPO=0，RTO<10秒。\n\n   TuGraph-DB高可用后续还将支持Witness、Learner等更多的功能角色。\n\n3. **图学习引擎**\n\n该文档介绍了蚂蚁公司开源的图数据库TuGraph-DB的最新版本v4.0，重点强调其新功能，包括对ISO GQL国际标准查询语言的支持、企业级高可用性以及集成图学习引擎。这一更新旨在提升数据库的功能性、易用性和设计质量，同时促进图数据库领域的标准化进程。"
            },
            {
                "content": "GQL（Graph Query Language）是一种用于图查询语言的国际标准，是图数据库领域的“SQL”，参与方包括国际标准机构、高校、图数据库厂商、非盈利组织等，是图生态中非常重要的一环。\n\n   新版本遵循GQL的最新标准，在查询引擎进行了支持，为用户提供了丰富多样的查询语言选择，也对图数据库领域查询语言的标准化起到了推动作用。\n\n2. **企业级高可用**\n\n   TuGraph-DB开源了企业级高可用能力，能够实现多活热备。支持用户便捷使用客户端来操作高可用功能，自动负载均衡，数据库不需要额外配置就可以支持更高的读负载。\n\n   在TuGraph-DB高可用集群模式中，服务器中有一个leader和多个follower，可以并发提供读写能力。在任一单个节点故障时，基于RAFT协议可以秒级切换leader，持续为业务提供读写服务，RPO=0，RTO<10秒。\n\n   TuGraph-DB高可用后续还将支持Witness、Learner等更多的功能角色。\n\n3. **图学习引擎**\n\n   TuGraph-DB v4.0深度集成了图学习引擎，兼容DGL、PyG等常见图学习框架。TuGraph-DB提供两种典型的图采样算子，包括对最新数据进行实时图采样，和基于快照进行批量图采用。学习引擎的实时图采样和查询引擎的图查询使用同一份存储数据。TuGraph-DB用户能够在图数据库上直接进行图学习训练。\n\n   用图数据库作为图学习引擎的后端，最显著的一个优势是可以支持充分利用硬盘空间，即图学习涉及的数据不用全部放到内存。相比较传统的大数据引擎的解决方案（比如Spark），TuGraph-DB的图学习引擎可以在单机进行超大规模的图学习，大大降低了部署成本。\n\n## 结语\n\n在过去的一年里，不论是接口的丰富性还是学习引擎的支持，TuGraph-DB都致力于在简单易用性和功能完备性方面取得更好的表现。在未来的规划中，TuGraph-DB将持续进行架构演进，努力打造更活跃的图生态。\n\n该文本块主要介绍了蚂蚁开源图数据库TuGraph-DB v4.0中的核心新功能，包括ISO GQL国际标准查询语言的支持、企业级高可用能力以及图学习引擎的集成。这些功能的说明紧接在对ISO GQL的介绍后，强调了这些更新如何提升数据库的查询能力和用户体验，同时为后续的企业级应用和图学习提供支持。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_156.md",
        "chunks": [
            {
                "content": "# 2023开放原子全球开源峰会，蚂蚁图计算平台开源业内首个工业级流图计算引擎\n\n6月11日，2023开放原子全球开源峰会在北京开幕。本次峰会以“开源赋能，普惠未来”为主题。在高峰论坛上，蚂蚁技术研究院院长、图计算负责人陈文光宣布开源 TuGraph 图计算平台核心成员——工业级流式图计算引擎 TuGraph Analytics。\n\n去年9月，蚂蚁集团开源了 TuGraph 图计算平台中的图数据库 TuGraph DB。这次开源是 TuGraph 图计算平台的又一次开源升级，进一步加大了蚂蚁在图计算基础软件领域的开放力度，也是通过开放协同促进科技创新的实际行动。\n\n图（Graph）是一种抽象的数据结构，由顶点和边构成。图计算是一种以图结构建模的算法模型，可对大规模数据进行关系挖掘和复杂计算，实现知识推理和事件溯源。图计算目前已广泛应用在金融、政务、医疗等领域，备受全球研发机构和顶尖科技公司关注。流式图计算是一种将流式计算和图计算结合的交叉创新，融合了流式计算的高度实效性和图计算的灵活性，攻坚难度极高。据了解，蚂蚁从2015年开始探索图计算，布局了图数据库、流式图计算引擎、图学习等相关技术，打造了世界规模领先的图计算集群，于业界首创了工业级流式图计算引擎，多次问鼎图数据库行业权威测试 LDBC 世界冠军并保持世界纪录。此次开源的工业级流式图计算引擎是蚂蚁从2017年开始布局打造，经过五年多工业级应用大考，流式图计算做到了在千亿数据规模的“图”上秒级延迟计算，是蚂蚁风控的核心基础技术，成功解决了金融场景风险分析难、识别率低、时效性差等业界难题。\n\n该文档报道了2023开放原子全球开源峰会的召开，重点介绍了蚂蚁集团在图计算领域的最新开源进展，包括开源工业级流式图计算引擎TuGraph Analytics，以及该技术在金融等领域的重要应用和发展背景。"
            },
            {
                "content": "图（Graph）是一种抽象的数据结构，由顶点和边构成。图计算是一种以图结构建模的算法模型，可对大规模数据进行关系挖掘和复杂计算，实现知识推理和事件溯源。图计算目前已广泛应用在金融、政务、医疗等领域，备受全球研发机构和顶尖科技公司关注。流式图计算是一种将流式计算和图计算结合的交叉创新，融合了流式计算的高度实效性和图计算的灵活性，攻坚难度极高。据了解，蚂蚁从2015年开始探索图计算，布局了图数据库、流式图计算引擎、图学习等相关技术，打造了世界规模领先的图计算集群，于业界首创了工业级流式图计算引擎，多次问鼎图数据库行业权威测试 LDBC 世界冠军并保持世界纪录。此次开源的工业级流式图计算引擎是蚂蚁从2017年开始布局打造，经过五年多工业级应用大考，流式图计算做到了在千亿数据规模的“图”上秒级延迟计算，是蚂蚁风控的核心基础技术，成功解决了金融场景风险分析难、识别率低、时效性差等业界难题。\n\n图计算是下一代人工智能关键核心技术。中国工程院院士郑纬民曾指出，“高性能图计算是当前全球人工智能竞争的战略性制高点，我们要加快攻克技术、突破产业瓶颈，防止在高性能图计算这一关键技术领域再被卡脖子”。而开源是共享科技成果，加速先进技术落地的最快路径。陈文光强调，开源是蚂蚁的核心技术战略，也是面向数字化未来可持续创新的动力。此次流式图计算引擎开源，是延续蚂蚁开源核心基础技术的实际动作，希望通过开放成熟的图计算技术，服务更广阔的数字化产业，向世界输出中国科技公司的前沿技术影响力。未来，蚂蚁集团也愿意携手行业伙伴共同突破技术创新，繁荣开源生态。据了解，蚂蚁开源聚焦于数据库、云原生、中间件等基础软件领域，积累了近100个社区头部开源项目、近1600个开源仓库、9大核心开源项目，如“2022世界人工智能大会镇馆之宝”隐语隐私计算技术栈、分布式数据库 OceanBase、行业首个通过商用密码产品认证的密码学技术“铜锁”等自研核心技术。\n\n该段落详细介绍了图计算和流式图计算的概念、应用及其在蚂蚁集团的技术布局，阐述了流式图计算引擎的开发历程以及其在金融领域的应用价值，同时强调开源的重要性及蚂蚁集团在开源生态中的贡献。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_157.md",
        "chunks": [
            {
                "content": "# 技术解读 | TuGraph 图分析引擎技术剖析\n\n图分析引擎又称图计算框架，主要用于进行复杂图分析，是一种能够全量数据集运行快速循环迭代的技术，适用场景包括社区发现、基因序列预测、重要性排名等，典型算法有 PageRank、WCC、BFS、LPA、SSSP。\n\nTuGraph 图数据管理平台社区版已于 2022 年 9 月在 Github 开源，本文将对 TuGraph 图分析引擎的技术进行剖析。\n\n## 1 TuGraph 图分析引擎概览\n\nTuGraph 的图分析引擎面向的场景主要是全图/全量数据分析类的任务。借助 TuGraph 的 C++ 图分析引擎 API，用户可以对不同数据来源的图数据快速导出一个待处理的复杂子图，然后在该子图上运行诸如 BFS、PageRank、LPA、WCC 等迭代式图算法，最后根据运行结果做出相应的对策。在 TuGraph 中，导出和计算过程均可以通过在内存中并行处理的方式进行加速，从而达到近乎实时的处理分析。与传统方法相比，即避免了数据导出落盘的开销，又能使用紧凑的图数据结构获得计算的理想性能。\n\n根据数据来源及实现不同，可分为 **Procedure**、**Embed** 和 **Standalone** 三种运行模式。其中，Procedure 模式和 Embed 模式的数据源是图存储中加载图数据，分别适用于 Client/Server 部署，以及服务端直接调用，后者多用于调试。\n\nStandalone 模式的数据源是 TXT、二进制、ODPS 文件等外部数据源，能够独立于图数据存储直接运行分析算法。\n\nTuGraph 图计算系统社区版内置 6 个基础算法，商业版内置了共 34 种算法，涵盖了图结构、社区发现、路径查询、重要性分析、模式挖掘和关联性分析的六大类常用方法，可以满足多种业务场景需要，因此用户几乎不需要自己实现具体的图计算过程。\n\n该文档对 TuGraph 图分析引擎进行技术剖析，介绍了引擎的功能、运行模式及内置算法，重点在于如何利用该引擎进行复杂图数据的分析和处理，适用于多种业务场景。"
            },
            {
                "content": "| 算法类型               | 中文算法名                      | 英文算法名                           | 程序名                   |\n|----------------------|-----------------------------|-----------------------------------|-----------------------|\n| 路径查询               | 广度优先搜索                  | Breadth-First Search              | bfs                   |\n|                       | 单源最短路径                  | Single-Source Shortest Paths      | sssp                  |\n|                       | 全对最短路径                  | All-Pair Shortest Path            | apsp                  |\n|                       | 多源最短路径                  | Multiple-source Shortest Paths     | mssp                  |\n|                       | 两点间最短路径                | Single-Pair Shortest Paths        | psp                   |\n| 重要性分析            | 网页排序                       | Pagerank                          | pagerank              |\n|                       | 介数中心度                    | Betweenness Centrality            | bc                    |\n\n该片段包含了 TuGraph 图分析引擎内置的算法类型及其对应的中文名、英文名和程序名，主要集中在路径查询和重要性分析两大类算法，为用户在进行图数据分析时提供了具体的算法选择和调用信息。"
            },
            {
                "content": "|                       | 多源最短路径                  | Multiple-source Shortest Paths     | mssp                  |\n|                       | 两点间最短路径                | Single-Pair Shortest Paths        | psp                   |\n| 重要性分析            | 网页排序                       | Pagerank                          | pagerank              |\n|                       | 介数中心度                    | Betweenness Centrality            | bc                    |\n|                       | 置信度传播                    | Belief Propagation                | bp                    |\n|                       | 距离中心度                    | Closeness Centrality              | clc                   |\n|                       | 个性化网页排序                | Personalized PageRank             | ppr                   |\n|                       | 带权重的网页排序              | Weighted Pagerank Algorithm       | wpagerank             |\n|                       | 信任指数排名                  | Trustrank                         | trustrank             |\n\n该内容片段位于第二部分\"功能介绍\"的算法列表中，详细列出了TuGraph图分析引擎内置的路径查询和重要性分析相关的算法，包括它们的中文名称、英文名称及程序标识，以便用户选择和理解不同的图算法。"
            },
            {
                "content": "|                       | 距离中心度                    | Closeness Centrality              | clc                   |\n|                       | 个性化网页排序                | Personalized PageRank             | ppr                   |\n|                       | 带权重的网页排序              | Weighted Pagerank Algorithm       | wpagerank             |\n|                       | 信任指数排名                  | Trustrank                         | trustrank             |\n|                       | 超链接主题搜索                | Hyperlink-Induced Topic Search    | hits                  |\n| 关联性分析            | 平均集聚系数                  | Local Clustering Coefficient      | lcc                   |\n|                       | 共同邻居                      | Common Neighborhood                | cn                    |\n|                       | 度数关联度                    | Degree Correlation                 | dc                    |\n|                       | 杰卡德系数                    | Jaccard Index                      | ji                    |\n\n该块内容位于文档的第二部分，主要列出TuGraph图分析引擎中“重要性分析”和“关联性分析”算法类型的具体列表，包括相应的中文名称、英文名称和程序标识，为用户选择和理解不同算法提供参考。"
            },
            {
                "content": "| 关联性分析            | 平均集聚系数                  | Local Clustering Coefficient      | lcc                   |\n|                       | 共同邻居                      | Common Neighborhood                | cn                    |\n|                       | 度数关联度                    | Degree Correlation                 | dc                    |\n|                       | 杰卡德系数                    | Jaccard Index                      | ji                    |\n| 图结构                | 直径估计                      | Dimension Estimation               | de                    |\n|                       | K核算法                      | K-core                             | kcore                 |\n|                       | k阶团计数算法                | Kcliques                          | kcliques              |\n|                       | k阶桁架计数算法              | Ktruss                            | ktruss                |\n|                       | 最大独立集算法                | Maximal independent set           | mis                   |\n\n该内容为TuGraph图分析引擎中关联性分析和图结构类别下的算法列表，详细列出了各个算法的中文名称、英文名称及程序标识，旨在为用户提供参考，以便在进行图分析时选择合适的算法。此部分位于第二章的算法介绍中，展示了引擎内置的各种图计算算法。"
            },
            {
                "content": "|                       | K核算法                      | K-core                             | kcore                 |\n|                       | k阶团计数算法                | Kcliques                          | kcliques              |\n|                       | k阶桁架计数算法              | Ktruss                            | ktruss                |\n|                       | 最大独立集算法                | Maximal independent set           | mis                   |\n| 社区发现              | 弱连通分量                    | Weakly Connected Components        | wcc                   |\n|                       | 标签传播                      | Label Propagation Algorithm       | lpa                   |\n|                       | EgoNet算法                   | EgoNet                            | en                    |\n|                       | 鲁汶社区发现                  | Louvain                           | louvain               |\n|                       | 强连通分量                    | Strongly Connected Components      | scc                   |\n\n该片段位于文档第二部分，内容涉及TuGraph图分析引擎内置的多种图算法，具体列出了图结构和社区发现类别下的算法名称，包括K核算法、k阶团计数算法、k阶桁架计数算法、最大独立集算法及相关社区发现算法。这些信息帮助用户了解可用于图分析的具体算法及其对应的程序标识。"
            },
            {
                "content": "|                       | 标签传播                      | Label Propagation Algorithm       | lpa                   |\n|                       | EgoNet算法                   | EgoNet                            | en                    |\n|                       | 鲁汶社区发现                  | Louvain                           | louvain               |\n|                       | 强连通分量                    | Strongly Connected Components      | scc                   |\n|                       | 监听标签传播                  | Speaker-listener Label Propagation | lpa                   |\n|                       | 莱顿算法                      | Leiden                            | leiden                |\n|                       | 带权重的标签传播              | Weighted Label Propagation Algorithm | wlpa                  |\n| 模式挖掘              | 三角计数                      | Triangle Counting                  | triangle              |\n|                       | 子图匹配算法                  | Subgraph Isomorphism              | subgraph_isomorphism   |\n\n该块内容位于第二部分的算法列表中，具体列出了图分析引擎中与社区发现和模式挖掘相关的算法及其中文、英文名称和程序标识，属于对可用算法的详细分类和说明。"
            },
            {
                "content": "|                       | 莱顿算法                      | Leiden                            | leiden                |\n|                       | 带权重的标签传播              | Weighted Label Propagation Algorithm | wlpa                  |\n| 模式挖掘              | 三角计数                      | Triangle Counting                  | triangle              |\n|                       | 子图匹配算法                  | Subgraph Isomorphism              | subgraph_isomorphism   |\n|                       | 模式匹配算法                  | Motif                             | motif                 |\n表格内容描述: \n该表格包含四列，分别是“算法类型”、“中文算法名”、“英文算法名”和“程序名”。根据这些列名，可以看出表格主要是列出不同算法的种类及其对应的名称和程序标识。\n\n该块内容位于文档的第二部分，主要列出和描述 TuGraph 图分析引擎中的各类算法，特别强调了与模式挖掘相关的算法及其对应的名称和程序标识，为用户提供了选择合适算法的参考。"
            },
            {
                "content": "- 第一行的“路径查询”下有五种算法：\n  1. 广度优先搜索（Breadth-First Search），程序名为bfs\n  2. 单源最短路径（Single-Source Shortest Paths），程序名为sssp\n  3. 全对最短路径（All-Pair Shortest Path），程序名为apsp\n  4. 多源最短路径（Multiple-source Shortest Paths），程序名为mssp\n  5. 两点间最短路径（Single-Pair Shortest Paths），程序名为psp\n\n- 第二行的“重要性分析”下有八种算法：\n  1. 网页排序（Pagerank），程序名为pagerank\n  2. 介数中心度（Betweenness Centrality），程序名为bc\n  3. 置信度传播（Belief Propagation），程序名为bp\n  4. 距离中心度（Closeness Centrality），程序名为clc\n  5. 个性化网页排序（Personalized PageRank），程序名为ppr\n  6. 带权重的网页排序（Weighted Pagerank Algorithm），程序名为wpagerank\n  7. 信任指数排名（Trustrank），程序名为trustrank\n  8. 超链接主题搜索（Hyperlink-Induced Topic Search），程序名为hits\n\n- 第三行的“关联性分析”下有四种算法：\n  1. 平均集聚系数（Local Clustering Coefficient），程序名为lcc\n  2. 共同邻居（Common Neighborhood），程序名为cn\n  3. 度数关联度（Degree Correlation），程序名为dc\n  4. 杰卡德系数（Jaccard Index），程序名为ji\n\n- 第四行的“图结构”下有五种算法：\n  1. 直径估计（Dimension Estimation），程序名为de\n  2. K核算法（K-core），程序名为kcore\n  3. k阶团计数算法（Kcliques），程序名为kcliques\n  4. k阶桁架计数算法（Ktruss），程序名为ktruss\n  5. 最大独立集算法（Maximal independent set），程序名为mis\n\n该段落旨在详细列出 TuGraph 图分析引擎内置的多种算法，以便用户了解可用的算法类型及其对应的名称和程序标识，方便在进行图分析任务时选择合适的算法。此信息位于关于算法分类的部分，属于 TuGraph 图分析引擎功能介绍的一个重要组成部分。"
            },
            {
                "content": "- 第三行的“关联性分析”下有四种算法：\n  1. 平均集聚系数（Local Clustering Coefficient），程序名为lcc\n  2. 共同邻居（Common Neighborhood），程序名为cn\n  3. 度数关联度（Degree Correlation），程序名为dc\n  4. 杰卡德系数（Jaccard Index），程序名为ji\n\n- 第四行的“图结构”下有五种算法：\n  1. 直径估计（Dimension Estimation），程序名为de\n  2. K核算法（K-core），程序名为kcore\n  3. k阶团计数算法（Kcliques），程序名为kcliques\n  4. k阶桁架计数算法（Ktruss），程序名为ktruss\n  5. 最大独立集算法（Maximal independent set），程序名为mis\n\n- 第五行的“社区发现”下有八种算法：\n  1. 弱连通分量（Weakly Connected Components），程序名为wcc\n  2. 标签传播（Label Propagation Algorithm），程序名为lpa\n  3. EgoNet算法（EgoNet），程序名为en\n  4. 鲁汶社区发现（Louvain），程序名为louvain\n  5. 强连通分量（Strongly Connected Components），程序名为scc\n  6. 监听标签传播（Speaker-listener Label Propagation），程序名为lpa\n  7. 莱顿算法（Leiden），程序名为leiden\n  8. 带权重的标签传播（Weighted Label Propagation Algorithm），程序名为wlpa\n\n- 第六行的“模式挖掘”下有三种算法：\n  1. 三角计数（Triangle Counting），程序名为triangle\n  2. 子图匹配算法（Subgraph Isomorphism），程序名为subgraph_isomorphism\n  3. 模式匹配算法（Motif），程序名为motif\n\n总结：该表格全面列出了多种图算法，分为路径查询、重要性分析、关联性分析、图结构、社区发现及模式挖掘六大类，涵盖了各种算法的中文名、英文名及其对应的程序标识，便于读者了解和选择合适的算法。\n\n\n## 2 功能介绍\n\n该段落位于文档的第二部分“功能介绍”之前，详细列出了TuGraph图分析引擎的各类算法，涵盖关联性分析、图结构、社区发现和模式挖掘等六大类，旨在帮助用户了解不同算法的名称及其功能。"
            },
            {
                "content": "- 第六行的“模式挖掘”下有三种算法：\n  1. 三角计数（Triangle Counting），程序名为triangle\n  2. 子图匹配算法（Subgraph Isomorphism），程序名为subgraph_isomorphism\n  3. 模式匹配算法（Motif），程序名为motif\n\n总结：该表格全面列出了多种图算法，分为路径查询、重要性分析、关联性分析、图结构、社区发现及模式挖掘六大类，涵盖了各种算法的中文名、英文名及其对应的程序标识，便于读者了解和选择合适的算法。\n\n\n## 2 功能介绍\n\n### 2.1 图分析框架\n\n图分析框架作为图分析引擎的“骨架”，可以联合多种模块有效的耦合协同工作。一般分为预处理、算法过程、结果分析三个阶段。\n\n预处理部分用于读入数据及参数进行图构建及相关信息的存储统计，并整理出算法过程所需的参数及数据。\n\n算法过程会根据得到的数据通过特定的算法进行逻辑计算，并得到结果数据。 结果分析部分根据得到的结果数据进行个性化处理（如取最值等），并将重要的信息写回和打印输出操作。\n\n### 2.2 点边筛选器\n\n点边筛选器作用于图分析引擎中的 Procedure 和 Embed 模式。对于图存储数据源可根据用户需要和实际业务场景对图数据进行筛查，选择有效的点边进行图结构的构建。\n\n### 2.3 一致性快照\n\nTuGraph 中的 Procedure 和 Embed 模式能够提供数据“快照”，即建立一个对指定数据集的完全可用拷贝，该拷贝包括相应数据在某个时间点（拷贝开始的时间点）的镜像。由于 OLAP 的操作仅涉及读操作而不涉及写操作，OlapOnDB 会以一种更紧凑的方式对数据进行排布，在节省空间的同时，提高数据访问的局部性。\n\n### 2.4 块状读写模块\n\n块状读写模块作用于图分析引擎中的 Standalone 模式，用于对不同外部数据源的数据进行高效读入，同时也包含对内部算法处理后的图数据结果写回。\n\n### 2.5 参数模块\n\n参数模块作用于分析引擎中的 Standalone 模式，用于对图的一般信息（如数据来源、算法名称、数据输入、输出路径、顶点个数等）以及根据不同数据来源、不同算法所配置的不同信息参数进行接受和整理，传输给图算法及各个模块，同时将最终结果模块化展示。\n\n## 3 使用示例\n\n该文本块位于文档的第二部分，主要介绍了TuGraph图分析引擎的核心功能和结构，特别是各种图算法的分类和用途，之后详细描述了图分析框架的工作流程、相关模块功能及如何有效利用这些工具进行图数据分析。"
            },
            {
                "content": "点边筛选器作用于图分析引擎中的 Procedure 和 Embed 模式。对于图存储数据源可根据用户需要和实际业务场景对图数据进行筛查，选择有效的点边进行图结构的构建。\n\n### 2.3 一致性快照\n\nTuGraph 中的 Procedure 和 Embed 模式能够提供数据“快照”，即建立一个对指定数据集的完全可用拷贝，该拷贝包括相应数据在某个时间点（拷贝开始的时间点）的镜像。由于 OLAP 的操作仅涉及读操作而不涉及写操作，OlapOnDB 会以一种更紧凑的方式对数据进行排布，在节省空间的同时，提高数据访问的局部性。\n\n### 2.4 块状读写模块\n\n块状读写模块作用于图分析引擎中的 Standalone 模式，用于对不同外部数据源的数据进行高效读入，同时也包含对内部算法处理后的图数据结果写回。\n\n### 2.5 参数模块\n\n参数模块作用于分析引擎中的 Standalone 模式，用于对图的一般信息（如数据来源、算法名称、数据输入、输出路径、顶点个数等）以及根据不同数据来源、不同算法所配置的不同信息参数进行接受和整理，传输给图算法及各个模块，同时将最终结果模块化展示。\n\n## 3 使用示例\n\n由前文所述可知，图分析引擎分为 Standalone、Embed 和 Procedure 模式，现在以 BFS 算法为例分别介绍它们的使用方式。\n\n### 3.1 Procedure 模式\n\nProcedure 模式主要用于 Client/Server 的 TuGraph 运行时，图算法的加载和调用。在 TuGraph/plugins 目录下执行以下命令即可在 TuGraph/plugins 目录下得到 bfs.so 文件：\n\n```bash\nbash make_so.sh bfs\n```\n\n将该文件以插件形式上传至 TuGraph-web，输入参数后即可执行。\n\n#### 示例\n\n在 TuGraph/plugins 编译.so 算法文件\n\n```bash\nbash make_so.sh bfs\n```\n\n将 bfs.so 文件以插件形式加载至 TuGraph-web 后，输入如下 JSON 参数：\n\n```json\n{\n\t\"root_id\": \"0\",\n\t\"label\": \"node\",\n\t\"field\": \"id\"\n}\n```\n\n即可得到返回结果。\n\n该块内容位于文档的第二部分“功能介绍”，主要描述了图分析引擎中的几个模块，包括点边筛选器、一致性快照、块状读写模块和参数模块，进一步阐述了这些模块在不同运行模式下的作用与功能，为后续使用示例部分（第3部分）提供基础。"
            },
            {
                "content": "## 3 使用示例\n\n由前文所述可知，图分析引擎分为 Standalone、Embed 和 Procedure 模式，现在以 BFS 算法为例分别介绍它们的使用方式。\n\n### 3.1 Procedure 模式\n\nProcedure 模式主要用于 Client/Server 的 TuGraph 运行时，图算法的加载和调用。在 TuGraph/plugins 目录下执行以下命令即可在 TuGraph/plugins 目录下得到 bfs.so 文件：\n\n```bash\nbash make_so.sh bfs\n```\n\n将该文件以插件形式上传至 TuGraph-web，输入参数后即可执行。\n\n#### 示例\n\n在 TuGraph/plugins 编译.so 算法文件\n\n```bash\nbash make_so.sh bfs\n```\n\n将 bfs.so 文件以插件形式加载至 TuGraph-web 后，输入如下 JSON 参数：\n\n```json\n{\n\t\"root_id\": \"0\",\n\t\"label\": \"node\",\n\t\"field\": \"id\"\n}\n```\n\n即可得到返回结果。\n\n```json\n{\n  \"core_cost\": 0.013641119003295898,\n  \"found_vertices\": 3829,\n  \"num_edges\": 88234,\n  \"num_vertices\": 4039,\n  \"output_cost\": 8.821487426757813e-06,\n  \"prepare_cost\": 0.03479194641113281,\n  \"total_cost\": 0.04844188690185547\n}\n```\n\n#### 输出内容解释：\n- `num_edges`：表示该图数据的边数量\n- `num_vertices`：表示该图数据顶点的数量\n- `prepare_cost`：表示预处理阶段所需要的时间。\n- `core_cost`：表示算法运行所需要的时间。\n- `found_vertices`：表示查找到顶点的个数。\n- `output_cost`：表示算法结果写回 db 所需要的时间。\n- `total_cost`：表示执行该算法整体运行时间。\n\n### 3.2 Embed 模式\n\n该文档主要介绍 TuGraph 图分析引擎的技术架构、功能及使用示例。第三部分的内容针对图分析引擎的三种运行模式（Standalone、Embed 和 Procedure），详细说明了以 BFS 算法为例的实际使用方式，包括如何加载算法、输入参数及解释返回结果。"
            },
            {
                "content": "即可得到返回结果。\n\n```json\n{\n  \"core_cost\": 0.013641119003295898,\n  \"found_vertices\": 3829,\n  \"num_edges\": 88234,\n  \"num_vertices\": 4039,\n  \"output_cost\": 8.821487426757813e-06,\n  \"prepare_cost\": 0.03479194641113281,\n  \"total_cost\": 0.04844188690185547\n}\n```\n\n#### 输出内容解释：\n- `num_edges`：表示该图数据的边数量\n- `num_vertices`：表示该图数据顶点的数量\n- `prepare_cost`：表示预处理阶段所需要的时间。\n- `core_cost`：表示算法运行所需要的时间。\n- `found_vertices`：表示查找到顶点的个数。\n- `output_cost`：表示算法结果写回 db 所需要的时间。\n- `total_cost`：表示执行该算法整体运行时间。\n\n### 3.2 Embed 模式\n\n该种方式主要用于TuGraph在后台程序中对预加载的图存储数据进行算法分析，多用于快速调试。在TuGraph/plugins目录下对embed_main.cpp文件完善，补充数据名称、输入参数、数据路径等信息，示例如下：\n\n#### C++ 示例代码\n\n以下是一个使用 TuGraph 数据库的 C++ 示例代码，展示如何打开数据库并处理请求。\n\n```cpp\n#include \n#include \"lgraph/lgraph.h\"\n#include \"lgraph/olap_base.h\"\n\nusing namespace std;\n\nextern \"C\" bool Process(lgraph_api::GraphDB &db, const std::string &request, std::string &response);\n\n该段落位于第三部分 \"3. 使用示例\" 中，主要介绍了 TuGraph 图分析引擎在不同运行模式下的应用示例。具体来说，这部分展示了 Procedure 模式中的 BFS 算法运行结果及相关输出内容解释，并segue至 Embed 模式，说明了该模式在后台程序中对图存储数据进行分析的使用方法和示例代码。"
            },
            {
                "content": "### 3.2 Embed 模式\n\n该种方式主要用于TuGraph在后台程序中对预加载的图存储数据进行算法分析，多用于快速调试。在TuGraph/plugins目录下对embed_main.cpp文件完善，补充数据名称、输入参数、数据路径等信息，示例如下：\n\n#### C++ 示例代码\n\n以下是一个使用 TuGraph 数据库的 C++ 示例代码，展示如何打开数据库并处理请求。\n\n```cpp\n#include \n#include \"lgraph/lgraph.h\"\n#include \"lgraph/olap_base.h\"\n\nusing namespace std;\n\nextern \"C\" bool Process(lgraph_api::GraphDB &db, const std::string &request, std::string &response);\n\nint main(int argc, char **argv) {\n    // db_path表示预加载图数据存放的路径\n    std::string db_path = \"./fb_db/\";\n    \n    if (argc > 1) {\n        db_path = argv[1];\n    }\n    \n    lgraph_api::Galaxy g(db_path);\n    g.SetCurrentUser(\"admin\", \"730TuGraph\");\n    // 指定图数据的名称\n    lgraph_api::GraphDB db = g.OpenGraph(\"fb_db\");\n    \n    std::string resp;\n    // 以json形式输入算法参数\n    bool r = Process(db, \"{\\\"root_id\\\": \\\"0\\\", \\\"label\\\": \\\"node\\\", \\\"field\\\": \\\"id\\\"}\", resp);\n    \n    cout << r << endl;\n    cout << resp << endl;\n    \n    return 0;\n}\n\n该文档主要介绍了 TuGraph 图分析引擎的技术细节及其应用，特别是在图数据管理和复杂图分析方面。第 3 节提供了不同运行模式的使用示例，其中 3.2 节 specifically 介绍了 Embed 模式，用于在后台对预加载的图存储数据进行算法分析，并给出了相应的 C++ 示例代码，展示如何打开数据库并处理算法请求。"
            },
            {
                "content": "保存后在TuGraph/plugins目录下执行 bash make_so.sh bfs 即可在TuGraph/plugins/cpp目录下的到bfs_procedure文件，bash make_embed.sh bfs\n\n在TuGraph/plugins文件夹下执行./cpp/bfs_procedure即可得到返回结果。\n\n```json\n{\"root_id\":\"0\", \"label\":\"node\", \"field\":\"id\"}\n```\n\nfound_vertices = 3829\n\n```json\n{\n    \"core_cost\": 0.025603055953979492,\n    \"found_vertices\": 3829,\n    \"num_edges\": 88234,\n    \"num_vertices\": 4039,\n    \"output_cost\": 9.059906005859375e-06,\n    \"prepare_cost\": 0.056738853454589844,\n    \"total_cost\": 0.0823509693145752\n}\n```\n\n### 3.3 Standalone 模式\n\n该片段位于文章的第三部分“使用示例”中，具体介绍了 TuGraph 图分析引擎的 Embed 模式使用方法，包括如何编译和运行 BFS 算法的示例，以及返回结果的解释。接下来将接入关于 Standalone 模式的内容。"
            },
            {
                "content": "found_vertices = 3829\n\n```json\n{\n    \"core_cost\": 0.025603055953979492,\n    \"found_vertices\": 3829,\n    \"num_edges\": 88234,\n    \"num_vertices\": 4039,\n    \"output_cost\": 9.059906005859375e-06,\n    \"prepare_cost\": 0.056738853454589844,\n    \"total_cost\": 0.0823509693145752\n}\n```\n\n### 3.3 Standalone 模式\n\nStandalone 模式可以独立于图存储运行，直接从文本文件或 ODPS 读取 Edgelist 形式的图数据。在 TuGraph/build 目录下执行 make bfs_standalone 即可得到 bfs_standalone 文件,该文件生成与 TuGraph/build/output/algo 文件夹下。运行：在 TuGraph/build 目录下执行./output/algo/bfs_standalone -–type [type] –-input_dir [input_dir] -–vertices [vertices] --root [root] –-output_dir [output_dir]\n\t•[type]：表示输入图文件的类型来源，包含 text 文本文件、BINARY_FILE 二进制文件和 ODPS 源。\n\t•[input_dir]：表示输入图文件的文件夹路径，文件夹下可包含一个或多个输入文件。TuGraph 在读取输入文件时会读取[input_dir]下的所有文件，要求[input_dir]下只能包含输入文件，不能包含其它文件。参数不可省略。\n\t•[vertices]：表示图的顶点个数，为 0 时表示用户希望系统自动识别顶点数量；为非零值时表示用户希望自定义顶点个数，要求用户自定义顶点个数需大于最大的顶点 ID。参数可省略，默认值为 0。\n\t•[root]：表示进行 bfs 的起始顶点 id。参数不可省略。\n\t•[output_dir]：表示输出数据保存的文件夹路径，将输出内容保存至该文件中，参数不可省略。\n\n示例：在 TuGraph/build 编译 standalone 算法程序\n\n该文档对 TuGraph 图分析引擎的技术进行详细剖析，介绍了其概述、功能、使用示例及操作模式。本段落位于使用示例部分，具体介绍了 Standalone 模式的操作步骤和性能输出，展示了如何独立于图存储读取并处理 Edgelist 形式的图数据，以及相关的算法运行结果。"
            },
            {
                "content": "示例：在 TuGraph/build 编译 standalone 算法程序\n\nmake bfs_standalone\n\n在 TuGraph/build/output 目录下运行 text 源文件\n\n/output/algo/bfs_standalone --type text --\ninput_dir ../test/integration/data/algo/fb_unweighted --root 0\n\n得到运行结果：\n\n- **prepare_cost**: 0.10 s\n- **core_cost**: 0.02 s\n- **found_vertices**: 3829\n- **output_cost**: 0.00 s\n- **total_cost**: 0.11 s\n**DONE.**\n\n\n结果参数解释同上。\n\n## 4 小结\n\n综上，图分析引擎可以高效、快速地处理多种来源的数据，其并行的图构建方式保证了内存占用小的特点。此外，图分析引擎也具有易于安装部署、灵活性高、耦合程度低、易于上手等对用户友好的特性，可以帮助用户结合具体业务解决问题。\n\n该块内容位于文档的第3节“使用示例”，具体介绍了TuGraph图分析引擎的Standalone模式的使用方法，包括编译和运行standalone算法程序的示例代码及其结果解释，为用户展示如何独立于图存储执行图算法。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_158.md",
        "chunks": [
            {
                "content": "# 3月30日 TuGraph 社区 Meetup “图数据库智能化建设与探索”\n\nTuGraph 社区 Meetup “图数据库智能化建设与探索”在北京顺利举办，探讨大模型时代下的图数据库智能化。\n\n## 01. 技术分享｜TuGraph计算引擎模型推理系统设计与优化\n\n“虽然传统的基于迭代的算法能够解决我们现实生活中的大多数问题，但随着业务需求的不断发展和现实问题的日渐复杂化，这些算法往往难以满足某些具体的需求。尤其是当规模和维度日益增长、数据越发密集时，我们很难利用这种传统的方法去提取到更加关键的一些信息，或者说是我们从人的视角上更难理解的一些信息。因此，由于图结构在表达能力上的优势，结合机器学习分析技术，图算法近年来引起了广泛关注，并在业界落地和取得了较好的商业价值。”\n\n## 02. 技术分享｜TuGraph-DB兼容Neo4j客户端：Bolt协议设计与实现\n\n“兼容Neo4j客户端的最大优势在于生态支持。以客户端为例，Neo4j官方自身支持五种编程语言的客户端，社区又贡献了两种，共计七种语言的客户端得以直接使用。此外，还有一系列与上下游生态相接的组件，如与Apache Spark或Apache Kafka的连接，都有现成的代码可供利用。在编程框架方面，特别是Java，例如OGM（Object-Graph Mapping，对象图映射）以及一些业务开发框架，如Spring，这些所需的相关代码都已现成，无需重新编写。这种做法极大地节约了研发资源，我们可以将这些资源重新投入到提升数据库本身能力上。”\n\n## 03. 技术分享｜知识图谱语义框架SPG及图谱推理\n\n“当前，我们正处于图谱技术发展的第三阶段，这一阶段的核心是将图谱与大型模型相结合。目标转向了知识的标准化、跨领域数据的联通与复用。随着这个阶段的深入，简单地在推理过程中融入文本概念和信息，或者是加入交易与社交的实体关系，已经不能明显提升推理效果了。关键的做法应当是结合实体信息的多元素特征进行深度协作，从而更精准地关联相关性，揭示那些稀疏的实体间关系，并实现意义解释的密集化。”\n\n## 04. 技术分享｜CStore Compaction模块的设计与优化\n\n该部分内容属于关于“图数据库智能化建设与探索”的TuGraph社区Meetup会议记录，主要介绍了多项技术分享，包括TuGraph计算引擎模型推理系统设计、兼容Neo4j客户端的Bolt协议以及知识图谱语义框架SPG等，进一步探讨了图技术在大模型时代的应用和优化。"
            },
            {
                "content": "## 03. 技术分享｜知识图谱语义框架SPG及图谱推理\n\n“当前，我们正处于图谱技术发展的第三阶段，这一阶段的核心是将图谱与大型模型相结合。目标转向了知识的标准化、跨领域数据的联通与复用。随着这个阶段的深入，简单地在推理过程中融入文本概念和信息，或者是加入交易与社交的实体关系，已经不能明显提升推理效果了。关键的做法应当是结合实体信息的多元素特征进行深度协作，从而更精准地关联相关性，揭示那些稀疏的实体间关系，并实现意义解释的密集化。”\n\n## 04. 技术分享｜CStore Compaction模块的设计与优化\n\n“TuGraph Analytics本质上是一款图分析OLAP数据库。CStore作为一个单机版存储引擎，提供了坚实的存储基础。同时，RocksDB也可以作为TuGraph Analytics的存储基础。我们采用LDBC提供的通用社交网络图数据集进行了基准测试，测试涉及让TuGraph Analytics分别连结RocksDB以及我们自有版本的CStore进行分析。在同步与异步compaction（数据压缩整理）两种方式下进行了读写性能测试：同步方式意味着数据写入完成后进行compaction，完成之后再进行读性能测试；异步方式则是写入和compaction同时进行，写入完成后立即测试读性能。在这两种情境下，使用CStore的TuGraph Analytics的读性能超过了使用RocksDB的三倍以上。”\n\n## 05. 社区规划｜TuGraph 社区技术路线\n\n最后是展望未来环节，TuGraph 开源负责人范志东与大家分享了大模型时代的图计算要做些什么，包括Q2即将推出的开源数据分析工具 OSGraph，Q3即将开源的 TuGraph 研发平台 TuGraphMaker，结合大模型的“与图对话”工具 ChatTuGraph 等项目。\n\n## 06. 圆桌讨论｜图技术、图生态、图智能\n\n该文档记录了3月30日TuGraph社区 Meetup的活动内容，涵盖了多项技术分享、社区规划以及圆桌讨论，其中第03和第04部分分别讨论了知识图谱与大型模型结合的推理及CStore模块的设计与优化，展示了TuGraph在图数据库智能化和性能提升方面的探索与成果。"
            },
            {
                "content": "## 05. 社区规划｜TuGraph 社区技术路线\n\n最后是展望未来环节，TuGraph 开源负责人范志东与大家分享了大模型时代的图计算要做些什么，包括Q2即将推出的开源数据分析工具 OSGraph，Q3即将开源的 TuGraph 研发平台 TuGraphMaker，结合大模型的“与图对话”工具 ChatTuGraph 等项目。\n\n## 06. 圆桌讨论｜图技术、图生态、图智能\n\n在自由讨论环节，TuGraph 布道师戚仕鹏邀请了几位 TuGraph 的老朋友一起聊聊图技术、图生态、图智能。包括中国开源先锋人物、华为产业发展专家、Rust 技术专家马全一老师，北京大学前沿交叉学科研究院数据科学博士庞悦，蚂蚁集团知识图谱专家王少飞，以及TuGraph 开源负责人范志东。各位老师就为什么开源、图技术的未来与学术热点、图与AI等话题进行了精彩讨论。2024年，TuGraph 将努力更贴近客户，更拥抱开源，更关注生态。欢迎大家继续关注！\n\n该块内容位于TuGraph社区Meetup会议的最后部分，主要讨论了TuGraph未来的发展规划以及与会专家对于图技术、图生态和图智能的见解，展望了即将推出的开源工具和项目，强调了开源和生态的重要性。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_159.md",
        "chunks": [
            {
                "content": "# 蚂蚁集团开源图数据库TuGraph，成立图计算开源委员会\n\n9月1日，2022世界人工智能大会“新一代图智能技术发展与实践论坛”上，蚂蚁集团图计算负责人陈文光宣布开源蚂蚁集团高性能图数据库TuGraph单机版，并成立图计算开源技术委员会，中国工程院院士郑纬民、陈纯分别担任主席、副主席，5位业界知名专家担任委员。\n\nTuGraph由蚂蚁集团和清华大学共同研发，是图数据库权威测试世界纪录保持者，也是世界上有测试纪录的“最快”的图数据库。\n\n随着TuGraph的开源，图数据领域将迎来一款性能卓越、功能丰富、生态完备的开源产品。\n\n开发者可以聚焦应用层，轻松打造属于自己的图数据，从而提升行业整体技术应用水位。TuGraph开源采用Apache2.0协议，在Github和Gitee上进行托管。\n\n图数据库区别于关系型数据库，基于图模型，使用点边来表示、存储、处理数据，拥有灵活的数据抽象模型，能够更好地表达出“关系”的概念。\n\n蚂蚁TuGraph是一套分布式图数据库系统，可以支持万亿级边上的实时查询。此次开源的TuGraph单机版，同样具备完备的图数据库基础功能和成熟的产品设计，可以轻松支持 TB 级别数据和百亿级别大图，足以满足大多数业务场景需求。相较于市场上常见的开源产品，TuGraph单机版的性能高 10 倍以上。\n\n蚂蚁集团2015年开始自主研发分布式图数据库、流式图计算等图相关技术，2016 年发布自研分布式图数据库，并应用于支付宝。至今TuGraph已应用于蚂蚁内部150多个场景，包括在线支付的实时链路，以支付宝风险识别能力提升近 10倍、风险审理分析效率提升 90%的成绩，验证了其高可靠性。\n\n就在上个月，LDBC（关联数据基准委员会）发布最新图数据库SNB测试结果，TuGraph在功能完整性、吞吐率、响应速度等层面全球领先。\n\n目前，蚂蚁集团已形成了一套以图数据库为底座、同时包含流式图计算，离线图学习的大规模图计算系统。\n\n蚂蚁集团图数据库负责人洪春涛表示，图技术是未来大数据、人工智能和高性能计算产业发展的关键所在，它很有可能会成为下一代的数据底座。蚂蚁集团愿意通过开源持续输出核心技术优势，推动图数据库更广泛的应用生态，携手行业抢占技术高地，不断探索技术的可能性。\n\n该文档介绍了蚂蚁集团在2022年世界人工智能大会上开源其高性能图数据库TuGraph的相关信息，包括项目背景、技术优势、应用案例以及图计算开源委员会的成立，强调了图技术在大数据和人工智能领域的重要性。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_160.md",
        "chunks": [
            {
                "content": "# 蚂蚁高性能图数据库TuGraph-DB的技术思考与实践\n\n在近日举行的 DTCC 2022 第十三届中国数据库技术大会-图数据技术与应用创新专场，蚂蚁集团图数据库负责人洪春涛博士分享了蚂蚁高性能图数据库TuGraph-DB的技术思考和实践，以下为演讲内容要点回顾。\n\n## 图计算的优势\n\n图计算是一种高效的抽象计算方法，可以方便地处理复杂的多维数据。我们将员工和公司之间的关系画成图，这样可以快速查询员工的信息，例如员工的工作情况、与其他员工的关系以及与哪些公司有联系。相比之下，在关系数据库中，我们需要分别建立员工信息表、公司信息表以及员工和公司之间的关系表。这就把整个数据切成了很多张二维表，在实际应用系统中经常能够看到几百上千张表。这样会使得系统变得更加复杂，需要基于多张表去做推断，对人或机器来说都会带来挑战。\n\n对比来看什么是简单查询和复杂查询：\n\n图中表格的前两行属于比较简单的查询，比如某个员工的工龄，直接找到对应的那一行然后取出来就可以；比如找出所有的雇员数大于5的公司，可能在雇佣关系表中就能找出来，在关系数据库里这些都属于常规的操作。\n\n但如果查询再复杂一点，我想知道员工A和员工C之间有什么关系，不一定是一跳的关系，可能包含在同一家公司工作，也可能包含参与了同一个项目，甚至还包含他们有一个共同好友，这些关系就是多种多样的，想用SQL列举所有可能的关系其实就没有那么容易了。如果确定知道这里可能有几种关系，还能靠SQL穷举出来，但随着表越来越多，里面的关系可能有几百上千的时候，再想去穷举就非常难了。\n\n最后还有一种更复杂的查询，比如想找员工A和员工E的所有关系，可能包括A认识B，B认识C，C认识E，相当于在做一个不定长跳数的查询，在SQL里面就非常难写了，相信绝大多数人都难以写出这种查询。\n\n业界有句话，所谓的关系数据库实际上并不擅长处理关系。例如，员工A和E之间的所有关系实际上就是我们要查询的关系，但在关系数据库中处理这种关系查询实际上是不够友好的。这是图数据库的优势所在，它们更擅长处理复杂的关系数据。我们发现，大部分浅显的数据信息都可以比较容易地挖掘出来，但要想更深入地利用数据产生更多的价值，就必须挖掘更深层次的信息，这时就一定会遇到这些复杂的关系，这也是为什么图数据库越来越受欢迎的原因。\n\n## 为什么图数据库开始流行\n\n该内容为蚂蚁集团图数据库负责人洪春涛博士在DTCC 2022大会上的演讲摘要，讨论了图计算的优势及其在复杂数据处理中的应用，阐述了图数据库相较于传统关系数据库的优势，并分析了图数据库逐渐流行的原因。"
            },
            {
                "content": "但如果查询再复杂一点，我想知道员工A和员工C之间有什么关系，不一定是一跳的关系，可能包含在同一家公司工作，也可能包含参与了同一个项目，甚至还包含他们有一个共同好友，这些关系就是多种多样的，想用SQL列举所有可能的关系其实就没有那么容易了。如果确定知道这里可能有几种关系，还能靠SQL穷举出来，但随着表越来越多，里面的关系可能有几百上千的时候，再想去穷举就非常难了。\n\n最后还有一种更复杂的查询，比如想找员工A和员工E的所有关系，可能包括A认识B，B认识C，C认识E，相当于在做一个不定长跳数的查询，在SQL里面就非常难写了，相信绝大多数人都难以写出这种查询。\n\n业界有句话，所谓的关系数据库实际上并不擅长处理关系。例如，员工A和E之间的所有关系实际上就是我们要查询的关系，但在关系数据库中处理这种关系查询实际上是不够友好的。这是图数据库的优势所在，它们更擅长处理复杂的关系数据。我们发现，大部分浅显的数据信息都可以比较容易地挖掘出来，但要想更深入地利用数据产生更多的价值，就必须挖掘更深层次的信息，这时就一定会遇到这些复杂的关系，这也是为什么图数据库越来越受欢迎的原因。\n\n## 为什么图数据库开始流行\n\n图数据库的概念最早出现在七八十年代初期，但当时为什么人们没有选择使用图数据库，而是选择了关系数据库呢？我认为主要原因是，当时的计算机并不那么强大，使用二维表格形式的关系数据库对计算机来说更友好。我们知道，计算机最擅长的事情就是重复的劳动，重复的任务。如果我们要在一张二维表中找一行数据，我们可以一行一行查找，或者使用二分查找（如果数据是树状有序的）。每一层都是重复的算法在运行，这对计算机来说是一个非常规整的数据，容易处理。但如果把数据抽象成一张图，那么难度就会大很多，对计算机来说会更难处理。\n\n举个例子，一个员工可能与其他人有各种不同的关系，比如朋友关系、雇佣关系、参与项目关系，每种关系的类型都不同，对应的数据也都不同。此外，一个点上的边数也非常不规律，有的人可能只有几个好友，而在微博上，一个普通人可能有两三百个粉丝，而大V账号可能有数百万甚至上亿的粉丝。这样一来，存储数据时，普通人和大V之间的差距就非常大了，对计算机来说，处理这两种数据的差异也会很大。\n\n该段落描述了图数据库在处理复杂关系查询时的优势，特别是与关系数据库相比的局限性。通过举例说明员工之间的多种关系，该段落强调了图数据库能够高效挖掘深层次信息的重要性，之后引入了图数据库流行的原因和早期发展的背景，为后续讨论图数据库的技术演进与应用场景奠定了基础。"
            },
            {
                "content": "## 为什么图数据库开始流行\n\n图数据库的概念最早出现在七八十年代初期，但当时为什么人们没有选择使用图数据库，而是选择了关系数据库呢？我认为主要原因是，当时的计算机并不那么强大，使用二维表格形式的关系数据库对计算机来说更友好。我们知道，计算机最擅长的事情就是重复的劳动，重复的任务。如果我们要在一张二维表中找一行数据，我们可以一行一行查找，或者使用二分查找（如果数据是树状有序的）。每一层都是重复的算法在运行，这对计算机来说是一个非常规整的数据，容易处理。但如果把数据抽象成一张图，那么难度就会大很多，对计算机来说会更难处理。\n\n举个例子，一个员工可能与其他人有各种不同的关系，比如朋友关系、雇佣关系、参与项目关系，每种关系的类型都不同，对应的数据也都不同。此外，一个点上的边数也非常不规律，有的人可能只有几个好友，而在微博上，一个普通人可能有两三百个粉丝，而大V账号可能有数百万甚至上亿的粉丝。这样一来，存储数据时，普通人和大V之间的差距就非常大了，对计算机来说，处理这两种数据的差异也会很大。\n\n我们知道，在七八十年代，计算机相对来说很弱，如果那个时候使用图来表示数据，整个处理和查询的难度就会大很多。所以，人们选择使用关系数据表的形式表示数据。事实上，那个时候有人做过图数据库，但并没有流行起来，原因就是性能相对关系数据库来说差得太多了。\n\n我们知道，所有的事物，尤其是电脑，一直在不断进步。这包括硬件和软件方面的改进。如今的硬件和几十年前的硬件完全不是一个概念，而现在的软件优化也大不相同。随着这些改进，我们会发现对当前的电脑和计算机系统来说，使用图数据库带来的额外开销可能不是很大的问题。\n\n举个例子，我们会发现，过去人们都使用低级编程语言编写程序，但随着时间的推移，有了高级语言。比如最开始、最原始的电脑可能是用纸袋和机器码写程序，后来有了汇编，再后来有C语言、C++，现在很多人都直接写Python。虽然 Python 程序的执行速度可能较慢，但是写的很快，而用用C++或者汇编去写得写半天，对于编写程序到最终得出结果的整个过程来说，使用 Python 会更方便。\n\n计算机编程语言的发展是从低级向高级演变的，数据抽象也是一样。我们认为，未来的数据抽象一定会对人更友好一些，而不是专注于对机器更友好。如图所示，编程语言的发展是从低级语言向高级语言转变的，我们也认为数据抽象层次也会慢慢从低层次表格抽象向高层次图表抽象发展。\n\n该段落位于关于蚂蚁高性能图数据库TuGraph-DB的技术讨论中，主要探讨了图数据库相较于关系数据库流行的原因，分析了历史背景、计算机技术的进步及数据处理的易用性，强调了未来数据抽象将更加友好与高层次。"
            },
            {
                "content": "我们知道，所有的事物，尤其是电脑，一直在不断进步。这包括硬件和软件方面的改进。如今的硬件和几十年前的硬件完全不是一个概念，而现在的软件优化也大不相同。随着这些改进，我们会发现对当前的电脑和计算机系统来说，使用图数据库带来的额外开销可能不是很大的问题。\n\n举个例子，我们会发现，过去人们都使用低级编程语言编写程序，但随着时间的推移，有了高级语言。比如最开始、最原始的电脑可能是用纸袋和机器码写程序，后来有了汇编，再后来有C语言、C++，现在很多人都直接写Python。虽然 Python 程序的执行速度可能较慢，但是写的很快，而用用C++或者汇编去写得写半天，对于编写程序到最终得出结果的整个过程来说，使用 Python 会更方便。\n\n计算机编程语言的发展是从低级向高级演变的，数据抽象也是一样。我们认为，未来的数据抽象一定会对人更友好一些，而不是专注于对机器更友好。如图所示，编程语言的发展是从低级语言向高级语言转变的，我们也认为数据抽象层次也会慢慢从低层次表格抽象向高层次图表抽象发展。\n\n## 图计算在蚂蚁的应用\n\n自2015年开始，蚂蚁实际上投入了大量资源来研究图计算，研究如何在蚂蚁的业务中使用图计算。例如数据血缘应用。在对业务的处理过程中，我们需要较好地追踪这些数据的流转路径，如果修改了一份源数据会对下游数据产生什么影响，会对最终业务产生什么影响。为了更好地追踪，我们使用图数据库来存储数据。\n\n另一个比较有趣的应用场景就是程序分析。相信几乎所有互联网公司内部都有大量的程序，因此，我们需要管理这些程序，并在每次提交代码时了解将会对哪些内容产生影响。为此，蚂蚁负责程序分析的团队会分析这里的图数据。例如，定义一个变量A，然后使用变量A，“定义”与“使用”之间就会有一条边，使用关系会存储在图数据库中。目前我们的图中已经有超过200亿条边，这是一个非常大的数据量。我们需要对这些数据进行存储、查询和分析，这是蚂蚁公司内部非常多的图数据场景之一。\n\n举个例子来说明优惠券反套现的场景：满额返券是一种比较常见的促销方式，比如购物满2000元就可以享受100元的优惠。这种情况下，如果正常消费，用户花费2000元，通过返券省下100元。但是有些人会想办法注册假商铺，进行虚假交易，目的是把平台补贴的优惠券套出来。因此当用户去买东西，平台要去付补贴的过程，我们需要去实时检测一下会不会有可疑的资金交易情况。\n\n该 chunk 位于文档中关于图数据库和图计算的技术思考部分，具体阐述了计算机硬件和软件的进步如何影响图数据库的使用，使其更具可行性，并通过编程语言的演变类比，强调未来数据抽象将更加人性化。随后，文档转向蚂蚁在实际业务中应用图计算的具体案例，如数据血缘追踪和程序分析，以及反套现的场景分析。"
            },
            {
                "content": "另一个比较有趣的应用场景就是程序分析。相信几乎所有互联网公司内部都有大量的程序，因此，我们需要管理这些程序，并在每次提交代码时了解将会对哪些内容产生影响。为此，蚂蚁负责程序分析的团队会分析这里的图数据。例如，定义一个变量A，然后使用变量A，“定义”与“使用”之间就会有一条边，使用关系会存储在图数据库中。目前我们的图中已经有超过200亿条边，这是一个非常大的数据量。我们需要对这些数据进行存储、查询和分析，这是蚂蚁公司内部非常多的图数据场景之一。\n\n举个例子来说明优惠券反套现的场景：满额返券是一种比较常见的促销方式，比如购物满2000元就可以享受100元的优惠。这种情况下，如果正常消费，用户花费2000元，通过返券省下100元。但是有些人会想办法注册假商铺，进行虚假交易，目的是把平台补贴的优惠券套出来。因此当用户去买东西，平台要去付补贴的过程，我们需要去实时检测一下会不会有可疑的资金交易情况。\n\n蚂蚁有很多业务需要研究图计算系统和图数据库等技术来满足需求，因为这些业务需要对大量的点边进行分析，数据量超过了100TB，基本上已经达到了PB级别。我们需要对这些图进行实时查询，吞吐率大约在百万级别。由于需要对用户的付款进行实时判断，所以需要比较低的延迟，大约在20毫秒的级别。如果延迟太长，会导致用户体验很差，比如付款需要等待5秒才能完成，这样就会非常麻烦。\n\n## 图计算系统建设中的问题与挑战\n\n在建立蚂蚁图计算系统的过程中，我们遇到了各种各样的问题。为了解决这些问题，我们与学术界和许多研究界的同事一起合作，并发表了许多相关的学术论文，包括EuroSys等。然而，我们在建立系统的过程中发现，目前的图计算仍处于较早期的阶段，因此许多标准尚未成形。这对我们来说是一个棘手的问题。例如，在关系型数据库中，查询语言基本上就是SQL，但在图数据库中，仅查询语言就有许多种，包括Gremlin、G-SQL等等。这导致了市场的碎片化，人们学习和使用的成本也很高。\n\n该段落讨论了蚂蚁集团在图计算系统中的具体应用，特别是程序分析和优惠券反套现的案例，强调了图数据库在处理大规模数据和实时查询中的重要性，以及在实际业务中面临的挑战和需求。"
            },
            {
                "content": "蚂蚁有很多业务需要研究图计算系统和图数据库等技术来满足需求，因为这些业务需要对大量的点边进行分析，数据量超过了100TB，基本上已经达到了PB级别。我们需要对这些图进行实时查询，吞吐率大约在百万级别。由于需要对用户的付款进行实时判断，所以需要比较低的延迟，大约在20毫秒的级别。如果延迟太长，会导致用户体验很差，比如付款需要等待5秒才能完成，这样就会非常麻烦。\n\n## 图计算系统建设中的问题与挑战\n\n在建立蚂蚁图计算系统的过程中，我们遇到了各种各样的问题。为了解决这些问题，我们与学术界和许多研究界的同事一起合作，并发表了许多相关的学术论文，包括EuroSys等。然而，我们在建立系统的过程中发现，目前的图计算仍处于较早期的阶段，因此许多标准尚未成形。这对我们来说是一个棘手的问题。例如，在关系型数据库中，查询语言基本上就是SQL，但在图数据库中，仅查询语言就有许多种，包括Gremlin、G-SQL等等。这导致了市场的碎片化，人们学习和使用的成本也很高。\n\n在建立图计算系统的过程中，我们也遇到了许多挑战。为了分担较大的通信量，需要将图数据分布到多台机器上，但这会导致边的信息在不同机器之间传递，造成大量的通信。此外，单次查询所涉及的数据量也比较大，例如五跳查询涉及的点数就已达到10的五次方，图中还存在一些非常大的点。同时，用户对图计算系统的需求也十分多样，既有快速查询的需求，也有对复杂算法（如社区发现）的需求，单一系统很难满足这些不同的需求。\n\n## TuGraph技术优势\n\n蚂蚁自己开发了一套图计算系统TuGraph，既能解决图数据的存储问题，也能解决流式计算、离线计算和图学习的问题。目前，超过100个业务线和300多个场景都在使用这套系统。这套系统在2021年获得了世界互联网大会领先科技成果奖。\n\n在TuGraph中，性能是一个重要的因素，因为图数据集的体积很大，如果性能不佳就会浪费机器资源，导致许多情况下无法完成任务。比如，希望业务的查询能在几十毫秒内返回结果，但是如果做的性能不好，几秒钟才能返回结果，就无法作为在线查询使用。因此，我们是非常对性能是很重视的，其中在 LDBC-SNB 标准测试中（类似于数据库领域性能标准测试TPC-C），TuGraph仍然是世界纪录的保持者。\n\n该段落主要讨论了蚂蚁集团在图计算系统建设过程中的实际需求与挑战，特别是在处理大规模数据（超过100TB及PB级别）时的实时查询能力和低延迟要求。同时介绍了蚂蚁自研发的图计算系统TuGraph的优势，强调其性能在行业标准测试中的表现，以适应各种业务场景。"
            },
            {
                "content": "## TuGraph技术优势\n\n蚂蚁自己开发了一套图计算系统TuGraph，既能解决图数据的存储问题，也能解决流式计算、离线计算和图学习的问题。目前，超过100个业务线和300多个场景都在使用这套系统。这套系统在2021年获得了世界互联网大会领先科技成果奖。\n\n在TuGraph中，性能是一个重要的因素，因为图数据集的体积很大，如果性能不佳就会浪费机器资源，导致许多情况下无法完成任务。比如，希望业务的查询能在几十毫秒内返回结果，但是如果做的性能不好，几秒钟才能返回结果，就无法作为在线查询使用。因此，我们是非常对性能是很重视的，其中在 LDBC-SNB 标准测试中（类似于数据库领域性能标准测试TPC-C），TuGraph仍然是世界纪录的保持者。\n\nTuGraph 的整个图存储是建立在完美哈希的基础上的，这是我们与其他图系统的一个重要区别。目前，大多数图系统使用的是基于数的存储，但数的问题在于永远存在一个 LogN 的查找操作。然而，在图中可以看到，不同的顶点之间实际上是无序的，不需要有顺序，所以顶点这个级别实际上是基于哈希的，理论上，顶点的读取是最优的。\n\n此外，TuGraph 还参与了许多标准的定制，整个系统在尽量往标准化的方向去做。\n\n除了为内部提供服务，我们还向外提供服务，主要是因为，作为一个系统，如果只为有限的客户提供服务，就很容易构建成一个专有系统。我们希望这是一个标准化、开放的系统，所以我们也在对外提供图计算系统的产品和服务。目前，我们也有很多外部客户，包括金融、工业、互联网以及政企领域。\n\n整个图计算系统目前仍处于较早期的阶段，我们认为还有很多工作要做，包括提升应用性、性能和降低成本。所有的系统都会有这些问题。但是，如果希望普及，我们认为最重要的是有健康的生态，来推动图计算系统的发展，需要有更多的用户和更多的场景使用这个系统。\n\n所有的计算机系统都需要去有一个更开放、更大的生态才能促进发展。蚂蚁有一句话叫做“成熟一个、开放一个”，一个系统成熟以后，我们就会试着开放出去，让更多的人去用。今年9月，我们已经在GitHub上开源了TuGraph中的单机版图数据库，以及一个离线图分析引擎TuGraph Compute。分布式图数据库和流式图计算现在已经包含在我们的商业化版本中，包括一站式图研发平台。我们计划在未来迭代更多更丰富的系统功能，希望能做得更好。\n\n## TuGraph开源版特色\n\n该块内容讨论了蚂蚁集团自主开发的图计算系统TuGraph的技术优势，包括其在图数据存储、流式计算、离线计算和图学习方面的能力，以及在性能、标准化和开放性方面的重要特性。此外，块中提到TuGraph的应用情况和未来发展计划，接着介绍了TuGraph开源版的特色。"
            },
            {
                "content": "除了为内部提供服务，我们还向外提供服务，主要是因为，作为一个系统，如果只为有限的客户提供服务，就很容易构建成一个专有系统。我们希望这是一个标准化、开放的系统，所以我们也在对外提供图计算系统的产品和服务。目前，我们也有很多外部客户，包括金融、工业、互联网以及政企领域。\n\n整个图计算系统目前仍处于较早期的阶段，我们认为还有很多工作要做，包括提升应用性、性能和降低成本。所有的系统都会有这些问题。但是，如果希望普及，我们认为最重要的是有健康的生态，来推动图计算系统的发展，需要有更多的用户和更多的场景使用这个系统。\n\n所有的计算机系统都需要去有一个更开放、更大的生态才能促进发展。蚂蚁有一句话叫做“成熟一个、开放一个”，一个系统成熟以后，我们就会试着开放出去，让更多的人去用。今年9月，我们已经在GitHub上开源了TuGraph中的单机版图数据库，以及一个离线图分析引擎TuGraph Compute。分布式图数据库和流式图计算现在已经包含在我们的商业化版本中，包括一站式图研发平台。我们计划在未来迭代更多更丰富的系统功能，希望能做得更好。\n\n## TuGraph开源版特色\n\n为什么要去开源单机版而不是分布式版本？主要是考虑到它的部署和使用成本比分布式版本要低得多，同时功能也很完整、独立。我们希望这样可以让许多刚开始使用图数据库或有使用图数据库解决问题的想法的人，可以先尝试用我们的单机版图数据库。因为它的部署非常简单，如果跑起来没有问题，那么再考虑是否需要分布式版本。如果确实需要，我们可以再跟进这个问题。\n\n我们的单机版图数据库已经能够支持TB级别的数据，我们内部也有很多情况使用单机版图数据库。在单台机器上，我们最大的数据量也达到了2TB多，在线上运行，能够处理百亿级别的点边。事实上，大多数用户使用单机版图数据库都是足够的。由于单机版的图数据库很容易优化，我们对它进行了极致的优化，因此单机版图数据库在性能上可以满足绝大多数场景的需求。此外，它的系统特性也很全面，包括高可用性、多图支持、权限管理、日志记录等，它可以被看作是一个成熟、易用的图数据库，类似于MySQL。\n\n图中所列出的开源版TuGraph几个特性包括：\n\n单机版图数据库能够处理数据量几个TB的数据，前提是磁盘足够大。\n\n成本很低，因为是单机版，部署和运维都很容易。\n\n该段落位于文章的后半部分，主要讨论蚂蚁集团的图计算系统TuGraph的开放性与商业化策略，强调通过开源单机版图数据库来促进用户使用和推动图计算技术的发展，同时介绍该版本的特点和优势。"
            },
            {
                "content": "## TuGraph开源版特色\n\n为什么要去开源单机版而不是分布式版本？主要是考虑到它的部署和使用成本比分布式版本要低得多，同时功能也很完整、独立。我们希望这样可以让许多刚开始使用图数据库或有使用图数据库解决问题的想法的人，可以先尝试用我们的单机版图数据库。因为它的部署非常简单，如果跑起来没有问题，那么再考虑是否需要分布式版本。如果确实需要，我们可以再跟进这个问题。\n\n我们的单机版图数据库已经能够支持TB级别的数据，我们内部也有很多情况使用单机版图数据库。在单台机器上，我们最大的数据量也达到了2TB多，在线上运行，能够处理百亿级别的点边。事实上，大多数用户使用单机版图数据库都是足够的。由于单机版的图数据库很容易优化，我们对它进行了极致的优化，因此单机版图数据库在性能上可以满足绝大多数场景的需求。此外，它的系统特性也很全面，包括高可用性、多图支持、权限管理、日志记录等，它可以被看作是一个成熟、易用的图数据库，类似于MySQL。\n\n图中所列出的开源版TuGraph几个特性包括：\n\n单机版图数据库能够处理数据量几个TB的数据，前提是磁盘足够大。\n\n成本很低，因为是单机版，部署和运维都很容易。\n\n性能很好，我们对其进行了大量优化。TuGraph的LDBC-SNB测试目前是世界第一，大家可以在GitHub上获取测试SNB的条款并进行测试。\n\n单机版图数据库是一个非常易用的完整系统，我们提供了导入导出工具和查询语言。此外，还提供了底层API，用户可以使用它来编写复杂的程序。\n\n我们的开源版本的目标主要有三点：\n\n首先，我们希望提供一个免费的图数据库产品，能够让更多的人使用图数据库，尝试用它来解决问题。\n\n其次，我们希望促进图数据库标准的成形。目前图数据库的差异太大，每个数据库都有所不同，我们希望通过提供一个参考答案来帮助大家达成趋同。这样大家就可以根据我们提供的设计来判断哪些特征合理，如果觉得合理就可以遵循这个设计，慢慢地大家就会逐渐靠近。假如所有产品在主要特征上保持一致，这样所有人的学习成本就会降低。\n\n最后，基础研究性问题可以不断优化发展，包括存储方面的问题，例如哈希可能是理论上最优的，但是是否还有其他需要调整的东西？目前没有一个很好的研究性平台让大家去进行这些尝试和研究，我们希望提供的开源TuGraph-DB能成为这些研究人员的对比基线，促进研究的发展。\n\n## TuGraph企业版特色\n\n该文档主要讨论蚂蚁高性能图数据库TuGraph-DB的技术背景、优势及应用，介绍了图计算的优点，以及图数据库在蚂蚁集团的具体应用场景。文中提到TuGraph开源版的特色，强调其独立性、易用性及对初学者的适用性，目的是促进图数据库的普及和标准化。此部分为关于TuGraph开源版的详细介绍，紧接着是对企业版的特色总结。"
            },
            {
                "content": "性能很好，我们对其进行了大量优化。TuGraph的LDBC-SNB测试目前是世界第一，大家可以在GitHub上获取测试SNB的条款并进行测试。\n\n单机版图数据库是一个非常易用的完整系统，我们提供了导入导出工具和查询语言。此外，还提供了底层API，用户可以使用它来编写复杂的程序。\n\n我们的开源版本的目标主要有三点：\n\n首先，我们希望提供一个免费的图数据库产品，能够让更多的人使用图数据库，尝试用它来解决问题。\n\n其次，我们希望促进图数据库标准的成形。目前图数据库的差异太大，每个数据库都有所不同，我们希望通过提供一个参考答案来帮助大家达成趋同。这样大家就可以根据我们提供的设计来判断哪些特征合理，如果觉得合理就可以遵循这个设计，慢慢地大家就会逐渐靠近。假如所有产品在主要特征上保持一致，这样所有人的学习成本就会降低。\n\n最后，基础研究性问题可以不断优化发展，包括存储方面的问题，例如哈希可能是理论上最优的，但是是否还有其他需要调整的东西？目前没有一个很好的研究性平台让大家去进行这些尝试和研究，我们希望提供的开源TuGraph-DB能成为这些研究人员的对比基线，促进研究的发展。\n\n## TuGraph企业版特色\n\n除了开源版本，我们也继续提供商业版本。这个版本包含一个分布式图数据库，以及离线计算引擎和流式图计算功能。此外，我们还提供了TuGraph Platform一站式图平台，包括运维、可视化等功能。在这个平台上，用户可以在图数据库中执行流式计算，并在线写回数据库。这种方式通常用于实时查询结果，因为流式计算的时间可能比较长，但用户可以立即查询到较早的结果。这对于在线业务来说非常重要。\n\n商业化产品还提供私有化部署，也可以通过一体机的方式部署硬件，并将很快推出云上部署方案，这样大家就可以在云上体验我们的产品。\n\n## 总结\n\n蚂蚁在图计算方面投入了大量资源，并在众多业务场景中磨练出了一整套在线查询、流式计算、离线分析以及图学习的体系。目前，我们已经在GitHub上开源了单机版（https://github.com/TuGraph-db），同时也提供企业版来满足不同用户需求。\n\n在文章的最后部分，介绍了TuGraph开源版本的特点，强调其性能、易用性以及对标准化的促进作用，接着提到商业版的功能与部署选项，以及蚂蚁在图计算领域的广泛应用和持续投入。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_161.md",
        "chunks": [
            {
                "content": "# TuGraph Analytics交互式图查询：让图所见即所得\n\nTuGraph Analytics提供了OLAP图分析能力，实现图上的交互式查询，用户在构图并导入数据之后，可以通过输入GQL语句对图查询分析，并以可视化的方式直观地展示点边结果。\n\n## OLAP架构\n\n在TuGraph Analytics OLAP架构中，主要以下组件:\n\n- **Client**: 用户通过Client提交查询语句, Client负责和Coordinator交互，发送查询请求。\n\n- **Coordinator**: 接收来自Client查询请求，将查询中的GQL语句进行解析、优化，构建查询的执行计划（执行计划的生成逻辑可参考《分布式图计算如何实现？带你一窥图计算执行计划》[1]），并将任务调度给Worker执行。\n\n- **Worker**: 具体分布式地执行任务的单元，接收到Coordinator发送的Pipeline，执行具体的计算和查询逻辑。\n\n- **Meta Service**: 服务注册管理，Coordinator启动后，会将服务的地址和端口向MetaService进行注册，Client提交查询时从MetaService获取Coordinator的服务地址，进行连接。目前支持http和rpc两种方式。\n\n组件间执行流程如下：\n\n## OLAP流程\n\n## 操作指南\n\n1. **定义图模型**\n   \n   以下图为例，图中有2种点person和software，以及2种边knows和creates。\n\n   ![图模型](#)\n\n   图模型定义可参考《TuGraph Analytics图建模研发：为图计算业务提速增效》[2]，图定义语法为：\n\n该文档介绍了TuGraph Analytics的交互式图查询功能及其OLAP架构，详细说明了各组件的角色与功能，以及如何定义图模型和准备数据，为用户提供可操作的图查询分析指南。"
            },
            {
                "content": "- **Worker**: 具体分布式地执行任务的单元，接收到Coordinator发送的Pipeline，执行具体的计算和查询逻辑。\n\n- **Meta Service**: 服务注册管理，Coordinator启动后，会将服务的地址和端口向MetaService进行注册，Client提交查询时从MetaService获取Coordinator的服务地址，进行连接。目前支持http和rpc两种方式。\n\n组件间执行流程如下：\n\n## OLAP流程\n\n## 操作指南\n\n1. **定义图模型**\n   \n   以下图为例，图中有2种点person和software，以及2种边knows和creates。\n\n   ![图模型](#)\n\n   图模型定义可参考《TuGraph Analytics图建模研发：为图计算业务提速增效》[2]，图定义语法为：\n\n   ```sql\n   CREATE GRAPH dy_modern (\n       Vertex person (\n         id bigint ID,\n         name varchar,\n         age int\n       ),\n       Vertex software (\n         id bigint ID,\n         name varchar,\n         lang varchar\n       ),\n       Edge knows (\n         srcId bigint SOURCE ID,\n         targetId bigint DESTINATION ID,\n         weight int\n       ),\n       Edge creates (\n         srcId bigint SOURCE ID,\n         targetId bigint DESTINATION ID,\n         weight int\n       )\n   ) WITH (\n       storeType='rocksdb',\n       shardCount = 2\n   );\n   ```\n\n2. **准备图数据**\n   \n   创建“加工”类型图任务，发布生成图作业。\n\n   ```sql\n   USE GRAPH dy_modern;\n\n该内容段落位于文档的OLAP架构部分，详细介绍了TuGraph Analytics中的Worker和Meta Service组件的功能，以及组件之间的执行流程，随后引入了图模型定义及图数据准备的操作指南。"
            },
            {
                "content": "2. **准备图数据**\n   \n   创建“加工”类型图任务，发布生成图作业。\n\n   ```sql\n   USE GRAPH dy_modern;\n\n   INSERT INTO dy_modern.person(id, name, age)\n   SELECT 1, 'jim', 20\n   UNION ALL\n   SELECT 2, 'kate', 22\n   UNION ALL\n   SELECT 3, 'tom', 24;\n\n   INSERT INTO dy_modern.software(id, name, lang)\n   SELECT 4, 'software1', 'java'\n   UNION ALL\n   SELECT 5, 'software2', 'java';\n\n   INSERT INTO dy_modern.knows\n   SELECT 1,2,2\n   UNION ALL\n   SELECT 1,3,3\n   UNION ALL\n   SELECT 3,2,3;\n\n   INSERT INTO dy_modern.creates\n   SELECT 2,4,6\n   UNION ALL\n   SELECT 3,5,8\n   UNION ALL\n   SELECT 3,4,8;\n   ```\n\n   图作业需要的worker数为23，在作业界面将参数进行修改，之后提交作业运行。\n\n3. **创建查询服务**\n   \n   创建图查询服务, 任务类型选择“图查询”，目标图选择刚才创建的图。\n\n   发布任务后，使用默认参数即可，提交作业。\n\n4. **执行查询**\n   \n   图查询服务的作业变成RUNNING状态后，可在任务界面点击“查询”进入图查询界面。\n\n   输入相应的gql查询语句，点击“执行”，即可得到查询结果。\n\n5. **图可视化**\n   \n   点击某个点，可以查看点关联的具体信息和属性，以及关联的其他点边。\n\n   除了可视化的方式，也可以json形式看到返回的结果。\n\n至此，我们就成功使用TuGraph Analytics实现了图上的交互式查询！是不是超简单！快来试一试吧！\n\n该段落位于TuGraph Analytics文档中的操作指南部分，具体介绍了如何准备图数据，包括创建图任务、插入顶点和边的数据，以及所需的工作节点数，接下来将详细说明如何创建查询服务和执行查询，最终实现图的交互式查询功能。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_162.md",
        "chunks": [
            {
                "content": "# 深入解读TuGraph计算引擎模型推理系统\n\nTuGraph计算引擎模型推理系统将基于迭代计算的图计算框架与模型推理系统相结合，推理系统可自定义推理依赖环境，图迭代计算与推理链路实现隔离。基于共享内存的跨进程通信方式，提高了推理数据交换效率，满足流图近线推理的时效性。在蚂蚁集团内部的实际应用场景中，大幅缩短了模型推理上线的链路与开发时间，用户迭代模型版本更方便快捷。\n\n## 1. 图算法概述\n\n在计算机科学中，图是一种表示实体（节点或顶点）以及实体之间关系（边）的数据结构。图模型可以天然地描述网络结构，能更清晰地表达复杂的数据关系和依赖，简化关联数据的理解和分析。在不同的场景下，图中点边具备不同的语义信息。例如，在资金交易场景下，每个人可以抽象成一个点表示，人与人之间的转账关系可以抽象成一条边表示。如下图，通过图数据模型反映出各个实体之间的资金往来关系，让数据的关联分析更加直观和高效。\n\n### 资金交易图谱示例\n\n在图数据模型上可以执行多种图算法，如社区检测、最短路径匹配、环路检测算法等。通过点边上的迭代计算，探索图模型中各个实体之间的关系。探索过程不依赖于数据的线性结构，从而便于识别隐藏的模式和关联关系。在主流迭代图算法中，节点通过消息传递的方式进行通信。每次迭代，节点可以接收来自它们邻居的消息，处理这些消息，然后决定是否发送新的消息给其他节点。迭代算法中，每个节点有一个状态，每次迭代它们都有可能更新这个状态直至收敛。例如，在PageRank算法中，每个节点的状态是其PageRank值，这个值在迭代过程中会随着邻居的值的更新而更新。\n\n该段落是文档的开头部分，介绍了TuGraph计算引擎模型推理系统的基本概念和功能，包括图计算框架的迭代计算与模型推理的结合，以及系统在蚂蚁集团的应用场景。接下来详细阐述了图算法的概述，解释了图数据模型的性质及其在各种场景中的应用，特别是在资金交易场景中的用例与算法示例。"
            },
            {
                "content": "## 1. 图算法概述\n\n在计算机科学中，图是一种表示实体（节点或顶点）以及实体之间关系（边）的数据结构。图模型可以天然地描述网络结构，能更清晰地表达复杂的数据关系和依赖，简化关联数据的理解和分析。在不同的场景下，图中点边具备不同的语义信息。例如，在资金交易场景下，每个人可以抽象成一个点表示，人与人之间的转账关系可以抽象成一条边表示。如下图，通过图数据模型反映出各个实体之间的资金往来关系，让数据的关联分析更加直观和高效。\n\n### 资金交易图谱示例\n\n在图数据模型上可以执行多种图算法，如社区检测、最短路径匹配、环路检测算法等。通过点边上的迭代计算，探索图模型中各个实体之间的关系。探索过程不依赖于数据的线性结构，从而便于识别隐藏的模式和关联关系。在主流迭代图算法中，节点通过消息传递的方式进行通信。每次迭代，节点可以接收来自它们邻居的消息，处理这些消息，然后决定是否发送新的消息给其他节点。迭代算法中，每个节点有一个状态，每次迭代它们都有可能更新这个状态直至收敛。例如，在PageRank算法中，每个节点的状态是其PageRank值，这个值在迭代过程中会随着邻居的值的更新而更新。\n\n图迭代算法解决了经典的图计算问题，但随着业务需求的复杂度提升，基于迭代的图算法存在着表达能力不足、自适应性能力差、异质图处理难度大等缺点。近年来随着深度学习的研究和应用的发展，以图神经网络（Graph Neural Networks，GNNs）为代表的一类神经网络算法，被设计用来捕获图中实体（节点）和关系（边）间的复杂模式。图神经网络能够结合节点特征和图的结构来学习节点和边的表示，相比之下，传统的迭代图算法通常不会直接从原始特征中学习，而更多地专注于结构特征。依赖于深度学习的天然优势，GNNs具有更强的表示学习能力，可以自动从数据中学习复杂的模式，这使得GNNs能够更好地处理多任务学习和迁移学习等问题。在社交网络分析、知识图谱、生物分子网络、推荐系统以及交通网络等领域，得到广泛应用。\n\n## 2. 流图推理简介\n\n该段落位于文档的开头部分，主要介绍了图算法的基本概念和应用，特别是图在复杂数据关系表达中的优势。随后，探讨了图迭代算法的局限性以及图神经网络（GNNs）在处理复杂模式方面的优势，为后续流图推理的介绍奠定了理论基础。"
            },
            {
                "content": "图迭代算法解决了经典的图计算问题，但随着业务需求的复杂度提升，基于迭代的图算法存在着表达能力不足、自适应性能力差、异质图处理难度大等缺点。近年来随着深度学习的研究和应用的发展，以图神经网络（Graph Neural Networks，GNNs）为代表的一类神经网络算法，被设计用来捕获图中实体（节点）和关系（边）间的复杂模式。图神经网络能够结合节点特征和图的结构来学习节点和边的表示，相比之下，传统的迭代图算法通常不会直接从原始特征中学习，而更多地专注于结构特征。依赖于深度学习的天然优势，GNNs具有更强的表示学习能力，可以自动从数据中学习复杂的模式，这使得GNNs能够更好地处理多任务学习和迁移学习等问题。在社交网络分析、知识图谱、生物分子网络、推荐系统以及交通网络等领域，得到广泛应用。\n\n## 2. 流图推理简介\n\nTuGraph计算引擎（TuGraph Analytics）是蚂蚁集团开源的大规模分布式实时图计算引擎（流图引擎），实现了流批一体的图计算模型，支持丰富的图计算算法。TuGraph Analytics的流图计算能力，能处理连续输入的数据流，并支持增量的计算模式，极大提高了数据的计算效率和实时性。TuGraph Analytics解决了业界大规模数据关联分析的实时计算问题，已广泛应用于数仓加速、金融风控、知识图谱以及社交推荐等场景。\n\n随着业务场景中问题复杂度的提升，基于传统的迭代图算法已无法满足业务的实际需求。例如在反洗钱场景中，利用图神经网络算法处理复杂的交易关系，能够捕获到节点的局部图结构信息。通过聚合邻接节点的特征信息，每个交易节点都可以感知到周边图网络结构的信息。类似的图神经网络等AI模型的推理逻辑，无法基于传统的图迭代计算模式直接高效地表达。\n\n受上述问题启发，我们思考是否可以将TuGraph Analytics的流图计算能力与图神经网络等深度学习模型相结合，开发一套基于流图计算的模型推理系统。最终期望的推理系统具备如下能力：\n\n- 对于图算法工程师，在图迭代计算过程中，能够方便地使用机器学习模型的推理能力。\n- 对于AI算法工程师，可以通过TuGraph Analytics分布式流式计算的能力实现实时的模型推理。\n\n该段落位于文章的第二部分，探讨了传统图迭代算法在复杂业务需求下的不足之处，并引入图神经网络（GNNs）作为改进方案。接着，介绍了TuGraph计算引擎在流图计算中的应用，强调了其处理复杂数据流和实时推理的能力，为后续探讨基于流图计算的模型推理系统奠定基础。"
            },
            {
                "content": "随着业务场景中问题复杂度的提升，基于传统的迭代图算法已无法满足业务的实际需求。例如在反洗钱场景中，利用图神经网络算法处理复杂的交易关系，能够捕获到节点的局部图结构信息。通过聚合邻接节点的特征信息，每个交易节点都可以感知到周边图网络结构的信息。类似的图神经网络等AI模型的推理逻辑，无法基于传统的图迭代计算模式直接高效地表达。\n\n受上述问题启发，我们思考是否可以将TuGraph Analytics的流图计算能力与图神经网络等深度学习模型相结合，开发一套基于流图计算的模型推理系统。最终期望的推理系统具备如下能力：\n\n- 对于图算法工程师，在图迭代计算过程中，能够方便地使用机器学习模型的推理能力。\n- 对于AI算法工程师，可以通过TuGraph Analytics分布式流式计算的能力实现实时的模型推理。\n\n众所周知，在深度学习为代表的数据科学领域，Python已经成为数据分析、模型训练和推理框架的主流开发语言，并提供了丰富的开发库和框架生态。而以Hadoop全家桶为代表的大数据计算引擎领域，基于Java语言开发的系统仍占据一席之地，当然TuGraph Analytics也在其中。这种语言差异带来的“互操作性”成本，使得相当一部分大数据和AI生态组件无法轻松地融合，这也是TuGraph Analytics支持图推理需要亟待解决的问题。\n\n## 3. 系统设计\n\n我们对业内的跨Python & Java语言的方案进行了充分的调研，通过深入对比现有的跨语言交互方案的性能与效率，最终决定将模型推理任务运行于Python原生环境中以发挥出最佳的性能。\n\n### 1. OONX\n\nOONX是一个开发的生态系统，为不同的机器学习框架之间提供一个标准的模型表示格式。它使得开发人员能够在不同的框架、工具、运行时环境之间以一种标准方式交换模型，从而简化了模型的迁移和部署。\n\n**优点**\n\n- 框架互操作性\n- 规范化模型格式\n- 优化推理\n- 生态系统支持\n\n**缺点**\n\n- 更新滞后\n- 版本兼容性\n- 转换成本高\n- 性能不一致\n\n### 2. Jython\n\n以Jython为代表的方式，主要思想是在运行的宿主虚拟机上，使用宿主语言重新编写实现。\n\n**优点**\n\n- Java集成\n- 跨平台\n- 线程\n\n**缺点**\n\n- 版本管理复杂\n- 支持库有限\n- 更新滞后\n- 支持Python3有限\n\n### 3. Py4j\n\n该文本块讨论了传统迭代图算法在应对复杂业务场景（如反洗钱）时的局限性，提出结合TuGraph Analytics流图计算能力与图神经网络的模型推理系统的必要性，并阐述了该系统的目标与设计背景，特别是Python与Java语言之间的互操作性问题。"
            },
            {
                "content": "## 3. 系统设计\n\n我们对业内的跨Python & Java语言的方案进行了充分的调研，通过深入对比现有的跨语言交互方案的性能与效率，最终决定将模型推理任务运行于Python原生环境中以发挥出最佳的性能。\n\n### 1. OONX\n\nOONX是一个开发的生态系统，为不同的机器学习框架之间提供一个标准的模型表示格式。它使得开发人员能够在不同的框架、工具、运行时环境之间以一种标准方式交换模型，从而简化了模型的迁移和部署。\n\n**优点**\n\n- 框架互操作性\n- 规范化模型格式\n- 优化推理\n- 生态系统支持\n\n**缺点**\n\n- 更新滞后\n- 版本兼容性\n- 转换成本高\n- 性能不一致\n\n### 2. Jython\n\n以Jython为代表的方式，主要思想是在运行的宿主虚拟机上，使用宿主语言重新编写实现。\n\n**优点**\n\n- Java集成\n- 跨平台\n- 线程\n\n**缺点**\n\n- 版本管理复杂\n- 支持库有限\n- 更新滞后\n- 支持Python3有限\n\n### 3. Py4j\n\nPy4j桥接库为代表的方式，以Socket通信模型为基础，实现Python和Java互相访问对象，方法，提供两个程序相互通信的能力。\n\n**优点**\n\n- 跨语言交互\n- 动态代理\n- 支持复杂类型\n- API使用简易\n\n**缺点**\n\n- 网络传输\n- 部署分发难度大\n- 版本难兼容\n- 运行时环境依赖复杂\n\n### 4. Web服务化\n\nWeb服务化是一种将机器学习模型部署成网络服务，调用者通过相应的API获取模型推理结果。\n\n**优点**\n\n- 扩展性好\n- 简易且轻量\n- 社区支持\n- 机器学习类库易集成\n\n**缺点**\n\n- 性能差\n- 不适合计算密集型场景\n- 无状态管理\n- 并发连接有限\n\n在TuGraph Analytics模型推理系统的架构设计中，核心部分是通过C++原生语言建立起来的一座桥梁，实现Python环境和Java虚拟机之间高效的数据交互和操作指令的传递。通过使用C++作为媒介语言，我们不仅能够利用其接近硬件的执行效率，确保数据交互的性能，还能够保证在两个虚拟环境之间数据交换的计算精度和稳定性。基于共享内存的设计允许Python和JVM进程各自独立运行，既保证了运行环境的安全隔离，又能实现数据的高效共享。\n\n## 4. 技术原理\n\n该章节介绍了TuGraph计算引擎模型推理系统的设计方案，重点分析了不同跨语言交互方案（如OONX、Jython、Py4j和Web服务化）的优缺点，并阐述了在架构中采用C++作为桥梁语言，以实现Python与Java之间的高效数据交互和共享内存设计。这为理解后续的技术原理部分奠定了基础。"
            },
            {
                "content": "**优点**\n\n- 跨语言交互\n- 动态代理\n- 支持复杂类型\n- API使用简易\n\n**缺点**\n\n- 网络传输\n- 部署分发难度大\n- 版本难兼容\n- 运行时环境依赖复杂\n\n### 4. Web服务化\n\nWeb服务化是一种将机器学习模型部署成网络服务，调用者通过相应的API获取模型推理结果。\n\n**优点**\n\n- 扩展性好\n- 简易且轻量\n- 社区支持\n- 机器学习类库易集成\n\n**缺点**\n\n- 性能差\n- 不适合计算密集型场景\n- 无状态管理\n- 并发连接有限\n\n在TuGraph Analytics模型推理系统的架构设计中，核心部分是通过C++原生语言建立起来的一座桥梁，实现Python环境和Java虚拟机之间高效的数据交互和操作指令的传递。通过使用C++作为媒介语言，我们不仅能够利用其接近硬件的执行效率，确保数据交互的性能，还能够保证在两个虚拟环境之间数据交换的计算精度和稳定性。基于共享内存的设计允许Python和JVM进程各自独立运行，既保证了运行环境的安全隔离，又能实现数据的高效共享。\n\n## 4. 技术原理\n\nTuGraph Analytics模型推理系统工作流中，Driver端（即控制节点）发挥着至关重要的角色。该节点运行在Java虚拟机进程，是整个推理流程的控制中心。Driver端初始化了一个非常关键的组件——InferenceContext对象，InferenceContext对象被设计为模型推理流程的核心，在JVM环境中创建并负责加载和预处理用户提供的模型文件和环境依赖信息。在模型推理任务之前，InferenceContext会详细检查并准备好模型文件，确保能够正确加载到预期的执行环境中。InferenceContext也负责初始化和配置与模型推理相关的虚拟环境，确保正确的Python环境或其他必要的运行时库得以安装和配置。\n\n如图所示，由流式数据源源不断的触发图迭代计算与模型推理工作。TuGraph计算引擎提供了DeltaGraphCompute计算接口，用户可自主定义增量图数据的处理逻辑，并更新历史的图存储(Graph Store)。通过TuGraph计算引擎模型推理系统，增量图迭代的中间计算结果，经过推理前置数据处理接口，并基于共享内存的跨进程通信方式，将处理后的数据流输入到推理进程，完成推理工作后的结果参与后续图迭代计算逻辑。下文将详细介绍各个数据接口的使用。\n\n该块内容位于文章关于TuGraph计算引擎模型推理系统的系统设计部分，主要探讨不同跨语言交互方式的优缺点，包括OONX、Jython、Py4j和Web服务化，进一步阐述在TuGraph Analytics架构中通过C++作为桥梁语言实现Python与Java间高效的数据交互。"
            },
            {
                "content": "如图所示，由流式数据源源不断的触发图迭代计算与模型推理工作。TuGraph计算引擎提供了DeltaGraphCompute计算接口，用户可自主定义增量图数据的处理逻辑，并更新历史的图存储(Graph Store)。通过TuGraph计算引擎模型推理系统，增量图迭代的中间计算结果，经过推理前置数据处理接口，并基于共享内存的跨进程通信方式，将处理后的数据流输入到推理进程，完成推理工作后的结果参与后续图迭代计算逻辑。下文将详细介绍各个数据接口的使用。\n\n### 4.1 计算推理隔离\n\n在TuGraph Analytics模型推理系统的架构中，集群的工作负载分配给多个worker节点。每个worker节点上运行着两个关键进程：负责图数据迭代计算的Java进程，以及执行模型推理的Python进程。为了充分利用计算系统的资源，推理进程在没有接收到推理请求时，会进入睡眠状态。这样的设计不仅减少了系统资源的占用，而且降低了系统的整体能耗。当推理请求到达时，推理进程会被立即唤醒，接收和执行新的推理任务。借助睡眠与唤醒机制以及智能的任务调度策略，可以保证系统能够以高效、稳定、节能的方式运行，同时满足了大规模图数据处理和实时推理的需求。\n\n在每个worker工作节点下，按照不同的推理作业级别划分基础的虚拟环境，从而保证一个worker节点也可以支持不同推理任务，支持标准的requirements.txt管理推理依赖库。\n\n在图迭代计算进程和推理进程之间通过数据队列实现双边数据的交互，通过在数据包的头文件中插入参数个数，长度等信息，推理进程在连续若干次收到空消息包后，将自动进入睡眠状态，释放CPU等资源。图迭代计算进程调用推理接口时，推理进程将快速退出睡眠状态，接收输入数据并完成推理流程。\n\n### 4.2 跨进程数据交换\n\n对于推理数据的交换部分，底层通过C++开发共享内存管理模块，实现两个进程之间的数据交互。在推理初始化阶段，由InferenceContext对象开辟进程共享内存，Java进程负责创建并初始化推理（Python）进程，通知推理进程共享内存的地址信息，并映射到相应的进程。如图，Java进程和推理进程均采用C++作为桥梁语言，实现共享内存中数据的流动操作。\n\n该块内容位于文档的第四部分“技术原理”中，重点介绍了TuGraph计算引擎模型推理系统如何通过流式数据源触发图迭代计算与模型推理，并阐述了计算推理隔离和跨进程数据交换的具体实现机制，为后续内容提供了技术细节和系统架构的背景。"
            },
            {
                "content": "在每个worker工作节点下，按照不同的推理作业级别划分基础的虚拟环境，从而保证一个worker节点也可以支持不同推理任务，支持标准的requirements.txt管理推理依赖库。\n\n在图迭代计算进程和推理进程之间通过数据队列实现双边数据的交互，通过在数据包的头文件中插入参数个数，长度等信息，推理进程在连续若干次收到空消息包后，将自动进入睡眠状态，释放CPU等资源。图迭代计算进程调用推理接口时，推理进程将快速退出睡眠状态，接收输入数据并完成推理流程。\n\n### 4.2 跨进程数据交换\n\n对于推理数据的交换部分，底层通过C++开发共享内存管理模块，实现两个进程之间的数据交互。在推理初始化阶段，由InferenceContext对象开辟进程共享内存，Java进程负责创建并初始化推理（Python）进程，通知推理进程共享内存的地址信息，并映射到相应的进程。如图，Java进程和推理进程均采用C++作为桥梁语言，实现共享内存中数据的流动操作。\n\n在推理系统的性能测试阶段，我们发现推理进程读写进程时，接口的调用开销不容忽视。常规的理解认为C++能够优化Python的执行效率，但前提是Python的执行内存足够复杂，优化执行内容的收益远大于接口的调用开销。然而，在我们系统设计中，共享内存的读写接口只是操作了内存地址，实现读写指针的移动。因此，接口的调用开销也是影响推理性能的关键因素，为此，我们充分调研了业界主流的方案。\n\n如图所示，我们对比了多种Python调用C链接库的方案，性能是第一要素，因此选择Cython作为推理进程和底层内存交互的工具。Cython是一个编程语言，是Python语言的一个超集，它将/C++的静态类型系统融合在了Python中，允许开发者可以在Python代码中直接使用C语言的特性，从而提高程序的执行效率。Cython将Python源代码翻译为C或C++代码，然后将其编译为二进制代码，能够显著提高数值计算和循环场景的代码执行性能。\n\n### 4.3 推理接口设计\n\n上文介绍了采用Cython作为推理进程内存管理的链接工具，如下为TuGraph Analytics模型推理系统的内存管理接口设计，提供了初始化、读和写三个接口。\n\n该段落位于文档的第4节“技术原理”中，具体探讨了TuGraph Analytics模型推理系统中worker节点的虚拟环境管理、图迭代计算与推理进程之间的数据交互机制，特别强调了跨进程数据交换的实现方法及Cython在内存管理中的应用。"
            },
            {
                "content": "在推理系统的性能测试阶段，我们发现推理进程读写进程时，接口的调用开销不容忽视。常规的理解认为C++能够优化Python的执行效率，但前提是Python的执行内存足够复杂，优化执行内容的收益远大于接口的调用开销。然而，在我们系统设计中，共享内存的读写接口只是操作了内存地址，实现读写指针的移动。因此，接口的调用开销也是影响推理性能的关键因素，为此，我们充分调研了业界主流的方案。\n\n如图所示，我们对比了多种Python调用C链接库的方案，性能是第一要素，因此选择Cython作为推理进程和底层内存交互的工具。Cython是一个编程语言，是Python语言的一个超集，它将/C++的静态类型系统融合在了Python中，允许开发者可以在Python代码中直接使用C语言的特性，从而提高程序的执行效率。Cython将Python源代码翻译为C或C++代码，然后将其编译为二进制代码，能够显著提高数值计算和循环场景的代码执行性能。\n\n### 4.3 推理接口设计\n\n上文介绍了采用Cython作为推理进程内存管理的链接工具，如下为TuGraph Analytics模型推理系统的内存管理接口设计，提供了初始化、读和写三个接口。\n\n1. 初始化接口：负责共享内存地址的映射和读指针的初始化。\n2. 读接口：数据bytes的长度作为输入参数，直接在内存端上移动相应长度返回数据段，并移动到读指针。\n3. 写接口：将bytes和bytes长度写入到共享内存，并移动至写指针。\n\n```cython\n@cython.final\ncdef class InferIpc:\n    cdef MmapIPC * ipc_bridge;\n    cdef uint8_t* read_ptr;\n\n    def __cinit__(self, r, w):\n        self.ipc_bridge = new MmapIPC(r, w)\n        self.read_ptr = self.ipc_bridge.getReadBufferPtr()\n\n本文段落位于深入解读TuGraph计算引擎模型推理系统的技术原理部分，具体讨论了推理系统在性能测试阶段所面临的接口调用开销问题，并阐述了为什么选择Cython作为推理进程与底层内存交互的工具，以及该工具在内存管理接口设计中的应用。"
            },
            {
                "content": "### 4.3 推理接口设计\n\n上文介绍了采用Cython作为推理进程内存管理的链接工具，如下为TuGraph Analytics模型推理系统的内存管理接口设计，提供了初始化、读和写三个接口。\n\n1. 初始化接口：负责共享内存地址的映射和读指针的初始化。\n2. 读接口：数据bytes的长度作为输入参数，直接在内存端上移动相应长度返回数据段，并移动到读指针。\n3. 写接口：将bytes和bytes长度写入到共享内存，并移动至写指针。\n\n```cython\n@cython.final\ncdef class InferIpc:\n    cdef MmapIPC * ipc_bridge;\n    cdef uint8_t* read_ptr;\n\n    def __cinit__(self, r, w):\n        self.ipc_bridge = new MmapIPC(r, w)\n        self.read_ptr = self.ipc_bridge.getReadBufferPtr()\n\n    cpdef inline bytes readBytes(self, bytesSize):\n        if bytesSize == 0:\n            return b\"\"\n        cdef int readSize\n        cdef int len_ = bytesSize\n        with nogil:\n            readSize = self.ipc_bridge.readBytes(len_)\n        if readSize == 0:\n            return b\"\"\n        cdef unsigned char * binary_data = self.read_ptr\n        return binary_data[:len_]\n\n在文档的第4节\"技术原理\"中，详细阐述了TuGraph Analytics模型推理系统的工作机制和架构设计。该段落主要介绍了推理接口的设计，特别是通过Cython实现的内存管理接口，包含初始化、读写操作的具体实现，为系统在Python和Java之间高效地进行数据交互提供了技术支持。"
            },
            {
                "content": "def __cinit__(self, r, w):\n        self.ipc_bridge = new MmapIPC(r, w)\n        self.read_ptr = self.ipc_bridge.getReadBufferPtr()\n\n    cpdef inline bytes readBytes(self, bytesSize):\n        if bytesSize == 0:\n            return b\"\"\n        cdef int readSize\n        cdef int len_ = bytesSize\n        with nogil:\n            readSize = self.ipc_bridge.readBytes(len_)\n        if readSize == 0:\n            return b\"\"\n        cdef unsigned char * binary_data = self.read_ptr\n        return binary_data[:len_]\n\n    cpdef inline bool writeBytes(self, bytesBuf, length):\n        cdef bool writeFlag\n        cdef int len_ = length\n        cdef char* buf_ = bytesBuf\n        with nogil:\n            writeFlag = self.ipc_bridge.writeBytes(buf_, len_)\n        return writeFlag\n\n    def __dealloc__(self):\n        del self.ipc_bridge\n```\n\n如下为用户实现推理的Java接口，同其它图迭代计算接口一样，需要推理的时候直接调用该接口，将图迭代的中间结果inputs发送到推理进程并返回模型结果。\n\n```java\npublic interface GraphInferContext extends Closeable {\n    OUT infer(Object... inputs);\n}\n```\n\n该代码块位于TuGraph Analytics模型推理系统的技术原理部分，具体描述了内存管理接口的设计，使用Cython实现Python与C++之间的共享内存交互功能，以及用户在Java中实现推理接口的方式。这部分内容突出系统在图数据处理和模型推理中的高效数据交换机制。"
            },
            {
                "content": "cpdef inline bool writeBytes(self, bytesBuf, length):\n        cdef bool writeFlag\n        cdef int len_ = length\n        cdef char* buf_ = bytesBuf\n        with nogil:\n            writeFlag = self.ipc_bridge.writeBytes(buf_, len_)\n        return writeFlag\n\n    def __dealloc__(self):\n        del self.ipc_bridge\n```\n\n如下为用户实现推理的Java接口，同其它图迭代计算接口一样，需要推理的时候直接调用该接口，将图迭代的中间结果inputs发送到推理进程并返回模型结果。\n\n```java\npublic interface GraphInferContext extends Closeable {\n    OUT infer(Object... inputs);\n}\n```\n\n## 5. 最佳实践\n\n我们以PageRank任务结合群组打分模型推理流程为例，演示具体的操作流程。\n\n### 5.1 数据处理\n\n定义推理数据前后置处理逻辑如下：\n\n```python\nimport abc\nimport json\nimport sys\nimport os\nimport torch\n\nclass MyInference(TransFormFunction):\n    def __init__(self):\n        super().__init__(2)\n\n    def transform_pre(self, *args):\n        return args[0], args[1]\n\n    def transform_post(self, *args):\n        return args[0]\n```\n\n### 5.2 图迭代推理\n\n定义图迭代计算结合推理逻辑如下：\n\n```java\npublic static class PRVertexCentricComputeFunction implements\n        IncVertexCentricComputeFunction {\n\n该代码段位于\"TuGraph计算引擎模型推理系统\"文档的第五部分，\"最佳实践\"中，具体介绍了如何通过Cython实现内存管理接口，并展示了用户如何实现推理的Java接口。此外，还开始展示结合PageRank任务与群组打分模型的推理流程，进一步阐述数据处理和图迭代推理的具体逻辑。"
            },
            {
                "content": "我们以PageRank任务结合群组打分模型推理流程为例，演示具体的操作流程。\n\n### 5.1 数据处理\n\n定义推理数据前后置处理逻辑如下：\n\n```python\nimport abc\nimport json\nimport sys\nimport os\nimport torch\n\nclass MyInference(TransFormFunction):\n    def __init__(self):\n        super().__init__(2)\n\n    def transform_pre(self, *args):\n        return args[0], args[1]\n\n    def transform_post(self, *args):\n        return args[0]\n```\n\n### 5.2 图迭代推理\n\n定义图迭代计算结合推理逻辑如下：\n\n```java\npublic static class PRVertexCentricComputeFunction implements\n        IncVertexCentricComputeFunction {\n\n    private IncGraphComputeContext graphContext;\n    private IncGraphInferContext inferContext;\n\n    @Override\n    public void init(IncGraphComputeContext graphContext) {\n        this.graphContext = graphContext;\n        this.inferContext = (IncGraphInferContext) graphContext;\n    }\n\n该段落处于文档的第5部分，具体演示了如何在TuGraph Analytics模型推理系统中实现PageRank任务与群组打分模型的结合。它详细描述了数据处理以及图迭代推理的逻辑，提供了Python和Java代码示例以便于开发者理解和应用。"
            },
            {
                "content": "def transform_post(self, *args):\n        return args[0]\n```\n\n### 5.2 图迭代推理\n\n定义图迭代计算结合推理逻辑如下：\n\n```java\npublic static class PRVertexCentricComputeFunction implements\n        IncVertexCentricComputeFunction {\n\n    private IncGraphComputeContext graphContext;\n    private IncGraphInferContext inferContext;\n\n    @Override\n    public void init(IncGraphComputeContext graphContext) {\n        this.graphContext = graphContext;\n        this.inferContext = (IncGraphInferContext) graphContext;\n    }\n\n    @Override\n    public void evolve(Integer vertexId,\n                       TemporaryGraph temporaryGraph) {\n        long lastVersionId = 0L;\n        IVertex vertex = temporaryGraph.getVertex();\n        HistoricalGraph historicalGraph = graphContext\n                .getHistoricalGraph();\n        if (vertex == null) {\n            vertex = historicalGraph.getSnapShot(lastVersionId).vertex().get();\n        }\n\n该代码片段位于文章的“5.2 图迭代推理”部分，讨论如何结合图迭代计算与模型推理的逻辑。具体展示了一个名为`PRVertexCentricComputeFunction`的Java类，实现了图计算中的增量迭代和参数处理，以便在图计算过程中调用模型推理功能。"
            },
            {
                "content": "@Override\n    public void evolve(Integer vertexId,\n                       TemporaryGraph temporaryGraph) {\n        long lastVersionId = 0L;\n        IVertex vertex = temporaryGraph.getVertex();\n        HistoricalGraph historicalGraph = graphContext\n                .getHistoricalGraph();\n        if (vertex == null) {\n            vertex = historicalGraph.getSnapShot(lastVersionId).vertex().get();\n        }\n\n        if (vertex != null) {\n            List> newEs = temporaryGraph.getEdges();\n            List> oldEs = historicalGraph.getSnapShot(lastVersionId)\n                    .edges().getOutEdges();\n            if (newEs != null) {\n                for (IEdge edge : newEs) {\n                    graphContext.sendMessage(edge.getTargetId(), vertexId);\n                }\n            }\n            if (oldEs != null) {\n                for (IEdge edge : oldEs) {\n                    graphContext.sendMessage(edge.getTargetId(), vertexId);\n                }\n            }\n        }\n    }\n\n该代码块位于文档的“最佳实践”部分，具体是在介绍图迭代计算结合模型推理逻辑的上下文中。它展示了如何在图计算过程中处理每个顶点的演变，结合新的临时图和历史图的数据，以便在迭代过程中发送消息并更新图结构。这段代码是实现图神经网络模型推理的关键部分之一。"
            },
            {
                "content": "@Override\n    public void compute(Integer vertexId, Iterator messageIterator) {\n        int max = 0;\n        while (messageIterator.hasNext()) {\n            int value = messageIterator.next();\n            max = max > value ? max : value;\n        }\n        I\n\nVertex vertex = graphContext.getVertex(vertexId);\n        if (vertex != null) {\n            inferContext.infer(max, \"1.0\");\n        }\n    }\n}\n```\n\n### 5.3 创建作业\n\n在Console作业管理平台创建一个HLA任务，上传图迭代计算jar包，模型文件和依赖管理文件。\n\n### 5.4 配置参数\n\n配置相关参数，启动运行作业即可。\n\n- `\"geaflow.infer.env.enable\": \"true\"`  // 初始化虚拟环境等待时间\n- `\"geaflow.infer.env.init.timeout.sec\": 120`  // 是否接收日志\n- `\"geaflow.infer.env.suppress.log.enable\": \"true\"`\n\n\n## 6. 总结\n\n通过将AI模型推理引入TuGraph Analytics流图计算系统，让我们能够对图数据进行深度地分析和预测。利用最新的机器学习和深度学习技术，TuGraph Analytics图计算引擎不仅可以对图数据进行分类和回归分析，还可以预测未来趋势，从而在多个维度上提供决策支持。\n\n希望通过以上的介绍，可以让大家对TuGraph Analytics模型推理系统有个比较清晰的了解，非常欢迎大家加入我们社区（https://github.com/TuGraph-family/tugraph-analytics），一起构建图数据上的智能化分析能力！\n\n该代码段属于第5章“最佳实践”中的图迭代推理部分，具体演示了如何在图计算中实现推理功能，特别是在compute方法中处理消息并调用模型推理的逻辑。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_163.md",
        "chunks": [
            {
                "content": "# 社区贡献 | 新Feature发布：TuGraph-DB支持空间数据类型\n\n本文介绍了来自北京大学的TuGraph开源社区开发者孙同学的工作，孙同学基于开源图数据库TuGraph-DB的开发，支持了空间数据类型。文章将从空间数据类型的应用、在TuGraph-DB中的实现以及使用三个方面进行介绍。孙同学的工作丰富了TuGraph-DB功能，因此获得“TuGraph社区年度优秀贡献者”，再次感谢孙同学的贡献，项目功能正在持续完善中，也欢迎更多伙伴加入TuGraph社区一起共建。\n\n近年来，地理数据类型/空间数据类型（Spatial Data Type）在图数据库中的应用价值显著，它不仅增强了数据的表达能力，还促进了跨领域数据的融合分析，尤其在社交网络、地图探索、城市规划等关键领域展现了强大的实用价值。\n\n## 空间数据类型在图数据库中的应用案例\n\n空间地理数据也是天然适合使用图数据库的一种场景，我们先来看看在图数据库中使用空间数据的几个经典场景:\n\n### 场景案例一：判断某空间类型内的坐标\n\n如上图1和图2所示，日常生活中我们通常需要在地图中查询距离自己一定距离内的景点/美食信息。对应的在图数据库中，即为判断哪些坐标在以某点为中心的圆形或矩形区域内，对应的Cypher查询语句如下:\n\n#### 判断在圆形区域内\n\n```cypher\nWITH point({latitude: $latitude, longitude:$longitude}) AS radiusCenter\n\nMATCH (p:Point)-[:HAS_GEOMETRY]-(poi:PointOfInterest)-[:HAS_TAGS]->(t:Tags)\n    WHERE point.distance(p.location, radiusCenter) < $radius\nRETURN p {\n    latitude: p.location.latitude,\n    longitude: p.location.longitude,\n    name: poi.name,\n    categories: labels(poi),\n    tags: t{.*}                       \n} AS point\n```\n\n#### 判断在矩形区域内\n\n该文档介绍了TuGraph-DB支持空间数据类型的最新功能，重点阐述了开发者孙同学的贡献及其在图数据库中的应用场景，包括空间数据类型的使用案例、需求分析、实现方法以及具体查询示例等内容。"
            },
            {
                "content": "#### 判断在圆形区域内\n\n```cypher\nWITH point({latitude: $latitude, longitude:$longitude}) AS radiusCenter\n\nMATCH (p:Point)-[:HAS_GEOMETRY]-(poi:PointOfInterest)-[:HAS_TAGS]->(t:Tags)\n    WHERE point.distance(p.location, radiusCenter) < $radius\nRETURN p {\n    latitude: p.location.latitude,\n    longitude: p.location.longitude,\n    name: poi.name,\n    categories: labels(poi),\n    tags: t{.*}                       \n} AS point\n```\n\n#### 判断在矩形区域内\n\n```cypher\nMATCH (p:Point)-[:HAS_GEOMETRY]-(poi:PointOfInterest)-[:HAS_TAGS]->(t:Tags)\n   WHERE point.withinBBox(\n        p.location,\n        point({longitude: $lowerLeftLon, latitude: $lowerLeftLat}),\n        point({longitude: $upperRightLon, latitude: $upperRightLat})\n   )\nRETURN p {\n  latitude: p.location.latitude,\n  longitude: p.location.longitude,\n  name: poi.name,\n  categories: labels(poi),\n  tags: t{.*}\n} AS point\n```\n\n### 场景案例二：判断路径与某空间类型是否重合\n\n如上图3所示，移动物体的行动轨迹可以被抽象成一条线，这条轨迹往往伴随着时序信息。日常生活中，有时候我们想知道哪部分行动轨迹和给定区域有重合。对应在图数据库中，即判断一系列坐标中哪些坐标落在在空间类型内。对应的Cypher查询语句如下:\n\n该片段位于文章的“空间数据类型在图数据库中的应用案例”部分，具体描述了如何在图数据库中实现对空间数据的查询操作，包括判断坐标点是否在圆形或矩形区域内，以及如何分析移动物体的轨迹与空间类型的重合情况。"
            },
            {
                "content": "### 场景案例二：判断路径与某空间类型是否重合\n\n如上图3所示，移动物体的行动轨迹可以被抽象成一条线，这条轨迹往往伴随着时序信息。日常生活中，有时候我们想知道哪部分行动轨迹和给定区域有重合。对应在图数据库中，即判断一系列坐标中哪些坐标落在在空间类型内。对应的Cypher查询语句如下:\n\n```cypher\nWITH point({latitude: $latitude, longitude: $longitude}) AS radiusCenter\n\nMATCH (g: Geometry)\n    WHERE any(\n        p IN g.coordiates WHERE point.distance(p, radiusCenter) < $radius\n    )\nRETURN [n IN g.coordinates | [n.latitude, n.longitude]] AS route\n```\n\n## 空间数据类型在TuGraph-DB中的实现\n\n### 需求分析\n\n结合上述案例，我们可以分析总结出对空间数据类型的需求:\n\n- 支持不同坐标系下（包括地球地理坐标系，平面几何坐标系等）不同空间数据类型（包括Point、LineString、Polygon）的存储与创建\n- 支持不同坐标系下的常见空间查询操作, 包括Distance、BoundingBox、Disjoint（判断两个数据是否相交）的查询等\n- 支持空间数据索引（R-Tree）\n- 支持常见空间数据格式的导入（ESRI Shapefile data / OpenStreetMap）\n- 支持空间数据的可视化\n\n### 空间数据类型的表示\n\n空间数据类型可以用不同的坐标系来表示，EPSG[1]是一个标准化的地理空间参考系统标识符集合，用于标识不同的地理空间参考系统，包括坐标系统、地理坐标系、投影坐标系等。通常使用EPSG编码表示数据的坐标系。行业内一般采用\n\n- WGS84坐标系（没错，就是GPS系统的坐标系），标识符为EPSG 4326\n- Cartesian（笛卡尔）坐标系（没错，就是你高中数学学的直角坐标系），标识符为EPSG 7203\n\n该文档介绍了TuGraph-DB开源图数据库支持空间数据类型的功能，其中“场景案例二：判断路径与某空间类型是否重合”部分具体描述了在日常生活中如何利用图数据库判断移动物体的轨迹与特定区域的重合情况，接着分析了对空间数据类型的需求，以及如何在TuGraph-DB中实现这些数据类型和查询操作。"
            },
            {
                "content": "### 需求分析\n\n结合上述案例，我们可以分析总结出对空间数据类型的需求:\n\n- 支持不同坐标系下（包括地球地理坐标系，平面几何坐标系等）不同空间数据类型（包括Point、LineString、Polygon）的存储与创建\n- 支持不同坐标系下的常见空间查询操作, 包括Distance、BoundingBox、Disjoint（判断两个数据是否相交）的查询等\n- 支持空间数据索引（R-Tree）\n- 支持常见空间数据格式的导入（ESRI Shapefile data / OpenStreetMap）\n- 支持空间数据的可视化\n\n### 空间数据类型的表示\n\n空间数据类型可以用不同的坐标系来表示，EPSG[1]是一个标准化的地理空间参考系统标识符集合，用于标识不同的地理空间参考系统，包括坐标系统、地理坐标系、投影坐标系等。通常使用EPSG编码表示数据的坐标系。行业内一般采用\n\n- WGS84坐标系（没错，就是GPS系统的坐标系），标识符为EPSG 4326\n- Cartesian（笛卡尔）坐标系（没错，就是你高中数学学的直角坐标系），标识符为EPSG 7203\n\nWGS84是全球定位系统(GPS)的基础，允许全球的GPS接收器确定精确位置。几乎所有现代GPS设备都是基于WGS84坐标系来提供位置信息。在地图制作和GIS（地图制作和地理信息系统）领域，WGS84被广泛用于定义地球上的位置。这包括各种类型的地图创建、空间数据分析和管理等。\n\nCartesian（笛卡尔）坐标系，又称直角坐标系，是一种最基本、最广泛应用的坐标系统。它通过两条数轴定义一个平面，三条数轴定义一个空间，这些轴互相垂直，在数学、物理、工程、天文和许多其他领域中有着广泛的应用。\n\n### 空间数据类型的实现\n\nOGC(Open Geospatial Consortium) 定义了空间数据的标准表示格式，分别为EWKT(extended well known text)与EWKB(extended well known binary)格式，用于在不同系统和平台之间交换和存储空间数据，现已被广泛采用。\n\n#### EWKT\n\nEWKT格式数据如下所示，先指定空间数据类型，再在括号内指定具体的坐标，一个坐标对表示一个点，每个坐标对之间用逗号隔开。其中，对于Polygon类型的数据，第一个坐标对需要与最后一个坐标对相同，形成闭合的面。\n\n该内容块位于文章的中段，主要讨论了空间数据类型在TuGraph-DB中的需求分析、表示方式和实现细节，包括不同坐标系的支持、标准表示格式以及空间数据的具体表示方法，为后续对空间数据类型在TuGraph-DB中具体实现的讨论奠定基础。"
            },
            {
                "content": "Cartesian（笛卡尔）坐标系，又称直角坐标系，是一种最基本、最广泛应用的坐标系统。它通过两条数轴定义一个平面，三条数轴定义一个空间，这些轴互相垂直，在数学、物理、工程、天文和许多其他领域中有着广泛的应用。\n\n### 空间数据类型的实现\n\nOGC(Open Geospatial Consortium) 定义了空间数据的标准表示格式，分别为EWKT(extended well known text)与EWKB(extended well known binary)格式，用于在不同系统和平台之间交换和存储空间数据，现已被广泛采用。\n\n#### EWKT\n\nEWKT格式数据如下所示，先指定空间数据类型，再在括号内指定具体的坐标，一个坐标对表示一个点，每个坐标对之间用逗号隔开。其中，对于Polygon类型的数据，第一个坐标对需要与最后一个坐标对相同，形成闭合的面。\n\n```\nSRID=s;POINT ( )\nSRID=s;LINESTRING( ,  , …)\n```\n注: SRID默认为4326, 可以不指定\n\n#### EWKB\n\nEWKB格式数据如下图所示，\n\n- 第0-1位: 表示编码方式 00表示大端法，01表示小端法\n- 第2 - 5位: 空间数据类型\n  - 0100: point\n  - 0200: linestring\n  - 0300: polygon\n- 第6 - 9位: 数据维度\n  - 0020: 二维\n  - 0030: 三维\n- 第10 - 17位: 坐标系的EPSG编码\n- 第18 - n位: double类型的坐标对的16进制表示\n\n注: 对于POINT类型，其EWKB格式为定长存储，固定长度为50，而对于其他类型，则为不定长。\n\n### 实现思路\n\n在TuGraph-DB的实现，基于boost geometry库的基础上进行封装，用EWKB格式存储数据，其中Point类型为定长存储50，其余皆为变长存储。我们支持了Point, Linestring与Polygon三种类型，同时支持了WGS84, CARTESIAN两种坐标系，数据类型与坐标系均可根据需要拓展。\n\n## 在TuGraph-DB中使用空间数据类型\n\n### 定义空间数据类型\n\nTuGraph-DB当前已经支持Point、Linestring与Polygon三种类型\n\n本文介绍了TuGraph-DB中空间数据类型的实现，具体包括Cartesian坐标系的定义、空间数据的标准表示格式EWKT和EWKB，以及在TuGraph-DB中对这些空间数据类型的支持和存储实现。这一部分在讨论空间数据类型的功能与存储基础上，连接后续对TuGraph-DB中空间数据类型的使用描述。"
            },
            {
                "content": "- 第0-1位: 表示编码方式 00表示大端法，01表示小端法\n- 第2 - 5位: 空间数据类型\n  - 0100: point\n  - 0200: linestring\n  - 0300: polygon\n- 第6 - 9位: 数据维度\n  - 0020: 二维\n  - 0030: 三维\n- 第10 - 17位: 坐标系的EPSG编码\n- 第18 - n位: double类型的坐标对的16进制表示\n\n注: 对于POINT类型，其EWKB格式为定长存储，固定长度为50，而对于其他类型，则为不定长。\n\n### 实现思路\n\n在TuGraph-DB的实现，基于boost geometry库的基础上进行封装，用EWKB格式存储数据，其中Point类型为定长存储50，其余皆为变长存储。我们支持了Point, Linestring与Polygon三种类型，同时支持了WGS84, CARTESIAN两种坐标系，数据类型与坐标系均可根据需要拓展。\n\n## 在TuGraph-DB中使用空间数据类型\n\n### 定义空间数据类型\n\nTuGraph-DB当前已经支持Point、Linestring与Polygon三种类型\n\n- Point：点，创建方式例如POINT(2.0, 2.0, 7203)\n- Linestring：折线，创建方式例如LINESTRING(0 2,1 1,2 0)\n- Polygon：多边形，创建方式例如POLYGON((0 0,0 7,4 2,2 0,0 0))\n\n其中坐标点都是double型\n\n### 相关函数介绍\n\n创建空间数据相关函数，以Point为例：\n\n该部分内容位于文章中关于TuGraph-DB中空间数据类型实现的讨论部分，具体介绍了EWKB格式的存储细节，包括编码方式、数据类型、维度、坐标系及存储格式。同时，该段落还引入了实现思路，并简要列出了TuGraph-DB当前支持的空间数据类型及其创建方式，接下来会介绍相关函数的创建与使用。"
            },
            {
                "content": "注: 对于POINT类型，其EWKB格式为定长存储，固定长度为50，而对于其他类型，则为不定长。\n\n### 实现思路\n\n在TuGraph-DB的实现，基于boost geometry库的基础上进行封装，用EWKB格式存储数据，其中Point类型为定长存储50，其余皆为变长存储。我们支持了Point, Linestring与Polygon三种类型，同时支持了WGS84, CARTESIAN两种坐标系，数据类型与坐标系均可根据需要拓展。\n\n## 在TuGraph-DB中使用空间数据类型\n\n### 定义空间数据类型\n\nTuGraph-DB当前已经支持Point、Linestring与Polygon三种类型\n\n- Point：点，创建方式例如POINT(2.0, 2.0, 7203)\n- Linestring：折线，创建方式例如LINESTRING(0 2,1 1,2 0)\n- Polygon：多边形，创建方式例如POLYGON((0 0,0 7,4 2,2 0,0 0))\n\n其中坐标点都是double型\n\n### 相关函数介绍\n\n创建空间数据相关函数，以Point为例：\n\n| 函数名      | 描述                              | 输入参数                                 | 返回值类型 |\n|-------------|-----------------------------------|------------------------------------------|------------|\n| `Point()`   | 根据坐标或EWKB创建Point            | 坐标对 (double, double) / EWKB format(string) | point      |\n| `PointWKB()`| 根据WKB与指定SRID创建Point         | WKB format(string), SRID(int)            | point      |\n| `PointWKT()`| 根据WKT与指定SRID创建Point         | WKT format(string), SRID(int)            | point      |\n表格内容描述：\n\n该文本块位于文章中关于TuGraph-DB空间数据类型实现的部分，主要介绍了空间数据类型（如Point、Linestring和Polygon）的定长和变长存储方式，并列出了如何在TuGraph-DB中创建和使用这些空间数据类型的相关函数及其描述。这部分内容紧接着对于空间数据类型的表示和存储的前述讨论，是实现空间数据操作的具体应用示例。"
            },
            {
                "content": "该表格包含四列，分别为“函数名”、“描述”、“输入参数”和“返回值类型”。每一行对应一个函数的详细信息。\n\n1. 第一行涉及的函数是 `Point()`，它的功能是根据给定的坐标对或EWKB格式创建一个Point对象。输入参数可以是一个双精度浮点数的坐标对或者一个EWKB格式的字符串，返回值的类型为Point。\n\n2. 第二行的函数是 `PointWKB()`，该函数用于根据WKB格式和指定的SRID创建一个Point对象。它接受的输入参数是一个WKB格式的字符串和一个整型SRID，返回值的类型同样是Point。\n\n3. 第三行介绍的函数是 `PointWKT()`，其功能是根据WKT格式和指定的SRID创建Point对象。输入参数包括一个WKT格式的字符串和一个整型SRID，返回值的类型为Point。\n\n总结：该表格展示了三个用于创建Point对象的函数，并详细说明了每个函数的描述、输入参数及返回值类型。所有函数均返回Point类型的对象，输入参数涵盖了不同格式的数据。\n\n\n### 查询用相关函数：\n\n| 函数名      | 描述                              | 输入参数                                 | 返回值类型 |\n|-------------|-----------------------------------|------------------------------------------|------------|\n| `Distance()`   | 计算两个空间数据间的距离\t           | 注：要求坐标系相同| Spatial data1, Spatial data2         | double\t    |\n| `Disjoint()`| 判断两个空间数据是否相交\t         | 注：开发中| Spatial data1, Spatial data2        | bool\t    |\n| `WithinBBox()`| 判断某个空间数据是否在给定的长方形区域内\t       | 注：开发中| Spatial data, Point1       | bool\t    |\n表格内容描述：\n该表格包含四个列名：函数名、描述、输入参数和返回值类型。\n\n该段落位于文章的中间部分，主要介绍了在TuGraph-DB中有关空间数据类型的相关函数，包括如何创建Point对象的函数（如`Point()`, `PointWKB()`, `PointWKT()`）及其输入参数和返回值类型。此外，还描述了用于查询的相关函数（如`Distance()`, `Disjoint()`, `WithinBBox()`）及其功能。这部分内容旨在帮助用户理解如何在TuGraph-DB中处理和查询空间数据。"
            },
            {
                "content": "1. `Distance()`函数用于计算两个空间数据之间的距离。该函数要求输入的空间数据具有相同的坐标系，输入参数为两个空间数据（Spatial data1和Spatial data2），返回值类型为一个双精度浮点数（double）。\n\n2. `Disjoint()`函数用于判断两个空间数据是否相交。该函数目前处于开发中，输入参数同样为两个空间数据（Spatial data1和Spatial data2），返回值类型为布尔值（bool），用于表示相交状态。\n\n3. `WithinBBox()`函数用于判断某个空间数据是否位于指定的长方形区域内。该函数也处于开发中，输入参数包括一个空间数据（Spatial data）和一个点（Point1），返回值类型为布尔值（bool），用于表明该空间数据是否在指定区域内。\n\n整体总结：该表格列出了三种空间数据处理的函数，它们的功能包括计算距离、判断相交与判断是否在指定区域内。其中，`Distance()`已完成，而`Disjoint()`和`WithinBBox()`仍在开发中。返回值类型涵盖了双精度浮点数和布尔值两种。\n\n### 使用实例如下：\n\n#### 创建包含空间数据类型的点模型\n\nCALL db.createVertexLabel('food', 'id', 'id', int64, false, 'name', string, true,'pointTest',point,true) \n\n#### 插入标记美食点的数据\n\nCREATE (n:food {id:10001, name: 'aco Bell',pointTest:point(3.0,4.0,7203)}) RETURN n\n\n#### 创建具有折线属性的点模型\n\nCALL db.createVertexLabel('lineTest', 'id', 'id', int64, false, 'name', string, true,'linestringTest',linestring,true)\n\n#### 插入具有折线属性的点数据\n\nCREATE (n:lineTest {id:102, name: 'Tom',linestringTest:linestringwkt('LINESTRING(0 2,1 1,2 0)', 7203)}) RETURN n\n\n#### 创建具有多边型属性的点模型\n\n该段落位于文档的“相关函数介绍”部分，主要介绍了TuGraph-DB中的三个空间数据处理函数，包括`Distance()`、`Disjoint()`和`WithinBBox()`，阐述了它们的功能、输入参数和返回值类型，并展示了如何创建和插入空间数据类型的模型的实际示例。"
            },
            {
                "content": "CALL db.createVertexLabel('food', 'id', 'id', int64, false, 'name', string, true,'pointTest',point,true) \n\n#### 插入标记美食点的数据\n\nCREATE (n:food {id:10001, name: 'aco Bell',pointTest:point(3.0,4.0,7203)}) RETURN n\n\n#### 创建具有折线属性的点模型\n\nCALL db.createVertexLabel('lineTest', 'id', 'id', int64, false, 'name', string, true,'linestringTest',linestring,true)\n\n#### 插入具有折线属性的点数据\n\nCREATE (n:lineTest {id:102, name: 'Tom',linestringTest:linestringwkt('LINESTRING(0 2,1 1,2 0)', 7203)}) RETURN n\n\n#### 创建具有多边型属性的点模型\n\nCALL db.createVertexLabel('polygonTest', 'id', 'id', int64, false, 'name', string, true,'polygonTest',polygon,true)\n\n#### 插入具有多边型属性的点数据\n\nCREATE (n:polygonTest {id:103, name: 'polygonTest',polygonTest:polygonwkt('POLYGON((0 0,0 7,4 2,2 0,0 0))', 7203)}) RETURN n\n\n## Demo演示：基于地理位置个性化推荐的美食探索\n\n在本章节中，我们将探索如何利用TuGraph-DB图数据库的地理空间功能，构建一个生动有趣的美食探索应用，“人”与“美食”通过地理位置紧密相连，实现个性化美食推荐。\n\n### 数据模型设计\n\n定义两种核心节点类型：\n\n- **Food（美食）点**：每一家餐厅或小吃店都可以作为一个Food节点，其属性包括但不限于名称、地址、评分、美食类别等。特别地，我们将在每个Food节点上附加地理坐标信息，用以精确记录其地理位置。\n\n该部分内容位于文章的\"在TuGraph-DB中使用空间数据类型\"章节，主要介绍如何在TuGraph-DB中创建和插入包含空间数据类型的节点模型，包括美食、折线和多边形的属性。同时，随后引入了一个基于地理位置的个性化美食推荐应用的Demo演示，展示如何利用图数据库的地理空间功能实现相关查询和推荐。"
            },
            {
                "content": "CALL db.createVertexLabel('polygonTest', 'id', 'id', int64, false, 'name', string, true,'polygonTest',polygon,true)\n\n#### 插入具有多边型属性的点数据\n\nCREATE (n:polygonTest {id:103, name: 'polygonTest',polygonTest:polygonwkt('POLYGON((0 0,0 7,4 2,2 0,0 0))', 7203)}) RETURN n\n\n## Demo演示：基于地理位置个性化推荐的美食探索\n\n在本章节中，我们将探索如何利用TuGraph-DB图数据库的地理空间功能，构建一个生动有趣的美食探索应用，“人”与“美食”通过地理位置紧密相连，实现个性化美食推荐。\n\n### 数据模型设计\n\n定义两种核心节点类型：\n\n- **Food（美食）点**：每一家餐厅或小吃店都可以作为一个Food节点，其属性包括但不限于名称、地址、评分、美食类别等。特别地，我们将在每个Food节点上附加地理坐标信息，用以精确记录其地理位置。\n\n- **Person（人物）点**：代表应用的用户，属性包含用户名、当前位置等。用户的当前位置同样通过地理坐标表示，便于后续的地理空间查询。\n\n### 创建Schema\n\nCALL db.createVertexLabel('food', 'id', 'id', int64, false, 'name', string, true,'pointTest',point,true,'mark',double,true)\n\nCALL db.createVertexLabel('person', 'id', 'id', int64, false, 'name', string, true,'pointTest',point,true)\n\n### 插入示例数据 food\n\nCREATE (n:food {id:10001, name: 'Starbucks',pointTest:point(1.0,1.0,7203),mark:4.8}) RETURN n\n\nCREATE (n:food {id:10002, name: 'KFC',pointTest:point(2.0,1.0,7203),mark:4.5}) RETURN n\n\n该段落位于文章的中后部分，主要介绍了如何在TuGraph-DB中创建带有多边形属性的节点模型，并如何插入相应的数据。之后进入了一个名为“基于地理位置个性化推荐的美食探索”的演示章节，阐述了如何利用地理空间功能设计相关的数据模型和插入美食与用户节点的数据。"
            },
            {
                "content": "### 创建Schema\n\nCALL db.createVertexLabel('food', 'id', 'id', int64, false, 'name', string, true,'pointTest',point,true,'mark',double,true)\n\nCALL db.createVertexLabel('person', 'id', 'id', int64, false, 'name', string, true,'pointTest',point,true)\n\n### 插入示例数据 food\n\nCREATE (n:food {id:10001, name: 'Starbucks',pointTest:point(1.0,1.0,7203),mark:4.8}) RETURN n\n\nCREATE (n:food {id:10002, name: 'KFC',pointTest:point(2.0,1.0,7203),mark:4.5}) RETURN n\n\nCREATE (n:food {id:10003, name: 'Pizza Hut',pointTest:point(2.0,5.0,7203),mark:4.5}) RETURN n\n\nCREATE (n:food {id:10004, name: 'Taco Bell',pointTest:point(3.0,4.0,7203),mark:4.7}) RETURN n\n\nCREATE (n:food {id:10005, name: 'Pizza Fusion',pointTest:point(5.0,3.0,7203),mark:4.9}) RETURN n\n\nCREATE (n:food {id:10006, name: 'HaiDiLao Hot Pot',pointTest:point(2.0,2.0,7203),mark:4.8}) RETURN n\n\nCREATE (n:food {id:10007, name: 'Lao Sze Chuan',pointTest:point(4.0,3.0,7203),mark:4.7}) RETURN n\n\n### 插入示例数据 person\n\n该块内容位于文档的“在TuGraph-DB中使用空间数据类型”部分，具体介绍了如何创建数据库模式（Schema）以及插入示例数据，包含美食（food）和人物（person）节点的信息，这是利用TuGraph-DB图数据库进行地理空间功能应用的关键步骤。"
            },
            {
                "content": "CREATE (n:food {id:10003, name: 'Pizza Hut',pointTest:point(2.0,5.0,7203),mark:4.5}) RETURN n\n\nCREATE (n:food {id:10004, name: 'Taco Bell',pointTest:point(3.0,4.0,7203),mark:4.7}) RETURN n\n\nCREATE (n:food {id:10005, name: 'Pizza Fusion',pointTest:point(5.0,3.0,7203),mark:4.9}) RETURN n\n\nCREATE (n:food {id:10006, name: 'HaiDiLao Hot Pot',pointTest:point(2.0,2.0,7203),mark:4.8}) RETURN n\n\nCREATE (n:food {id:10007, name: 'Lao Sze Chuan',pointTest:point(4.0,3.0,7203),mark:4.7}) RETURN n\n\n### 插入示例数据 person\n\nCREATE (n:person {id:1, name: 'Tom',pointTest:point(3.0,3.0,7203)}) RETURN n\n\n### 构建美食探索查询\n\n能够根据用户的当前位置，寻找距离2.5以内的美食，根据距离进行升序排列，返回距离和评分。\n\nMATCH (n:person{id:1}), (m:food)\n\nWITH n.pointTest AS p1, m.pointTest AS p2, m.name AS food, m.mark AS mark\n\nCALL spatial.distance(p1,p2) YIELD distance \n\nWHERE distance < 2.5\n\nRETURN food,distance,mark\n\nORDER BY distance\n\n此查询首先匹配特定的Person节点，然后找到所有Food节点，利用自定义的distance函数计算Person节点当前位置与每个Food节点之间的直线距离，筛选出距离在2.5之内的美食。最后，按照美食的距离升序排列结果，附带评分参考，为用户提供最优质的推荐。\n\n### 未来展望\n\n该段落位于文章的后半部分，主要介绍了在TuGraph-DB中插入美食和用户数据的示例，以及如何构建基于用户当前地理位置的美食推荐查询。它展示了TuGraph-DB处理空间数据的具体应用，特别是在个性化推荐场景中的实际操作和查询能力，同时也为讨论未来功能扩展铺垫了基础。"
            },
            {
                "content": "CREATE (n:person {id:1, name: 'Tom',pointTest:point(3.0,3.0,7203)}) RETURN n\n\n### 构建美食探索查询\n\n能够根据用户的当前位置，寻找距离2.5以内的美食，根据距离进行升序排列，返回距离和评分。\n\nMATCH (n:person{id:1}), (m:food)\n\nWITH n.pointTest AS p1, m.pointTest AS p2, m.name AS food, m.mark AS mark\n\nCALL spatial.distance(p1,p2) YIELD distance \n\nWHERE distance < 2.5\n\nRETURN food,distance,mark\n\nORDER BY distance\n\n此查询首先匹配特定的Person节点，然后找到所有Food节点，利用自定义的distance函数计算Person节点当前位置与每个Food节点之间的直线距离，筛选出距离在2.5之内的美食。最后，按照美食的距离升序排列结果，附带评分参考，为用户提供最优质的推荐。\n\n### 未来展望\n\n孙同学的工作，让TuGraph-DB具备了处理地理空间数据的能力。未来，TuGraph-DB将来会继续实现Disjoint() 、WithinBBox()等更多的函数，以及实现更高级的索引、数据导入、可视化等功能，丰富更多的使用场景。作为开源项目，TuGraph社区也欢迎大家一起参与共建开发地理空间功能。\n\n该内容位于文档的实用实例部分，展示了如何在TuGraph-DB中创建用户节点和进行美食探索查询的具体操作，包括根据用户位置寻找附近美食的Cypher查询示例及其解释，随后提到未来的功能展望。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_164.md",
        "chunks": [
            {
                "content": "# 权威报告：蚂蚁集团TuGraph跻身中国图数据库市场“领导者”象限\n\n7月15日，全球领先的IT市场研究和咨询公司IDC发布了最新的市场研究报告《IDC MarketScape：中国图数据库市场厂商评估，2023》。报告显示，蚂蚁集团自研的企业级图数据管理平台TuGraph跻身\"领导者\"象限。\n\nIDC在报告中列举了蚂蚁集团TuGraph的五大优势。第一，TuGraph研发七年多来支持了蚂蚁集团300多种应用，在大量不同场景中长时间使用，产品成熟度、丰富度等方面具有优势。第二，具备业界鲜有的在线、流式、离线\"三线一致\"计算能力，覆盖了毫秒级延迟、分钟级和小时级等不同引擎，满足不同场景的性能需求。第三，支持每秒千万级查询的超高吞吐，毫秒级超低延迟。第四，生态工具“一站式图研发及可视化平台 TuGraph-Platform”降低了用户使用门槛。第五，在其他非金融场景，如社交推荐、数据血缘管理、故障归因分析等场景广泛使用，应用体系成熟。\n\n本次报告IDC主要评估了中国市场上12家典型的企业级图数据库厂商，类型覆盖互联网厂商、云服务厂商、大数据厂商等。IDC针对入选图数据库厂商的产品能力（Capabilities）和技术战略（Strategies）两个维度，考察了目前的产品技术能力、市场和生态以及未来发展战略等，评估了16个细分能力指标和4个细分战略指标，包含72个指标评估项，并配以不同权重。该报告为企业发展图计算和投资选型提供了有力支持。\n\n图数据库，即以图（Graph）数据结构来进行存储和分析的数据库。与传统数据库相比，图数据库擅长关系分析，能更好地管理和组织数据，开发上层智能模型，同时也能实现海量数据的高并发、低延迟分析处理，提高数据变现的商业价值。当前图数据库应用主要集中在欺诈检测、人际关系分析和预测分析等领域。\n\nIDC调研发现，数字经济、产业数字化转型进入深化发展阶段，企业对于业务逻辑开发和关系挖掘需求增强，图数据库市场受大型央国企数字化转型政策的推动明显。95%的企业认为图数据库是重要的数据管理工具，超过 65%的厂商认为在业务上图数据库优于其他选择。整体来看，图数据库的使用仍处于早期阶段，仍然缺乏统一标准范式，技术生态环境弱势，低操作门槛的图计算平台仍有较大缺口。\n\n该段落概述了2023年IDC发布的报告，指出蚂蚁集团的TuGraph在中国图数据库市场中被评为“领导者”，并详细说明了TuGraph的五大优势及IDC的评估方法和市场现状，强调了图数据库在数字经济和企业数字化转型中的重要性。"
            },
            {
                "content": "图数据库，即以图（Graph）数据结构来进行存储和分析的数据库。与传统数据库相比，图数据库擅长关系分析，能更好地管理和组织数据，开发上层智能模型，同时也能实现海量数据的高并发、低延迟分析处理，提高数据变现的商业价值。当前图数据库应用主要集中在欺诈检测、人际关系分析和预测分析等领域。\n\nIDC调研发现，数字经济、产业数字化转型进入深化发展阶段，企业对于业务逻辑开发和关系挖掘需求增强，图数据库市场受大型央国企数字化转型政策的推动明显。95%的企业认为图数据库是重要的数据管理工具，超过 65%的厂商认为在业务上图数据库优于其他选择。整体来看，图数据库的使用仍处于早期阶段，仍然缺乏统一标准范式，技术生态环境弱势，低操作门槛的图计算平台仍有较大缺口。\n\n蚂蚁集团从2015年开始布局图技术，与清华大学合作研发了高性能图数据库TuGraph，扛住了蚂蚁万亿级业务的高性能要求。TuGraph在功能完整性、吞吐率、响应时间等技术指标上处于全球领先水平，两次打破国际图数据库基准性能测试世界纪录，成为LDBC-SNB世界纪录保持者。TuGraph在2021年帮助支付宝实现了资产损失率小于亿分之0.98的目标。\n\n目前，蚂蚁集团已经开源了TuGraph系统中的单机版图数据TuGraph-DB和流式图计算引擎TuGraph-Analytics。TuGraph-DB提供了完备的图数据库基础功能和成熟的产品设计，具备完整的事务支持和丰富的系统特性，可在单机上部署，使用成本低，支持TB级别的数据规模。而TuGraph-Analytics是业界首个工业级流式图计算引擎，能够在超大规模图上进行流式复杂计算。\n\n未来，蚂蚁将持续加强技术开放，为业界带来先进的图计算技术能力，与行业携手建设图计算技术生态。\n\n该块内容主要介绍了图数据库的定义、优势及应用领域，强调了数字经济对图数据库的需求增长，以及蚂蚁集团在图数据库领域的技术布局和开源项目，为整体报告关于蚂蚁集团TuGraph在中国图数据库市场中的领导地位提供背景支持。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_165.md",
        "chunks": [
            {
                "content": "# 技术解读 I TuGraph查询引擎简析\n\n存储和计算是图数据库的两个重要组成部分。TuGraph的计算层包括图分析引擎、图查询引擎和图学习引擎。我们之前已经介绍了图分析引擎，现在我们将分享一下图查询引擎。\n\n图查询引擎是一种用于查询图数据库的工具，它使用特定的查询语言（如Cypher或ISO GQL）来执行和操作图数据库。这些查询语言允许用户描述图模式并查询图数据，例如查找特定节点或查找节点之间的路径。\n\n目前，TuGraph支持使用Open Cypher作为查询语言，即将支持ISO GQL查询语言。与关系型数据库的SQL类似，Open Cypher和ISO GQL都是声明式查询语言。它们需要转换成高效的命令式执行计划，以便计算机系统能够理解和执行。查询引擎需要完成理解用户查询意图和转换执行计划的功能。\n\n在本文中，我们将概述Open Cypher/ISO GQL查询如何执行，但不会详细探讨其中的技术细节，以帮助用户从整体上理解TuGraph查询引擎的工作原理。\n\n## 01 TuGraph查询引擎架构\n\nTuGraph在不断演进，将图查询和图分析引擎融合在一起，旨在提供混合查询和分析能力，并保持一致的使用体验。其架构如下图所示：\n\n## 02 查询引擎工作流程\n\nTuGraph查询引擎的主要步骤包括：\n\n1. 将输入的查询字符串转换为抽象语法树（AST）。\n2. 优化并归一化AST，生成通用语法中间表示（GST）。\n3. 使用GST创建查询图并提取符号表，创建逻辑执行计划。\n4. 优化逻辑执行计划。\n5. 根据逻辑执行计划创建（物理）执行计划。\n6. 校验schema约束、访问权限等。\n7. 执行上述执行计划，得到查询结果。\n\n### 将输入的查询字符串转换为抽象语法树（AST）\n\n将用户输入的（Open Cypher或者ISO GQL）查询字符串转换为抽象语法树（AST）。在此过程中，任何语法错误都会被捕获并返回给用户，但我们在此阶段不进行语义检查。\n\n### 优化并归一化AST，生成通用语法中间表示（GST）\n\n在将查询字符串转换为抽象语法树（AST）后，我们仍需要解决一些问题。首先，原始AST层次较高，分支较为繁杂。更重要的是，AST与查询语言相关，不同的查询语言（如Open Cypher和ISO GQL）会生成完全不同的AST，这不利于后续的统一处理。\n\n该文档主要探讨了TuGraph查询引擎的架构和工作流程。前面部分介绍了图查询引擎的基本概念和使用的查询语言（Open Cypher和ISO GQL），接下来的内容详细描述了查询引擎的工作流程，包括将查询字符串转换为抽象语法树（AST）、优化和生成通用语法中间表示（GST）等步骤。此段落具体描述了查询引擎工作流程的前两个步骤。"
            },
            {
                "content": "## 02 查询引擎工作流程\n\nTuGraph查询引擎的主要步骤包括：\n\n1. 将输入的查询字符串转换为抽象语法树（AST）。\n2. 优化并归一化AST，生成通用语法中间表示（GST）。\n3. 使用GST创建查询图并提取符号表，创建逻辑执行计划。\n4. 优化逻辑执行计划。\n5. 根据逻辑执行计划创建（物理）执行计划。\n6. 校验schema约束、访问权限等。\n7. 执行上述执行计划，得到查询结果。\n\n### 将输入的查询字符串转换为抽象语法树（AST）\n\n将用户输入的（Open Cypher或者ISO GQL）查询字符串转换为抽象语法树（AST）。在此过程中，任何语法错误都会被捕获并返回给用户，但我们在此阶段不进行语义检查。\n\n### 优化并归一化AST，生成通用语法中间表示（GST）\n\n在将查询字符串转换为抽象语法树（AST）后，我们仍需要解决一些问题。首先，原始AST层次较高，分支较为繁杂。更重要的是，AST与查询语言相关，不同的查询语言（如Open Cypher和ISO GQL）会生成完全不同的AST，这不利于后续的统一处理。\n\n为了解决这些问题，我们将在此步骤中完成以下任务：\n\n- 进行语义检查。\n- 根据语义生成通用语法表示（GST），对AST进行压缩，以便按相同语义进行处理。\n\n无论使用哪种查询语言，生成的GST都是相同的。\n\n### 使用GST创建查询图并提取符号表，创建逻辑执行计划\n\n我们使用通用语法中间表示（GST）来创建查询图，它是查询的更抽象、更高级的表示。使用查询图而不是直接在GST上操作，可以更有效地计算成本和执行优化。\n\n逻辑计划是一棵多叉树，由类似于关系数据库逻辑计划所使用的运算符组成。为每个查询图生成一个逻辑计划（根据查询，查询图可能由子查询图组成）。这是按照自下而上的方法逐步完成的。优化逻辑执行计划在传统的关系型数据库中，关系代数（以及等价的元组关系演算和域关系演算）构成了数据库查询理论的基础。它们也是执行计划优化的理论基础。\n\nTuGraph总结了图代数是SQL关系代数的扩展，如下图所示：\n\n因此，TuGraph的优化器包含了许多优化，例如filter安置、dedup安置、traversal规划、lazy materialization等等。在后续的文章中，我们将详细介绍这些优化。\n\n### 由逻辑执行计划创建（物理）执行计划\n\n该内容段落位于文章的第二部分，专注于TuGraph查询引擎的工作流程，详细描述了查询引擎执行用户查询的主要步骤，包括从输入的查询字符串转化为执行计划的整个过程，从而帮助用户理解查询引擎的运作机制。"
            },
            {
                "content": "- 进行语义检查。\n- 根据语义生成通用语法表示（GST），对AST进行压缩，以便按相同语义进行处理。\n\n无论使用哪种查询语言，生成的GST都是相同的。\n\n### 使用GST创建查询图并提取符号表，创建逻辑执行计划\n\n我们使用通用语法中间表示（GST）来创建查询图，它是查询的更抽象、更高级的表示。使用查询图而不是直接在GST上操作，可以更有效地计算成本和执行优化。\n\n逻辑计划是一棵多叉树，由类似于关系数据库逻辑计划所使用的运算符组成。为每个查询图生成一个逻辑计划（根据查询，查询图可能由子查询图组成）。这是按照自下而上的方法逐步完成的。优化逻辑执行计划在传统的关系型数据库中，关系代数（以及等价的元组关系演算和域关系演算）构成了数据库查询理论的基础。它们也是执行计划优化的理论基础。\n\nTuGraph总结了图代数是SQL关系代数的扩展，如下图所示：\n\n因此，TuGraph的优化器包含了许多优化，例如filter安置、dedup安置、traversal规划、lazy materialization等等。在后续的文章中，我们将详细介绍这些优化。\n\n### 由逻辑执行计划创建（物理）执行计划\n\n我们为逻辑运算符选择物理实现并缓存执行计划，从而根据逻辑计划创建执行计划。物理执行计划是一棵由运算符组成的树，它与逻辑执行计划同构。其中的每个物理运算符都准确地完成逻辑运算符规定的操作，接收逻辑运算符规定的输入输出。\n\n### 校验schema约束、访问权限等\n\n在此步骤中，我们会对执行计划的有效性进行校验，包括schema约束、访问权限等。如果校验不通过，我们将报错并返回给用户。\n\n### 执行上述执行计划得到查询结果\n\n通过校验的执行计划将被实际执行，执行的结果将作为查询结果返回给用户。\n\n## 03 小结\n\n一款卓越的图查询引擎通常具备如下特质：功能强大、快速执行查询、易于使用、并且能够扩展到更大型的图数据库以提供卓越的性能。TuGraph查询引擎的设计恰是基于这些特质而进行的。我们将在未来用更多文章详细介绍TuGraph查询引擎的设计和每一步的工作。\n\n该文本块位于文档的第二部分“查询引擎工作流程”中，具体描述了TuGraph查询引擎在将抽象语法树（AST）转换为通用语法中间表示（GST）后，进行的语义检查、创建查询图、生成逻辑执行计划的过程，以及后续物理执行计划的生成和校验。这一部分详述了查询引擎的核心工作机制，帮助用户理解图查询的执行流。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_166.md",
        "chunks": [
            {
                "content": "# 源码解读｜TuGraph Schema\n\n## 什么是schema\n\nTuGraph作为强schema的图数据库，在插入数据之前要求数据一定归属于某个schema，即创建某个类型的点边模型之后，才可以插入数据，那么什么是schema呢？schema是一种约束和规定，它有两个方面的作用：\n\n- 它规定了某个类型的点边拥有哪些属性，这些属性是什么类型的，属性是如何存储在磁盘中的，是否可以为空，它有多少定长的属性，多少变长的属性。\n- 如何从一个点或边数据中解析出某个属性值等等功能。\n\n总而言之，schema指导了如何根据磁盘中的一段二进制数据解析出某个点或边的属性内容和属性值，用于后续的计算。\n\n## TuGraph Schema\n\n### schema的定义\n\nschema的定义具体表现为一种约束，它指定了一个点或者边有哪些属性，属性大小，以及如何排布。它的定义主要由如下类提供：\n\n### schema的应用\n\nschema的应用具体表现为一种格式，它指定了一个点或边的数据(即点或边的属性值)如何存储在磁盘中。下文中所说的点或边的属性值的二进制即指磁盘中的点或边数据。\n\n## 点的存储格式\n\n点的存储格式一共包含如下几部分内容：\n\n- **Label Id**：schema的唯一标示，uint16_t类型，因此一个子图(即一个LightningGraph)中的点或边的个数不能超过65535个，超过将会无法区分。\n- **Null-Array**：值可以为空(即optional)类型的属性数组，每个optional的field占一位，以字节对齐，第一个optional的属性标记位于Null-Array第一字节的最后一位，第七个optional的属性标记位于Null-Array第一字节的最前面一位，用于指示某个点或边optional属性对应的数据是否为空。\n- **Fixed-fields**：定长属性列，属性值紧挨着保存，定长属性的长度确定，因此只要知道开始位置就可以正确取出内容，起始位置保存在FieldExtractor类的成员data_off中。\n- **Variable-Offsets**：变长属性偏移列表，记录变长属性开始的位置，变长属性通过当前属性开始位置和下一个属性开始位置的差值计算长度，通过开始位置和长度可以正确取出内容。\n- **Variable-Data**：变长属性内容列表，记录变长属性的值。\n\n本文档主要介绍了TuGraph图数据库中的schema概念及其应用。该段落详细解释了schema的定义、作用以及如何存储点的数据格式，包括label id、可选属性数组、定长和变长属性的存储方式。这为后续的点和边的实现与操作奠定了基础。"
            },
            {
                "content": "- **Label Id**：schema的唯一标示，uint16_t类型，因此一个子图(即一个LightningGraph)中的点或边的个数不能超过65535个，超过将会无法区分。\n- **Null-Array**：值可以为空(即optional)类型的属性数组，每个optional的field占一位，以字节对齐，第一个optional的属性标记位于Null-Array第一字节的最后一位，第七个optional的属性标记位于Null-Array第一字节的最前面一位，用于指示某个点或边optional属性对应的数据是否为空。\n- **Fixed-fields**：定长属性列，属性值紧挨着保存，定长属性的长度确定，因此只要知道开始位置就可以正确取出内容，起始位置保存在FieldExtractor类的成员data_off中。\n- **Variable-Offsets**：变长属性偏移列表，记录变长属性开始的位置，变长属性通过当前属性开始位置和下一个属性开始位置的差值计算长度，通过开始位置和长度可以正确取出内容。\n- **Variable-Data**：变长属性内容列表，记录变长属性的值。\n\n## 边的存储格式\n\n边的存储格式一共包含如下几部分，LabelId作为key的一部分，因此不需要保存在数据中：\n\n- **Null-Array**：值可以为空(即optional)类型的属性数组，每个optional的field占一位，以字节对齐，第一个optional的属性标记位于Null-Array第一字节的最后一位，第七个optional的属性标记位于Null-Array第一字节的最前面一位，用于指示某个点或边optional属性对应的数据是否为空。\n- **Fixed-fields**：定长属性列，每种属性紧挨着保存，定长属性的长度确定，因此只要知道开始位置就可以正确取出内容，起始位置保存在FieldExtractor类的成员data_off中。\n- **Variable-Offsets**：变长属性偏移列表，记录变长属性开始的位置，变长属性通过当前属性开始位置和下一个属性开始位置的差值计算长度，通过开始位置和长度可以正确取出内容。\n- **Variable-Data**：变长属性内容列表，记录变长属性的值。\n\n## schema使用场景\n\n该块内容主要介绍了TuGraph图数据库中点和边的存储格式，包括Label Id、Null-Array、Fixed-fields、Variable-Offsets和Variable-Data等组成部分，此外还简要提及了边的存储格式，并为后续的schema使用场景作铺垫。"
            },
            {
                "content": "## 边的存储格式\n\n边的存储格式一共包含如下几部分，LabelId作为key的一部分，因此不需要保存在数据中：\n\n- **Null-Array**：值可以为空(即optional)类型的属性数组，每个optional的field占一位，以字节对齐，第一个optional的属性标记位于Null-Array第一字节的最后一位，第七个optional的属性标记位于Null-Array第一字节的最前面一位，用于指示某个点或边optional属性对应的数据是否为空。\n- **Fixed-fields**：定长属性列，每种属性紧挨着保存，定长属性的长度确定，因此只要知道开始位置就可以正确取出内容，起始位置保存在FieldExtractor类的成员data_off中。\n- **Variable-Offsets**：变长属性偏移列表，记录变长属性开始的位置，变长属性通过当前属性开始位置和下一个属性开始位置的差值计算长度，通过开始位置和长度可以正确取出内容。\n- **Variable-Data**：变长属性内容列表，记录变长属性的值。\n\n## schema使用场景\n\n通过schema可以将一段磁盘中的二进制数据解析成某种类型的点或边，可以获取点边属性，也可以将一些值拼接成某个类型的点或边属性的二进制值，存入磁盘中。\n\n### 获取点索引\n\n通过transaction类获取某个label_name对应点的schema，就可以通过schema获取到具体的索引信息：\n\n```cpp\nSchema* schema = Transaction::curr_schema_->v_schema_manager->GetSchema(label_name);\nfor (auto& fid : schema->indexed_fields_) {\n    _detail::FieldExtractor* fe = schema->fields_[fid];\n    VertexIndex* index = fe->vertex_index_;\n}\n```\n\n### 获取边索引\n\n通过transaction类获取某个label_name对应边的schema，就可以通过schema获取到具体的索引信息：\n\n该文档主要介绍了TuGraph图数据库中的schema概念，包括其定义、应用和存储格式。上段内容具体讨论了边的存储格式，详细描述了边的各个组成部分，以及后续如何通过schema使用场景获取点和边的索引。"
            },
            {
                "content": "## schema使用场景\n\n通过schema可以将一段磁盘中的二进制数据解析成某种类型的点或边，可以获取点边属性，也可以将一些值拼接成某个类型的点或边属性的二进制值，存入磁盘中。\n\n### 获取点索引\n\n通过transaction类获取某个label_name对应点的schema，就可以通过schema获取到具体的索引信息：\n\n```cpp\nSchema* schema = Transaction::curr_schema_->v_schema_manager->GetSchema(label_name);\nfor (auto& fid : schema->indexed_fields_) {\n    _detail::FieldExtractor* fe = schema->fields_[fid];\n    VertexIndex* index = fe->vertex_index_;\n}\n```\n\n### 获取边索引\n\n通过transaction类获取某个label_name对应边的schema，就可以通过schema获取到具体的索引信息：\n\n```cpp\nSchema* schema = Transaction::curr_schema_->e_schema_manager->GetSchema(label_name);\nfor (auto& fid : schema->indexed_fields_) {\n    _detail::FieldExtractor* fe = schema->fields_[fid];\n    VertexIndex* index = fe->edge_index_;\n}\n```\n\n### 解析LabelId\n\n获取到一段代表点或边属性的二进制之后，通过读取前2字节就可以获取到label id：\n\n```cpp\nchar* p = value.Data();  // 表示一个点或边属性值的二进制形式\nLabelId id = *(uint16_t*) value;\n```\n\n### 解析定长属性\n\n获取到一段代表点或边属性的二进制之后，通过如下方式可以获取到定长属性的值：\n\n该文本段落位于文档的后半部分，主要讨论了TuGraph数据库中schema的实际应用场景，包括如何通过schema解析存储在磁盘中的二进制数据，具体操作涉及获取点和边的索引以及解析其属性值，如LabelId、定长属性和变长属性等。"
            },
            {
                "content": "通过transaction类获取某个label_name对应边的schema，就可以通过schema获取到具体的索引信息：\n\n```cpp\nSchema* schema = Transaction::curr_schema_->e_schema_manager->GetSchema(label_name);\nfor (auto& fid : schema->indexed_fields_) {\n    _detail::FieldExtractor* fe = schema->fields_[fid];\n    VertexIndex* index = fe->edge_index_;\n}\n```\n\n### 解析LabelId\n\n获取到一段代表点或边属性的二进制之后，通过读取前2字节就可以获取到label id：\n\n```cpp\nchar* p = value.Data();  // 表示一个点或边属性值的二进制形式\nLabelId id = *(uint16_t*) value;\n```\n\n### 解析定长属性\n\n获取到一段代表点或边属性的二进制之后，通过如下方式可以获取到定长属性的值：\n\n```cpp\nFieldExtractor fe = schema.fields_[schema.name_to_idx_.find(field_name).second];\nchar* p = value.Data(); \n// 通过起始位置 + 定长属性的偏移位置与属性长度可以获取属性值\nType val = *((Type*)(p + fe.data_off));\n```\n\n### 解析变长属性\n\n获取到一段代表点或边属性的二进制之后，通过如下方式可以获取到变长属性的值：\n\n该段落位于文档的“边的存储格式”部分，主要介绍如何通过transaction类获取边的schema及其索引信息，接着解析LabelId、定长属性和变长属性的获取方法。这些内容帮助理解TuGraph中边的数据存储与解析机制，适用于需要深入了解Graph数据库属性处理的读者。"
            },
            {
                "content": "### 解析LabelId\n\n获取到一段代表点或边属性的二进制之后，通过读取前2字节就可以获取到label id：\n\n```cpp\nchar* p = value.Data();  // 表示一个点或边属性值的二进制形式\nLabelId id = *(uint16_t*) value;\n```\n\n### 解析定长属性\n\n获取到一段代表点或边属性的二进制之后，通过如下方式可以获取到定长属性的值：\n\n```cpp\nFieldExtractor fe = schema.fields_[schema.name_to_idx_.find(field_name).second];\nchar* p = value.Data(); \n// 通过起始位置 + 定长属性的偏移位置与属性长度可以获取属性值\nType val = *((Type*)(p + fe.data_off));\n```\n\n### 解析变长属性\n\n获取到一段代表点或边属性的二进制之后，通过如下方式可以获取到变长属性的值：\n\n```cpp\nFieldExtractor fe = schema.fields_[schema.name_to_idx_.find(field_name).second];\nchar* p = value.Data(); \n// 通过起始位置 + fe.v_offs获取Variable-Offsets的位置，记为 pos\n// 通过pos + fe.idx * sizeof(int32_t)可以获取到指向该可变属性值的起始位置的指针\nType val = *((Type*)(*(p + fe.v_offs + fe.idx * sizeof(int32_t))));\n```\n\n### 解析属性是否为optional\n\n对于optional的属性，值可以为空，当值为空时，该属性将不会保存任何值。如何判断该属性值是否为空，需要借助于Null-Array：\n\n该块内容位于文档的后半部分，主要讲解如何解析图数据库TuGraph中点或边的属性值。其中包括获取LabelId、定长属性、变长属性的解析方法，以及判断属性是否为optional的机制，具体内容涉及相应的代码示例和操作步骤。"
            },
            {
                "content": "### 解析变长属性\n\n获取到一段代表点或边属性的二进制之后，通过如下方式可以获取到变长属性的值：\n\n```cpp\nFieldExtractor fe = schema.fields_[schema.name_to_idx_.find(field_name).second];\nchar* p = value.Data(); \n// 通过起始位置 + fe.v_offs获取Variable-Offsets的位置，记为 pos\n// 通过pos + fe.idx * sizeof(int32_t)可以获取到指向该可变属性值的起始位置的指针\nType val = *((Type*)(*(p + fe.v_offs + fe.idx * sizeof(int32_t))));\n```\n\n### 解析属性是否为optional\n\n对于optional的属性，值可以为空，当值为空时，该属性将不会保存任何值。如何判断该属性值是否为空，需要借助于Null-Array：\n\n```cpp\nFieldExtractor fe = schema.fields_[schema.name_to_idx_.find(field_name).second];\nchar* p = value.Data(); \n// 通过起始位置 + fe.nullable_array_off_可以得到Null-Array数组\n// 如果对应的位为1，则为空，否则不为空\nbool is_nul = (p + fe.nullable_array_off_)[fe.null_bit_off_] & (0x1 << (fe.null_bit_off_% 8));\n```\n\n该块内容位于文档的“解析变长属性”和“解析属性是否为optional”部分，主要描述了如何从二进制数据中提取图数据库中点或边的可变长度属性值及判断可选属性是否为空的具体方法。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_167.md",
        "chunks": [
            {
                "content": "# 源码解读｜TuGraph key-val存储\n\n## 存储模型\n\nTuGraph存储层采用开源的lmdb实现，底层存储采用了B+树，在B+树之上抽象出了一层key-val存储。它与基于hash的key-val存储有着本质的区别，基于hash的key-val存储在无hash碰撞的情况下，一次key-val的查询只需要一次hash计算和一次内存寻址，时间复杂度是O(1)，但在TuGraph的实现中，key-val层是基于B+树来实现的，key-val查找的本质还是基于B+树的范围查找，因此一次key-val的查询是要在树中进行二分查找的，性能是O(log(n))。\n\nTuGraph基于lmdb的存储模型，对由点边数据组成的key-val进行了包装，将点边数据打包保存在一起，对于非大点，通过一次key-val的查询就可以查找到点以及该点的出边和入边，减少了在B+树中进行二分查找的次数，将基于全图完整数据的查找限定在某个key对应的value中，提升了TuGraph在适用场景下的查找性能。对于大点来说，为了避免某个key对应的value过大，影响写入或修改性能，权衡之下将点和边数据以阀值按类型切分为多个value，分别保存在不同的类型的key中，既提升了查找性能，也降低了大点带来的写入性能损失。\n\n## key的类型\n\n```cpp\nenum PackType {\n    PACKED_DATA = 0, \n    VERTEX_ONLY = 1, \n    OUT_EDGE = 2,    \n    IN_EDGE = 3     \n};\n```\n\n### PACKED_DATA\n\nPACKED_DATA类型的key共计6字节，由5字节的点id和1字节的类型组成，此类key对应的是混合存储的val。将某个点和与之关联的边数据打包在一起保存，适用于非大点的存储，新插入的点也属于此类型。\n\n### VERTEX_ONLY\n\n本段落介绍了TuGraph的存储模型，特别是其基于lmdb和B+树的key-val存储实现，并阐述了不同类型key的结构及用途，包括PACKED_DATA和VERTEX_ONLY类型的详细定义，旨在提升对图数据的查询效率。"
            },
            {
                "content": "## key的类型\n\n```cpp\nenum PackType {\n    PACKED_DATA = 0, \n    VERTEX_ONLY = 1, \n    OUT_EDGE = 2,    \n    IN_EDGE = 3     \n};\n```\n\n### PACKED_DATA\n\nPACKED_DATA类型的key共计6字节，由5字节的点id和1字节的类型组成，此类key对应的是混合存储的val。将某个点和与之关联的边数据打包在一起保存，适用于非大点的存储，新插入的点也属于此类型。\n\n### VERTEX_ONLY\n\nVERTEX_ONLY类型key共6字节，由5字节的点id和1字节的类型组成，此类key对应的val中只保存了单点的属性，当一个PACKED_DATA类型的key对应的value长度超过阀值::lgraph::_detail::NODE_SPLIT_THRESHOLD(1000字节)时，会被拆分成VERTEX_ONLY，OUT_EDGE，IN_EDGE三种类型，分别表示一个单独的点，一组从该点出发的边，和一组目标点为该点的边。\n\n### OUT_EDGE\n\nOUT_EDGE类型key共计25字节，由5字节的源点id，1字节的类型，2字节的边label id，8字节的tid，5字节的目标点id，以及4字节的eid组成。此类key对应的val中保存了由src_vertex_id点出发，按label_id和tid以及目标点id排序好的一组出边。适用于大点切分后保存出边。其中key中的源点id和类型对于value中的所有值都是一致的，label id，tid以及目标点id是取了这组边中最后一个边的属性。\n\n### IN_EDGE\n\nIN_EDGE类型key共计25字节，由5字节的目标点id，1字节的类型，2字节的边label id，8字节的tid，5字节的最大源点id，以及4字节的eid组成，此类key对应的val中保存了指向dst_vertex_id，按label_id和tid以及源点id排序好的一组出边。适用于大点切分后保存出边。其中key中的目标点id和类型对于value中的所有值都是一致的，label id，tid以及目标点id是取了这组边中最后一个边的属性。\n\n## 获取key中对应的属性\n\n可以通过key的地址加上对应属性的字节偏移获取对应的值。\n\n该文档主要讨论TuGraph的存储模型及其key-val存储实现，其中包含对基于B+树的存储机制的详细解析。该chunk具体描述了不同类型的key及其结构，包括PACKED_DATA、VERTEX_ONLY、OUT_EDGE和IN_EDGE类型的key，以及它们在存储点和边数据时的应用和优先级，进一步阐释了如何通过地址和字节偏移获取key中的属性。"
            },
            {
                "content": "OUT_EDGE类型key共计25字节，由5字节的源点id，1字节的类型，2字节的边label id，8字节的tid，5字节的目标点id，以及4字节的eid组成。此类key对应的val中保存了由src_vertex_id点出发，按label_id和tid以及目标点id排序好的一组出边。适用于大点切分后保存出边。其中key中的源点id和类型对于value中的所有值都是一致的，label id，tid以及目标点id是取了这组边中最后一个边的属性。\n\n### IN_EDGE\n\nIN_EDGE类型key共计25字节，由5字节的目标点id，1字节的类型，2字节的边label id，8字节的tid，5字节的最大源点id，以及4字节的eid组成，此类key对应的val中保存了指向dst_vertex_id，按label_id和tid以及源点id排序好的一组出边。适用于大点切分后保存出边。其中key中的目标点id和类型对于value中的所有值都是一致的，label id，tid以及目标点id是取了这组边中最后一个边的属性。\n\n## 获取key中对应的属性\n\n可以通过key的地址加上对应属性的字节偏移获取对应的值。\n\n```cpp\nstatic const size_t FID_OFF = 0;                  // first vid  0\nstatic const size_t PT_OFF = FID_OFF + 5;          // pair type  5\nstatic const size_t LID_OFF = PT_OFF + 1;         // label      6\nstatic const size_t TID_OFF = LID_OFF + 2;        // primary id 8\nstatic const size_t SID_OFF = TID_OFF + 8;        // second vid 16\nstatic const size_t EID_OFF = SID_OFF + 5;        // edge id    21\nstatic const size_t EDGE_KEY_SIZE = EID_OFF + 4;  //      25\n```\n\n## val的类型\n\n### VertexValue\n\n该段落位于TuGraph key-val存储的文档中，主要描述了OUT_EDGE和IN_EDGE类型的key的结构及其对应的val的内容。这部分内容旨在解释如何存储和检索图结构中边的数据，尤其是在处理大点时的分割策略。紧接着，文档还介绍了如何获取key中对应的属性，并预告了val的数据类型。"
            },
            {
                "content": "```cpp\nstatic const size_t FID_OFF = 0;                  // first vid  0\nstatic const size_t PT_OFF = FID_OFF + 5;          // pair type  5\nstatic const size_t LID_OFF = PT_OFF + 1;         // label      6\nstatic const size_t TID_OFF = LID_OFF + 2;        // primary id 8\nstatic const size_t SID_OFF = TID_OFF + 8;        // second vid 16\nstatic const size_t EID_OFF = SID_OFF + 5;        // edge id    21\nstatic const size_t EDGE_KEY_SIZE = EID_OFF + 4;  //      25\n```\n\n## val的类型\n\n### VertexValue\n\nVertexValue类型的值用于保存key为VERTEX_ONLY的值，代表单个的点数据，数据格式按照预定义好的schema来保存，存储格式如下：\n\n### EdgeValue\n\nEdgeValue类型的值用于保存key为OUT_EDGE与IN_EDGE的值，代表从某个点出发，或者指向某个点的一组边数据。存储格式如下，绿色部分是EdgeValue，它包含三部分内容，第一部分是1字节的边个数，因此一个EdgeValue类型的数据中最多只能保存255条边，第二部分是一个偏移数组，代表了每条边在value中的偏移位置，第三部分是边的内容数组，每个成员代表了一条边。\n\n边的内容包含edge header和edge value两部分。edge header由一字节的指示器开始，它的作用是标识后面紧跟着的几个字段长度。edge value保存的是按照edge schema序列化好的数据。这里为了节省磁盘空间，对edge_label_id, temporal_id, vertex_id以及edge_id进行了压缩，采用的压缩算法如下：\n\n该代码段定义了不同属性在key中的字节偏移，以及key的总大小，随后介绍了val的类型，包括VertexValue和EdgeValue，解释了如何保存和组织点和边的数据。这部分内容位于文档关于TuGraph存储机制的详细说明中，具体描述了key-val存储模型的实现细节。"
            },
            {
                "content": "## val的类型\n\n### VertexValue\n\nVertexValue类型的值用于保存key为VERTEX_ONLY的值，代表单个的点数据，数据格式按照预定义好的schema来保存，存储格式如下：\n\n### EdgeValue\n\nEdgeValue类型的值用于保存key为OUT_EDGE与IN_EDGE的值，代表从某个点出发，或者指向某个点的一组边数据。存储格式如下，绿色部分是EdgeValue，它包含三部分内容，第一部分是1字节的边个数，因此一个EdgeValue类型的数据中最多只能保存255条边，第二部分是一个偏移数组，代表了每条边在value中的偏移位置，第三部分是边的内容数组，每个成员代表了一条边。\n\n边的内容包含edge header和edge value两部分。edge header由一字节的指示器开始，它的作用是标识后面紧跟着的几个字段长度。edge value保存的是按照edge schema序列化好的数据。这里为了节省磁盘空间，对edge_label_id, temporal_id, vertex_id以及edge_id进行了压缩，采用的压缩算法如下：\n\n- **edge_label_id**：如果edge_label_id为0则不占用存储空间，如果edge_label_id < 0x100(十进制256)则占用1字节，如果0x100 <= edge_label_id < 0xFF则占用两字节。\n- **temporal_id**：如果temporal_id为0则不占用存储空间，不为0则占用8字节存储空间。\n- **vertex_id**：去除vertex_id中前导的0，按8位对齐。\n- **edge_id**：去除edge_id中前导的0，按8位对齐。\n\n### PackedDataValue\n\n该文档主要介绍TuGraph的存储模型，重点在于其基于lmdb和B+树的key-val存储实现。文中详细解释了不同类型的key，包括PACKED_DATA、VERTEX_ONLY、OUT_EDGE和IN_EDGE，并探讨了如何获取key中对应的属性。此部分“val的类型”专注于描述与这些key对应的值的具体结构和存储格式，包括VertexValue、EdgeValue和PackedDataValue，进一步阐述了边数据的存储优化及其压缩算法。"
            },
            {
                "content": "边的内容包含edge header和edge value两部分。edge header由一字节的指示器开始，它的作用是标识后面紧跟着的几个字段长度。edge value保存的是按照edge schema序列化好的数据。这里为了节省磁盘空间，对edge_label_id, temporal_id, vertex_id以及edge_id进行了压缩，采用的压缩算法如下：\n\n- **edge_label_id**：如果edge_label_id为0则不占用存储空间，如果edge_label_id < 0x100(十进制256)则占用1字节，如果0x100 <= edge_label_id < 0xFF则占用两字节。\n- **temporal_id**：如果temporal_id为0则不占用存储空间，不为0则占用8字节存储空间。\n- **vertex_id**：去除vertex_id中前导的0，按8位对齐。\n- **edge_id**：去除edge_id中前导的0，按8位对齐。\n\n### PackedDataValue\n\nPackedDataValue类型的值用于保存key为PACKED_DATA的value，代表将某个点与其出边、入边一起打包后保存，因为将点和边打包在同一段存储结构中，因此结构复杂，它包含两个int32_t类型的偏移，分别指向这个点的出边和入边的首地址，以及一个VertexValue表示一个点和两个EdgeValue，分别表示这个点的出边和入边。存储格式如下，其中红色部分是PackedDataValue，绿色部分是EdgeValue，紫色部分是VertexValue（保存的是按照vertex schema序列化好的点数据），蓝色部分是按照edge schema序列化好的边数据。\n\n该段落位于文档的val类型部分，详细解释了边的内容结构，包括边头信息和边值的序列化及存储方式，同时描述了如何压缩存储边的相关属性。此外，还介绍了PackedDataValue类型的结构，说明了如何将点及其出边和入边打包存储。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_168.md",
        "chunks": [
            {
                "content": "# 重磅发布！TuGraph开源高性能原生图存储系统CStore\n\nCStore已在蚂蚁集团内部具备多年大规模生产化经验。目前，CStore系统已全部开源到TuGraph Analytics仓库（geaflow-cstore模块），未来我们将不断迭代升级，提升系统性能。也非常欢迎图计算和图存储的开发者一起参与进来，共同推进CStore的开源和演进。\n\nCStore是一款专门为图分析场景而设计的原生图存储引擎，它采用了Rust语言编写，使用基于图的存储结构，针对图分析场景进行特定优化。CStore可以存储包含千亿级点和万亿级边的图数据，在蚂蚁集团内部的多场景使用中，已经积累了多年的经验，存储容量达到了PB级别。\n\n## 图存储系统\n\n在设计数据存储引擎时，需要考虑众多因素。例如，所应用的具体场景，是联机分析处理(OLAP)还是联机事务处理(OLTP)；再如，数据存储方式的选择，内存、本地硬盘或分布式存储；还有就是存储数据的格式，像是文档、JSON，宽表，对象，键值对等。图存储引擎是诸多数据存储引擎中的一种，它专门用于图数据的存储。从DB-Engines网站的统计来看，Graph DBMS的热度从2014后一直领先其他类型数据库。\n\n根据图数据存储方式的不同，现有的图存储引擎主要分为下面几大类：\n\n1. 基于链表，例如Neo4j。\n2. 基于Hash+链表，例如ArangoDB。\n3. 基于Key-Value键值，例如Titan/JanusGraph/HugeGraph。\n4. 基于传统关系型数据库，例如AgensGraph。\n\nCStore基于Array+链表的方式存储数据，支持实时读写能力。为了提供更好的图分析能力，CStore把图元数据和属性分离存储，单独对元数据构建多级索引。CStore在存储方式和索引设计上都充分考虑到图语义，有效地结合图数据访问的特点，充分利用计算机硬件的优势，在蚂蚁内部多个场景中得到验证，取得很好的业务效果。接下来从建模、存储、索引三个方面来介绍CStore作为原生图存储引擎的特点。\n\n## 原生图建模\n\n该文档主要介绍了TuGraph开源的高性能原生图存储系统CStore，包括其设计理念、技术架构、存储机制、索引策略及未来规划等内容。所提供的这一段落详细阐述了CStore的背景、存储系统的概念，以及它在图分析场景中的具体应用和技术优势，为后续对原生图建模等方面的讨论奠定基础。"
            },
            {
                "content": "根据图数据存储方式的不同，现有的图存储引擎主要分为下面几大类：\n\n1. 基于链表，例如Neo4j。\n2. 基于Hash+链表，例如ArangoDB。\n3. 基于Key-Value键值，例如Titan/JanusGraph/HugeGraph。\n4. 基于传统关系型数据库，例如AgensGraph。\n\nCStore基于Array+链表的方式存储数据，支持实时读写能力。为了提供更好的图分析能力，CStore把图元数据和属性分离存储，单独对元数据构建多级索引。CStore在存储方式和索引设计上都充分考虑到图语义，有效地结合图数据访问的特点，充分利用计算机硬件的优势，在蚂蚁内部多个场景中得到验证，取得很好的业务效果。接下来从建模、存储、索引三个方面来介绍CStore作为原生图存储引擎的特点。\n\n## 原生图建模\n\n图形数据非常适用于描述复杂的网络关系。与其他存储格式相比较，图形数据具有自身的独特之处。举例来说，在 NoSQL 数据库中，Key-Value 数据库只包含 Key 和 Value 这两种元素，用户更容易理解和操作，并且存储引擎的设计也可以遵循一定的规则。另外，对于 DBMS（数据库管理系统）来说，实体关系模型必须按照一定的规范来进行设计，通常情况下，要求业务表的设计至少要符合第三范式，以此来消除数据冗余现象。CStore基于属性图来建模，属性图是由点，边，以及点和边上的属性组成的图，点数据中记录了起始点ID和图元数据（标签，时间戳），边数据记录了起始点ID和图元数据（终点ID，方向，标签，时间戳），每个起始点ID唯一确定一组点边数据。\n\n点边数据进入到CStore之后，把点边起始点ID转化为从0开始的ID，这个过程称之为ID化。由于用户定义的起始点ID格式不固定，蚂蚁内部使用的起始点通常大于20bytes，转化为4个bytes ID后，可以极大减少索引内存消耗；另外规范化ID之后，CStore使用array来做主键索引，array的index为ID，查询效率为O(1)。\n\n## ID字典\n\nID化之后，点边数据被序列化为PrimaryKey和GraphData，GraphData由SecondKey和Property组成。PrimaryKey记录点边ID，SecondKey记录图元数据，Property记录点边属性数据。\n\n该段落介绍了现有图存储引擎的分类及CStore的存储方式，强调CStore采用基于Array+链表的存储结构以及图元数据和属性的分离存储，以增强图分析能力。此外，段落探讨了CStore的原生图建模方法和ID化过程，为文档后续内容关于ID字典的构建提供了基础。"
            },
            {
                "content": "点边数据进入到CStore之后，把点边起始点ID转化为从0开始的ID，这个过程称之为ID化。由于用户定义的起始点ID格式不固定，蚂蚁内部使用的起始点通常大于20bytes，转化为4个bytes ID后，可以极大减少索引内存消耗；另外规范化ID之后，CStore使用array来做主键索引，array的index为ID，查询效率为O(1)。\n\n## ID字典\n\nID化之后，点边数据被序列化为PrimaryKey和GraphData，GraphData由SecondKey和Property组成。PrimaryKey记录点边ID，SecondKey记录图元数据，Property记录点边属性数据。\n\nSecondKey编码格式如下，target id大小不固定，其他部分消耗20 bytes。write ts字段记录数据写入时间，被用于数据淘汰，sequence id记录了数据写入顺序，transaction和compaction都会用到。graph info记录是否是点，是否是入边，是否包含属性，标签，其他meta, 点边时间属性等信息。\n\n## 图数据编码\n\n这样编码有两点好处：\n\n1. 点边数据变成CStore内部具有固定格式的二进制数据，有效减少内存消耗，方便后续数据写入磁盘；\n2. 图元数据被压缩到8字节，这样可以把更多的图信息放到索引侧，能够提前在索引侧过滤掉用户不需要的数据。\n\n许多图形数据库会选择将点边数据编码为键值对的形式存储。相比之下，CStore是一款针对图分析场景而设计的存储引擎，目的是提供更快的分析能力。为了实现这一点，CStore会对经过编码后的图形信息建立多级索引。在下面的内容里，我们将讨论如何存储数据以及构建多级索引。\n\n\n## 友好图存储\n\n蚂蚁内部图数据的访问有以下几个特点。\n\n1. 通常相同起始点ID的点边数据大概率一起被访问；\n2. 相同类型, 时间的数据通常被一起访问；\n3. 用户点边数据的属性非常大，而点边元数据信息为固定结构且数据量不大；\n4. 点数据查询频率大于边数据。\n\n该段落描述了CStore图存储引擎中点边数据的ID化过程及其序列化方式，包括ID字典的构建和图数据编码的优势，重点阐述了CStore在处理图数据时的性能优化方法，并引入了友好图存储的特点，为系统设计提供了背景。"
            },
            {
                "content": "## 图数据编码\n\n这样编码有两点好处：\n\n1. 点边数据变成CStore内部具有固定格式的二进制数据，有效减少内存消耗，方便后续数据写入磁盘；\n2. 图元数据被压缩到8字节，这样可以把更多的图信息放到索引侧，能够提前在索引侧过滤掉用户不需要的数据。\n\n许多图形数据库会选择将点边数据编码为键值对的形式存储。相比之下，CStore是一款针对图分析场景而设计的存储引擎，目的是提供更快的分析能力。为了实现这一点，CStore会对经过编码后的图形信息建立多级索引。在下面的内容里，我们将讨论如何存储数据以及构建多级索引。\n\n\n## 友好图存储\n\n蚂蚁内部图数据的访问有以下几个特点。\n\n1. 通常相同起始点ID的点边数据大概率一起被访问；\n2. 相同类型, 时间的数据通常被一起访问；\n3. 用户点边数据的属性非常大，而点边元数据信息为固定结构且数据量不大；\n4. 点数据查询频率大于边数据。\n\nCStore在设计存储结构的时候，结合上述特点，对特定场景进行优化。针对第一个特点，CStore尽可能的把具有相同的起始点ID的点边数据存储到物理上连续的存储空间。点边数据被序列化之后，数据首先被写入GraphData Segment，它为内存数据结构，使用跳表来组成数据，维护了起始点ID到GraphData List的结构。GraphData Segment主要有两个功能：\n\n1. 数据聚合。把相同的src_id的点边数据聚合到一起存储。\n2. 排序。按照用户指定顺序把相同src_id的点边数据排序，用于构建二级索引。\n\n### GraphData Segment数据结构\n\nGraphData Segment到达阈值之后被刷入到磁盘，数据被刷入到磁盘之前，把具有相同类型，写入时间（通常以天为单位）的数据作为一个分区写入到连续的物理存储空间，每个分区之间数据互相独立。\n\n### GraphData Segment分区\n\n再者根据点边数据属性大而元数据固定的特点，CStore采用了属性分离的架构，把图属性和图元数据分离存储到不同的物理存储空间。一方面对于图元数据单独加索引能够加速图查询性能，另外一方面属性分离也能够减少数据compaction的读写放大开销。\n\n该内容块主要讨论了CStore中的图数据编码和友好的图存储结构，强调了编码的优点以及针对蚂蚁内部图数据访问特点的优化设计，包括GraphData Segment的构建及其分区策略。这部分内容在整个文档中属于对CStore存储引擎设计和实现细节的深入分析，重点在于如何提高图数据的存取效率和存储性能。"
            },
            {
                "content": "1. 数据聚合。把相同的src_id的点边数据聚合到一起存储。\n2. 排序。按照用户指定顺序把相同src_id的点边数据排序，用于构建二级索引。\n\n### GraphData Segment数据结构\n\nGraphData Segment到达阈值之后被刷入到磁盘，数据被刷入到磁盘之前，把具有相同类型，写入时间（通常以天为单位）的数据作为一个分区写入到连续的物理存储空间，每个分区之间数据互相独立。\n\n### GraphData Segment分区\n\n再者根据点边数据属性大而元数据固定的特点，CStore采用了属性分离的架构，把图属性和图元数据分离存储到不同的物理存储空间。一方面对于图元数据单独加索引能够加速图查询性能，另外一方面属性分离也能够减少数据compaction的读写放大开销。\n\n另外CStore还支持用户配置点边数据存储到不同的存储介质，点边数据在物理上隔离。点边数据的访问频率在不同的场景有所不同，分离存储能够进一步优化数据访问性能，提前过滤掉不需要的数据，减少数据读放大。\n\n## 高效图索引\n\nCStore具有高效的图数据检索能力，支持多维度索引，不仅提供针对图元数据的分区索引，主键索引和二级索引，还支持针对点边属性的全文索引，可以根据指定的条件快速定位和返回数据。\n\n### 图索引架构\n\nGraphData Segment写入到磁盘之前，把相同起始点ID的GraphData根据用户指定的顺序排序，然后把排序好的SecondKey构建索引，把排序好的Property直接写入到属性文件（记为vs文件）。\n\nCStore的分区索引对应到磁盘中某个目录，不同的分区数据落在不同的目录。主键索引是稀疏索引，默认索引间隔为2048，目前仅支持以起始点ID构建主键，主键索引常驻内存。通过主键索引，可以快速定位到属性存储的文件id和offset。\n\n### 主键索引\n\n二级索引包括min max索引，bloom filter索引等，用于快速判断某个稀疏索引块是否包含某个主键。min max索引记录某个索引块的上界和下界，bloom filter记录索引块的主键。\n\n在文档中，该块内容主要讨论了CStore的GraphData Segment数据结构及其分区与索引机制，着重分析了数据在磁盘上的存储方式、聚合和排序的过程，以及如何通过高效的索引架构提升图数据的检索能力。这部分内容紧接在CStore的存储结构描述后，深入探讨了如何优化图数据的访问和索引，以提高系统性能。"
            },
            {
                "content": "## 高效图索引\n\nCStore具有高效的图数据检索能力，支持多维度索引，不仅提供针对图元数据的分区索引，主键索引和二级索引，还支持针对点边属性的全文索引，可以根据指定的条件快速定位和返回数据。\n\n### 图索引架构\n\nGraphData Segment写入到磁盘之前，把相同起始点ID的GraphData根据用户指定的顺序排序，然后把排序好的SecondKey构建索引，把排序好的Property直接写入到属性文件（记为vs文件）。\n\nCStore的分区索引对应到磁盘中某个目录，不同的分区数据落在不同的目录。主键索引是稀疏索引，默认索引间隔为2048，目前仅支持以起始点ID构建主键，主键索引常驻内存。通过主键索引，可以快速定位到属性存储的文件id和offset。\n\n### 主键索引\n\n二级索引包括min max索引，bloom filter索引等，用于快速判断某个稀疏索引块是否包含某个主键。min max索引记录某个索引块的上界和下界，bloom filter记录索引块的主键。\n\n对于热点数据，二级索引做了特殊支持，比如一个起始点ID对应了10亿条边，如果没有索引，需要把满足min max和bloom filter索引的所有边读到内存过滤一次，返回用户指定的数据。为了加速这种场景，CStore对点边类型，指向，写入时间加了二级索引。比如用户只想要读取label为student，dt为2023-10-1数据，通过二级索引，首先过滤掉所有label非student的数据，然后过滤掉dt非2023-10-1的数据，可以极大减少数据读开销，提升用户查询性能。\n\n## 二级索引\n\n构建完索引，数据写入到索引文件（记为is文件），is文件按照LSM-Tree结构组织，key为主键索引中的index，value为索引block压缩后的数据。is文件内部对于key有序，第0层单个文件内部对于key有序，其他层文件间对于key有序。\n\n## 并发Compaction\n\n为了加快 LSM-Tree compact的性能，CStore 支持单层的多线程compact。在示意图中，每一个单独的compactor都代表一个compact工作线程。不同的compactor线程和compact清理线程（负责清理被compact的文件)将会并行执行。\n\n以下是单个compactor内部运作过程的示意图，其中包括四个关键步骤：\n\n该文档介绍了TuGraph开源的高性能原生图存储系统CStore，重点阐述了其设计理念、数据存储方式以及图数据分析能力。高效图索引部分（所提及的chunk）详细描述了CStore在图数据检索方面的能力，包括多维度索引的构建和优化策略，可以提高用户在大规模图数据查询中的效率。此部分紧接在CStore的存储和索引设计之后，强调了系统如何通过索引机制提升图查询性能。"
            },
            {
                "content": "## 二级索引\n\n构建完索引，数据写入到索引文件（记为is文件），is文件按照LSM-Tree结构组织，key为主键索引中的index，value为索引block压缩后的数据。is文件内部对于key有序，第0层单个文件内部对于key有序，其他层文件间对于key有序。\n\n## 并发Compaction\n\n为了加快 LSM-Tree compact的性能，CStore 支持单层的多线程compact。在示意图中，每一个单独的compactor都代表一个compact工作线程。不同的compactor线程和compact清理线程（负责清理被compact的文件)将会并行执行。\n\n以下是单个compactor内部运作过程的示意图，其中包括四个关键步骤：\n\n1. 计算各层次得分并选择其中最高的；\n2. 收集需要compact的文件；\n3. 将上述收集到的文件进行compact并生成新的文件；\n4. 最后一步是将新的文件更新至 LSM-Tree及内存索引中。\n\n\n## Compaction管理\n\n### 编译构建\n\n单独编译CStore代码需要提前准备Rust和C++工具链。\n\n#### 安装Rust\n\n```bash\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\n#### 安装nightly工具链\n\n```bash\nrustup update && rustup toolchain install nightly && rustc --version\n```\n\n#### 安装其他依赖\n\n```bash\nyum install make gcc gcc-c++ protobuf-devel protobuf clang\n```\n\n下载TuGraph Analytics代码后，执行以下命令编译CStore源代码：\n\n```bash\ngit clone https://github.com/TuGraph-family/tugraph-analytics.git\ncd tugraph-analytics/geaflow-cstore && make build\n```\n\n执行`make help`可以查看makefile提供的功能，当前版本的功能和对应描述如下：\n\n#### geaflow-cstore 0.1.0\n\n该段落主要介绍CStore的二级索引构建和并发压缩（Compaction）管理，详细阐述了索引文件的组织结构、压缩过程及其关键步骤，以及如何编译构建CStore代码的相关步骤和依赖。这些内容位于CStore的存储和索引机制部分，是对整个系统性能优化的重要技术细节。"
            },
            {
                "content": "```bash\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\n#### 安装nightly工具链\n\n```bash\nrustup update && rustup toolchain install nightly && rustc --version\n```\n\n#### 安装其他依赖\n\n```bash\nyum install make gcc gcc-c++ protobuf-devel protobuf clang\n```\n\n下载TuGraph Analytics代码后，执行以下命令编译CStore源代码：\n\n```bash\ngit clone https://github.com/TuGraph-family/tugraph-analytics.git\ncd tugraph-analytics/geaflow-cstore && make build\n```\n\n执行`make help`可以查看makefile提供的功能，当前版本的功能和对应描述如下：\n\n#### geaflow-cstore 0.1.0\n\nUsage: make ``\n\n##### Targets:\n\n该chunk位于文档的“编译构建”部分，主要描述了如何安装Rust和其他依赖，以及如何下载和编译TuGraph Analytics中的CStore源代码。此外，还列出了当前版本的功能和对应的命令目标。"
            },
            {
                "content": "- **build-dev**: Build the geaflow-cstore with dev version. Both `` and `` work.\n- **build-release**: Build the geaflow-cstore with release version.\n- **fmt**: Format the code by rustfmt.toml.\n- **clippy**: Check statically code with clippy.\n- **test-all**: Run all integration tests and unit tests, include ignored tests.\n- **test**: Execute all the unit tests.\n- **test-fn**: Use \"make test-fn mod=\" to specify which function of test to run.\n- **test-in**: Use \"make test-in mod=\" to specify which target of integration tests to run.\n- **bench-all**: Run all benches.\n- **bench**: Use \"make bench mod=\" to specify which bench of mod to run.\n- **doc**: Generate the document of geaflow-cstore and open it in html.\n- **all**: Execute code style and static checks, release version compilation and tests in sequence.\n- **update**: Update all the dependences to the newest version, include rust analyzer.\n- **gen**: Generate the code described by proto.\n\n该块内容位于文档的“编译构建”部分，具体介绍了如何编译和构建CStore代码的相关命令和目标，包括开发版本和发布版本的构建、代码格式化、静态检查、测试、基准测试和文档生成等功能。"
            },
            {
                "content": "- **test-in**: Use \"make test-in mod=\" to specify which target of integration tests to run.\n- **bench-all**: Run all benches.\n- **bench**: Use \"make bench mod=\" to specify which bench of mod to run.\n- **doc**: Generate the document of geaflow-cstore and open it in html.\n- **all**: Execute code style and static checks, release version compilation and tests in sequence.\n- **update**: Update all the dependences to the newest version, include rust analyzer.\n- **gen**: Generate the code described by proto.\n- **features**: Use \"make features mod=\" {0->[default] 1->[hdfs]} to set the env in ~/.cstore_buildrc.\n- **clean**: Clean up the cargo cache.\n- **version**: Show the version of geaflow-cstore.\n- **help**: List optional commands.\n\n该块内容位于文档的编译构建部分，详细列出了CStore源代码编译时可用的Makefile命令及其对应功能，旨在指导开发者如何构建、测试和管理CStore项目。"
            },
            {
                "content": "## 未来规划\n\nCStore已在蚂蚁集团内部具备多年大规模生产化经验，未来我们将不断迭代升级，提升系统性能。然而，在一些特定的情况下，我们认识到CStore还有进步的空间。在未来一至两年内，我们计划更加深入地探索优化图分析场景，支持图数据列式存储，图融合以及物化视图能力。同时，为了提高用户的体验度，我们也将引入remote compactor功能，以解决因compact而导致的资源竞争问题。\n\n目前，CStore系统已全部开源到TuGraph Analytics仓库（geaflow-cstore模块），当前推送的代码涵盖了CStore的核心功能特性，仍有大量的增强功能还在整合中。TuGraph团队将持续投入图存储系统CStore的建设工作，也非常欢迎图计算和图存储的开发者一起参与进来，共同推进CStore的开源和演进。\n\n## 总结\n\n当下TuGraph Analytics项目已经内置了CStore JNI的依赖，你可以在高阶API任务中使用并体验CStore静态图存储系统，CStore动态图能力正在建设中，敬请期待。同时我们也非常欢迎图存储系统/Rust爱好者加入到CStore开源项目的建设中来。\n\n该文档介绍了蚂蚁集团开源的高性能原生图存储系统CStore的各项特性和技术细节，包括图数据的存储、索引、编码及其设计理念。文末的“未来规划”部分详细阐述了CStore未来的迭代方向和新功能，同时呼吁开发者参与开源项目的建设，为系统的进一步发展提供支持。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_169.md",
        "chunks": [
            {
                "content": "# 认识图计算和图数据库\n\n## 什么是图\n\n图（Graph）是一种非常直观表达事物及其关联关系的数据结构，基本元素是“点”和“边”。点表示一个事物，边表示它们之间具有一定关系。\n\n比如下面这张图，它的点有公司、员工、项目，边即他们之间的关系——公司和员工之间是雇佣关系、员工和员工之间可以有好友关系、项目和员工之间也可以有参与关系。也就是说我们可以用图的方式来把事物和它们的关系抽象出来。\n\n这是一张结构比较简单的图。随着点和边不断增加，图数据越来越多越来越复杂，逐渐形成更丰富的网状结构。比如一些金融交易图，它的规模可能会非常大，超过 10 亿个点，有千亿甚至万亿边。可以想象，要真正处理这些图还是很有挑战的。\n\n## 为什么需要图计算\n\n把计算机想象成大脑，我们要解决两个关键问题：数据的存储和分析。\n\n传统的数据存储采用关系型数据库，其结构是“表结构”（想象一下 Excel 表格）。比如一家银行的客户转账信息可能包含交易人员、交易金额、交易时间，记录在一张表格里。假如交易人 A 和 B 之间有直接转账关系，这种直接关系用关系型数据库是不难发现的。但对于非直接关系，关系型数据库就较难“穿透”多个点来发现了，即便可以处理，查询速度也可能非常慢。我们用信用卡套现来举例。\n\n首先是简单的直接套现模式。如左侧图显示，一个人办了一张信用卡，他其实不是真的想去还款，他找了一个商店，这个商店提供一个非法的服务就是信用卡套现。那么他通过信用卡付款，把 2020 元钱转到这个商店。这个商店直接就把其中的 2000 元钱返回给付款人，就完成了一次套现。这样的一种套现是非常简单的，我们通过对这个个体、这个商店的收款记录和付款记录做分析，就可以识别出套现行为。\n\n但右边这张图就复杂了很多。我们可以看到，右上角的这个人，他还是通过信用卡付款，付了 2020 元钱给了商店。这个时候，商店没有直接把钱退给付款的人，而是由一个个人付了 2000 元钱给到一个第三人。这个个人和商店之间，我们可以通过一些分析发现，他实际上拥有这个商店，所以我们把这种关系叫做同人关系。就是店和人虽然看起来是不同的实体，但其实他们之间有一个非常强的关联。那么他付款给的第三人也不是最开始刷卡的人，而是刷卡人的一个亲友，店主付款到了刷卡人亲友的银行卡上。那这样的一个套现模式就比左边的复杂很多了。我们把这种模式叫做多跳闭环模式。\n\n该块内容主要介绍了图及其在图计算和图数据库中的重要性，重点阐述了图的基本概念、点和边的关系，并通过信用卡套现的案例说明传统关系型数据库在处理复杂非直接关系时的局限性。这段内容属于文档的引言部分，为后续讨论图计算的必要性奠定基础。"
            },
            {
                "content": "首先是简单的直接套现模式。如左侧图显示，一个人办了一张信用卡，他其实不是真的想去还款，他找了一个商店，这个商店提供一个非法的服务就是信用卡套现。那么他通过信用卡付款，把 2020 元钱转到这个商店。这个商店直接就把其中的 2000 元钱返回给付款人，就完成了一次套现。这样的一种套现是非常简单的，我们通过对这个个体、这个商店的收款记录和付款记录做分析，就可以识别出套现行为。\n\n但右边这张图就复杂了很多。我们可以看到，右上角的这个人，他还是通过信用卡付款，付了 2020 元钱给了商店。这个时候，商店没有直接把钱退给付款的人，而是由一个个人付了 2000 元钱给到一个第三人。这个个人和商店之间，我们可以通过一些分析发现，他实际上拥有这个商店，所以我们把这种关系叫做同人关系。就是店和人虽然看起来是不同的实体，但其实他们之间有一个非常强的关联。那么他付款给的第三人也不是最开始刷卡的人，而是刷卡人的一个亲友，店主付款到了刷卡人亲友的银行卡上。那这样的一个套现模式就比左边的复杂很多了。我们把这种模式叫做多跳闭环模式。\n\n要分析这种多跳闭环模式，就需要找出复杂的关联关系，而不能只对这个个体进行分析。但是大家可能会说，你画的这张图很简单呀，我一眼就能看出来，这是一个闭环，这个坏人我很快就能抓住。  \n但实际生活中情况可能会更加复杂，有更多其它交易和关系，就没那么容易看出来了。如下图所示，右边这张图可能会有千亿条甚至万亿条边，怎么很快地在这个图上把环找出来，这就对整个分析技术——复杂的关联分析技术提出了非常高的要求，性能成为了关键。\n\n## 什么时候要用图计算\n\n随着数据量和深度的增加，如果我们用传统的关系数据库的方法去分析，那就可能非常非常慢，难以在有效的时间内计算出结果。而图计算技术直接将事物与其关系像制作地图一样定位存储下来，直接支撑对事物和关系的各种查询和计算——这与我们大脑对信息的处理模式很像，大脑本身也可以建模成一个图。由于提供了对关联数据最直接的表达，以及图模型对异构数据天然的包容力，可以很好地解决目前遇到的关联数据分析问题。\n\n由此可见，关系型数据库的设计擅长回答“已知”的问题，而图数据库可以回答超出设想的“未知”问题。相较于关系型数据库，图数据库是真正注重“关系”的数据库。\n\n这段内容描述了图计算在识别复杂金融犯罪行为中的应用，尤其是对信用卡套现行为的分析，介绍了简单和复杂的套现模式，并强调了多跳闭环模式的复杂性以及图计算在处理这类关系分析中的优势。"
            },
            {
                "content": "要分析这种多跳闭环模式，就需要找出复杂的关联关系，而不能只对这个个体进行分析。但是大家可能会说，你画的这张图很简单呀，我一眼就能看出来，这是一个闭环，这个坏人我很快就能抓住。  \n但实际生活中情况可能会更加复杂，有更多其它交易和关系，就没那么容易看出来了。如下图所示，右边这张图可能会有千亿条甚至万亿条边，怎么很快地在这个图上把环找出来，这就对整个分析技术——复杂的关联分析技术提出了非常高的要求，性能成为了关键。\n\n## 什么时候要用图计算\n\n随着数据量和深度的增加，如果我们用传统的关系数据库的方法去分析，那就可能非常非常慢，难以在有效的时间内计算出结果。而图计算技术直接将事物与其关系像制作地图一样定位存储下来，直接支撑对事物和关系的各种查询和计算——这与我们大脑对信息的处理模式很像，大脑本身也可以建模成一个图。由于提供了对关联数据最直接的表达，以及图模型对异构数据天然的包容力，可以很好地解决目前遇到的关联数据分析问题。\n\n由此可见，关系型数据库的设计擅长回答“已知”的问题，而图数据库可以回答超出设想的“未知”问题。相较于关系型数据库，图数据库是真正注重“关系”的数据库。\n\n我们刚才举的是金融方面的例子，但图计算的用途远远不限于金融行业。在互联网、工业领域、医药、公共卫生、公共安全等领域都有很多应用。如绘制用户社交关系图谱进行社交影响力排名、好友推荐；构建设备关系网络图谱实现物联网建模分析、供电网络建模分析等。\n\n随着互联网和 5G 时代数据指数级增长，数据之间的关系越来越复杂，企业管理和分析数据面临更高难度。越来越多的企业管理者们开始关注以图为代表的技术来更智能地使用数据，Google、Facebook 等科技巨头也早就在通过图数据库的力量来支撑主要业务应用。\n\n国际知名咨询公司 Gartner 每年都会发布各种技术趋势的报告。在 2021 年的《十大数据分析技术趋势》报告中，Gartner 提到了“Graph relates everything”。这是一个非常有趣的双关，即图连接万物，一方面表示了图的本质，就是把各种事物连起来，另一方面也表达了图会在数据分析的各个领域得到广泛应用。Gartner 预测到 2025 年，图技术在数据和分析创新中的占比将从 2021 年的 10%上升到 80%。\n\n该段落讨论了复杂的多跳闭环模式分析的挑战，说明在实际生活中如何利用图计算技术有效处理关联关系，强调图数据库相较于传统关系数据库在解决未知问题方面的优势。随后提到图计算在多个行业的应用及其在数据分析中的重要性，引用Gartner的预测来展望图技术的未来发展。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_170.md",
        "chunks": [
            {
                "content": "# 陈文光：AI时代需要怎样的数据处理技术？\n\n大家好，我是清华大学/蚂蚁技术研究院陈文光，今天为大家带来《AI 时代的数据处理技术》主题分享。\n\n我们身处一个以信息技术为核心驱动力的大数据时代。从下面这张图，我们可以看出，数据量和数据生成的速度在飞速增长。与此同时，新的产生数据的形式在产生，数据模态也在不断增长，不仅包括自然语言，还有声音、图像、视频等等多种形式。最近非常流行的多模态大模型包括具身智能、触觉等新的数据形态。\n\n丰富的数据形态要求我们要对数据做有效处理。模仿“马斯洛需求层次理论”，数据处理也有一个层次，从最底下的收集数据、存储数据到做一般的数据查询处理，更上面的层次是现在越来越接近于用 AI 方式处理数据，甚至最后还能生成很多内容。\n\n## 1. AI时代数据处理新需求\n\n这样的大模型崛起的时代也引发了对数据处理的新需求。最近，Meta 出了一个新模型 LLaMA-3，效果非常好，它实现了在十几万亿的 Token 上面做的训练，而我们之前很多模型可能只是在 4T 的或者几个 T 的 Token上面做训练。\n\n那么，如何获得增加的这部分 Token？实际上，这需要从很多网上低质量的数据中做大量的数据处理，清洗出来可用的高质量数据，如果想让大模型的能力进一步增长，实际上需要数据处理做很多的工作。\n\n另一方面，大模型直接应用在生产服务场景下，本身还存在很多缺陷，比如幻觉问题、上下文长度的问题。目前的多数超长上下文大模型并不能完整记录真正领域的知识。为了满足需求，向量数据库和大语言模型结合起来，提供高质量的服务。  \n从数据服务的角度来讲，向量数据库是一种使用嵌入的方式表达知识，再用另外索引的方式快速找到相应知识的方式，它和大模型配合才能获得很好的效果。所以大模型的发展和崛起，对数据库领域也提出了很多新需求。\n\n## 2. AI时代数据库发展趋势\n\n在这样的趋势下，我今天想分享三个观点，也是未来的数据库面临的三个比较重要的发展趋势：\n\n### （一）在线离线一体化\n\n这张图是企业常见的在线、离线两个链路。\n\n- 上面是在线链路，一个数据请求会先经过预处理，再通过训练好的模型做推理，比如风控、分类等等，再把结果反馈到 KV 里，直接服务用户的请求。\n- 下面是离线链路，收到数据请求后，我们要想办法处理，去更新模型。经过一段时间后再把模型更新到在线链路上。\n\n本文为清华大学/蚂蚁技术研究院的陈文光进行的主题分享，探讨在AI时代数据处理技术的发展需求与趋势。开篇介绍了数据量的快速增长及多模态数据的出现，接着提出了AI时代对数据处理的新需求和数据库的发展趋势，重点分析了在线离线一体化的重要性。"
            },
            {
                "content": "另一方面，大模型直接应用在生产服务场景下，本身还存在很多缺陷，比如幻觉问题、上下文长度的问题。目前的多数超长上下文大模型并不能完整记录真正领域的知识。为了满足需求，向量数据库和大语言模型结合起来，提供高质量的服务。  \n从数据服务的角度来讲，向量数据库是一种使用嵌入的方式表达知识，再用另外索引的方式快速找到相应知识的方式，它和大模型配合才能获得很好的效果。所以大模型的发展和崛起，对数据库领域也提出了很多新需求。\n\n## 2. AI时代数据库发展趋势\n\n在这样的趋势下，我今天想分享三个观点，也是未来的数据库面临的三个比较重要的发展趋势：\n\n### （一）在线离线一体化\n\n这张图是企业常见的在线、离线两个链路。\n\n- 上面是在线链路，一个数据请求会先经过预处理，再通过训练好的模型做推理，比如风控、分类等等，再把结果反馈到 KV 里，直接服务用户的请求。\n- 下面是离线链路，收到数据请求后，我们要想办法处理，去更新模型。经过一段时间后再把模型更新到在线链路上。\n\n在线、离线两个链路分开，在生产中会遇到一些比较严重的问题，主要就是在线、离线不一致。\n\n比如在离线链路上做了各种仿真模拟，但是当把策略、模型上传到在线链路时，会出现与离线链路仿真效果不一样的情况。造成这种现象的根本原因，就是我们通过不同的数据链路把新数据接入进来，离线链路处理的数据与在线链路不一致。\n\n怎么解决这个问题？最好的解决方案，就是只有一套数据。如果能够做到一个系统既能够做事务处理，可以支持事务在数据上面原子化地做更新，同时还可以在这一批数据上做后续分析型的业务。也就是说用一份数据给在线离线链路的一致性打下基础。  \n这里面也有非常多的技术问题。一般来说，事务处理行存会比较好，分析一般是列存比较好，当一套系统需要同时支持行存和列存的时候，需要什么样的存储结构？另外，事务处理对于优先级、延迟/尾延迟、吞吐率要求比较高。那么在系统里如何调度不同优先级的请求，这里涉及到很多相关技术。\n\n该段落讨论了大语言模型在生产服务中的缺陷，以及向量数据库与大语言模型结合的重要性，接着引入了关于AI时代数据库发展的趋势，首先聚焦于在线与离线一体化的问题。"
            },
            {
                "content": "在线、离线两个链路分开，在生产中会遇到一些比较严重的问题，主要就是在线、离线不一致。\n\n比如在离线链路上做了各种仿真模拟，但是当把策略、模型上传到在线链路时，会出现与离线链路仿真效果不一样的情况。造成这种现象的根本原因，就是我们通过不同的数据链路把新数据接入进来，离线链路处理的数据与在线链路不一致。\n\n怎么解决这个问题？最好的解决方案，就是只有一套数据。如果能够做到一个系统既能够做事务处理，可以支持事务在数据上面原子化地做更新，同时还可以在这一批数据上做后续分析型的业务。也就是说用一份数据给在线离线链路的一致性打下基础。  \n这里面也有非常多的技术问题。一般来说，事务处理行存会比较好，分析一般是列存比较好，当一套系统需要同时支持行存和列存的时候，需要什么样的存储结构？另外，事务处理对于优先级、延迟/尾延迟、吞吐率要求比较高。那么在系统里如何调度不同优先级的请求，这里涉及到很多相关技术。\n\n在蚂蚁的图风控中，也有另外一个场景。刚才我们讲到，可以通过数据库本身的 HTAP 引擎解决在线/离线一致性的问题，如果没有这样的混合系统，应该如何实现两份数据达到在线离线一致性？下面以图风控方案中的在线离线一体化为例，给大家介绍。  \nTuGraph DB（分布式图数据库），是一个支持事务处理的图数据库。TuGraph Dataflow（流图计算系统），可以看作是一个支持图语义的 Flink。\n\n在我们原来的方案中，这两个系统采用不同的查询语言，一个是我们自定义的 GQuery 语言，另外一个是基于 Java 的支持 Gremlin 语言。这两个系统的数据通过 TuGraph Dataflow 处理完成后，一条线通过 TuGraph DB 去做在线链路，另外一个经过存储去完成后续的离线分析，这时就会出现数据不一致的情况。\n\n该段落讨论了在线和离线数据链路之间的一致性问题，强调为了确保数据一致性，系统应实现事务处理和分析处理的整合，并介绍了蚂蚁集团在图风控中采用的技术解决方案，包括TuGraph DB和TuGraph Dataflow的协作。此内容属于“在线离线一体化”主题下，反映了AI时代数据处理技术的复杂性与挑战。"
            },
            {
                "content": "在蚂蚁的图风控中，也有另外一个场景。刚才我们讲到，可以通过数据库本身的 HTAP 引擎解决在线/离线一致性的问题，如果没有这样的混合系统，应该如何实现两份数据达到在线离线一致性？下面以图风控方案中的在线离线一体化为例，给大家介绍。  \nTuGraph DB（分布式图数据库），是一个支持事务处理的图数据库。TuGraph Dataflow（流图计算系统），可以看作是一个支持图语义的 Flink。\n\n在我们原来的方案中，这两个系统采用不同的查询语言，一个是我们自定义的 GQuery 语言，另外一个是基于 Java 的支持 Gremlin 语言。这两个系统的数据通过 TuGraph Dataflow 处理完成后，一条线通过 TuGraph DB 去做在线链路，另外一个经过存储去完成后续的离线分析，这时就会出现数据不一致的情况。\n\n这个问题如何解决呢？首先需要让数据保持一致性。数据虽然是两份，但是在TuGraph DB 和存储之间新增了一条数据同步链路，就是通过从 Binlog 中读取数据，保证两份数据的一致性，防止出现两边写，一边写成功、一边写失败，而导致的数据不一致。当把在线数据里已经处理完成的数据同步至离线数据，这时数据的一致性是有保证的。  \n另外，我们把这两个系统的查询语言和语义都统一起来，都使用国际标准图查询语言 ISO-GQL，同样一套查询语言在两个系统上用同一个语义支持，在进行后续的策略分析时，数据和查询语言的语义是一致的，可以达到更好的一致性。\n\n这里也存在非常复杂的情况。图数据库的基本功能是从一个点扩出去很多点，但是有些点的邻居非常多，可能有几十万、上百万个，所以我们会限制每个点扩展的点数，比如只扩两百个。但同时还需要在两个系统中保证不仅只扩两百个点，这两百个点都是一样的，才能保证数据一致性。所以想要在两个系统中要保证数据一致性，需要花费相当大的精力。\n\n### （二）向量数据库和关系型数据库一体化\n\n向量数据库和大语言模型的结合有非常重要的作用，如果一个企业要用大语言模型做服务，既要部署语言模型又要部署向量数据库，同时企业的很多数据又保存在关系型数据库中。\n\n该段落位于《AI 时代的数据处理技术》分享中，主要探讨蚂蚁集团在图风控中的在线与离线数据一致性问题，重点介绍TuGraph DB和TuGraph Dataflow如何解决数据不一致，以及查询语言的一致性如何提高系统整体的协调性。此段落后续内容将继续讨论向量数据库与关系型数据库的一体化。"
            },
            {
                "content": "这里也存在非常复杂的情况。图数据库的基本功能是从一个点扩出去很多点，但是有些点的邻居非常多，可能有几十万、上百万个，所以我们会限制每个点扩展的点数，比如只扩两百个。但同时还需要在两个系统中保证不仅只扩两百个点，这两百个点都是一样的，才能保证数据一致性。所以想要在两个系统中要保证数据一致性，需要花费相当大的精力。\n\n### （二）向量数据库和关系型数据库一体化\n\n向量数据库和大语言模型的结合有非常重要的作用，如果一个企业要用大语言模型做服务，既要部署语言模型又要部署向量数据库，同时企业的很多数据又保存在关系型数据库中。\n\n这样一个多系统复杂混合的部署，开发、部署、维护非常困难。因为涉及到多个系统之间的依赖性，软件版本、系统之间的交互也会存在很多的问题。如果能够把这些功能做到一起，就能够实现一致性的管理。  \n在关系型数据库中，可以通过一些插件支持向量数据库的语义，同时在调用查询引擎的时候，将数据分到不同的链路上执行，从用户的角度就可以实现只部署一个系统，使用一套语言，完成相关工作。\n\n蚂蚁集团有一套内部的 VSAG 的向量库，实现了主流向量数据库的相关功能，而且在实际生产中已经得到应用。向量数据库最有名的是 FaceBook 开源的 FAISS 系统。\n\nVSAG 和 FAISS 之间有什么区别？FAISS 功能非常强大、性能非常好，对 GPU 也做了很多优化，但是相对来说提供了很多底层功能，这就需要通过调整各种参数、配置，从中得到一个对应用比较合适的配置。\n\n而蚂蚁集团的 VSAG 库更多从开发者和产品应用性的角度出发，默认把很多基础配置的事情都做好了，而且在 CPU 上也实现了很多优化，提供了近似于开箱即用的功能。  \n在 OceanBase 里，以插件的方式集成了 VSAG 功能，可以在 OceanBase 里使用 VSAG 向量化的功能，用一套系统达到这样的效果。\n\n### （三）数据处理与 AI 计算一体化\n\n本段内容探讨了图数据库和向量数据库在数据一致性管理中的复杂性，以及它们与关系型数据库的整合。作者强调了在多系统环境中实现高效管理的重要性，并介绍了蚂蚁集团内部开发的VSAG向量库及其相对于FAISS系统的优势，旨在提升数据库的多功能性和用户体验。"
            },
            {
                "content": "蚂蚁集团有一套内部的 VSAG 的向量库，实现了主流向量数据库的相关功能，而且在实际生产中已经得到应用。向量数据库最有名的是 FaceBook 开源的 FAISS 系统。\n\nVSAG 和 FAISS 之间有什么区别？FAISS 功能非常强大、性能非常好，对 GPU 也做了很多优化，但是相对来说提供了很多底层功能，这就需要通过调整各种参数、配置，从中得到一个对应用比较合适的配置。\n\n而蚂蚁集团的 VSAG 库更多从开发者和产品应用性的角度出发，默认把很多基础配置的事情都做好了，而且在 CPU 上也实现了很多优化，提供了近似于开箱即用的功能。  \n在 OceanBase 里，以插件的方式集成了 VSAG 功能，可以在 OceanBase 里使用 VSAG 向量化的功能，用一套系统达到这样的效果。\n\n### （三）数据处理与 AI 计算一体化\n\n有人可能会问，数据处理不就是 SQL 吗？AI 是神经网络层面的东西，AI 与 SQL 为什么会结合到一起？我举一个例子。大家知道世界上有很多的网页，网页上面有很多内容，内容量非常大，远超几十 T、几百 T。但是在这些海量内容中，很多内容质量很低，如何从中提取出高质量的内容？FaceBook 提出了一套 CCNet 的流程，下图的 CCNet 流程展示了数据处理和 AI 的模型在这一过程中的融合试用。\n\n第一步，CCNet 对网页的原始数据进行解析，在 HTML 的网页中抓取内容，这里涉及到解析等工作。\n\n第二步是删冗，删冗也可以被认为是一个 JOIN，因为抓取网页内容中可能用到了别的网页内容，语料里面有冗余不利于最后的训练，即对每段话都做一个哈希，和过去已有的内容对比，是相同还是不相同。解析与删冗是非常典型的数据处理过程。\n\n第三步，做语言分类，需要经过神经网络模型判断网页的语言。\n\n接下来，通过一些 AI 模型对数据做分词、质量评估，后面的过滤、分桶工作，又回到数据处理。\n\n在这个应用里，数据处理和 AI 计算处于交叠的状态，不是一次数据处理之后都交给AI完成后续的处理，这是一个复杂的来回交互的链路。\n\n那这种情况下，什么样的系统可以支撑这样复杂交互的服务？现在的 AI 和大数据生态基本是割裂的生态：\n\n- AI 用 Python，主要用 GPU；\n- 大数据基本上是用 CPU，用基于 Java 的 Spark 实现。\n\n在《AI时代数据处理技术》主题分享中，陈文光讨论了AI时代对数据处理的需求和数据库的发展趋势。在特别关注向量数据库与关系型数据库一体化的部分，他提到了蚂蚁集团的VSAG向量库与Facebook的FAISS系统的比较，以及两者在应用开发的不同重点。接着，分享了数据处理与AI计算一体化的重要性，通过CCNet的流程展示了数据处理和AI模型的结合，指出目前AI与大数据生态的割裂现状。"
            },
            {
                "content": "第一步，CCNet 对网页的原始数据进行解析，在 HTML 的网页中抓取内容，这里涉及到解析等工作。\n\n第二步是删冗，删冗也可以被认为是一个 JOIN，因为抓取网页内容中可能用到了别的网页内容，语料里面有冗余不利于最后的训练，即对每段话都做一个哈希，和过去已有的内容对比，是相同还是不相同。解析与删冗是非常典型的数据处理过程。\n\n第三步，做语言分类，需要经过神经网络模型判断网页的语言。\n\n接下来，通过一些 AI 模型对数据做分词、质量评估，后面的过滤、分桶工作，又回到数据处理。\n\n在这个应用里，数据处理和 AI 计算处于交叠的状态，不是一次数据处理之后都交给AI完成后续的处理，这是一个复杂的来回交互的链路。\n\n那这种情况下，什么样的系统可以支撑这样复杂交互的服务？现在的 AI 和大数据生态基本是割裂的生态：\n\n- AI 用 Python，主要用 GPU；\n- 大数据基本上是用 CPU，用基于 Java 的 Spark 实现。\n\n另一方面，在很多小数据的处理上，Python 已经展现出非常强大的性能，像 Pandas 这样的系统，在单机数据的处理上提供了非常方便的接口。\n\n当 AI 逐渐成为主流计算形态的时候，数据应该如何与 AI 融合？\n\n由于 Spark 是基于 Java 的生态，当我们如果把大模型处理交给 Spark 去做，它产出的结果要通过文件系统、或者其他传输方式交给 AI 的 Python 程序，Python 处理完之后可能还有一些后续处理。在刚才的例子里面，数据处理和 AI 计算之间会有多次的交互，对整个系统的开发、调试、部署、维护带来非常大的问题。\n\n有人尝试把数据处理和 AI 结合起来。2019 年，英特尔出了一个系统“BigDL”，在 Spark 里面把神经网络的描述、优化器、训练方式把这些东西加进去。当时只支持了 CPU，而且是基于 Java 的。我们可以认为，这种方式是试图把 AI 融入到大数据的生态里面。\n\n我们反过来看，如何把大数据的生态往 AI 的方向牵引？这其实是 Spark 的 Python 化。\n\n该段落位于文章的第三部分，讨论了数据处理与AI计算的融合，具体描述了CCNet在网页数据处理中的步骤和交互，强调了当前AI与大数据生态的割裂性及未来融合的必要性。"
            },
            {
                "content": "另一方面，在很多小数据的处理上，Python 已经展现出非常强大的性能，像 Pandas 这样的系统，在单机数据的处理上提供了非常方便的接口。\n\n当 AI 逐渐成为主流计算形态的时候，数据应该如何与 AI 融合？\n\n由于 Spark 是基于 Java 的生态，当我们如果把大模型处理交给 Spark 去做，它产出的结果要通过文件系统、或者其他传输方式交给 AI 的 Python 程序，Python 处理完之后可能还有一些后续处理。在刚才的例子里面，数据处理和 AI 计算之间会有多次的交互，对整个系统的开发、调试、部署、维护带来非常大的问题。\n\n有人尝试把数据处理和 AI 结合起来。2019 年，英特尔出了一个系统“BigDL”，在 Spark 里面把神经网络的描述、优化器、训练方式把这些东西加进去。当时只支持了 CPU，而且是基于 Java 的。我们可以认为，这种方式是试图把 AI 融入到大数据的生态里面。\n\n我们反过来看，如何把大数据的生态往 AI 的方向牵引？这其实是 Spark 的 Python 化。\n\n上图是 2022 年在 DataBricks Summit上讲的。这是一个分布式的 PySpark，就是 Python 接口的 Spark系统。当时 PySpark 的使用率已经达到了整个 Spark 使用率的近 50%，很多人已经愿意用 PySpark 了。但是 PySpark 还存在一个问题：它的性能很差。\n\nPython 是一个动态语言，在编译时不知道它的类型，动态时才知道，所以它的性能很差，比 Java 的 Spark 还要慢一半。所以虽然 PySpark 对编程非常友好，很多人也习惯用，但是性能不太好。因此我们在处理大量数据的时候，希望能够避免这一问题。\n\n所以，我们提出一个愿景，融合数据处理和 AI 生态。\n\n我认为还是要基于 Python，因为 AI 是主要的计算形式，所以整个数据处理应该围绕 AI 建设。从编译优化的角度来讲，我们希望把 PySpark 做很多的优化。这件事是可以做的，我们最近也有了一些成果。在删冗部分，通过把 PySpark 做相关优化，基本上性能可以提升一倍多，可以达到我们的性能预期。\n\n未来，这个生态不只是编程要融合，底层的硬件也要融合，数据和 AI 结合以后，底层的硬件生态也要支持 GPU、弹性任务调度，最后可以达到“一次编写到处执行”的效果。\n\n在《AI时代的数据处理技术》分享中，陈文光探讨了数据处理技术在AI时代的发展需求和趋势。该文段主要讨论了数据处理与AI计算的融合，强调了Python在小数据处理上的优势，并分析了当前Spark与AI之间的生态割裂问题以及未来的优化方向。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_171.md",
        "chunks": [
            {
                "content": "# Cypher API\n> 此文档主要介绍了TuGraph-Cypher的详细使用说明。\n## 1. 操作符\n### 1.1. 概述\nOperators支持进度一览：\n\n该文档是一份关于TuGraph-Cypher的详细使用说明，其中包含不同类别的操作符支持情况、示例代码以及与OpenCypher的区别，旨在帮助用户了解和使用Cypher查询语言。上述chunk是文档的开头部分，介绍了文档的主题和操作符的概述。"
            },
            {
                "content": "| 类别                                 | 支持                                                                                                        | 待支持                             |\n| ------------------------------------ | ----------------------------------------------------------------------------------------------------------- | ---------------------------------- |\n| 通用操作符                           | `DISTINCT`, `.` 用于属性访问                                                                             | `[]` 用于动态属性访问             |\n| 数学操作符                           | `+`, `-`, `*`, `/`, `%`, `^`                                                                               |                                    |\n| 比较操作符                           | `=`, `<>`, `<`, `>`, `<=`, `>=`, `IS NULL`, `IS NOT NULL`                                                 |                                    |\n\n该内容位于文档的第一部分，主要介绍了TuGraph-Cypher中操作符的分类及其支持状态。通过列出各种操作符的情况，对已支持和待支持的操作符进行对比，以便用户了解在实际使用中的可用功能。"
            },
            {
                "content": "| 数学操作符                           | `+`, `-`, `*`, `/`, `%`, `^`                                                                               |                                    |\n| 比较操作符                           | `=`, `<>`, `<`, `>`, `<=`, `>=`, `IS NULL`, `IS NOT NULL`                                                 |                                    |\n| 字符串特定比较操作符                 | `STARTS WITH`, `ENDS WITH`, `CONTAINS`, `REGEXP`                                                        |                                    |\n| 布尔操作符                           | `AND`, `OR`, `XOR`, `NOT`                                                                                 |                                    |\n| 字符串操作符                         | `+` 用于连接                                                                                               |                                    |\n\n该块内容位于文档的“操作符”部分，具体列出了数学操作符、比较操作符、字符串特定比较操作符、布尔操作符和字符串操作符等类型的支持情况，旨在提供对TuGraph-Cypher中可用操作符的清晰概述。"
            },
            {
                "content": "| 布尔操作符                           | `AND`, `OR`, `XOR`, `NOT`                                                                                 |                                    |\n| 字符串操作符                         | `+` 用于连接                                                                                               |                                    |\n| 列表操作符                           | `+` 用于连接，`IN` 用于检查元素在列表中的存在，`[]` 用于访问元素(s)                                     |                                    |\n表格内容描述:\n该表格包括两个主要列：类别和支持/待支持。其中，类别列列出了不同类型的操作符，而支持和待支持列则分别表示这些操作符是否被支持或待支持。\n\n该块内容位于文档的第一部分，主要介绍了TuGraph-Cypher的操作符分类，具体列出了布尔操作符、字符串操作符和列表操作符的支持情况及其应用场景。在整体文档中，此块为用户了解不同操作符的功能和使用提供了基础信息。"
            },
            {
                "content": "逐行描述数据内容如下：\n1. 通用操作符：支持的操作符包括 `DISTINCT` 和 `.`（用于属性访问），而待支持的操作符为 `[]`（用于动态属性访问）。\n2. 数学操作符：支持的操作符包括 `+`, `-`, `*`, `/`, `%`, `^`，待支持的操作符为空。\n3. 比较操作符：支持的操作符有 `=`, `<>`, `<`, `>`, `<=`, `>=`, `IS NULL`, `IS NOT NULL`，待支持的操作符为空。\n4. 字符串特定比较操作符：支持的操作符包括 `STARTS WITH`, `ENDS WITH`, `CONTAINS`, `REGEXP`，待支持的操作符为空。\n5. 布尔操作符：支持的操作符有 `AND`, `OR`, `XOR`, `NOT`，待支持的操作符为空。\n6. 字符串操作符：支持的操作符为 `+`（用于连接），待支持的操作符为空。\n7. 列表操作符：支持操作符包括 `+`（用于连接），`IN`（用于检查元素在列表中的存在），`[]`（用于访问元素(s)），待支持的操作符为空。\n\n总体而言，该表格详细列出了在不同类别下已支持和待支持的操作符，强调了各种操作符的应用场景及其现状，部分操作符已经完全支持，而其它操作符则仍待支持。\n### 1.2. 通用操作符\n- ✓ 使用 DISTINCT 操作符\n\n```\nMATCH (p:person) RETURN DISTINCT p.born\n```\n\n- ❏ 使用 `.` 操作符访问嵌套字面量映射的属性\n\n```\nWITH {person: {name: 'Anne', age: 25}} AS p\nRETURN p.person.name\n```\n\n- ❏ 使用 `[]` 操作符对动态计算的属性键进行过滤\n\n```\nCREATE (a:Restaurant {name: 'Hungry Jo', rating_hygiene: 10, rating_food: 7}),\n       (b:Restaurant {name: 'Buttercup Tea Rooms', rating_hygiene: 5, rating_food:6}),\n       (c1:Category {name: 'hygiene'}), (c2:Category {name: 'food'})\n```\n\n该段落位于文档的第一部分，主要介绍了TuGraph-Cypher中的操作符及其支持情况，特别是通用操作符的具体用法和示例。它详细列出了不同类别的操作符，包括已支持和待支持的操作符，以及对应的示例代码，帮助用户理解操作符的应用和限制。"
            },
            {
                "content": "```\nMATCH (p:person) RETURN DISTINCT p.born\n```\n\n- ❏ 使用 `.` 操作符访问嵌套字面量映射的属性\n\n```\nWITH {person: {name: 'Anne', age: 25}} AS p\nRETURN p.person.name\n```\n\n- ❏ 使用 `[]` 操作符对动态计算的属性键进行过滤\n\n```\nCREATE (a:Restaurant {name: 'Hungry Jo', rating_hygiene: 10, rating_food: 7}),\n       (b:Restaurant {name: 'Buttercup Tea Rooms', rating_hygiene: 5, rating_food:6}),\n       (c1:Category {name: 'hygiene'}), (c2:Category {name: 'food'})\n```\n\n```\nMATCH (restaurant:Restaurant), (category:Category)\nWHERE restaurant[\"rating_\" + category.name] > 6\nRETURN DISTINCT restaurant.name\n```\n### 1.3. 数学运算符\n- ✓ 使用指数运算符 `^`\n\n```\nWITH 2 AS number, 3 AS exponent\nRETURN number ^ exponent AS result\n```\n\n- ✓ 使用一元减法运算符 `-`\n\n```\nWITH -3 AS a, 4 AS b\nRETURN b - a AS result\n```\n\n### 1.4. 比较运算符\n- ✓ 比较两个数字\n\n```\nWITH 4 AS one, 3 AS two\nRETURN one > two AS result\n```\n输出:\n### 1.5.字符串特定比较运算符\n- ✓ 使用 STARTS WITH 过滤名称\n\n该片段位于文档的“1.2. 通用操作符”部分，具体讨论了通用操作符的使用示例，包括如何使用 DISTINCT 操作符进行去重，以及访问嵌套映射属性和动态属性键的操作示例。接下来的内容则介绍了数学运算符和比较运算符的用法。"
            },
            {
                "content": "```\nMATCH (restaurant:Restaurant), (category:Category)\nWHERE restaurant[\"rating_\" + category.name] > 6\nRETURN DISTINCT restaurant.name\n```\n### 1.3. 数学运算符\n- ✓ 使用指数运算符 `^`\n\n```\nWITH 2 AS number, 3 AS exponent\nRETURN number ^ exponent AS result\n```\n\n- ✓ 使用一元减法运算符 `-`\n\n```\nWITH -3 AS a, 4 AS b\nRETURN b - a AS result\n```\n\n### 1.4. 比较运算符\n- ✓ 比较两个数字\n\n```\nWITH 4 AS one, 3 AS two\nRETURN one > two AS result\n```\n输出:\n### 1.5.字符串特定比较运算符\n- ✓ 使用 STARTS WITH 过滤名称\n\n```\nWITH ['John', 'Mark', 'Jonathan', 'Bill'] AS somenames\nUNWIND somenames AS names\nWITH names AS candidate\nWHERE candidate STARTS WITH 'Jo'\nRETURN candidate\n```\n\n- ✓ 使用 REGEXP 过滤名称\n\n```\nWITH ['John', 'Mark', 'Jonathan', 'Bill'] AS somenames\nUNWIND somenames AS names\nWITH names AS candidate\nWHERE candidate REGEXP 'Jo.*n'\nRETURN candidate\n```\n输出：\n### 1.6.布尔运算符\n- ✓ 使用布尔运算符过滤数字\n\n```\nWITH [2, 4, 7, 9, 12] AS numberlist\nUNWIND numberlist AS number\nWITH number\nWHERE number = 4 OR (number > 6 AND number < 10)\nRETURN number\n```\n输出：\n### 1.7. 字符串操作符\n字符串操作符包括：\n\n该代码块位于文档的操作符部分，特别是数学运算符和比较运算符的介绍中。其中展示了如何使用动态属性访问以及指数和一元减法运算符的示例，紧接着是比较两个数字的用法。这部分内容有助于理解在TuGraph-Cypher中如何进行基本运算和条件判断。"
            },
            {
                "content": "- ✓ 使用 REGEXP 过滤名称\n\n```\nWITH ['John', 'Mark', 'Jonathan', 'Bill'] AS somenames\nUNWIND somenames AS names\nWITH names AS candidate\nWHERE candidate REGEXP 'Jo.*n'\nRETURN candidate\n```\n输出：\n### 1.6.布尔运算符\n- ✓ 使用布尔运算符过滤数字\n\n```\nWITH [2, 4, 7, 9, 12] AS numberlist\nUNWIND numberlist AS number\nWITH number\nWHERE number = 4 OR (number > 6 AND number < 10)\nRETURN number\n```\n输出：\n### 1.7. 字符串操作符\n字符串操作符包括：\n\n- ✓ 连接字符串: `+`\n输出:\n### 1.8. 列表运算符\n- ✓ 使用 + 连接两个列表\n\n```\nRETURN [1,2,3,4,5]+[6,7] AS myList\n```\n\n- ✓ 使用 IN 检查一个数字是否在列表中\n\n```\nWITH [2, 3, 4, 5] AS numberlist\nUNWIND numberlist AS number\nWITH number\nWHERE number IN [2, 3, 8]\nRETURN number\n```\n\n- ✓ 使用 [] 运算符访问列表中的元素\n\n```\nWITH ['Anne', 'John', 'Bill', 'Diane', 'Eve'] AS names\nRETURN names[1..3] AS result\n```\n## 2.子句\n### 2.1.摘要\nClauses支持进度一览：\n\n该片段位于文档的操作符部分，具体涵盖字符串特定比较操作符和布尔操作符的使用示例，并紧接着介绍了字符串和列表操作符的功能。这部分内容为读者提供了多种操作符的具体用法示例，有助于理解和应用TuGraph-Cypher查询语言的各种操作。"
            },
            {
                "content": "| 类别                    | 语法                                  | 备注   |\n| ----------------------- | ------------------------------------- | ------ |\n| 阅读子句                | MATCH                                 | 支持   |\n|                         | OPTIONAL MATCH                        | 支持   |\n|                         | MANDATORY MATCH                       | 待支持 |\n| 投影子句                | RETURN … [AS]                        | 支持   |\n|                         | WITH … [AS]                          | 支持   |\n|                         | UNWIND … [AS]                        | 支持   |\n| 阅读子子句              | WHERE                                 | 支持   |\n|                         | ORDER BY [ASC[ENDING] / DESC[ENDING]] | 支持   |\n|                         | SKIP                                  | 支持   |\n|                         | LIMIT                                 | 支持   |\n| 写入子句                | CREATE                                | 支持   |\n\n该片段位于文档的第二部分，主要介绍了Cypher语法中的不同类别子句及其支持状态，包括读取子句、投影子句、阅读子子句和写入子句，旨在明确列出已支持和待支持的语法结构，以帮助用户理解和使用TuGraph的查询语言。"
            },
            {
                "content": "|                         | UNWIND … [AS]                        | 支持   |\n| 阅读子子句              | WHERE                                 | 支持   |\n|                         | ORDER BY [ASC[ENDING] / DESC[ENDING]] | 支持   |\n|                         | SKIP                                  | 支持   |\n|                         | LIMIT                                 | 支持   |\n| 写入子句                | CREATE                                | 支持   |\n|                         | DELETE                                | 支持   |\n|                         | DETACH DELETE                         | 支持   |\n|                         | SET                                   | 支持   |\n|                         | REMOVE                                | 支持   |\n| 阅读/写入子句          | MERGE                                 | 支持   |\n|                         | CALL […YIELD]                        | 支持   |\n| 集合操作                | UNION                                 | 待支持 |\n\n该区块位于文档的第二部分，主要是关于Cypher语法的子句支持状态汇总。它详细列出了不同类别的阅读子句、写入子句、阅读/写入子句以及集合操作的具体语法及其支持情况，帮助用户了解在TuGraph-Cypher中各类子句的使用现状。"
            },
            {
                "content": "|                         | DELETE                                | 支持   |\n|                         | DETACH DELETE                         | 支持   |\n|                         | SET                                   | 支持   |\n|                         | REMOVE                                | 支持   |\n| 阅读/写入子句          | MERGE                                 | 支持   |\n|                         | CALL […YIELD]                        | 支持   |\n| 集合操作                | UNION                                 | 待支持 |\n|                         | UNION ALL                             | 支持   |\n表格内容描述:  \n该表格包含三列，分别是“类别”、“语法”和“备注”。  \n- 在“阅读子句”类别中，包含三条语法，其中“MATCH”和“OPTIONAL MATCH”均为支持状态，而“MANDATORY MATCH”标注为待支持。  \n- 在“投影子句”类别下，列出了三条语法，包括“RETURN … [AS]”、“WITH … [AS]”和“UNWIND … [AS]”，这些语法均为支持状态。  \n- 在“阅读子子句”类别中，同样包含四条语法，所有条款“WHERE”、“ORDER BY [ASC[ENDING] / DESC[ENDING]”、“SKIP”和“LIMIT”均为支持状态。  \n- 在“写入子句”类别中，列出了五条语法：“CREATE”、“DELETE”、“DETACH DELETE”、“SET”和“REMOVE”，均为支持状态。  \n- 在“阅读/写入子句”类别中，包含“MERGE”和“CALL […YIELD]”这两条语法，均为支持。\n\n该片段位于文档的“子句”部分，具体涵盖了各种子句的类别、语法和备注信息，主要包括阅读子句、投影子句和写入子句等的支持情况。此部分详细列出了在TuGraph-Cypher中已支持及待支持的操作，以帮助用户更好地理解和使用相关功能。"
            },
            {
                "content": "|                         | UNION ALL                             | 支持   |\n表格内容描述:  \n该表格包含三列，分别是“类别”、“语法”和“备注”。  \n- 在“阅读子句”类别中，包含三条语法，其中“MATCH”和“OPTIONAL MATCH”均为支持状态，而“MANDATORY MATCH”标注为待支持。  \n- 在“投影子句”类别下，列出了三条语法，包括“RETURN … [AS]”、“WITH … [AS]”和“UNWIND … [AS]”，这些语法均为支持状态。  \n- 在“阅读子子句”类别中，同样包含四条语法，所有条款“WHERE”、“ORDER BY [ASC[ENDING] / DESC[ENDING]”、“SKIP”和“LIMIT”均为支持状态。  \n- 在“写入子句”类别中，列出了五条语法：“CREATE”、“DELETE”、“DETACH DELETE”、“SET”和“REMOVE”，均为支持状态。  \n- 在“阅读/写入子句”类别中，包含“MERGE”和“CALL […YIELD]”这两条语法，均为支持。  \n- 最后，在“集合操作”类别中，列出了两条语法，其中“UNION”标注为待支持，而“UNION ALL”标注为支持。\n\n该段落位于文档的第二部分“子句”中，具体讨论了不同类别的Cypher语法及其支持状态，包括阅读子句、投影子句和集合操作等，旨在概述当前支持的语法功能和未来待支持的语法。"
            },
            {
                "content": "总体来看，该表格总结了不同类别的 Cypher 语法的支持状态，显示出在大多数情况下支持的语法，只有少数条款仍待支持。\n### 2.2.匹配\n- 基本节点查找\n\n  - ✓ 获取所有节点\n\n  ```\n  MATCH (n)\n  RETURN n\n  ```\n\n  - ✓ 获取具有标签的所有节点\n\n  ```\n  MATCH (movie:movie)\n  RETURN movie.title\n  ```\n\n  - ✓ 相关节点\n\n  ```\n  MATCH (person {name: 'Laurence Fishburne'})-[]-(movie)\n  RETURN movie.title\n  ```\n\n  - ✓ 带标签的匹配\n\n  ```\n  MATCH (:person {name: 'Laurence Fishburne'})-[]-(movie:movie)\n  RETURN movie.title\n  ```\n\n- 关系基础\n\n  - ✓ 输出关系\n\n  ```\n  MATCH (:person {name: 'Laurence Fishburne'})-[]->(movie)\n  RETURN movie.title\n  ```\n\n  - ✓ 有向关系和变量\n\n  ```\n  MATCH (:person {name: 'Laurence Fishburne'})-[r]->(movie)\n  RETURN type(r)\n  ```\n\n  - ✓ 根据关系类型匹配\n\n  ```\n  MATCH (matrix:movie {title: 'The Matrix'})<-[:acted_in]-(actor)\n  RETURN actor.name\n  ```\n\n  - ✓ 根据多个关系类型匹配\n\n  ```\n  MATCH (matrix {title: 'The Matrix'})<-[:acted_in|:directed]-(person)\n  RETURN person.name\n  ```\n\n  - ✓ 根据关系类型匹配并使用变量\n\n  ```\n  MATCH (matrix {title: 'The Matrix'})<-[r:acted_in]-(actor)\n  RETURN r.role\n  ```\n\n- 深入了解关系\n\n  - ❏ 关系类型包含非常规字符\n\n该段落位于文档的第二部分“子句”下，具体是“2.2.匹配”小节，主要介绍了如何在 TuGraph-Cypher 中进行基本节点查找和关系查询的语法，包括获取所有节点、具有标签的节点、相关节点及其关系基础的操作示例。"
            },
            {
                "content": "- ✓ 有向关系和变量\n\n  ```\n  MATCH (:person {name: 'Laurence Fishburne'})-[r]->(movie)\n  RETURN type(r)\n  ```\n\n  - ✓ 根据关系类型匹配\n\n  ```\n  MATCH (matrix:movie {title: 'The Matrix'})<-[:acted_in]-(actor)\n  RETURN actor.name\n  ```\n\n  - ✓ 根据多个关系类型匹配\n\n  ```\n  MATCH (matrix {title: 'The Matrix'})<-[:acted_in|:directed]-(person)\n  RETURN person.name\n  ```\n\n  - ✓ 根据关系类型匹配并使用变量\n\n  ```\n  MATCH (matrix {title: 'The Matrix'})<-[r:acted_in]-(actor)\n  RETURN r.role\n  ```\n\n- 深入了解关系\n\n  - ❏ 关系类型包含非常规字符\n\n  ```\n  MATCH (n {name: 'Rob Reiner'})-[r:`TYPE WITH SPACE`]->()\n  RETURN type(r)\n  ```\n\n  - ✓ 多重关系\n\n  ```\n  MATCH (laurence {name: 'Laurence Fishburne'})-[:acted_in]->(movie)<-[:directed]-(director)\n  RETURN movie.title, director.name\n  ```\n\n  - ✓ 变长关系\n\n  ```\n  MATCH (laurence {name: 'Laurence Fishburne'})-[:acted_in*1..3]-(movie:movie)\n  RETURN movie.title\n  ```\n\n  - ✓ 在变长关系中使用关系变量\n\n  ```\n  MATCH p = (laurence {name: 'Laurence Fishburne'})-[:acted_in*2]-(co_actor)\n  RETURN p\n  ```\n\n  - ❏ 在变长路径上根据属性进行匹配\n\n该段落位于文档的“匹配”子章中，具体讲述了Cypher查询语言中如何使用匹配语法来查找和过滤有向关系，包括基于关系类型、变量及多重关系的匹配示例，适用于用户理解如何在图数据库中有效地查询节点和关系。"
            },
            {
                "content": "```\n  MATCH (n {name: 'Rob Reiner'})-[r:`TYPE WITH SPACE`]->()\n  RETURN type(r)\n  ```\n\n  - ✓ 多重关系\n\n  ```\n  MATCH (laurence {name: 'Laurence Fishburne'})-[:acted_in]->(movie)<-[:directed]-(director)\n  RETURN movie.title, director.name\n  ```\n\n  - ✓ 变长关系\n\n  ```\n  MATCH (laurence {name: 'Laurence Fishburne'})-[:acted_in*1..3]-(movie:movie)\n  RETURN movie.title\n  ```\n\n  - ✓ 在变长关系中使用关系变量\n\n  ```\n  MATCH p = (laurence {name: 'Laurence Fishburne'})-[:acted_in*2]-(co_actor)\n  RETURN p\n  ```\n\n  - ❏ 在变长路径上根据属性进行匹配\n\n  ```\n  MATCH p = (charlie:person)-[* {blocked:false}]-(martin:person)\n  WHERE charlie.name = 'Charlie Sheen' AND martin.name = 'Martin Sheen'\n  RETURN p\n  ```\n\n  - ✓ 零长度路径\n\n  ```\n  MATCH (matrix:movie {title: 'The Matrix'})-[*0..1]-(x)\n  RETURN x\n  ```\n\n  - ✓ 命名路径\n\n  ```\n  MATCH p = (michael {name: 'Michael Douglas'})-[]->() RETURN p\n  ```\n\n  - ✓ 基于约束关系的匹配\n\n  ```\n  MATCH (a)-[r]->(b)\n  WHERE euid(r)=\"0_3937_0_0_0\"\n  RETURN a,b\n  ```\n\n- 最短路径\n\n  - ✓ 单个最短路径\n\n该内容位于文档的第二部分“2.2.匹配”下，主要介绍了在 TuGraph-Cypher 中执行关系匹配的不同用法，包括多重关系、变长关系、零长度路径等示例，涉及如何匹配节点之间的复杂关系及其相关属性。"
            },
            {
                "content": "- ❏ 在变长路径上根据属性进行匹配\n\n  ```\n  MATCH p = (charlie:person)-[* {blocked:false}]-(martin:person)\n  WHERE charlie.name = 'Charlie Sheen' AND martin.name = 'Martin Sheen'\n  RETURN p\n  ```\n\n  - ✓ 零长度路径\n\n  ```\n  MATCH (matrix:movie {title: 'The Matrix'})-[*0..1]-(x)\n  RETURN x\n  ```\n\n  - ✓ 命名路径\n\n  ```\n  MATCH p = (michael {name: 'Michael Douglas'})-[]->() RETURN p\n  ```\n\n  - ✓ 基于约束关系的匹配\n\n  ```\n  MATCH (a)-[r]->(b)\n  WHERE euid(r)=\"0_3937_0_0_0\"\n  RETURN a,b\n  ```\n\n- 最短路径\n\n  - ✓ 单个最短路径\n\n  ```\n  MATCH (martin:person {name: 'Carrie-Anne Moss'}), (laurence:person {name: 'Laurence Fishburne'})\n  CALL algo.shortestPath(martin, laurence) YIELD nodeCount,totalCost,path RETURN nodeCount,totalCost,path\n  ```\n\n  - ✓ 所有最短路径\n\n  ```\n  MATCH (martin:person {name: 'Carrie-Anne Moss'}), (laurence:person {name: 'Laurence Fishburne'}) WITH martin, laurence\n  CALL algo.allShortestPaths(martin, laurence) YIELD nodeIds,relationshipIds,cost RETURN nodeIds,relationshipIds,cost\n  ```\n\n- 根据 ID 获取节点或关系\n\n  - ✓ 根据 ID 获取节点\n\n该文段位于文档的第2.2节“匹配”中，主要介绍了在Cypher查询中如何匹配变长路径、零长度路径、命名路径和基于约束关系的匹配，以及如何查找最短路径和根据ID获取节点或关系的示例代码。"
            },
            {
                "content": "- ✓ 所有最短路径\n\n  ```\n  MATCH (martin:person {name: 'Carrie-Anne Moss'}), (laurence:person {name: 'Laurence Fishburne'}) WITH martin, laurence\n  CALL algo.allShortestPaths(martin, laurence) YIELD nodeIds,relationshipIds,cost RETURN nodeIds,relationshipIds,cost\n  ```\n\n- 根据 ID 获取节点或关系\n\n  - ✓ 根据 ID 获取节点\n\n  ```\n  MATCH (n)\n  WHERE id(n)= 0\n  RETURN n\n  ```\n\n  - ✓ 根据 ID 获取关系\n\n  ```\n  MATCH ()-[r]->()\n  WHERE euid(r) = \"0_3937_0_0_0\"\n  RETURN r\n  ```\n\n  - ✓ 根据 ID 获取多个节点\n\n  ```\n  MATCH (n)\n  WHERE id(n) IN [0, 3, 5]\n  RETURN n\n  ```\n### 2.3.返回\n- ✓ 返回节点\n\n```\nMATCH (n {name: 'Carrie-Anne Moss'}) RETURN n\n```\n\n- ✓ 返回关系\n\n```\nMATCH (n {name: 'Carrie-Anne Moss'})-[r:acted_in]->(c)\nRETURN r\n```\n\n- ✓ 返回属性\n\n```\nMATCH (n {name: 'Carrie-Anne Moss'}) RETURN n.born\n```\n\n- ❏ 返回所有元素\n\n```\nMATCH p = (a {name: 'A'})-[r]->(b)\nRETURN *\n```\n\n- ❏ 带有不常见字符的变量\n\n```\nMATCH (`This isn\\'t a common variable`)\nWHERE `This isn\\'t a common variable`.name = 'A'\nRETURN `This isn\\'t a common variable`.happy\n```\n\n- ✓ 字段别名\n\n该块内容位于文档的第2节，主要介绍了在TuGraph-Cypher中获取最短路径及根据ID获取节点或关系的操作，以及返回操作的相关示例。此部分涵盖了基本的查询语法和示例，适用于数据库查询的初学者或需要查阅具体用法的用户。"
            },
            {
                "content": "```\nMATCH (n {name: 'Carrie-Anne Moss'}) RETURN n\n```\n\n- ✓ 返回关系\n\n```\nMATCH (n {name: 'Carrie-Anne Moss'})-[r:acted_in]->(c)\nRETURN r\n```\n\n- ✓ 返回属性\n\n```\nMATCH (n {name: 'Carrie-Anne Moss'}) RETURN n.born\n```\n\n- ❏ 返回所有元素\n\n```\nMATCH p = (a {name: 'A'})-[r]->(b)\nRETURN *\n```\n\n- ❏ 带有不常见字符的变量\n\n```\nMATCH (`This isn\\'t a common variable`)\nWHERE `This isn\\'t a common variable`.name = 'A'\nRETURN `This isn\\'t a common variable`.happy\n```\n\n- ✓ 字段别名\n\n```\nMATCH (a {name: 'Carrie-Anne Moss'})\nRETURN a.born AS SomethingTotallyDifferent\n```\n\n- ✓ Optional properties\n\n```\nMATCH (n)\nRETURN n.age\n```\n\n- ❏ 其他表达式\n\n```\nMATCH (a {name: 'Carrie-Anne Moss'})\nRETURN a.born > 1900, \"I'm a literal\", (a)-[]->()\n```\n\n`(a)-[]->()`  不支持。\n\n- ✓ 唯一结果\n\n```\nMATCH (a {name: 'Carrie-Anne Moss'})-[]->(b)\nRETURN DISTINCT b\n```\n### 2.4. 哪里\n- 基本用法\n  - ✓ 布尔运算\n\n  ```\n  MATCH (n)\n  WHERE n.name = 'Laurence Fishburne' XOR (n.born > 1965 AND n.name = 'Carrie-Anne Moss')\n  RETURN n.name, n.born\n  ```\n\n  - ✓ 按节点标签过滤\n\n该部分内容属于文档的\"返回\"子章节，介绍了如何使用Cypher查询语言返回节点、关系及其属性的不同方法和示例，包括特定条件下的返回方式（如使用变量名、返回所有元素、字段别名等）。"
            },
            {
                "content": "- ✓ Optional properties\n\n```\nMATCH (n)\nRETURN n.age\n```\n\n- ❏ 其他表达式\n\n```\nMATCH (a {name: 'Carrie-Anne Moss'})\nRETURN a.born > 1900, \"I'm a literal\", (a)-[]->()\n```\n\n`(a)-[]->()`  不支持。\n\n- ✓ 唯一结果\n\n```\nMATCH (a {name: 'Carrie-Anne Moss'})-[]->(b)\nRETURN DISTINCT b\n```\n### 2.4. 哪里\n- 基本用法\n  - ✓ 布尔运算\n\n  ```\n  MATCH (n)\n  WHERE n.name = 'Laurence Fishburne' XOR (n.born > 1965 AND n.name = 'Carrie-Anne Moss')\n  RETURN n.name, n.born\n  ```\n\n  - ✓ 按节点标签过滤\n\n  ```\n  MATCH (n)\n  WHERE n:person\n  RETURN n.name, n.born\n  ```\n\n  - ✓ 按节点属性过滤\n\n  ```\n  MATCH (n)\n  WHERE n.born > 2000\n  RETURN n.name, n.born\n  ```\n\n  - ✓ 按关系属性过滤\n\n  ```\n  MATCH (n)-[k:acted_in]->(f)\n  WHERE k.role = \"Trinity\"\n  RETURN f.title\n  ```\n\n  - ❏ 按动态计算的属性过滤\n\n  ```\n  WITH 'AGE' AS propname\n  MATCH (n)\n  WHERE n[toLower(propname)]< 30\n  RETURN n.name, n.age\n  ```\n\n  - ✓ 属性存在性检查\n\n  ```\n  MATCH (n)\n  WHERE exists(n.born)\n  RETURN n.name, n.born\n  ```\n\n- 字符串匹配\n  - ✓ 匹配字符串的开头\n\n  ```\n  MATCH (n)\n  WHERE n.name STARTS WITH 'Pet'\n  RETURN n.name, n.born\n  ```\n\n该块内容位于文档的第2章，主要介绍了Cypher查询语言中的返回子句和条件过滤子句的用法，包括可选属性、布尔运算、节点标签过滤、节点和关系属性过滤等基本用法。"
            },
            {
                "content": "- ✓ 按节点属性过滤\n\n  ```\n  MATCH (n)\n  WHERE n.born > 2000\n  RETURN n.name, n.born\n  ```\n\n  - ✓ 按关系属性过滤\n\n  ```\n  MATCH (n)-[k:acted_in]->(f)\n  WHERE k.role = \"Trinity\"\n  RETURN f.title\n  ```\n\n  - ❏ 按动态计算的属性过滤\n\n  ```\n  WITH 'AGE' AS propname\n  MATCH (n)\n  WHERE n[toLower(propname)]< 30\n  RETURN n.name, n.age\n  ```\n\n  - ✓ 属性存在性检查\n\n  ```\n  MATCH (n)\n  WHERE exists(n.born)\n  RETURN n.name, n.born\n  ```\n\n- 字符串匹配\n  - ✓ 匹配字符串的开头\n\n  ```\n  MATCH (n)\n  WHERE n.name STARTS WITH 'Pet'\n  RETURN n.name, n.born\n  ```\n\n  - ✓ 匹配字符串的结尾\n\n  ```\n  MATCH (n)\n  WHERE n.name ENDS WITH 'ter'\n  RETURN n.name, n.born\n  ```\n\n  - ✓ 匹配字符串中的任意位置\n\n  ```\n  MATCH (n)\n  WHERE n.name CONTAINS 'ete'\n  RETURN n.name, n.born\n  ```\n\n  - ✓ 字符串匹配否定\n\n  ```\n  MATCH (n)\n  WHERE NOT n.name ENDS WITH 's'\n  RETURN n.name, n.born\n  ```\n\n- 在 `WHERE` 中使用路径模式\n  - ❏ 按模式过滤\n\n  ```\n  MATCH (tobias {name: 'Tobias'}), (others)\n  WHERE others.name IN ['Andres', 'Peter'] AND (tobias)<-[]-(others)\n  RETURN others.name, others.age\n  ```\n\n  - ❏ 使用 NOT 按模式过滤\n\n该片段位于文档的“2.4. 哪里”部分，主要介绍了在Cypher查询中使用`WHERE`子句进行节点和关系的属性过滤、字符串匹配及路径模式过滤的示例。"
            },
            {
                "content": "- ✓ 匹配字符串的结尾\n\n  ```\n  MATCH (n)\n  WHERE n.name ENDS WITH 'ter'\n  RETURN n.name, n.born\n  ```\n\n  - ✓ 匹配字符串中的任意位置\n\n  ```\n  MATCH (n)\n  WHERE n.name CONTAINS 'ete'\n  RETURN n.name, n.born\n  ```\n\n  - ✓ 字符串匹配否定\n\n  ```\n  MATCH (n)\n  WHERE NOT n.name ENDS WITH 's'\n  RETURN n.name, n.born\n  ```\n\n- 在 `WHERE` 中使用路径模式\n  - ❏ 按模式过滤\n\n  ```\n  MATCH (tobias {name: 'Tobias'}), (others)\n  WHERE others.name IN ['Andres', 'Peter'] AND (tobias)<-[]-(others)\n  RETURN others.name, others.age\n  ```\n\n  - ❏ 使用 NOT 按模式过滤\n\n  ```\n  MATCH (persons), (peter {name: 'Peter'})\n  WHERE NOT (persons)-[]->(peter)\n  RETURN persons.name, persons.age\n  ```\n\n  - ❏ 按含属性的模式过滤\n\n  ```\n  MATCH (n)\n  WHERE (n)-[:KNOWS]-({name: 'Tobias'})\n  RETURN n.name, n.age\n  ```\n\n  - ✓ 按关系类型过滤\n\n  ```\n  MATCH (n)-[r]->()\n  WHERE n.name='Laurence Fishburne' AND type(r) STARTS WITH 'ac'\n  RETURN type(r), r.role\n  ```\n\n- 列表\n  - ✓ IN 操作符\n\n  ```\n  MATCH (a)\n  WHERE a.name IN ['Laurence Fishburne', 'Tobias']\n  RETURN a.name, a.born\n  ```\n\n- 缺失的属性和值\n  - ✓ 如果缺失属性则默认为 false\n\n该片段位于文档的第二部分\"子句\"下，详细描述了在`WHERE`子句中的字符串匹配、路径模式过滤、列表操作及缺失属性的处理方式，提供了相关的Cypher查询示例和支持情况。"
            },
            {
                "content": "- ❏ 按含属性的模式过滤\n\n  ```\n  MATCH (n)\n  WHERE (n)-[:KNOWS]-({name: 'Tobias'})\n  RETURN n.name, n.age\n  ```\n\n  - ✓ 按关系类型过滤\n\n  ```\n  MATCH (n)-[r]->()\n  WHERE n.name='Laurence Fishburne' AND type(r) STARTS WITH 'ac'\n  RETURN type(r), r.role\n  ```\n\n- 列表\n  - ✓ IN 操作符\n\n  ```\n  MATCH (a)\n  WHERE a.name IN ['Laurence Fishburne', 'Tobias']\n  RETURN a.name, a.born\n  ```\n\n- 缺失的属性和值\n  - ✓ 如果缺失属性则默认为 false\n\n  ```\n  MATCH (n)\n  WHERE n.belt = 'white'\n  RETURN n.name, n.age, n.belt\n  ```\n\n  - ✓ 如果缺失属性则默认为 true\n\n  ```\n  MATCH (n)\n  WHERE n.belt = 'white' OR n.belt IS NULL RETURN n.name, n.age, n.belt\n  ORDER BY n.name\n  ```\n\n  - ✓ 按 null 过滤\n\n  ```\n  MATCH (person)\n  WHERE person.name = 'Peter' AND person.belt IS NULL RETURN person.name, person.age,\n  person.belt\n  ```\n\n- 使用范围\n  - ✓ 简单范围\n\n  ```\n  MATCH (a)\n  WHERE a.name >= 'Peter'\n  RETURN a.name, a.born\n  ```\n\n  - ✓ 复合范围\n\n  ```\n  MATCH (a)\n  WHERE a.name > 'Andres' AND a.name < 'Tobias'\n  RETURN a.name, a.born\n  ```\n### 2.5.SKIP\n- ✓ 跳过前三条记录\n\n该片段位于文档的2.4节“WHERE”下，主要讲述了在Cypher查询中使用不同条件进行过滤、处理缺失属性的逻辑以及范围查询的语法示例。这一部分对用户在编写查询时如何使用WHERE子句进行条件筛选提供了具体的实例和指导。"
            },
            {
                "content": "```\n  MATCH (n)\n  WHERE n.belt = 'white' OR n.belt IS NULL RETURN n.name, n.age, n.belt\n  ORDER BY n.name\n  ```\n\n  - ✓ 按 null 过滤\n\n  ```\n  MATCH (person)\n  WHERE person.name = 'Peter' AND person.belt IS NULL RETURN person.name, person.age,\n  person.belt\n  ```\n\n- 使用范围\n  - ✓ 简单范围\n\n  ```\n  MATCH (a)\n  WHERE a.name >= 'Peter'\n  RETURN a.name, a.born\n  ```\n\n  - ✓ 复合范围\n\n  ```\n  MATCH (a)\n  WHERE a.name > 'Andres' AND a.name < 'Tobias'\n  RETURN a.name, a.born\n  ```\n### 2.5.SKIP\n- ✓ 跳过前三条记录\n\n```\nMATCH (n:person)\nRETURN n.name\nORDER BY n.name\nSKIP 3\n```\n\n- ✓ 返回中间两条记录\n\n```\nMATCH (n:person)\nRETURN n.name\nORDER BY n.name\nSKIP 1\nLIMIT 2\n```\n\n- ❏ 使用带有 SKIP 的表达式来返回记录的子集\n\n```\nMATCH (n:person)\nRETURN n.name\nORDER BY n.name\nSKIP toInteger(3*rand())+ 1\n```\nOutput:\n### 2.6.限制\n- ✓ 返回记录的一个子集\n\n```\nMATCH (n:person)\nRETURN n.name\nLIMIT 3\n```\n\n- ❏ 使用带LIMIT的表达式返回记录的一个子集\n\n```\nMATCH (n:person)\nRETURN n.name\nLIMIT toInteger(3 * rand()) + 1\n```\n输出：\n### 2.7.CREATE\n- 创建节点\n\n> **注意**\n> TuGraph不支持创建空的节点，也不支持多标签。\n\n  - ☒ 创建单个节点\n\n该片段位于文档的“WHERE”子部分，讨论了如何在Cypher查询中使用条件过滤，包括按null值和范围过滤的示例，同时接着介绍了“SKIP”和“LIMIT”子句的使用，特别是如何跳过特定数量的记录或限制返回记录的数量。这些内容涵盖了查询语言中对数据检索的控制方式。"
            },
            {
                "content": "- ✓ 返回中间两条记录\n\n```\nMATCH (n:person)\nRETURN n.name\nORDER BY n.name\nSKIP 1\nLIMIT 2\n```\n\n- ❏ 使用带有 SKIP 的表达式来返回记录的子集\n\n```\nMATCH (n:person)\nRETURN n.name\nORDER BY n.name\nSKIP toInteger(3*rand())+ 1\n```\nOutput:\n### 2.6.限制\n- ✓ 返回记录的一个子集\n\n```\nMATCH (n:person)\nRETURN n.name\nLIMIT 3\n```\n\n- ❏ 使用带LIMIT的表达式返回记录的一个子集\n\n```\nMATCH (n:person)\nRETURN n.name\nLIMIT toInteger(3 * rand()) + 1\n```\n输出：\n### 2.7.CREATE\n- 创建节点\n\n> **注意**\n> TuGraph不支持创建空的节点，也不支持多标签。\n\n  - ☒ 创建单个节点\n\n  ```\n  CREATE (n)\n  ```\n\n  - ☒ 创建多个节点\n\n  ```\n  CREATE (n), (m)\n  ```\n\n  - ☒ 创建一个带标签的节点\n\n  ```\n  CREATE (n:person)\n  ```\n\n  - ☒ 创建一个带多个标签的节点\n\n  ```\n  CREATE (n:Person:Swedish)\n  ```\n\n  - ✓ 创建节点并添加标签和属性\n\n  ```\n  CREATE (n:person {id:2001, name: 'Andres'})\n  ```\n\n  - ✓ 返回创建的节点\n\n  ```\n  CREATE (n:person {id:2002, name: 'Andres'})\n  RETURN n\n  ```\n\n- 创建关系\n  - ✓ 在两个节点之间创建关系\n\n  ```\n  MATCH (n:person), (m:movie)\n  WHERE n.name = 'Jada Pinkett Smith' AND m.title = 'The Matrix'\n  CREATE (n)-[r:write]->(m)\n  ```\n\n  - ✓ 创建关系并设置属性\n\n该块内容位于文档的“子句”部分，涵盖了关于使用 `SKIP` 和 `LIMIT` 操作符进行结果限制的示例，以及如何创建节点和关系的相关内容。这些示例展示了 TuGraph-Cypher 查询语言的基本用法和限制功能。"
            },
            {
                "content": "- ☒ 创建多个节点\n\n  ```\n  CREATE (n), (m)\n  ```\n\n  - ☒ 创建一个带标签的节点\n\n  ```\n  CREATE (n:person)\n  ```\n\n  - ☒ 创建一个带多个标签的节点\n\n  ```\n  CREATE (n:Person:Swedish)\n  ```\n\n  - ✓ 创建节点并添加标签和属性\n\n  ```\n  CREATE (n:person {id:2001, name: 'Andres'})\n  ```\n\n  - ✓ 返回创建的节点\n\n  ```\n  CREATE (n:person {id:2002, name: 'Andres'})\n  RETURN n\n  ```\n\n- 创建关系\n  - ✓ 在两个节点之间创建关系\n\n  ```\n  MATCH (n:person), (m:movie)\n  WHERE n.name = 'Jada Pinkett Smith' AND m.title = 'The Matrix'\n  CREATE (n)-[r:write]->(m)\n  ```\n\n  - ✓ 创建关系并设置属性\n\n  ```\n  MATCH (n:person), (m:movie)\n  WHERE n.name = 'Jada Pinkett Smith' AND m.title = 'The Matrix'\n  CREATE (n)-[r:acted_in{role: 'Trinity'}]->(m)\n  ```\n\n  - ❏ 创建一个完整路径\n\n  ```\n  CREATE p = (andres:person {id: 2005, name:'Andres'})-[:acted_in {role: 'Trinity'}]->\n  (m:movie {id: 2006})<-[:acted_in {role: 'Trinity'}]-(michael {id: 2006, name:'Michael'})\n  RETURN p\n  ```\n\n- 使用参数创建\n  - ❏ 创建一个包含属性参数的节点\n\n  ```\n  CREATE (n:Person $props)\n  RETURN n\n  ```\n\n  - ☒ 使用属性参数创建多个节点\n\n该片段位于文档的“2.7.CREATE”小节中，主要讲述了在TuGraph中创建节点和关系的语法。包括创建单个节点、带标签的节点、多个标签的节点以及创建关系的示例，强调了不支持创建空节点和多个标签的节点，并列出了使用属性参数创建节点的限制。"
            },
            {
                "content": "- ✓ 创建关系并设置属性\n\n  ```\n  MATCH (n:person), (m:movie)\n  WHERE n.name = 'Jada Pinkett Smith' AND m.title = 'The Matrix'\n  CREATE (n)-[r:acted_in{role: 'Trinity'}]->(m)\n  ```\n\n  - ❏ 创建一个完整路径\n\n  ```\n  CREATE p = (andres:person {id: 2005, name:'Andres'})-[:acted_in {role: 'Trinity'}]->\n  (m:movie {id: 2006})<-[:acted_in {role: 'Trinity'}]-(michael {id: 2006, name:'Michael'})\n  RETURN p\n  ```\n\n- 使用参数创建\n  - ❏ 创建一个包含属性参数的节点\n\n  ```\n  CREATE (n:Person $props)\n  RETURN n\n  ```\n\n  - ☒ 使用属性参数创建多个节点\n\n  ```\n  UNWIND $props AS map\n  CREATE (n)\n  SET n = map\n  ```\n  不能创建没有标签的顶点。\n### 2.8.CALL[…YIELD]\n- ✓ 使用 CALL 调用一个过程\n\n```\nCALL db.vertexLabels\n```\n\n- ✓ 查看一个过程的签名\n\n```\nCALL dbms.procedures() YIELD name, signature\nRETURN signature\n```\n\n- ❏ 使用引用的命名空间和名称调用一个过程\n\n```\nCALL `db`.`vertexLabels`\n```\n\n- ✓ 以字面参数调用一个过程\n\n```\nCALL org.opencypher.procedure.example.addNodeToIndex('users', 0, 'name')\n```\n\n- ❏ 使用参数参数调用一个过程\n\n```\nCALL org.opencypher.procedure.example.addNodeToIndex($indexName,$node,$propKey)\n```\n\n- ❏ 使用混合字面和参数参数调用一个过程\n\n该段落位于文档的第2.7节和第2.8节之间，主要介绍了在TuGraph-Cypher中创建关系与节点的基本操作，包括设置属性、使用参数创建节点等内容，为用户提供创建和调用过程的示例。"
            },
            {
                "content": "```\nCALL db.vertexLabels\n```\n\n- ✓ 查看一个过程的签名\n\n```\nCALL dbms.procedures() YIELD name, signature\nRETURN signature\n```\n\n- ❏ 使用引用的命名空间和名称调用一个过程\n\n```\nCALL `db`.`vertexLabels`\n```\n\n- ✓ 以字面参数调用一个过程\n\n```\nCALL org.opencypher.procedure.example.addNodeToIndex('users', 0, 'name')\n```\n\n- ❏ 使用参数参数调用一个过程\n\n```\nCALL org.opencypher.procedure.example.addNodeToIndex($indexName,$node,$propKey)\n```\n\n- ❏ 使用混合字面和参数参数调用一个过程\n\n```\nCALL org.opencypher.procedure.example.addNodeToIndex('users', $node, 'name')\n```\n\n- ✓ 使用字面和默认参数调用一个过程\n\n```\nCALL org.opencypher.procedure.example.addNodeToIndex('users', 0)\n```\n\n- ✓ 在复杂查询中使用 CALL…YIELD 调用一个过程\n\n```\nCALL db.vertexLabels() YIELD label\nRETURN count(label) AS numLabels\n```\n\n- ❏ 调用一个过程并过滤其结果\n\n```\nCALL db.vertexLabels() YIELD label\nWHERE label CONTAINS 'User'\nRETURN count(label) AS numLabels\n```\n\n- ❏ 在复杂查询中调用一个过程并重命名其输出\n\n```\nCALL db.propertyKeys() YIELD propertyKey AS prop\nMATCH (n)\nWHERE n[prop] IS NOT NULL RETURN prop, count(n) AS numNodes\n```\n### 2.9.联合\n- ✓ 组合两个查询并保留重复项\n\n该片段位于文档中的“子句”部分，具体讨论了如何调用不同的过程以及使用CALL语句的多种方法，包括以字面参数和参数参数调用过程的示例。这部分强调了在复杂查询中的CALL…YIELD使用，以及对结果的过滤和重命名。"
            },
            {
                "content": "- ✓ 使用字面和默认参数调用一个过程\n\n```\nCALL org.opencypher.procedure.example.addNodeToIndex('users', 0)\n```\n\n- ✓ 在复杂查询中使用 CALL…YIELD 调用一个过程\n\n```\nCALL db.vertexLabels() YIELD label\nRETURN count(label) AS numLabels\n```\n\n- ❏ 调用一个过程并过滤其结果\n\n```\nCALL db.vertexLabels() YIELD label\nWHERE label CONTAINS 'User'\nRETURN count(label) AS numLabels\n```\n\n- ❏ 在复杂查询中调用一个过程并重命名其输出\n\n```\nCALL db.propertyKeys() YIELD propertyKey AS prop\nMATCH (n)\nWHERE n[prop] IS NOT NULL RETURN prop, count(n) AS numNodes\n```\n### 2.9.联合\n- ✓ 组合两个查询并保留重复项\n\n```\nMATCH (n:person)\nRETURN n.name AS name\nUNION ALL MATCH (n:movie)\nRETURN n.title AS name\n```\n\n- ❏ 组合两个查询并移除重复项\n\n该块内容位于文档的第2.8节，主要讨论了如何使用CALL语句调用过程，包括使用字面和默认参数、复杂查询中的调用、结果过滤及输出重命名等操作。接下来的2.9节则关注于UNION操作的使用，包括组合查询、保留或移除重复项的情况。"
            },
            {
                "content": "```\nMATCH (n:Actor)\nRETURN n.name AS name\nUNION\nMATCH (n:Movie)\nRETURN n.title AS name\n```\n## 3.功能\n### 3.1.功能完整列表\n| 种类                   | 功能               | 备注                      |\n| ---------------------- |------------------| ------------------------- |\n| 谓词函数              | exists()         |                           |\n|                        | all()            | 不支持                    |\n|                        | any()            | 不支持                    |\n|                        | single()         | 不支持                    |\n|                        | none()           | 不支持                    |\n| 标量函数              | id()             |                           |\n|                        | euid()           |                           |\n|                        | properties()     |                           |\n|                        | head()           |                           |\n|                        | last()           |                           |\n\n该代码块展示了使用 UNION 操作符将演员和电影的名称结合查询的示例，并紧接着介绍了文档中功能完整列表的起始部分，涵盖了各种类型的函数及其支持状态，主要用于帮助用户理解 TuGraph-Cypher 的功能。"
            },
            {
                "content": "|                        | single()         | 不支持                    |\n|                        | none()           | 不支持                    |\n| 标量函数              | id()             |                           |\n|                        | euid()           |                           |\n|                        | properties()     |                           |\n|                        | head()           |                           |\n|                        | last()           |                           |\n|                        | toBoolean()      |                           |\n|                        | toFloat()        |                           |\n|                        | toInteger()      |                           |\n|                        | toString()       |                           |\n|                        | type()           |                           |\n|                        | startnode()      |                           |\n\n该片段位于文档的“功能”部分，主要列出了标量函数的支持情况，包括已支持和待支持的函数。"
            },
            {
                "content": "|                        | toBoolean()      |                           |\n|                        | toFloat()        |                           |\n|                        | toInteger()      |                           |\n|                        | toString()       |                           |\n|                        | type()           |                           |\n|                        | startnode()      |                           |\n|                        | endnode()        |                           |\n|                        | size()           |                           |\n|                        | length()         |                           |\n|                        | substring()      |                           |\n|                        | concat()         |                           |\n|                        | label()          | OpenCypher扩展方法      |\n| 聚合函数              | avg()            |                           |\n\n该部分内容属于文档的“功能完整列表”章节，具体列出了各种标量函数，包括其名称及功能说明，旨在为用户提供关于TuGraph-Cypher支持的标量函数的详细信息。"
            },
            {
                "content": "|                        | endnode()        |                           |\n|                        | size()           |                           |\n|                        | length()         |                           |\n|                        | substring()      |                           |\n|                        | concat()         |                           |\n|                        | label()          | OpenCypher扩展方法      |\n| 聚合函数              | avg()            |                           |\n|                        | collect()        |                           |\n|                        | count()          |                           |\n|                        | max()            |                           |\n|                        | min()            |                           |\n|                        | percentileCont() |                           |\n|                        | percentileDisc() |                           |\n\n该部分内容位于文档的第三部分“功能”中，详细列出了可用的标量函数和聚合函数，包括其名称和备注，说明了这些函数在TuGraph中的具体作用和应用场景。"
            },
            {
                "content": "|                        | collect()        |                           |\n|                        | count()          |                           |\n|                        | max()            |                           |\n|                        | min()            |                           |\n|                        | percentileCont() |                           |\n|                        | percentileDisc() |                           |\n|                        | stDev()          |                           |\n|                        | stDevP()         |                           |\n|                        | variance()       |                           |\n|                        | varianceP()      |                           |\n|                        | sum()            |                           |\n| 列表函数              | keys()           |                           |\n|                        | labels()         | 返回结果有且只有一个label |\n|                        | nodes()          |                           |\n\n该片段位于文档的“功能”部分，详细列出了聚合函数和列表函数的名称及其功能，旨在为用户提供在TuGraph-Cypher中可用的函数的概述，帮助用户理解和运用这些函数进行数据查询与分析。"
            },
            {
                "content": "|                        | stDevP()         |                           |\n|                        | variance()       |                           |\n|                        | varianceP()      |                           |\n|                        | sum()            |                           |\n| 列表函数              | keys()           |                           |\n|                        | labels()         | 返回结果有且只有一个label |\n|                        | nodes()          |                           |\n|                        | range()          |                           |\n|                        | subscript()      | 不支持                    |\n| 数学函数              | abs()            |                           |\n|                        | ceil()           |                           |\n|                        | floor()          |                           |\n|                        | rand()           |                           |\n|                        | round()          |                           |\n\n该部分内容属于文档中的“3.功能”章节，具体列出了支持的各种函数，包括聚合函数、列表函数和数学函数，描述了各自的功能及备注信息，便于用户理解和使用这些函数进行数据库操作和查询。"
            },
            {
                "content": "|                        | range()          |                           |\n|                        | subscript()      | 不支持                    |\n| 数学函数              | abs()            |                           |\n|                        | ceil()           |                           |\n|                        | floor()          |                           |\n|                        | rand()           |                           |\n|                        | round()          |                           |\n|                        | sign()           |                           |\n| 字符串函数            | /                |                           |\n表格内容描述: 该表格列出了不同类型的函数及其功能和备注信息，分为五类：谓词函数、标量函数、聚合函数、列表函数和数学函数。\n\n该片段位于文档的功能部分，具体涉及内置函数的分类和支持情况，包括数学函数和字符串函数。在此部分中，列出了不同类型的函数及其功能和备注信息，以帮助用户了解可用的函数操作。"
            },
            {
                "content": "1. 谓词函数包括：\n   - exists()：检查元素是否存在，功能正常。\n   - all()、any()、single()、none()：均不支持。\n\n2. 标量函数包括：\n   - id()、euid()、properties()、head()、last()、toBoolean()、toFloat()、toInteger()、toString()、type()、startnode()、endnode()、size()、length()、substring()、concat()：均功能正常。\n   - label()：为OpenCypher扩展方法。\n\n3. 聚合函数包括：\n   - avg()、collect()、count()、max()、min()、percentileCont()、percentileDisc()、stDev()、stDevP()、variance()、varianceP()、sum()：均功能正常。\n\n4. 列表函数包括：\n   - keys()、labels()（返回结果有且只有一个label）、nodes()、range()：均功能正常。\n   - subscript()：不支持。\n\n5. 数学函数包括：\n   - abs()、ceil()、floor()、rand()、round()、sign()：均功能正常。\n\n总结：该表格系统地列出了不同类型的函数，涵盖了其功能以及支持情况，提供了对各种操作的清晰概览。其中，多个谓词函数和列表函数存在不支持的情况，而大部分其他类型的函数则正常运作。\n### 3.2.谓词函数\n- exists()\n  判断一个顶点或边是否存在该字段。\n  **范围：** 整个实例。\n  **示例输入：**\n\n```\nMATCH (n)\nWHERE exists(n.born)\nRETURN n.name, n.born\n```\n\n**示例输出：**\n\n该块内容位于文档的第三部分，主要描述了TuGraph中不同类型的函数，包括谓词函数、标量函数、聚合函数、列表函数和数学函数。内容详细列出了每种函数的功能、支持状态及示例。"
            },
            {
                "content": "4. 列表函数包括：\n   - keys()、labels()（返回结果有且只有一个label）、nodes()、range()：均功能正常。\n   - subscript()：不支持。\n\n5. 数学函数包括：\n   - abs()、ceil()、floor()、rand()、round()、sign()：均功能正常。\n\n总结：该表格系统地列出了不同类型的函数，涵盖了其功能以及支持情况，提供了对各种操作的清晰概览。其中，多个谓词函数和列表函数存在不支持的情况，而大部分其他类型的函数则正常运作。\n### 3.2.谓词函数\n- exists()\n  判断一个顶点或边是否存在该字段。\n  **范围：** 整个实例。\n  **示例输入：**\n\n```\nMATCH (n)\nWHERE exists(n.born)\nRETURN n.name, n.born\n```\n\n**示例输出：**\n\n| exists(name) |\n| ------------ |\n| true         |\n表格内容描述: 表格只有一列，列名为 \"exists(name)\"，其含义是用于指示某个名称是否存在。该表格中的数据内容为一行，值为 \"true\"，表示该名称确实存在。整体来看，该表格确认了某一名称的存在状态。\n输出：\n### 3.3.标量函数\n- id()\n  获取顶点的ID。\n  **作用域:** 整个实例。\n  **示例输入:**\n\n```\nMATCH (a)\nRETURN id(a)\n```\n\n**示例输出:**\n\n| vid |\n| --- |\n| 1   |\n| 2   |\n| ... |\n表格内容描述: 此表格包含一列名为\"vid\"的数据。该列列出了不同的唯一识别码（ID），根据示例，包含ID 1、2等。这些ID可能代表某种实体或项目的标识符，尽管具体的背景信息未在表格中提供。整体来看，表格呈现了一系列的唯一识别码，可能用于数据管理或跟踪的目的。\n\n- properties()\n  获取一个包含节点或关系所有属性的映射。\n  **作用域:** 整个实例。\n  **示例输入:**\n\n```\nMATCH (n:person {name: 'Laurence Fishburne'})\nRETURN n\n```\n\n- head()\n  获取列表的第一个元素。\n  **作用域:** 整个实例。\n  **示例输入:**\n\n该段落位于文档的第三部分，主要介绍TuGraph-Cypher中的函数分类，包括谓词函数、标量函数和数学函数，详细说明了每种函数的功能、示例输入及输出，以及支持情况。它是整个文档中关于函数使用的重要组成部分，帮助用户理解如何在查询中有效地利用这些函数。"
            },
            {
                "content": "```\nMATCH (a)\nRETURN id(a)\n```\n\n**示例输出:**\n\n| vid |\n| --- |\n| 1   |\n| 2   |\n| ... |\n表格内容描述: 此表格包含一列名为\"vid\"的数据。该列列出了不同的唯一识别码（ID），根据示例，包含ID 1、2等。这些ID可能代表某种实体或项目的标识符，尽管具体的背景信息未在表格中提供。整体来看，表格呈现了一系列的唯一识别码，可能用于数据管理或跟踪的目的。\n\n- properties()\n  获取一个包含节点或关系所有属性的映射。\n  **作用域:** 整个实例。\n  **示例输入:**\n\n```\nMATCH (n:person {name: 'Laurence Fishburne'})\nRETURN n\n```\n\n- head()\n  获取列表的第一个元素。\n  **作用域:** 整个实例。\n  **示例输入:**\n\n```\nWITH ['one','two','three'] AS coll RETURN coll, head(coll)\n```\n\n**示例输出:**\n\n| coll                  | head(coll)    |\n| --------------------- | ------------- |\n| [\"one\",\"two\",\"three\"] | \"one\"         |\n表格内容描述: 该表格包含两列，分别为\"coll\"和\"head(coll)\"。第一列\"coll\"中包含一个数组，列出三个元素： \"one\"、 \"two\" 和 \"three\"。第二列\"head(coll)\"中的内容为\"one\"，这是数组\"coll\"中的第一个元素。整体来看，该表格展示了一个包含多个元素的数组及其首个元素的信息。\n\n- last()\n  获取列表的最后一个元素。\n  **作用域:** 整个实例。\n  **示例输入:**\n\n```\nWITH ['one','two','three'] AS coll RETURN coll, last(coll)\n```\n\n**示例输出:**\n\n此代码块位于文档的“3.3. 标量函数”部分，主要介绍了TuGraph中标量函数的使用，包括获取节点ID、属性和列表的首尾元素的功能示例及其输出结果。"
            },
            {
                "content": "```\nWITH ['one','two','three'] AS coll RETURN coll, head(coll)\n```\n\n**示例输出:**\n\n| coll                  | head(coll)    |\n| --------------------- | ------------- |\n| [\"one\",\"two\",\"three\"] | \"one\"         |\n表格内容描述: 该表格包含两列，分别为\"coll\"和\"head(coll)\"。第一列\"coll\"中包含一个数组，列出三个元素： \"one\"、 \"two\" 和 \"three\"。第二列\"head(coll)\"中的内容为\"one\"，这是数组\"coll\"中的第一个元素。整体来看，该表格展示了一个包含多个元素的数组及其首个元素的信息。\n\n- last()\n  获取列表的最后一个元素。\n  **作用域:** 整个实例。\n  **示例输入:**\n\n```\nWITH ['one','two','three'] AS coll RETURN coll, last(coll)\n```\n\n**示例输出:**\n\n| coll                  | last(coll)    |\n| --------------------- | ------------- |\n| [\"one\",\"two\",\"three\"] | \"three\"       |\n表格内容描述: 此表格包含两列：第一列为“coll”，表示一个包含字符串的数组；第二列为“last(coll)”，表示该数组中的最后一个元素。表格中只有一行数据，其中“coll”列的内容为一个数组包含“one”、“two”、“three”，而“last(coll)”列的值为“三”，即数组中的最后一个元素。总体来看，该表格展示了一个字符串数组及其最后一个元素的关系。\n\n- toFloat()\n  将整数或字符串值转换为浮点数。\n  **作用域:** 整个实例。\n  **示例输入:**\n\n```\nRETURN toFloat('11.5')\n```\n\n**示例输出:**\n\n| float |\n| ----- |\n| 11.5  |\n表格内容描述: 该表格只有一列，列名为 \"float\"。在该列中，有一个数值数据，即 11.5。整体来看，表格展示了一个浮点数值为 11.5。\n\n该段落位于TuGraph-Cypher文档的字符串函数部分，主要介绍了如何获取列表中的第一个和最后一个元素，以及将值转换为浮点数的相关示例及输出结果。通过示例代码和对应的输出表格，说明了这些函数的用法和返回的结果，帮助用户理解字符串处理和类型转换的功能。"
            },
            {
                "content": "- toFloat()\n  将整数或字符串值转换为浮点数。\n  **作用域:** 整个实例。\n  **示例输入:**\n\n```\nRETURN toFloat('11.5')\n```\n\n**示例输出:**\n\n| float |\n| ----- |\n| 11.5  |\n表格内容描述: 该表格只有一列，列名为 \"float\"。在该列中，有一个数值数据，即 11.5。整体来看，表格展示了一个浮点数值为 11.5。\n\n- toInteger()\n  将浮点或字符串值转换为整数值。\n  **作用域:** 整个实例。\n  **示例输入:**\n\n```\nRETURN toInteger('2.3') AS integer\n```\n\n**示例输出:**\n\n| integer |\n| ------- |\n| 2       |\n表格内容描述: 该表格包含一列，列名为“integer”。在该列中，有一个数据条目，值为2。整体来看，表格只是简单地列出了一个整数：2。\n\n- toString()\n  将整数、浮点数、布尔值转换为字符串。\n  **作用域:** 整个实例。\n  **示例输入:**\n\n```\nRETURN toString(2.3)\n```\n\n- type()\n  获取关系类型的字符串表示。\n  **作用域:** 整个实例。\n  **示例输入:**\n\n```\nMATCH (n)-[r]->()\nWHERE n.name = 'Laurence Fishburne'\nRETURN type(r)\n```\n\n**示例输出:**\n\n| type     |\n| -------- |\n| acted_in |\n| acted_in |\n表格内容描述: 该表格仅包含一列，列名为\"type\"。表格中的数据行包括两条记录，均为\"acted_in\"，表示在某个上下文中涉及到的都是“参与演出”的相关内容。总体来看，表格突出了参与演出的性别或项目类型，其内容相对单一，没有更多的多样性或变化。\n### 3.4. 聚合函数\n- avg()\n  返回一组数值的平均值。\n  **作用范围：** 整个实例。\n  **示例输入：**\n\n```\nMATCH (n:person)\nRETURN avg(n.born)\n```\n\n**示例输出：**\n\n该段内容主要介绍了TuGraph中的标量函数，涵盖了函数如toFloat、toInteger、toString和type的定义、作用域、示例输入和输出，以及相关的表格展示。这些函数用于数据类型转换和关系类型的获取，属于文档中功能完整列表的一部分。"
            },
            {
                "content": "```\nRETURN toString(2.3)\n```\n\n- type()\n  获取关系类型的字符串表示。\n  **作用域:** 整个实例。\n  **示例输入:**\n\n```\nMATCH (n)-[r]->()\nWHERE n.name = 'Laurence Fishburne'\nRETURN type(r)\n```\n\n**示例输出:**\n\n| type     |\n| -------- |\n| acted_in |\n| acted_in |\n表格内容描述: 该表格仅包含一列，列名为\"type\"。表格中的数据行包括两条记录，均为\"acted_in\"，表示在某个上下文中涉及到的都是“参与演出”的相关内容。总体来看，表格突出了参与演出的性别或项目类型，其内容相对单一，没有更多的多样性或变化。\n### 3.4. 聚合函数\n- avg()\n  返回一组数值的平均值。\n  **作用范围：** 整个实例。\n  **示例输入：**\n\n```\nMATCH (n:person)\nRETURN avg(n.born)\n```\n\n**示例输出：**\n\n| avg(n.born)        |\n| ------------------ |\n| 1869.2661654135338 |\n表格内容描述: 该表格只有一列，列名为“avg(n.born)”，其中记录的是平均出生人数的数值。该行数据显示，平均出生人数为1869.27（四舍五入至小数点后两位）。总体来看，表格提供的信息显示一个具体的统计数据，即某个时间段或区域内的平均出生人数。\n\n- collect()\n  返回一个包含表达式返回值的列表。\n  **作用范围：** 整个实例。\n  **示例输入：**\n\n```\nMATCH (n:person)\nRETURN collect(n.born)\n```\n\n**示例输出：**\n\n| collect(n.born) |\n| --------------- |\n| [1967,...]      |\n表格内容描述: \n\n该表格有一列，列名为“collect(n.born)”。该列中包含一个数组，表示年份信息，内容为“[1967,...]”，暗示该数据集合中可能包含从1967年开始的多个年份，但具体年份并未完全列出。\n\n总体来说，这个表格展示了一个数据集合，其中包含与出生年份相关的信息，起始年份为1967年。\n\n该片段位于文档的第3.3节和第3.4节之间，主要讨论了标量函数中的`toString()`函数及其使用示例，紧接着介绍了聚合函数中的`avg()`和`collect()`函数，具体展示了这些函数的作用和示例输入输出，强调了它们在数据处理和统计分析中的应用。"
            },
            {
                "content": "- collect()\n  返回一个包含表达式返回值的列表。\n  **作用范围：** 整个实例。\n  **示例输入：**\n\n```\nMATCH (n:person)\nRETURN collect(n.born)\n```\n\n**示例输出：**\n\n| collect(n.born) |\n| --------------- |\n| [1967,...]      |\n表格内容描述: \n\n该表格有一列，列名为“collect(n.born)”。该列中包含一个数组，表示年份信息，内容为“[1967,...]”，暗示该数据集合中可能包含从1967年开始的多个年份，但具体年份并未完全列出。\n\n总体来说，这个表格展示了一个数据集合，其中包含与出生年份相关的信息，起始年份为1967年。\n\n- count()\n  返回值或记录的数量。\n  **作用范围：** 整个实例。\n  **示例输入：**\n\n```\nMATCH (n {name: 'Laurence Fishburne'})-[]->(x)\nRETURN labels(n), n.born, count(*)\n```\n\n**示例输出：**\n\n| labels(n)  | n.born | count(*) |\n| ---------- | ------ | -------- |\n| [\"person\"] | 1961   | 3        |\n表格内容描述: 此表格包含三列，分别为“labels(n)”、“n.born”和“count(*)”。第一行的“labels(n)”列显示为“person”，表示相关数据涉及个体。第二列“n.born”记录为1961，显示与该标签相关的个体出生年份是1961年。第三列“count(*)”的值为3，表示在1961年出生的“person”标签下的个体数量为3个。\n\n总体而言，该表格总结了1961年出生的个体（标记为“person”）的数量，共有3名个体。\n\n- max()\n  返回一组值中的最大值。\n  **作用范围：** 整个实例。\n  **示例输入：**\n\n```\nMATCH (n:person)\nRETURN max(n.born)\n```\n\n**示例输出：**\n\n该块内容位于文档的第三部分“功能”，具体讲述了聚合函数的使用，包括`collect()`、`count()`以及`max()`等函数的功能描述、示例输入输出以及相应的数据表格展示，旨在提供关于如何在TuGraph中进行数据聚合的详细信息。"
            },
            {
                "content": "**示例输出：**\n\n| labels(n)  | n.born | count(*) |\n| ---------- | ------ | -------- |\n| [\"person\"] | 1961   | 3        |\n表格内容描述: 此表格包含三列，分别为“labels(n)”、“n.born”和“count(*)”。第一行的“labels(n)”列显示为“person”，表示相关数据涉及个体。第二列“n.born”记录为1961，显示与该标签相关的个体出生年份是1961年。第三列“count(*)”的值为3，表示在1961年出生的“person”标签下的个体数量为3个。\n\n总体而言，该表格总结了1961年出生的个体（标记为“person”）的数量，共有3名个体。\n\n- max()\n  返回一组值中的最大值。\n  **作用范围：** 整个实例。\n  **示例输入：**\n\n```\nMATCH (n:person)\nRETURN max(n.born)\n```\n\n**示例输出：**\n\n| max(n.born) |\n| ----------- |\n| 2003        |\n表格内容描述: 该表格包含一列，列名为“max(n.born)”。在该列中，记录的值为2003。这表示在相关数据集中，出生年份的最大值是2003年。总体来看，该表格提供了关于出生年份的最高值的简明信息。\n\n- min()\n  返回一组值中的最小值。\n  **作用范围：** 整个实例。\n  **示例输入：**\n\n```\nMATCH (n:person)\nRETURN min(n.born)\n```\n\n**示例输出：**\n\n| min(n.born) |\n| ----------- |\n| 1000        |\n表格内容描述: \n该表格包含一列，列名为“min(n.born)”。在该列中，唯一的一行数据为1000。\n\n总体来看，该表格提供了一个数字，该数字是某个数据集或统计信息中“n.born”的最小值，表示为1000。\n\n- percentileCont()\n  使用线性插值返回一组中的一个值的百分位。\n  **作用范围：** 整个实例。\n  **示例输入：**\n\n```\nMATCH (n:person)\nRETURN percentileCont(n.born, 0.4)\n```\n\n**示例输出：**\n\n该块内容位于文档的第三部分，详细介绍了TuGraph-Cypher中的聚合函数，重点阐述了`count()`、`max()`、`min()`和`percentileCont()`等函数的功能及示例，包括它们的作用范围、示例输入和输出。这些信息为用户提供了如何在查询中使用聚合函数的实用指导。"
            },
            {
                "content": "- min()\n  返回一组值中的最小值。\n  **作用范围：** 整个实例。\n  **示例输入：**\n\n```\nMATCH (n:person)\nRETURN min(n.born)\n```\n\n**示例输出：**\n\n| min(n.born) |\n| ----------- |\n| 1000        |\n表格内容描述: \n该表格包含一列，列名为“min(n.born)”。在该列中，唯一的一行数据为1000。\n\n总体来看，该表格提供了一个数字，该数字是某个数据集或统计信息中“n.born”的最小值，表示为1000。\n\n- percentileCont()\n  使用线性插值返回一组中的一个值的百分位。\n  **作用范围：** 整个实例。\n  **示例输入：**\n\n```\nMATCH (n:person)\nRETURN percentileCont(n.born, 0.4)\n```\n\n**示例输出：**\n\n| percentileCont(n.born, 0.4) |\n| --------------------------- |\n| 1953                        |\n表格内容描述：该表格包含一列，列名为“percentileCont(n.born, 0.4)”，表示在某统计分析中，出生人数的40百分位数值。表格中仅有一行数据，数值为1953。总体来看，该表格呈现了在研究对象中，40%出生人数的值为1953。\n\n- percentileDisc()\n  使用四舍五入方法返回一组中给定百分位的最近值。\n  **作用范围：** 整个实例。\n  **输出：** 给定值在一组中的百分位。\n  **示例输入：**\n\n```\nMATCH (n:person)\nRETURN percentileDisc(n.born, 0.5)\n```\n\n**示例输出：**\n\n| percentileDisc(n.age, 0.5) |\n| -------------------------- |\n| 1959                       |\n表格内容描述: \n该表格包含一列，列名为“percentileDisc(n.age, 0.5)”。在该列中，只有一行数据，值为1959。\n\n整体内容的概要总结: \n该表格显示了某项指标在50百分位数处的值为1959。\n\n该段落位于文档的第三部分“功能”下，具体聚焦于聚合函数的应用和示例，详细解释了最小值（min）、百分位数（percentileCont 和 percentileDisc）等函数的作用及其使用方法，包括示例输入和输出，帮助用户理解这些函数在数据统计中的实际应用。"
            },
            {
                "content": "- percentileDisc()\n  使用四舍五入方法返回一组中给定百分位的最近值。\n  **作用范围：** 整个实例。\n  **输出：** 给定值在一组中的百分位。\n  **示例输入：**\n\n```\nMATCH (n:person)\nRETURN percentileDisc(n.born, 0.5)\n```\n\n**示例输出：**\n\n| percentileDisc(n.age, 0.5) |\n| -------------------------- |\n| 1959                       |\n表格内容描述: \n该表格包含一列，列名为“percentileDisc(n.age, 0.5)”。在该列中，只有一行数据，值为1959。\n\n整体内容的概要总结: \n该表格显示了某项指标在50百分位数处的值为1959。\n\n- stDev()\n  返回在一组对总体样本的给定值的标准差。\n  **作用范围：** 整个实例。\n  **示例输入：**\n\n```\nMATCH (n)\nRETURN stDev(n.born)\n```\n\n**示例输出：**\n\n| stDev(n.born)      |\n| ------------------ |\n| 279.53117993401725 |\n表格内容描述: 该表格包含一列数据，列名为“stDev(n.born)”，表示新生儿数量的标准差。表格中的唯一数据项为279.53117993401725，表示新生儿数量的标准差值。整体来看，表格提供了关于新生儿数量波动程度的信息，标准差越大，说明新生儿数量的变动幅度越大。\n\n- stDevP()\n  返回在一组对整个总体的给定值的标准差。\n  **作用范围：** 整个实例。\n  **示例输入：**\n\n```\nMATCH (n)\nRETURN stDevP(n.born)\n```\n\n**示例输出：**\n\n| stDevP(n.born)     |\n| ------------------ |\n| 279.3209270423399  |\n表格内容描述: 该表格包含一列名为“stDevP(n.born)”的数据，表示在出生人数统计中的标准偏差。表格中只有一行数据，标准偏差的值为 279.3209270423399。整体来看，该表格提供了关于出生人数的标准偏差信息，反映了出生人数在统计上的变异程度。\n\n该片段位于文档的第3.4节，涵盖了TuGraph-Cypher中的聚合函数，具体介绍了percentileDisc、stDev和stDevP函数的功能、示例输入输出和表格结果。此部分对数据分析和统计有重要意义，特别是在处理与出生日期相关的数据时。"
            },
            {
                "content": "- stDevP()\n  返回在一组对整个总体的给定值的标准差。\n  **作用范围：** 整个实例。\n  **示例输入：**\n\n```\nMATCH (n)\nRETURN stDevP(n.born)\n```\n\n**示例输出：**\n\n| stDevP(n.born)     |\n| ------------------ |\n| 279.3209270423399  |\n表格内容描述: 该表格包含一列名为“stDevP(n.born)”的数据，表示在出生人数统计中的标准偏差。表格中只有一行数据，标准偏差的值为 279.3209270423399。整体来看，该表格提供了关于出生人数的标准偏差信息，反映了出生人数在统计上的变异程度。\n\n- variance()\n  返回在一组对总体样本的给定值的方差。\n  **作用范围：** 整个实例。\n  **示例输入：**\n\n```\nMATCH (n)\nRETURN variance(n.born)\n```\n\n**示例输出：**\n\n| variance(n.age)   |\n| ----------------- |\n| 78137.68055530392 |\n表格内容描述: 本表格包含一列数据，列名为“variance(n.age)”，表示的是年龄的方差。该列中仅有一行数据，其值为78137.68055530392。这表示在某个年龄相关数据集中的年龄分布存在较大的变异性。整体上，该数据展现了年龄的波动程度，方差越大，说明年龄的数据分布越分散。\n\n- varianceP()\n  返回在一组对整个总体的给定值的方差。\n  **作用范围：** 整个实例。\n  **示例输入：**\n\n```\nMATCH (n)\nRETURN varianceP(n.born)\n```\n\n**示例输出：**\n\n| varianceP(n.age)  |\n| ----------------- |\n| 78020.18028379219 |\n表格内容描述: 该表格包含一列名为“varianceP(n.age)”，表示某项数据的方差。根据表格中的数据，方差值为78020.18028379219。整体来看，表格仅提供了一个数据点，显示了该变量的方差情况。\n\n- sum()\n  返回一组数值的总和。\n  **作用范围：** 整个实例。\n  **示例输入：**\n\n该段落位于文档的“3.功能”部分，具体描述了几种统计函数，包括标准差（stDevP）、方差（variance 和 varianceP）以及总和（sum）的用法和示例。提供了示例输入和输出，帮助用户理解这些函数在数据库查询中的应用。"
            },
            {
                "content": "- varianceP()\n  返回在一组对整个总体的给定值的方差。\n  **作用范围：** 整个实例。\n  **示例输入：**\n\n```\nMATCH (n)\nRETURN varianceP(n.born)\n```\n\n**示例输出：**\n\n| varianceP(n.age)  |\n| ----------------- |\n| 78020.18028379219 |\n表格内容描述: 该表格包含一列名为“varianceP(n.age)”，表示某项数据的方差。根据表格中的数据，方差值为78020.18028379219。整体来看，表格仅提供了一个数据点，显示了该变量的方差情况。\n\n- sum()\n  返回一组数值的总和。\n  **作用范围：** 整个实例。\n  **示例输入：**\n\n```\nMATCH (n:person)\nRETURN sum(n.born)\n```\n\n**示例输出：**\n\n| sum(n.born) |\n| ----------- |\n| 1243062     |\n表格内容描述: 该表格只有一列，其列名为“sum(n.born)”。表格中只有一行数据，数值为1243062，表示出生人数的总和。整体来看，此表格总结了某一时间段内的出生总人数。\n### 3.5. 列表函数:\n- keys()\n  获取某个顶点的字段名称。\n  **范围:** 整个实例。\n  **示例输入:**\n\n```\nMATCH (a)\nRETURN keys(a) LIMIT 1\n```\n\n**示例输出:**\n\n| keys(a)               |\n| --------------------- |\n| [\"name\",\"age\",\"eyes\"] |\n表格内容描述: 该表格包含一个列名为“keys(a)”。在这一列中，列出了三个字符串元素：“name”、“age”和“eyes”。这些元素可能代表某个实体的属性或特征。总体来看，这个表格简单地列出了与某个对象相关的关键属性。\n\n- labels()/label()\n  返回包含节点、关系或映射的所有属性名称的字符串表示的列表。\n  **范围:** 整个实例。\n  **示例输入:**\n\n```\nMATCH (a)\nRETURN labels(a) LIMIT 1\n```\n\n**示例输出:**\n\n该块内容位于文档的“功能”部分，具体讨论了聚合函数的使用，包括方差函数 `varianceP()` 和总和函数 `sum()`，以及列表函数的相关内容，如获取字段名称的 `keys()` 和获取属性名称的 `labels()`。这部分旨在解释如何在TuGraph中进行数据分析和信息检索。"
            },
            {
                "content": "```\nMATCH (a)\nRETURN keys(a) LIMIT 1\n```\n\n**示例输出:**\n\n| keys(a)               |\n| --------------------- |\n| [\"name\",\"age\",\"eyes\"] |\n表格内容描述: 该表格包含一个列名为“keys(a)”。在这一列中，列出了三个字符串元素：“name”、“age”和“eyes”。这些元素可能代表某个实体的属性或特征。总体来看，这个表格简单地列出了与某个对象相关的关键属性。\n\n- labels()/label()\n  返回包含节点、关系或映射的所有属性名称的字符串表示的列表。\n  **范围:** 整个实例。\n  **示例输入:**\n\n```\nMATCH (a)\nRETURN labels(a) LIMIT 1\n```\n\n**示例输出:**\n\n| labels                 |\n| ---------------------- |\n| [\"Person\"]             |\n表格内容描述: \n\n该表格包含一列，列名为“labels”。在这一列中，有一行数据，内容为一个包含字符串“Person”的数组。整体来看，该表格只记录了一种标签，表示与“Person”相关的信息。\n\n- nodes()\n\n  获取一个路径的顶点ID。\n\n  **范围:** 整个实例。\n\n  **示例输入:**\n\n  ```\n  MATCH p = (from {name: 'Bob'})-[*1..]->(to {name: 'Alice\"})\n  RETURN nodes(p)\n  ```\n\n  **示例输出:**\n\n  | nodes(p)       |\n  | -------------- |\n  | [0, 1, 10, 12] |\n### 3.6.数学函数\n- abs()\n  获取某些数据的绝对值。\n  **范围：** 整个实例。\n  **示例输入：**\n\n```\nMATCH (a:person {name: 'Laurence Fishburne'}),(e:person {name: 'Carrie-Anne Moss'})\nRETURN a.born, e.born, abs(a.born-e.born)\n```\n\n**示例输出：**\n\n该内容块位于文档的第三部分，专注于TuGraph-Cypher的列表函数，具体介绍了获取节点属性名称和路径顶点ID的查询示例及其输出结果。"
            },
            {
                "content": "- nodes()\n\n  获取一个路径的顶点ID。\n\n  **范围:** 整个实例。\n\n  **示例输入:**\n\n  ```\n  MATCH p = (from {name: 'Bob'})-[*1..]->(to {name: 'Alice\"})\n  RETURN nodes(p)\n  ```\n\n  **示例输出:**\n\n  | nodes(p)       |\n  | -------------- |\n  | [0, 1, 10, 12] |\n### 3.6.数学函数\n- abs()\n  获取某些数据的绝对值。\n  **范围：** 整个实例。\n  **示例输入：**\n\n```\nMATCH (a:person {name: 'Laurence Fishburne'}),(e:person {name: 'Carrie-Anne Moss'})\nRETURN a.born, e.born, abs(a.born-e.born)\n```\n\n**示例输出：**\n\n  | a.born | e.born | abs(a.born - e.born) |\n  |--------|--------|-----------------------|\n  | 1961   | 1967   | 6                     |\n\n- ceil()\n  返回大于或等于给定数字并且等于数学整数的最小浮点数。\n  **范围：** 整个实例。\n  **示例输入：**\n\n```\nRETURN ceil(0.1)\n```\n\n**示例输出：**\n\n| ceil(0.1) |\n| --------- |\n| 1.0       |\n表格内容描述: 表格包含一列，列名为 \"ceil(0.1)\"，表示对数值0.1进行向上取整的结果。该列中只有一行数据，其值为1.0。这表示将0.1向上取整后得到的值是1.0。整体上，该表格展示了对数值0.1使用向上取整函数得到的结果。\n\n- floor()\n  获取小于或等于给定数字并且等于数学整数的最大浮点数。\n  **范围：** 整个实例。\n  **示例输入：**\n\n```\nRETURN floor(0.9)\n```\n\n**示例输出：**\n\n该chunk位于文档的第3.6节，介绍了TuGraph-Cypher中的数学函数，包括获取路径顶点ID的函数nodes()以及常用的数学函数如abs()、ceil()和floor()，并提供了示例输入和输出，以便展示这些函数的具体用法和结果。"
            },
            {
                "content": "| a.born | e.born | abs(a.born - e.born) |\n  |--------|--------|-----------------------|\n  | 1961   | 1967   | 6                     |\n\n- ceil()\n  返回大于或等于给定数字并且等于数学整数的最小浮点数。\n  **范围：** 整个实例。\n  **示例输入：**\n\n```\nRETURN ceil(0.1)\n```\n\n**示例输出：**\n\n| ceil(0.1) |\n| --------- |\n| 1.0       |\n表格内容描述: 表格包含一列，列名为 \"ceil(0.1)\"，表示对数值0.1进行向上取整的结果。该列中只有一行数据，其值为1.0。这表示将0.1向上取整后得到的值是1.0。整体上，该表格展示了对数值0.1使用向上取整函数得到的结果。\n\n- floor()\n  获取小于或等于给定数字并且等于数学整数的最大浮点数。\n  **范围：** 整个实例。\n  **示例输入：**\n\n```\nRETURN floor(0.9)\n```\n\n**示例输出：**\n\n| floor(0.9) |\n| ---------- |\n| 0.0        |\n表格内容描述: 该表格包含一列，列名为“floor(0.9)”。在这一列中，只有一行数据，数值为0.0。整体来看，这张表格的内容表明对0.9进行向下取整计算后得到的结果是0.0。\n\n- round()\n  返回四舍五入到最接近的整数的数字值。\n  **范围：** 整个实例。\n  **示例输入：**\n\n```\nRETURN round(3.141592)\n```\n\n**示例输出：**\n\n| round |\n| ----- |\n| 3     |\n表格内容描述: 该表格包含一列，列名为“round”，用于表示回合数。在该列中，唯一的数据项为3，表示这是第三回合。总体来说，表格简单明了，仅记录了一个回合数的数值。\n\n- rand()\n  返回一个随机浮点数，范围从 0（包含）到 1（不包含）。\n  **范围：** 整个实例。\n  **示例输入：**\n\n```\nRETURN rand()\n```\n\n**示例输出：**\n\n该片段位于文档的第三部分，主要介绍数学函数的使用，包括绝对值、向上取整、向下取整、四舍五入和生成随机数的功能及示例，提供了示例输入和相应输出的表格，详细说明了每个函数的作用和如何在TuGraph-Cypher中使用。"
            },
            {
                "content": "```\nRETURN floor(0.9)\n```\n\n**示例输出：**\n\n| floor(0.9) |\n| ---------- |\n| 0.0        |\n表格内容描述: 该表格包含一列，列名为“floor(0.9)”。在这一列中，只有一行数据，数值为0.0。整体来看，这张表格的内容表明对0.9进行向下取整计算后得到的结果是0.0。\n\n- round()\n  返回四舍五入到最接近的整数的数字值。\n  **范围：** 整个实例。\n  **示例输入：**\n\n```\nRETURN round(3.141592)\n```\n\n**示例输出：**\n\n| round |\n| ----- |\n| 3     |\n表格内容描述: 该表格包含一列，列名为“round”，用于表示回合数。在该列中，唯一的数据项为3，表示这是第三回合。总体来说，表格简单明了，仅记录了一个回合数的数值。\n\n- rand()\n  返回一个随机浮点数，范围从 0（包含）到 1（不包含）。\n  **范围：** 整个实例。\n  **示例输入：**\n\n```\nRETURN rand()\n```\n\n**示例输出：**\n\n| rand()             |\n| ------------------ |\n| 0.9797131960534085 |\n表格内容描述: 此表格包含一列名为 \"rand()\"，该列展示了一个随机生成的数值。表格的唯一数据行包含一个值：0.9797131960534085。整体来看，该表格提供了一个随机数的示例。\n\n- sign()\n  获取给定数字的符号：如果数字为 0，则为 0；如果是任何负数，则为 -1；如果是任何正数，则为 1。\n  **范围：** 整个实例。\n  **示例输入：**\n\n```\nRETURN sign(-17), sign(0.1)\n```\n\n**示例输出：**\n\n| sign(-17) | sign(0.1) |\n| --------- | --------- |\n| -1        | 1         |\n表格内容描述: 该表格包含两个列名，分别为 \"sign(-17)\" 和 \"sign(0.1)\"。第一行的数据为 -1，表示负数 -17 的符号；第二行的数据为 1，表示正数 0.1 的符号。总体来看，该表格用于表示两个数的符号情况，其中 -17 为负数，而 0.1 为正数。\n\n该块内容位于文档的第三部分“功能”，具体讨论了数学函数的使用示例，包括对浮点数进行下取整、四舍五入、生成随机数以及获取数字符号的相关输入和输出实用示例。这些示例有助于用户理解如何在TuGraph中使用数学函数进行数据处理和计算。"
            },
            {
                "content": "- sign()\n  获取给定数字的符号：如果数字为 0，则为 0；如果是任何负数，则为 -1；如果是任何正数，则为 1。\n  **范围：** 整个实例。\n  **示例输入：**\n\n```\nRETURN sign(-17), sign(0.1)\n```\n\n**示例输出：**\n\n| sign(-17) | sign(0.1) |\n| --------- | --------- |\n| -1        | 1         |\n表格内容描述: 该表格包含两个列名，分别为 \"sign(-17)\" 和 \"sign(0.1)\"。第一行的数据为 -1，表示负数 -17 的符号；第二行的数据为 1，表示正数 0.1 的符号。总体来看，该表格用于表示两个数的符号情况，其中 -17 为负数，而 0.1 为正数。\n\nTuGraph 查询语言与 OpenCypher 的不同点如下：\n\n- 标签数量\n  - TuGraph: 每个节点/关系必须有且仅有一个标签。因此如果没有标签会出现错误，如果有多个标签将选择第一个标签作为标签。\n  - OpenCypher: 一个节点/关系可以有 0 到多个标签。\n- 模式。\n  - TuGraph: TuGraph 具有强模式。\n  - OpenCypher: 无模式。\n## 4.附录1. 语法扩充及不同\nTuGraph查询语言与OpenCypher的不同点如下：\n\n- 标签数量\n  - TuGraph: 每个节点/关系必须具有一个且仅有一个标签。因此当没有标签时会出现错误，如果有多个标签，将选择第一个标签作为标签。\n  - OpenCypher: 一个节点/关系可以拥有0到多个标签。\n- 模式。\n  - TuGraph: TuGraph具有强模式\n  - OpenCypher: 无模式\n## 5.附录2. 内置procedures列表\n### 5.1.procedures样例\n* dbms.procedures()\n列出所有可用的过程。\n\n  **范围：** 整个实例。\n\n  **输出：** 一个包含 {`signature`, `name`} 的列表。\n\n  **示例输入：**\n\n  ```\n  CALL dbms.procedures()\n  ```\n\n  **示例输出：**\n\n该片段位于文档的函数章节，具体介绍了`sign()`函数的功能、示例输入输出及其详细说明。此外，该部分还提到了TuGraph与OpenCypher之间的区别，特别是在标签数量和模式方面的不同，后续内容转向内置程序（procedures）列表的示例和说明。"
            },
            {
                "content": "- 标签数量\n  - TuGraph: 每个节点/关系必须具有一个且仅有一个标签。因此当没有标签时会出现错误，如果有多个标签，将选择第一个标签作为标签。\n  - OpenCypher: 一个节点/关系可以拥有0到多个标签。\n- 模式。\n  - TuGraph: TuGraph具有强模式\n  - OpenCypher: 无模式\n## 5.附录2. 内置procedures列表\n### 5.1.procedures样例\n* dbms.procedures()\n列出所有可用的过程。\n\n  **范围：** 整个实例。\n\n  **输出：** 一个包含 {`signature`, `name`} 的列表。\n\n  **示例输入：**\n\n  ```\n  CALL dbms.procedures()\n  ```\n\n  **示例输出：**\n\n  | signature                        | name         |\n  | ---------------------------------------------------- | -------------------- |\n  | db.vertexLabels() :: (label::STRING)               | db.vertexLabels        |\n  | db.edgeLabels() :: (edgeLabels::STRING) | db.edgeLabels |\n  | db.indexes() :: (index::LIST)            | db.indexes       |\n  | ...                          | ...          |\n输出：\n* db.subgraph()\n**范围：** 整个实例。\n\n  **参数：**\n\n该段落位于文档的附录部分，主要讨论TuGraph查询语言与OpenCypher的不同之处，特别是在标签数量和模式的定义上。接下来将介绍内置的procedures及其示例，提供用户对使用和管理数据库过程的指导。"
            },
            {
                "content": "**示例输入：**\n\n  ```\n  CALL dbms.procedures()\n  ```\n\n  **示例输出：**\n\n  | signature                        | name         |\n  | ---------------------------------------------------- | -------------------- |\n  | db.vertexLabels() :: (label::STRING)               | db.vertexLabels        |\n  | db.edgeLabels() :: (edgeLabels::STRING) | db.edgeLabels |\n  | db.indexes() :: (index::LIST)            | db.indexes       |\n  | ...                          | ...          |\n输出：\n* db.subgraph()\n**范围：** 整个实例。\n\n  **参数：**\n\n  | 参数       | 参数类型       | 描述                                                             |\n  | ---------- | -------------- | ----------------------------------------------------------------- |\n  | vids       | 列表           | 顶点 ID 的列表                                                    |\n\n  **输出：**\n\n  获取一个包含所有节点和关系属性的 JSON。\n\n  **示例输入：**\n\n  ```\n  CALL db.subgraph([3937,4126,4066,4010])\n  ```\n\n  **示例输出**\n\n该片段位于文档的第五部分\"附录2. 内置procedures列表\"中，主要介绍了TuGraph的内置过程及其示例输入和输出。具体内容涉及列出所有可用的过程及其参数和输出格式，包括特定的过程示例，如`db.vertexLabels()`和`db.subgraph()`的使用。"
            },
            {
                "content": "**示例输出**\n\n  | 子图       |\n  | ---------- |\n  | {\"nodes\":[{\"identity\":3937,\"label\":\"movie\",\"properties\":{\"duration\":136,\"id\":1,\"poster_image\":\"http://image.tmdb.org/t/p/w185/gynBNzwyaHKtXqlEKKLioNkjKgN.jpg\",\"rated\":\"R\",\"summary\":\"Thomas A. Anderson 是一个过着双重生活的人。白天他是一名普通的计算机程序员，夜晚则是一个恶意黑客，名叫 Neo，当他接触到传奇计算机黑客 Morpheus 时，发现自己成为了警察的目标，Morpheus 向他揭示了我们现实的惊人真相。\",\"tagline\":\"欢迎来到真实世界。\",\"title\":\"黑客帝国\"}},{\"identity\":4010,\"label\":\"user\",\"properties\":{\"id\":44,\"login\":\"Howard\"}},{\"identity\":4066,\"label\":\"user\",\"properties\":{\"id\":202,\"login\":\"Enoch\"}},{\"identity\":4126,\"label\":\"user\",\"properties\":{\"id\":464,\"login\":\"Wilburn\"}}],\"relationships\":[{\"dst\":4126,\"forward\":true,\"identity\":0,\"label\":\"is_friend\",\"label_id\":3,\"src\":4010,\"temporal_id\":0},{\"dst\":4010,\"forward\":true,\"identity\":0,\"label\":\"is_friend\",\"label_id\":3,\"src\":4066,\"temporal_id\":0},{\"dst\":4066,\"forward\":true,\"identity\":0,\"label\":\"is_friend\",\"label_id\":3,\"src\":4126,\"temporal_id\":0}]} |\n* db.vertexLabels()\n列出所有可用的顶点标签。\n\n  **范围:** 整个实例。\n\n  **输出:** {`name`} 的列表。\n\n该内容位于TuGraph查询语言文档中的附录部分，具体涉及到`db.subgraph()`过程的示例输出，展示了查询返回的子图结构，包括节点和关系的详细信息。此外，还包含了`db.vertexLabels()`过程的介绍，说明如何列出所有可用的顶点标签及其输出格式。"
            },
            {
                "content": "**范围:** 整个实例。\n\n  **输出:** {`name`} 的列表。\n\n  **示例输入:**\n\n  ```\n  CALL db.vertexLabels()\n  ```\n  **示例输出:**\n\n    | 标签     |\n    | -------- |\n    | 类型     |\n    | 关键词   |\n    | 电影     |\n    | ...      |\n输出:\n* db.edgeLabels()\n列出所有可用的边标签。\n\n  **范围：** 整个实例。\n\n  **输出：** 一个 {边标签} 的列表。\n\n  **示例输入：**\n\n  ```\n  CALL db.edgeLabels()\n  ```\n\n  **示例输出：**\n\n  | relationshipType |\n  | ---------------- |\n  | acted_in     |\n  | directed     |\n  | ...          |\n输出：\n* db.createVertexLabel(label_name, primary_field, field_spec...)\n创建一个顶点标签。\n\n  **范围:** 整个实例。\n\n  **参数:**\n\n  | 参数         | 参数类型       | 描述                      |\n  | ------------ | -------------- | ------------------------- |\n  | label_name   | 字符串        | 顶点标签的名称             |\n  | primary_field | 字符串       | 顶点标签的主字段           |\n  | field_spec   | 列表          | 字段的规范                 |\n\n   其中每个 `field_spec` 是一个字符串列表，格式为 `[field_name, field_type, true]`，其中 true 仅针对可选字段指定。\n\n    **输出:** 如果成功，将返回成功消息。\n\n    **示例输入:**\n\n该部分内容位于文档的第五章“附录2. 内置procedures列表”中，具体介绍了TuGraph中可用的边标签和顶点标签的创建方法，以及相关的输入输出示例，帮助用户理解如何管理和操作标签。"
            },
            {
                "content": "**范围:** 整个实例。\n\n  **参数:**\n\n  | 参数         | 参数类型       | 描述                      |\n  | ------------ | -------------- | ------------------------- |\n  | label_name   | 字符串        | 顶点标签的名称             |\n  | primary_field | 字符串       | 顶点标签的主字段           |\n  | field_spec   | 列表          | 字段的规范                 |\n\n   其中每个 `field_spec` 是一个字符串列表，格式为 `[field_name, field_type, true]`，其中 true 仅针对可选字段指定。\n\n    **输出:** 如果成功，将返回成功消息。\n\n    **示例输入:**\n\n    ```\n    CALL db.createVertexLabel('Person', 'id', 'id', 'int64', false, 'name', 'string', true)\n    ```\n\n    **示例输出:**\n\n    ```\n    添加标签 [Person]\n    ```\n* db.getLabelSchema(label_type, label_name)\n获取子图中标签的 schema 定义。\n\n  **范围:** 子图，如 REST 或 RPC 请求中的 `graph` 参数所指定。\n\n  **参数:**\n\n  | 参数         | 参数类型     | 描述                     |\n  | ------------ | ------------ | ------------------------ |\n  | label_type   | 字符串       | 'vertex' 或 'edge'       |\n  | label_name   | 字符串       | 标签的名称               |\n\n  **输出:** 标签规格的列表，其中每个元素是以下字段的列表：\n\n该段落位于文档的第五部分“附录2. 内置procedures列表”，主要介绍了与标签相关的内置过程，包括如何创建顶点标签及获取标签的schema定义。这些内容为用户提供了关于如何在TuGraph中管理节点标签的具体操作指南。"
            },
            {
                "content": "**示例输出:**\n\n    ```\n    添加标签 [Person]\n    ```\n* db.getLabelSchema(label_type, label_name)\n获取子图中标签的 schema 定义。\n\n  **范围:** 子图，如 REST 或 RPC 请求中的 `graph` 参数所指定。\n\n  **参数:**\n\n  | 参数         | 参数类型     | 描述                     |\n  | ------------ | ------------ | ------------------------ |\n  | label_type   | 字符串       | 'vertex' 或 'edge'       |\n  | label_name   | 字符串       | 标签的名称               |\n\n  **输出:** 标签规格的列表，其中每个元素是以下字段的列表：\n\n  | 字段名称     | 字段类型     | 描述                     |\n  | ------------ | ------------ | ------------------------ |\n  | name         | 字符串       | 字段的名称               |\n  | type         | 字符串       | 字段的类型               |\n  | optional     | 布尔值       | 字段是否可选             |\n\n  **示例输入:**\n\n  ```\n  CALL db.getLabelSchema('vertex', 'Person')\n  ```\n\n  **示例输出:**\n\n该段落位于文档的第5章附录部分，具体讲述了TuGraph中的内置过程和函数，其中包含了如何获取子图中特定标签的schema定义以及相应的输入输出示例。这部分内容有助于用户理解和使用标签的结构及属性，以便在进行数据库操作时能够准确处理标签信息。"
            },
            {
                "content": "**输出:** 标签规格的列表，其中每个元素是以下字段的列表：\n\n  | 字段名称     | 字段类型     | 描述                     |\n  | ------------ | ------------ | ------------------------ |\n  | name         | 字符串       | 字段的名称               |\n  | type         | 字符串       | 字段的类型               |\n  | optional     | 布尔值       | 字段是否可选             |\n\n  **示例输入:**\n\n  ```\n  CALL db.getLabelSchema('vertex', 'Person')\n  ```\n\n  **示例输出:**\n\n  | name         | type   | optional |\n  | ------------ | ------ | -------- |\n  | id           | INT32  | false    |\n  | born         | INT32  | true     |\n  | name         | STRING | true     |\n  | poster_image | STRING | true     |\n* db.createLabel(label_type, label_name, extra, field_spec...)\n创建一个顶点或边的标签。\n\n  **参数:**\n\n该内容位于文档的“5.1.procedures样例”部分，具体介绍了如何获取标签的schema定义和创建标签的相关操作，包括输入示例和输出格式。整体上，这部分内容聚焦于数据库标签管理的具体功能和参数说明。"
            },
            {
                "content": "**示例输入:**\n\n  ```\n  CALL db.getLabelSchema('vertex', 'Person')\n  ```\n\n  **示例输出:**\n\n  | name         | type   | optional |\n  | ------------ | ------ | -------- |\n  | id           | INT32  | false    |\n  | born         | INT32  | true     |\n  | name         | STRING | true     |\n  | poster_image | STRING | true     |\n* db.createLabel(label_type, label_name, extra, field_spec...)\n创建一个顶点或边的标签。\n\n  **参数:**\n\n  | 参数        | 参数类型      | 描述                      |\n  | ---------- | -------------- | ------------------------- |\n  | label_type | 字符串     | 'vertex' 或 'edge' |\n  | label_name | 字符串     | 标签的名称                |\n  | extra      | 字符串      | 对于边，表示约束；对于顶点，表示主要属性 |\n  | field_spec | 列表       | 字段规格                  |\n\n    其中每个 `field_spec` 是一个字符串列表，形式为 `[field_name, field_type, optional]`。\n    对于边，`extra` 应该是一个 JSON 数组字符串，像这样 `[[\"label1\",\"label2\"], [\"label3\",\"label4\"]]`，如果边没有约束，给一个空的 JSON 数组，像这样 `[]`。\n\n  **输出:**\n\n  如果成功，它返回一个成功消息。\n\n  **示例输入:**\n\n该段落位于文档中关于TuGraph-Cypher操作命令的部分，具体讨论了创建标签的相关命令和参数设置，包括如何定义顶点或边的标签及其属性。它的上下文涉及标签的获取和创建，增强了用户对数据模型的理解。"
            },
            {
                "content": "其中每个 `field_spec` 是一个字符串列表，形式为 `[field_name, field_type, optional]`。\n    对于边，`extra` 应该是一个 JSON 数组字符串，像这样 `[[\"label1\",\"label2\"], [\"label3\",\"label4\"]]`，如果边没有约束，给一个空的 JSON 数组，像这样 `[]`。\n\n  **输出:**\n\n  如果成功，它返回一个成功消息。\n\n  **示例输入:**\n\n  ```\n  CALL db.createLabel('vertex', 'new_label', 'id', ['id','int32',false], ['name','string', true]);\n  CALL db.createLabel('edge', 'new_edge', '[[\"id1\",\"id2\"]]', ['id','int32',false], ['name', 'string', true]);\n  ```\n\n  **示例输出:**\n\n  ```\n  顶点标签 [new_label] 成功添加.\n  ```\n* db.deleteLabel(label_type, label_name)\n删除一个顶点或边的标签。\n\n  **参数:**\n\n  | 参数        | 参数类型  | 描述                          |\n  | ---------- | -------------- | ------------------------- |\n  | label_type | string     | 可以是 'vertex' 或 'edge' |\n  | label_name | string     | 标签的名称                  |\n\n  **输出:**\n\n  | 字段名称   | 字段类型  | 描述                           |\n  | ---------- | ---------- | ------------------------------ |\n  | affected   | integer    | 被删除的顶点/边的数量        |\n\n  **示例输入:**\n\n该部分内容位于文档关于创建和删除标签的章节，详细描述了如何创建顶点或边的标签，包括字段规范和约束，以及成功执行示例输入和输出。此内容紧接在对创建标签功能的介绍之后，说明了如何管理标签的生命周期。"
            },
            {
                "content": "**参数:**\n\n  | 参数        | 参数类型  | 描述                          |\n  | ---------- | -------------- | ------------------------- |\n  | label_type | string     | 可以是 'vertex' 或 'edge' |\n  | label_name | string     | 标签的名称                  |\n\n  **输出:**\n\n  | 字段名称   | 字段类型  | 描述                           |\n  | ---------- | ---------- | ------------------------------ |\n  | affected   | integer    | 被删除的顶点/边的数量        |\n\n  **示例输入:**\n\n  ```\n  CALL db.deleteLabel('vertex', 'Person')\n  ```\n\n  **示例输出:**\n\n  | affected |\n  | -------- |\n  | 1024     |\n* db.alterLabelDelFields(label_type, label_name, field_names)\n删除指定字段从标签中。\n\n  **参数：**\n\n  | 参数        | 参数类型       | 描述                          |\n  | ----------- | --------------- | ----------------------------- |\n  | label_type  | 字符串       | 可以是 'vertex' 或 'edge'      |\n  | label_name  | 字符串       | 标签的名称                     |\n  | field_names | 字符串列表    | 要删除的字段名称               |\n\n  **输出：**\n\n该段落位于文档的“内置procedures列表”部分，具体描述了`db.deleteLabel`和`db.alterLabelDelFields`两个过程的参数、输出和示例。它们分别用于删除标签和从标签中删除指定字段，提供了有关如何在TuGraph数据库中管理标签的具体信息。"
            },
            {
                "content": "```\n  CALL db.deleteLabel('vertex', 'Person')\n  ```\n\n  **示例输出:**\n\n  | affected |\n  | -------- |\n  | 1024     |\n* db.alterLabelDelFields(label_type, label_name, field_names)\n删除指定字段从标签中。\n\n  **参数：**\n\n  | 参数        | 参数类型       | 描述                          |\n  | ----------- | --------------- | ----------------------------- |\n  | label_type  | 字符串       | 可以是 'vertex' 或 'edge'      |\n  | label_name  | 字符串       | 标签的名称                     |\n  | field_names | 字符串列表    | 要删除的字段名称               |\n\n  **输出：**\n\n  | 字段名称   | 字段类型   | 描述                            |\n  | ---------- | ---------- | -------------------------------- |\n  | affected   | 整数      | 修改的顶点/边的数量              |\n\n  **示例输入：**\n\n  ```\n  CALL db.alterLabelDelFields('vertex', 'Person', ['name', 'image'])\n  ```\n\n  **示例输出：**\n\n  | affected |\n  | -------- |\n  | 1024     |\n* db.alterLabelAddFields(label_type, label_name, field_value_spec...)\n向标签添加指定字段。\n\n  **参数:**\n\n该块内容位于文档的第五部分，专门讨论与标签管理相关的操作，包括删除标签、删除标签字段以及添加字段等。具体示例展示了如何使用相关的数据库命令进行这些操作及其预期输出。"
            },
            {
                "content": "**输出：**\n\n  | 字段名称   | 字段类型   | 描述                            |\n  | ---------- | ---------- | -------------------------------- |\n  | affected   | 整数      | 修改的顶点/边的数量              |\n\n  **示例输入：**\n\n  ```\n  CALL db.alterLabelDelFields('vertex', 'Person', ['name', 'image'])\n  ```\n\n  **示例输出：**\n\n  | affected |\n  | -------- |\n  | 1024     |\n* db.alterLabelAddFields(label_type, label_name, field_value_spec...)\n向标签添加指定字段。\n\n  **参数:**\n\n  | 参数         | 参数类型    | 描述                       |\n  | ------------ | ----------- | -------------------------- |\n  | label_type   | 字符串      | 可以是 'vertex' 或 'edge'  |\n  | label_name   | 字符串      | 标签的名称                 |\n  | field_value_spec | 列表    | 字段的规范                 |\n\n    其中每个 `field_value_spec` 是一个字符串列表，形式为 `[field_name, field_type, field_value, optional]`，其中：`field_value` 是字段的默认值。\n\n  **输出:**\n\n  | 字段名称     | 字段类型    | 描述                         |\n  | ------------ | ----------- | ---------------------------- |\n  | affected     | 整数        | 修改的顶点/边的数量         |\n\n  **示例输入:**\n\n该内容位于文档的第五部分“附录2. 内置procedures列表”中，详细介绍了 `db.alterLabelDelFields` 和 `db.alterLabelAddFields` 这两个过程的功能、参数描述及其输入输出示例，属于数据库操作相关的内容。"
            },
            {
                "content": "其中每个 `field_value_spec` 是一个字符串列表，形式为 `[field_name, field_type, field_value, optional]`，其中：`field_value` 是字段的默认值。\n\n  **输出:**\n\n  | 字段名称     | 字段类型    | 描述                         |\n  | ------------ | ----------- | ---------------------------- |\n  | affected     | 整数        | 修改的顶点/边的数量         |\n\n  **示例输入:**\n\n  ```\n  CALL db.alterLabelAddFields(\n  'vertex',\n  'new_label',\n  ['birth_date', DATE, '', true],\n  ['img', BLOB, '', true])\n  ```\n\n  **示例输出:**\n\n  | affected     |\n  | ------------ |\n  | 1024         |\n* db.alterLabelModFields(label_type, label_name, field_spec...)\n修改标签中的指定字段。\n\n  **参数:**\n\n  | 参数        | 参数类型     | 描述                     |\n  | ---------- | -------------- | ------------------------- |\n  | label_type | 字符串       | 'vertex' 或 'edge'       |\n  | label_name | 字符串       | 标签的名称               |\n  | field_spec | 列表         | 字段的规范               |\n\n    其中每个 `field_spec` 是一个字符串列表，格式为 `[field_name, field_type, optional]`。目标字段应该存在。\n\n  **输出:**\n\n该块内容位于文档的“附录2. 内置procedures列表”部分，详细介绍了用于修改标签字段的两种数据库操作命令：`db.alterLabelAddFields` 和 `db.alterLabelModFields`，包括其参数、输出及示例输入输出。这部分内容为用户提供了标签修改的具体操作指南。"
            },
            {
                "content": "| affected     |\n  | ------------ |\n  | 1024         |\n* db.alterLabelModFields(label_type, label_name, field_spec...)\n修改标签中的指定字段。\n\n  **参数:**\n\n  | 参数        | 参数类型     | 描述                     |\n  | ---------- | -------------- | ------------------------- |\n  | label_type | 字符串       | 'vertex' 或 'edge'       |\n  | label_name | 字符串       | 标签的名称               |\n  | field_spec | 列表         | 字段的规范               |\n\n    其中每个 `field_spec` 是一个字符串列表，格式为 `[field_name, field_type, optional]`。目标字段应该存在。\n\n  **输出:**\n\n  | 字段名称  | 字段类型     | 描述                           |\n  | ---------- | ---------- | ------------------------------- |\n  | affected   | 整数       | 修改的顶点/边的数量           |\n\n  **示例输入:**\n\n    ```\n    CALL db.alterLabelModFields(\n    'vertex',\n    'new_label',\n    ['birth_date', DATETIME, true],\n    ['gender', BOOL, true])\n    ```\n\n  **示例输出:**\n\n  | affected |\n  | -------- |\n  | 1024     |\n* db.createEdgeLabel( label_name, field_spec...)\n创建一个边标签。\n\n  **参数:**\n\n该内容块位于文档的第5.2节“内置procedures完整列表”中，主要介绍了`db.alterLabelModFields`过程的功能、参数及输出，包括如何修改标签中的指定字段，并展示了对应的示例输入和输出。此部分为用户提供了操作标签字段的具体方法，有助于理解数据管理的细节。"
            },
            {
                "content": "**输出:**\n\n  | 字段名称  | 字段类型     | 描述                           |\n  | ---------- | ---------- | ------------------------------- |\n  | affected   | 整数       | 修改的顶点/边的数量           |\n\n  **示例输入:**\n\n    ```\n    CALL db.alterLabelModFields(\n    'vertex',\n    'new_label',\n    ['birth_date', DATETIME, true],\n    ['gender', BOOL, true])\n    ```\n\n  **示例输出:**\n\n  | affected |\n  | -------- |\n  | 1024     |\n* db.createEdgeLabel( label_name, field_spec...)\n创建一个边标签。\n\n  **参数:**\n\n  | 参数         | 参数类型        | 描述                       |\n  | ------------ | --------------- | ------------------------- |\n  | label_name   | 字符串          | 标签的名称                 |\n  | edge_constraints | 字符串      | 边的约束                   |\n  | field_spec  | 列表            | 字段的规范                   |\n\n  其中每个 `field_spec` 是一个字符串列表，格式为 `[field_name, field_type, optional]`，其中 optional 被指定为 true，仅用于可选字段。\n\n该片段位于文档的“附录2. 内置procedures列表”部分，具体讨论了如何修改标签字段和创建边标签的相关命令、参数及示例输入输出，属于对TuGraph查询语言操作的一部分，主要涉及数据库标签的管理功能。"
            },
            {
                "content": "**参数:**\n\n  | 参数         | 参数类型        | 描述                       |\n  | ------------ | --------------- | ------------------------- |\n  | label_name   | 字符串          | 标签的名称                 |\n  | edge_constraints | 字符串      | 边的约束                   |\n  | field_spec  | 列表            | 字段的规范                   |\n\n  其中每个 `field_spec` 是一个字符串列表，格式为 `[field_name, field_type, optional]`，其中 optional 被指定为 true，仅用于可选字段。\n\n  `edge_constraints` 是一个 json 数组字符串，该参数限制边的起始和结束顶点的组合，例如：`'[[\"vertex_label1\",\"vertex_label2\"],[\"vertex_label3\",\"vertex_label4\"]]'`，这限制了边的方向只能是从 `vertex_label1` 到 `vertex_label2` 或从 `vertex_label3` 到 `vertex_label4`。如果你不想有任何约束，给一个空数组字符串，如 `'[]'`。\n\n  **输出:**\n\n    如果成功，将返回成功消息。\n\n   **示例输入:**\n\n  ```\n  CALL db.createEdgeLabel('KNOWS', '[]', 'name', 'int32', true)\n  ```\n\n  **示例输出:**\n\n  ```\n  添加类型 [KNOWS]\n  ```\n* db.addIndex(label_name, field_name, unique)\n在某个顶点标签的某个字段上创建索引。\n\n  **参数:**\n\n该内容来自于TuGraph-Cypher文档的“内置procedures列表”部分，具体描述了创建边标签的参数、输出以及示例输入和输出。这一段落旨在指导用户如何使用相关命令定义和创建边标签，包括边的约束和字段规范，因此它属于命令用法和功能描述的范畴。"
            },
            {
                "content": "`edge_constraints` 是一个 json 数组字符串，该参数限制边的起始和结束顶点的组合，例如：`'[[\"vertex_label1\",\"vertex_label2\"],[\"vertex_label3\",\"vertex_label4\"]]'`，这限制了边的方向只能是从 `vertex_label1` 到 `vertex_label2` 或从 `vertex_label3` 到 `vertex_label4`。如果你不想有任何约束，给一个空数组字符串，如 `'[]'`。\n\n  **输出:**\n\n    如果成功，将返回成功消息。\n\n   **示例输入:**\n\n  ```\n  CALL db.createEdgeLabel('KNOWS', '[]', 'name', 'int32', true)\n  ```\n\n  **示例输出:**\n\n  ```\n  添加类型 [KNOWS]\n  ```\n* db.addIndex(label_name, field_name, unique)\n在某个顶点标签的某个字段上创建索引。\n\n  **参数:**\n\n  | 参数         | 参数类型   | 描述                           |\n  | ------------ | ---------- | ------------------------------ |\n  | label_name   | 字符串     | 标签的名称                     |\n  | field_name   | 字符串     | 字段的规范                     |\n  | unique       | 布尔值     | 指定索引是否唯一               |\n\n   **输出:**\n\n    如果成功，它将返回一条成功消息。\n\n   **示例输入:**\n\n  ```\n  CALL db.addIndex('Person', 'id', true)\n  ```\n\n   **示例输出:**\n\n  ```\n  Added index [Person:id]\n  ```\n* db.addEdgeIndex(label_name, field_name, unique, pair_unique)  \n在某个边标签的某个字段上创建索引。\n\n该片段位于文档的第五部分，具体涉及到创建边标签及其约束和索引的操作。在此部分，详细介绍了 `edge_constraints` 参数的使用及示例，同时还包括如何在顶点和边标签上创建索引的相关内容。"
            },
            {
                "content": "**输出:**\n\n    如果成功，它将返回一条成功消息。\n\n   **示例输入:**\n\n  ```\n  CALL db.addIndex('Person', 'id', true)\n  ```\n\n   **示例输出:**\n\n  ```\n  Added index [Person:id]\n  ```\n* db.addEdgeIndex(label_name, field_name, unique, pair_unique)  \n在某个边标签的某个字段上创建索引。\n\n  **参数：**\n\n  | 参数         | 参数类型     | 描述                        |\n  | ------------ | ------------ | --------------------------- |\n  | label_name   | 字符串      | 标签的名称                  |\n  | field_name   | 字符串      | 字段的规范                  |\n  | unique       | 布尔值      | 指定索引是否唯一            |\n  | pair_unique   | 布尔值      | 指定索引是否为成对唯一      |\n\n  **输出：**\n\n  如果成功，将返回成功消息。\n\n  **示例输入：**\n\n  ```\n  CALL db.addEdgeIndex('BornIn', 'id', true, false)\n  ```\n\n  **示例输出：**\n\n  ```\n  添加索引 [BornIn:id]\n  ```\n* dbms.security.changePassword(current_password ,new_password)\n更改当前用户的密码。\n\n  **参数：**\n\n该段落位于文档的第五部分“附录2. 内置procedures列表”中，具体描述了与索引相关的内置程序，包括创建顶点和边标签索引的命令及其参数和输出示例。"
            },
            {
                "content": "**输出：**\n\n  如果成功，将返回成功消息。\n\n  **示例输入：**\n\n  ```\n  CALL db.addEdgeIndex('BornIn', 'id', true, false)\n  ```\n\n  **示例输出：**\n\n  ```\n  添加索引 [BornIn:id]\n  ```\n* dbms.security.changePassword(current_password ,new_password)\n更改当前用户的密码。\n\n  **参数：**\n\n  | 参数            | 参数类型      | 描述                  |\n  | ---------------- | -------------- | -------------------- |\n  | current_password | 字符串        | 当前密码             |\n  | new_password     | 字符串        | 新密码               |\n\n  **输出：**\n\n    如果成功，将返回成功消息。\n\n   **示例输入：**\n\n  ```\n  CALL dbms.security.changePassword('73@TuGraph','admin')\n  ```\n\n   **示例输出：**\n\n  ```\n  true\n  ```\n* dbms.security.changeUserPassword(用户名称, 新密码)\n更改当前用户的密码。\n\n  **参数:**\n\n  | 参数          | 参数类型     | 描述           |\n  | ------------ | ------------ | -------------- |\n  | 用户名称     | 字符串       | 用户的名称     |\n  | 新密码       | 字符串       | 新密码         |\n\n  **输出:**\n\n    如果成功，它将返回成功消息。\n\n   **示例输入:**\n\n  ```\n  CALL dbms.security.changeUserPassword('quest','73@TuGraph')\n  ```\n\n  **示例输出:**\n\n该段落位于文档的**附录2**部分，重点介绍了TuGraph中的内置程序（procedures），具体描述了与用户密码管理有关的命令，包括更改当前用户密码和更改特定用户密码的操作，以及相关参数和示例输入输出。这部分内容适用于用户权限和安全管理的相关查询或操作。"
            },
            {
                "content": "**示例输入：**\n\n  ```\n  CALL dbms.security.changePassword('73@TuGraph','admin')\n  ```\n\n   **示例输出：**\n\n  ```\n  true\n  ```\n* dbms.security.changeUserPassword(用户名称, 新密码)\n更改当前用户的密码。\n\n  **参数:**\n\n  | 参数          | 参数类型     | 描述           |\n  | ------------ | ------------ | -------------- |\n  | 用户名称     | 字符串       | 用户的名称     |\n  | 新密码       | 字符串       | 新密码         |\n\n  **输出:**\n\n    如果成功，它将返回成功消息。\n\n   **示例输入:**\n\n  ```\n  CALL dbms.security.changeUserPassword('quest','73@TuGraph')\n  ```\n\n  **示例输出:**\n\n  ```\n  true\n  ```\n* dbms.security.createUser(user_name, password)\n在此图形数据库中创建新用户。\n\n  **参数:**\n\n  | 参数       | 参数类型       | 描述                   |\n  | ---------- | -------------- | ---------------------- |\n  | user_name  | 字符串       | 新用户的名称          |\n  | password   | 字符串       | 新用户的密码          |\n  \n   **输出:**\n  \n    如果成功，它将返回一条成功消息。\n  \n   **示例输入:**\n  \n  ```\n  CALL dbms.security.createUser('quest',\"admin\")\n  ```\n  \n   **示例输出:**\n  \n  ```\n  true\n  ```\n* dbms.security.deleteUser(user_name)  \n在此图形数据库中删除用户。\n\n  **参数：**\n\n该文本块位于文档的“内置procedures列表”部分，具体涵盖与用户管理相关的操作，包括更改密码、创建用户和删除用户的命令和示例。此内容为用户在使用TuGraph时提供了管理用户的功能和相应的API接口。"
            },
            {
                "content": "**参数:**\n\n  | 参数       | 参数类型       | 描述                   |\n  | ---------- | -------------- | ---------------------- |\n  | user_name  | 字符串       | 新用户的名称          |\n  | password   | 字符串       | 新用户的密码          |\n  \n   **输出:**\n  \n    如果成功，它将返回一条成功消息。\n  \n   **示例输入:**\n  \n  ```\n  CALL dbms.security.createUser('quest',\"admin\")\n  ```\n  \n   **示例输出:**\n  \n  ```\n  true\n  ```\n* dbms.security.deleteUser(user_name)  \n在此图形数据库中删除用户。\n\n  **参数：**\n\n  | 参数       | 参数类型   | 描述                         |\n  | ---------- | ---------- | ---------------------------- |\n  | user_name  | 字符串    | 要删除的用户名               |\n\n  **输出：**\n\n    如果成功，返回成功消息。\n\n  **示例输入：**\n\n  ```\n  CALL dbms.security.deleteUser('quest')\n  ```\n\n  **示例输出：**\n\n  ```\n  true\n  ```\n* dbms.security.listUsers()\n获取图数据库中所有用户的名称。\n\n  **输出：**\n\n   用户名列表，每个元素是以下字段的列表：\n\n该片段位于文档的“内置procedures列表”部分，具体涉及用户管理的相关命令，包括创建用户、删除用户及列出所有用户的名称。"
            },
            {
                "content": "**参数：**\n\n  | 参数       | 参数类型   | 描述                         |\n  | ---------- | ---------- | ---------------------------- |\n  | user_name  | 字符串    | 要删除的用户名               |\n\n  **输出：**\n\n    如果成功，返回成功消息。\n\n  **示例输入：**\n\n  ```\n  CALL dbms.security.deleteUser('quest')\n  ```\n\n  **示例输出：**\n\n  ```\n  true\n  ```\n* dbms.security.listUsers()\n获取图数据库中所有用户的名称。\n\n  **输出：**\n\n   用户名列表，每个元素是以下字段的列表：\n\n  | 参数        | 参数类型   | 描述                       |\n  | ----------- | ---------- | -------------------------- |\n  | user.name   | 字符串      | 用户名                     |\n  | is.admin    | 布尔值     | 此用户的权限               |\n\n   **示例输入：**\n\n  ```\n  CALL dbms.security.listUsers()\n  ```\n\n  **示例输出：**\n\n  | user.name | is.admin |\n  | --------- | -------- |\n  | admin     | true     |\n  | ...       |  ...     |  \n输出：\n* dbms.security.showCurrentUser()\n获取当前用户的名称。\n\n  **输出：**\n\n    用户名列表，其中每个元素是以下字段的列表：\n\n该段落位于文档的“内置procedures列表”部分，具体描述了与用户管理相关的命令，包括删除用户、列出所有用户及获取当前用户信息的参数、输出和示例输入输出。"
            },
            {
                "content": "| 参数        | 参数类型   | 描述                       |\n  | ----------- | ---------- | -------------------------- |\n  | user.name   | 字符串      | 用户名                     |\n  | is.admin    | 布尔值     | 此用户的权限               |\n\n   **示例输入：**\n\n  ```\n  CALL dbms.security.listUsers()\n  ```\n\n  **示例输出：**\n\n  | user.name | is.admin |\n  | --------- | -------- |\n  | admin     | true     |\n  | ...       |  ...     |  \n输出：\n* dbms.security.showCurrentUser()\n获取当前用户的名称。\n\n  **输出：**\n\n    用户名列表，其中每个元素是以下字段的列表：\n\n  | 参数       | 参数类型      | 描述                   |\n  | ---------- | -------------- | --------------------- |\n  | user.user  | 字符串        | 当前用户名             |\n\n  **示例输入：**\n\n  ```\n  CALL dbms.security.showCurrentUser()\n  ```\n\n  **示例输出：**\n\n  | user.name |\n  | --------- |\n  | admin     |\n输出：\n* dbms.security.listAllowedHosts()\n获取允许的IP列表。\n\n  **输出：**\n\n   允许的IP列表。\n\n  **示例输入：**\n\n  ```\n  CALL dbms.security.listAllowedHosts()\n  ```\n\n  **示例输出：**\n\n该块内容位于文档的附录部分，主要涉及数据库安全管理的内置过程，具体描述了用户管理、权限检查、当前用户信息获取以及允许的IP列表查询等功能。同时，提供了相应的示例输入和输出，便于用户理解如何使用这些过程。"
            },
            {
                "content": "**输出：**\n\n    用户名列表，其中每个元素是以下字段的列表：\n\n  | 参数       | 参数类型      | 描述                   |\n  | ---------- | -------------- | --------------------- |\n  | user.user  | 字符串        | 当前用户名             |\n\n  **示例输入：**\n\n  ```\n  CALL dbms.security.showCurrentUser()\n  ```\n\n  **示例输出：**\n\n  | user.name |\n  | --------- |\n  | admin     |\n输出：\n* dbms.security.listAllowedHosts()\n获取允许的IP列表。\n\n  **输出：**\n\n   允许的IP列表。\n\n  **示例输入：**\n\n  ```\n  CALL dbms.security.listAllowedHosts()\n  ```\n\n  **示例输出：**\n\n  | 主机       |\n  | ------------ |\n  | 192.168.1.22 |\n  | ...      |\n输出:\n* dbms.security.deleteAllowedHosts(hosts)\n从允许的 IP 列表中删除一些 IP。\n\n  **输出：**\n\n   被删除的 IP 数量。\n\n   **示例输入：**\n\n  ```\n  CALL dbms.security.deleteAllowedHosts('192.168.1.22','192.168.1.23')\n  ```\n\n  **示例输出：**\n\n  | success |\n  | ------- |\n  | 2       |\n* dbms.security.addAllowedHosts(hosts)\n将一些ip从允许的ip列表中添加。\n\n  **输出：**\n\n    已添加的ip数量。\n\n  **示例输入：**\n\n  ```\n  CALL dbms.security.addAllowedHosts('192.168.1.22','192.168.1.23')\n  ```\n\n  **示例输出：**\n\n该片段位于文档的“附录2. 内置procedures列表”部分，主要描述了与用户权限和安全性相关的内置过程，包括获取当前用户信息、列出允许的IP地址、删除IP地址以及添加IP地址等操作的示例和输出格式。"
            },
            {
                "content": "| 主机       |\n  | ------------ |\n  | 192.168.1.22 |\n  | ...      |\n输出:\n* dbms.security.deleteAllowedHosts(hosts)\n从允许的 IP 列表中删除一些 IP。\n\n  **输出：**\n\n   被删除的 IP 数量。\n\n   **示例输入：**\n\n  ```\n  CALL dbms.security.deleteAllowedHosts('192.168.1.22','192.168.1.23')\n  ```\n\n  **示例输出：**\n\n  | success |\n  | ------- |\n  | 2       |\n* dbms.security.addAllowedHosts(hosts)\n将一些ip从允许的ip列表中添加。\n\n  **输出：**\n\n    已添加的ip数量。\n\n  **示例输入：**\n\n  ```\n  CALL dbms.security.addAllowedHosts('192.168.1.22','192.168.1.23')\n  ```\n\n  **示例输出：**\n\n  | 成功   |\n  | ------ |\n  | 2      |\n* dbms.graph.createGraph(graph_name, description, max_size_GB)\n在此图数据库中创建一个新的子图。\n\n  **参数：**\n\n  | 参数         | 参数类型  | 描述                          |\n  | ------------ | --------- | ----------------------------- |\n  | graph_name   | 字符串   | 新子图的名称                  |\n  | description  | 字符串   | 新子图的描述                  |\n  | max_size_GB  | 整数     | 子图容量的上限                |\n\n   **输出：**\n\n    如果成功，将返回 true。\n\n   **示例输入：**\n\n该块内容位于文档的5.2节“内置procedures完整列表”中，主要描述了与IP管理相关的过程，如删除和添加被允许的主机IP。此外，还包括创建新的子图过程的详细说明，涵盖参数及其描述。"
            },
            {
                "content": "**示例输出：**\n\n  | 成功   |\n  | ------ |\n  | 2      |\n* dbms.graph.createGraph(graph_name, description, max_size_GB)\n在此图数据库中创建一个新的子图。\n\n  **参数：**\n\n  | 参数         | 参数类型  | 描述                          |\n  | ------------ | --------- | ----------------------------- |\n  | graph_name   | 字符串   | 新子图的名称                  |\n  | description  | 字符串   | 新子图的描述                  |\n  | max_size_GB  | 整数     | 子图容量的上限                |\n\n   **输出：**\n\n    如果成功，将返回 true。\n\n   **示例输入：**\n\n  ```\n  CALL dbms.graph.createGraph('graph1', 'description', 2045)\n  ```\n\n  **示例输出：**\n\n  | success |\n  | ------- |\n  | true    |\n* dbms.graph.deleteGraph(graph_name)\n在此图数据库中删除一个子图。\n\n  | 参数        | 参数类型   | 描述                           |\n  | ----------- | ---------- | ------------------------------ |\n  | graph_name  | 字符串     | 要删除的子图的名称            |\n\n  **输出：**\n\n    如果成功，将返回 true。\n\n  **示例输入：**\n\n  ```\n  CALL dbms.graph.deleteGraph('graph1')\n  ```\n\n   **示例输出：**\n\n该块内容位于文档的第五部分“附录2. 内置procedures列表”中，具体介绍了数据库操作命令，包括创建和删除子图的相关命令及其参数、输出示例。这为用户在使用TuGraph进行图数据库管理时提供了具体的指引和示例。"
            },
            {
                "content": "**输出：**\n\n    如果成功，将返回 true。\n\n   **示例输入：**\n\n  ```\n  CALL dbms.graph.createGraph('graph1', 'description', 2045)\n  ```\n\n  **示例输出：**\n\n  | success |\n  | ------- |\n  | true    |\n* dbms.graph.deleteGraph(graph_name)\n在此图数据库中删除一个子图。\n\n  | 参数        | 参数类型   | 描述                           |\n  | ----------- | ---------- | ------------------------------ |\n  | graph_name  | 字符串     | 要删除的子图的名称            |\n\n  **输出：**\n\n    如果成功，将返回 true。\n\n  **示例输入：**\n\n  ```\n  CALL dbms.graph.deleteGraph('graph1')\n  ```\n\n   **示例输出：**\n\n  | 成功      |\n  | --------- |\n  | true      |\n* dbms.graph.modGraph(graph_name, config)\n删除此图数据库中的子图。\n\n  **参数：**\n\n  | 参数         | 参数类型      | 描述                           |\n  | ------------ | ------------- | ------------------------------ |\n  | graph_name   | 字符串       | 要删除的子图的名称            |\n  | config       | 映射         | 要修改的配置                  |\n\n  **输出：**\n\n    如果成功，将返回 true。\n\n  **示例输入：**\n\n  ```\n  CALL dbms.graph.modGraph('graph1',{description:'this graph', max_size_GB:20})\n  ```\n\n  **示例输出：**\n\n该块内容位于文档的第五部分“附录2. 内置procedures列表”，具体介绍了与图数据库操作相关的内置过程，包括创建、删除和修改子图的具体命令及其参数和输出示例。这部分内容提供了用户对图数据库管理功能的全面理解。"
            },
            {
                "content": "| 成功      |\n  | --------- |\n  | true      |\n* dbms.graph.modGraph(graph_name, config)\n删除此图数据库中的子图。\n\n  **参数：**\n\n  | 参数         | 参数类型      | 描述                           |\n  | ------------ | ------------- | ------------------------------ |\n  | graph_name   | 字符串       | 要删除的子图的名称            |\n  | config       | 映射         | 要修改的配置                  |\n\n  **输出：**\n\n    如果成功，将返回 true。\n\n  **示例输入：**\n\n  ```\n  CALL dbms.graph.modGraph('graph1',{description:'this graph', max_size_GB:20})\n  ```\n\n  **示例输出：**\n\n  | 成功     |\n  | -------- |\n  | true     |\n* dbms.graph.listGraphs()\n获取此图数据库中的所有子图。\n\n  **输出：**\n\n    一个 {子图和配置} 的列表。\n\n  **示例输入：**\n\n  ```\n  CALL dbms.graph.listGraphs()\n  ```\n\n  **示例输出：**\n\n该片段介绍了 TuGraph 数据库中的图形管理功能，具体包括修改子图的配置和列出当前数据库中的所有子图。通过调用相应的数据库程序，用户可以获取并修改子图的描述和大小限制。"
            },
            {
                "content": "**输出：**\n\n    如果成功，将返回 true。\n\n  **示例输入：**\n\n  ```\n  CALL dbms.graph.modGraph('graph1',{description:'this graph', max_size_GB:20})\n  ```\n\n  **示例输出：**\n\n  | 成功     |\n  | -------- |\n  | true     |\n* dbms.graph.listGraphs()\n获取此图数据库中的所有子图。\n\n  **输出：**\n\n    一个 {子图和配置} 的列表。\n\n  **示例输入：**\n\n  ```\n  CALL dbms.graph.listGraphs()\n  ```\n\n  **示例输出：**\n\n  | graph.name | configuration                 |\n  | ---------- | --------------------------------------------- |\n  | default    | {\"description\":\"\",\"max_size_GB\":1024}     |\n  | graph1     | {\"description\":\"this graph\",\"max_size_GB\":20} |\n  | ...        |         ...                  |\n* dbms.graph.listUserGraphs(user_name)\n获取指定用户可以读取或写入的子图列表\n\n  **输出:**\n\n  一个 {子图和配置} 的列表。\n\n  **示例输入:**\n\n  ```\n  CALL dbms.graph.listUserGraphs(\"test_user\")\n  ```\n\n  **示例输出:**\n\n该片段位于文档的第五部分“附录2. 内置procedures列表”中，具体介绍了与图数据库操作相关的过程，包括修改子图属性、列出所有子图以及列出用户可访问的子图等功能。这部分内容整理了各种数据库过程的输入、输出示例及其功能描述，为用户提供了操作指南。"
            },
            {
                "content": "**示例输出：**\n\n  | graph.name | configuration                 |\n  | ---------- | --------------------------------------------- |\n  | default    | {\"description\":\"\",\"max_size_GB\":1024}     |\n  | graph1     | {\"description\":\"this graph\",\"max_size_GB\":20} |\n  | ...        |         ...                  |\n* dbms.graph.listUserGraphs(user_name)\n获取指定用户可以读取或写入的子图列表\n\n  **输出:**\n\n  一个 {子图和配置} 的列表。\n\n  **示例输入:**\n\n  ```\n  CALL dbms.graph.listUserGraphs(\"test_user\")\n  ```\n\n  **示例输出:**\n\n  | graph.name | configuration                 |\n  | ---------- | --------------------------------------------- |\n  | default    | {\"description\":\"\",\"max_size_GB\":1024}     |\n  | graph1     | {\"description\":\"this graph\",\"max_size_GB\":20} |\n  | ...        |         ...                  |\n输出:\n* dbms.config.list()\n获取此图数据库的配置。\n\n  **输出：**\n\n    一份 {配置} 的列表。\n\n  **示例输入：**\n\n  ```\n  CALL dbms.config.list()\n  ```\n\n  **示例输出：**\n\n该段落位于文档的5.1节，关于内置过程样例，具体描述了数据库操作命令和示例输出，其中包括列出用户可以访问的子图和数据库的配置设置。"
            },
            {
                "content": "**示例输入:**\n\n  ```\n  CALL dbms.graph.listUserGraphs(\"test_user\")\n  ```\n\n  **示例输出:**\n\n  | graph.name | configuration                 |\n  | ---------- | --------------------------------------------- |\n  | default    | {\"description\":\"\",\"max_size_GB\":1024}     |\n  | graph1     | {\"description\":\"this graph\",\"max_size_GB\":20} |\n  | ...        |         ...                  |\n输出:\n* dbms.config.list()\n获取此图数据库的配置。\n\n  **输出：**\n\n    一份 {配置} 的列表。\n\n  **示例输入：**\n\n  ```\n  CALL dbms.config.list()\n  ```\n\n  **示例输出：**\n\n  | 名称       | 值      |\n  |-----------| ---------|\n  | bind_host | 0.0.0.0 |\n  | durable   | true    |\n  | ...       |  ...    |\n输出：\n* dbms.config.update(updates)\n获取此图数据库的一些配置。\n\n  **输出：**\n\n    如果成功，它将返回成功消息。\n\n  **示例输入：**\n\n  ```\n  CALL dbms.config.update({\n    enable_ip_check:false,\n    durable:true,\n    optimistic_txn:true,\n    enable_audit_log:true})\n  ```\n\n  **示例输出：**\n\n  ```\n  更新成功。\n  ```\n* dbms.takeSnapshot()\n在当前图形数据库上创建快照。\n\n  **输出:**\n\n    如果成功，它将返回快照的路径。\n\n  **示例输入:**\n\n  ```\n  CALL dbms.takeSnapshot()\n  ```\n\n此段落位于文档的“内置procedures列表”部分，具体介绍了与图数据库相关的管理命令，涵盖了用户图的查询、数据库配置的获取和更新以及创建快照的操作示例，旨在为读者提供对TuGraph查询语言中数据库管理功能的具体应用。"
            },
            {
                "content": "**输出：**\n\n    如果成功，它将返回成功消息。\n\n  **示例输入：**\n\n  ```\n  CALL dbms.config.update({\n    enable_ip_check:false,\n    durable:true,\n    optimistic_txn:true,\n    enable_audit_log:true})\n  ```\n\n  **示例输出：**\n\n  ```\n  更新成功。\n  ```\n* dbms.takeSnapshot()\n在当前图形数据库上创建快照。\n\n  **输出:**\n\n    如果成功，它将返回快照的路径。\n\n  **示例输入:**\n\n  ```\n  CALL dbms.takeSnapshot()\n  ```\n\n  **示例输出:**\n\n  | 路径                                   |\n  | ----------------------------------- |\n  | log/db/snapshot/2020-07-20_17.20.03 |\n* dbms.listBackupFiles()\n获取备份文件的路径。\n\n  **输出：**\n\n    如果成功，它将返回快照的路径。\n\n  **示例输入：**\n\n  ```\n  CALL dbms.listBackupFiles()\n  ```\n\n  **示例输出：**\n\n  | path               |\n  | -------------------------- |\n  | tugraph/db/binlog/binlog_0 |\n* algo.shortestPath(startNode, endNode, config)\n获取两个顶点之间的最短路径之一。\n\n  **参数:**\n\n该段落位于文档的“5.2.内置procedures完整列表”部分，主要介绍了TuGraph中的一些内置过程，包括如何更新数据库配置、创建快照、获取备份文件路径以及查询最短路径等。这些过程的输出格式和示例输入输出都被详细说明，适用于数据库管理和维护。"
            },
            {
                "content": "**示例输入:**\n\n  ```\n  CALL dbms.takeSnapshot()\n  ```\n\n  **示例输出:**\n\n  | 路径                                   |\n  | ----------------------------------- |\n  | log/db/snapshot/2020-07-20_17.20.03 |\n* dbms.listBackupFiles()\n获取备份文件的路径。\n\n  **输出：**\n\n    如果成功，它将返回快照的路径。\n\n  **示例输入：**\n\n  ```\n  CALL dbms.listBackupFiles()\n  ```\n\n  **示例输出：**\n\n  | path               |\n  | -------------------------- |\n  | tugraph/db/binlog/binlog_0 |\n* algo.shortestPath(startNode, endNode, config)\n获取两个顶点之间的最短路径之一。\n\n  **参数:**\n\n  | 参数       | 参数类型       | 描述                                      |\n  | --------- | -------------- | ---------------------------------------------------------- |\n  | startNode | Node       | 路径的源节点                              |\n  | endNode   | Node       | 路径的目的节点                            |\n  | config    | MAP        | 最短路径的筛选条件，格式为 {maxHops:3, relationshipQuery:'HAS_CHILD'} |\n\n  **输出:**\n\n    如果成功，它将返回一组最短路径的结果。\n\n  **示例输入:**\n\n该块内容位于文档的后半部分，主要涉及常用的数据库操作命令，尤其是与快照和备份文件相关的过程调用，包括如何创建数据库快照以及列出备份文件路径。此外，还介绍了获取两个顶点之间最短路径的命令和参数，进一步说明了数据库查询和管理的功能。"
            },
            {
                "content": "**参数:**\n\n  | 参数       | 参数类型       | 描述                                      |\n  | --------- | -------------- | ---------------------------------------------------------- |\n  | startNode | Node       | 路径的源节点                              |\n  | endNode   | Node       | 路径的目的节点                            |\n  | config    | MAP        | 最短路径的筛选条件，格式为 {maxHops:3, relationshipQuery:'HAS_CHILD'} |\n\n  **输出:**\n\n    如果成功，它将返回一组最短路径的结果。\n\n  **示例输入:**\n\n  ```\n  MATCH (n1 {name:'Hugo Weaving'}),(n2 {title:'The Matrix'})\n  CALL algo.shortestPath(n1,n2) YIELD nodeCount,totalCost RETURN nodeCount,totalCost\n  ```\n\n  **示例输出:**\n\n  | nodeCount | totalCost |\n  | --------- | --------- |\n  | 2     | 1     |\n* algo.allShortestPaths(startNode, endNode, config))\n获取备份文件的路径。\n\n  **输出：**\n\n    如果成功，它将返回快照的路径。\n\n  **示例输入：**\n\n  ```\n  MATCH (n1 {name:'Hugo Weaving'}),(n2 {title:'The Matrix'})\n  CALL algo.allShortestPaths(n1,n2) YIELD nodeIds,cost RETURN nodeIds,cost\n  ```\n\n  **示例输出：**\n\n该块内容位于文档的第5.2节“内置procedures完整列表”中的“algo.shortestPath”和“algo.allShortestPaths”部分，介绍了如何通过调用这些内置过程来查询两个节点之间的最短路径及所有最短路径，包含了参数、输出以及示例输入和输出。"
            },
            {
                "content": "**示例输出:**\n\n  | nodeCount | totalCost |\n  | --------- | --------- |\n  | 2     | 1     |\n* algo.allShortestPaths(startNode, endNode, config))\n获取备份文件的路径。\n\n  **输出：**\n\n    如果成功，它将返回快照的路径。\n\n  **示例输入：**\n\n  ```\n  MATCH (n1 {name:'Hugo Weaving'}),(n2 {title:'The Matrix'})\n  CALL algo.allShortestPaths(n1,n2) YIELD nodeIds,cost RETURN nodeIds,cost\n  ```\n\n  **示例输出：**\n\n  | nodeIds | cost |\n  | ------- | ---- |\n  | [2,665] | 1    |\n  | ...     |      |  \nOutput:\n* algo.algo.native.extract(id, config)\n获取一组顶点或边的字段值。\n\n  **参数：**\n\n  | 参数      | 参数类型 | 描述                                                   |\n  | --------- | -------- | ------------------------------------------------------ |\n  | id        | 任意     | 顶点或边的 id，id 必须是变量                          |\n  | config    | 映射     | 这次提取顶点或边的配置                                |\n\n  其中每个 `config` 是一个形式为 `{isNode:true, filed:'HAS_CHILD'}` 的映射，如果 `isNode` 被指定为 true，则 `id` 是一个顶点 id，否则它是一个边 id。\n\n  **输出：**\n\n    如果成功，它将返回指定字段的顶点或边的值的列表。\n\n  **示例输入：**\n\n此块内容位于文档的第5部分，详细介绍了TuGraph中的算法相关过程，包括最短路径查询和提取顶点或边的字段值的功能及其示例输入输出，属于功能详情的描述部分。"
            },
            {
                "content": "**参数：**\n\n  | 参数      | 参数类型 | 描述                                                   |\n  | --------- | -------- | ------------------------------------------------------ |\n  | id        | 任意     | 顶点或边的 id，id 必须是变量                          |\n  | config    | 映射     | 这次提取顶点或边的配置                                |\n\n  其中每个 `config` 是一个形式为 `{isNode:true, filed:'HAS_CHILD'}` 的映射，如果 `isNode` 被指定为 true，则 `id` 是一个顶点 id，否则它是一个边 id。\n\n  **输出：**\n\n    如果成功，它将返回指定字段的顶点或边的值的列表。\n\n  **示例输入：**\n\n  ```\n  with [2,3] as vids CALL algo.native.extract(vids,{isNode:true, field:'id'})\n  YIELD value  RETURN value\n  ```\n\n  **示例输出：**\n\n  | value   |\n  | ------- |\n  | [4,5]   |\n\n该段落位于文档的“内置procedures完整列表”部分，具体描述了`algo.native.extract`过程的参数、输出及示例，旨在帮助用户理解如何提取特定顶点或边的字段值。"
            },
            {
                "content": "### 5.2.内置procedures完整列表\n| 名称                                   | 描述                                   | 签名                                                                                                                                                                                 |\n|---------------------------------------|---------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| db.subgraph                           | 列出点的子图                                | db.subgraph(vids::LIST) :: (subgraph::STRING)                                                                                                                                           |\n\n该内容位于文档的第五部分，主要介绍了TuGraph的内置过程，包括程序的名称、描述和调用签名，旨在为用户提供有关数据库操作的详细信息和便捷的参考。"
            },
            {
                "content": "| db.subgraph                           | 列出点的子图                                | db.subgraph(vids::LIST) :: (subgraph::STRING)                                                                                                                                           |\n| db.vertexLabels                       | 列出所有Vertex Label                      | db.vertexLabels() :: (label::STRING)                                                                                                                                                    |\n| db.edgeLabels                         | 列出所有Edge Label                        | db.edgeLabels() :: (edgeLabels::STRING)                                                                                                                                                 |\n\n该内容块属于文档的第五部分“附录2. 内置procedures列表”，具体列出了TuGraph中可用的内置过程及其功能、描述和签名，旨在帮助用户了解和使用数据库的操作指令。"
            },
            {
                "content": "| db.edgeLabels                         | 列出所有Edge Label                        | db.edgeLabels() :: (edgeLabels::STRING)                                                                                                                                                 |\n| db.indexes                            | 列出所有索引                                | db.indexes() :: (label::STRING,field::STRING,label_type:STRING,unique::BOOLEAN,pair_unique::BOOLEAN)                                                                                    |\n| db.listLabelIndexes                   | 列出所有与某个Label相关的索引                     | db.listLabelIndexes(label_name:STRING,label_type:STRING) :: (label::STRING,field::STRING,unique::BOOLEAN,pair_unique::BOOLEAN)                                                          |\n\n该块内容位于文档的“附录2. 内置procedures列表”部分，具体列出了与边标签和索引相关的操作命令及其描述，包括如何列出所有边标签、所有索引以及与特定标签相关的索引。这些命令帮助用户管理图数据库中的标签和索引结构。"
            },
            {
                "content": "| db.listLabelIndexes                   | 列出所有与某个Label相关的索引                     | db.listLabelIndexes(label_name:STRING,label_type:STRING) :: (label::STRING,field::STRING,unique::BOOLEAN,pair_unique::BOOLEAN)                                                          |\n| db.warmup                             | 预热数据                                  | db.warmup() :: (time_used::STRING)                                                                                                                                                      |\n| db.createVertexLabel                  | 创建Vertex Label                        | db.createVertexLabel(label_name::STRING,field_specs::LIST) :: (::VOID)                                                                                                                  |\n\n该块内容位于文档的“内置procedures完整列表”部分，列出了与数据库操作相关的特定命令，包括列出与某个标签相关的索引、预热数据以及创建顶点标签的操作及其对应的签名。这部分内容为用户提供了具体的操作方法和函数调用格式，以便于进行数据库管理和操作。"
            },
            {
                "content": "| db.createVertexLabel                  | 创建Vertex Label                        | db.createVertexLabel(label_name::STRING,field_specs::LIST) :: (::VOID)                                                                                                                  |\n| db.createLabel                        | 创建Vertex/Edge Label                   | db.createLabel(label_type::STRING,label_name::STRING,extra::STRING,field_specs::LIST) :: ()                                                                                             |\n| db.getLabelSchema                     | 列出label schema                        | db.getLabelSchema(label_type::STRING,label_name::STRING) :: (name::STRING,type::STRING,optional::BOOLEAN)                                                                               |\n\n该块内容位于文档的“内置procedures完整列表”部分，其中列出了与图数据库中标签相关的操作命令，包括创建标签、列出标签架构等功能。这些命令的详细描述和签名格式为用户在使用TuGraph查询语言时提供了具体的指引。"
            },
            {
                "content": "| db.getLabelSchema                     | 列出label schema                        | db.getLabelSchema(label_type::STRING,label_name::STRING) :: (name::STRING,type::STRING,optional::BOOLEAN)                                                                               |\n| db.getVertexSchema                    | 列出点的 schema                           | db.getVertexSchema(label::STRING) :: (schema::MAP)                                                                                                                                      |\n| db.getEdgeSchema                      | 列出边的 schema                           | db.getEdgeSchema(label::STRING) :: (schema::MAP)                                                                                                                                        |\n\n该片段位于文档的\"5.2.内置procedures完整列表\"部分，列出了与数据库标签及其结构相关的命令，包括获取标签模式、点的模式以及边的模式的功能和签名。这些命令用于操作和查询数据库中的节点和关系的结构信息。"
            },
            {
                "content": "| db.getEdgeSchema                      | 列出边的 schema                           | db.getEdgeSchema(label::STRING) :: (schema::MAP)                                                                                                                                        |\n| db.deleteLabel                        | 删除Vertex/Edge Label                   | db.deleteLabel(label_type::STRING,label_name::STRING) :: (::VOID)                                                                                                                       |\n| db.alterLabelDelFields                | 修改label删除属性                           | db.alterLabelDelFields(label_type::STRING,label_name::STRING,del_fields::LIST) :: (record_affected::INTEGER)                                                                            |\n\n此片段位于文档的第五部分“附录2. 内置procedures列表”，具体涵盖与边的schema相关的操作命令及标签的删除与修改功能，旨在提供用户操作数据库中标签和边属性结构的详细信息。"
            },
            {
                "content": "| db.alterLabelDelFields                | 修改label删除属性                           | db.alterLabelDelFields(label_type::STRING,label_name::STRING,del_fields::LIST) :: (record_affected::INTEGER)                                                                            |\n| db.alterLabelAddFields                | 修改label添加field                        | db.alterLabelAddFields(label_type::STRING,label_name::STRING,add_field_spec_values::LIST) :: (record_affected::INTEGER)                                                                 |\n| db.alterLabelModFields                | 修改label field                         | db.alterLabelModFields(label_type::STRING,label_name::STRING,mod_field_specs::LIST) :: (record_affected::INTEGER)                                                                       |\n\n该片段位于文档的后半部分，专门介绍了与标签管理相关的数据库操作命令，包括修改标签字段的添加、删除和修改。这些命令的签名和用途明确列出，旨在帮助用户对标签的结构和属性进行灵活的调整。"
            },
            {
                "content": "| db.alterLabelModFields                | 修改label field                         | db.alterLabelModFields(label_type::STRING,label_name::STRING,mod_field_specs::LIST) :: (record_affected::INTEGER)                                                                       |\n| db.createEdgeLabel                    | 创建Edge Label                          | db.createEdgeLabel(type_name::STRING,field_specs::LIST) :: (::VOID)                                                                                                                     |\n| db.addIndex                           | 创建索引                                  | db.addIndex(label_name::STRING,field_name::STRING,unique::BOOLEAN) :: (::VOID)                                                                                                          |\n\n该文本块位于文档的第五部分“内置procedures完整列表”，具体列出了与标签字段修改、边标签创建和索引创建相关的数据库操作命令及其描述和签名。这些命令用于对数据库中的标签和索引进行管理和操作。"
            },
            {
                "content": "| db.addIndex                           | 创建索引                                  | db.addIndex(label_name::STRING,field_name::STRING,unique::BOOLEAN) :: (::VOID)                                                                                                          |\n| db.addEdgeIndex                       | 创建索引                                  | db.addEdgeIndex(label_name::STRING,field_name::STRING,unique::BOOLEAN,pair_unique::BOOLEAN) :: (::VOID)                                                                                 |\n| db.addVertexCompositeIndex            | 创建组合索引                                | db.addVertexCompositeIndex(label_name::STRING,field_names::LIST,unique::BOOLEAN) :: (::VOID)                                                                                            |\n\n该段落位于文档的“内置procedures完整列表”部分，主要详细介绍了与数据库索引相关的操作命令，包括创建普通索引、边索引和组合索引的具体语法和功能。这些命令帮助用户在数据集上提高查询效率和性能。"
            },
            {
                "content": "| db.addVertexCompositeIndex            | 创建组合索引                                | db.addVertexCompositeIndex(label_name::STRING,field_names::LIST,unique::BOOLEAN) :: (::VOID)                                                                                            |\n| db.deleteIndex                        | 删除索引                                  | db.deleteIndex(label_name::STRING,field_name::STRING) :: (::VOID)                                                                                                                       |\n| db.deleteCompositeIndex               | 删除组合索引                                | db.deleteIndex(label_name::STRING,field_names::LIST) :: (::VOID)                                                                                                                        |\n\n该段落位于文档的“内置procedures完整列表”章节中，具体描述了与索引相关的数据库操作命令，包括创建组合索引、删除索引和删除组合索引的功能及其签名。这些命令能够帮助用户管理数据库中的索引，以提高查询效率和数据管理灵活性。"
            },
            {
                "content": "| db.deleteCompositeIndex               | 删除组合索引                                | db.deleteIndex(label_name::STRING,field_names::LIST) :: (::VOID)                                                                                                                        |\n| db.backup                             | 备份数据                                  | db.backup(destination::STRING) :: ()                                                                                                                                                    |\n| dbms.procedures                       | 列出所有procedures                        | dbms.procedures() :: (name::STRING,signature::STRING)                                                                                                                                   |\n\n该块内容位于文档的第五部分“内置procedures完整列表”中，列出了与数据库操作相关的内置过程，包括删除组合索引、备份数据以及列出所有可用的过程。这些过程帮助用户管理数据库和查询系统的功能。"
            },
            {
                "content": "| dbms.procedures                       | 列出所有procedures                        | dbms.procedures() :: (name::STRING,signature::STRING)                                                                                                                                   |\n| dbms.security.changePassword          | 更改当前用户的密码                             | dbms.security.changePassword(current_password::STRING,new_password::STRING) :: (::VOID)                                                                                                 |\n| dbms.security.changeUserPassword      | 更改指定用户的密码                             | dbms.security.changeUserPassword(user_name::STRING,new_password::STRING) :: (::VOID)                                                                                                    |\n\n该段内容属于文档的第五部分“附录2. 内置procedures列表”，具体列出了TuGraph数据库中的一些内置过程，包括列出所有过程、改变密码等相关操作命令及其签名。这部分提供了数据库功能的调用方式，便于用户在使用过程中查询和管理数据库。"
            },
            {
                "content": "| dbms.security.changeUserPassword      | 更改指定用户的密码                             | dbms.security.changeUserPassword(user_name::STRING,new_password::STRING) :: (::VOID)                                                                                                    |\n| dbms.security.createUser              | 创建用户                                  | dbms.security.createUser(user_name::STRING,password::STRING) :: (::VOID)                                                                                                                |\n| dbms.security.deleteUser              | 删除用户                                  | dbms.security.deleteUser(user_name::STRING) :: (::VOID)                                                                                                                                 |\n\n该块内容位于文档的“内置procedures完整列表”部分，具体列出了与用户管理相关的操作命令，包括更改密码、创建用户和删除用户的具体签名和描述。这些命令旨在提供对数据库用户的管理功能。"
            },
            {
                "content": "| dbms.security.deleteUser              | 删除用户                                  | dbms.security.deleteUser(user_name::STRING) :: (::VOID)                                                                                                                                 |\n| dbms.security.listUsers               | 列出所有用户                                | dbms.security.listUsers() :: (user_name::STRING,user_info::MAP)                                                                                                                         |\n| dbms.security.showCurrentUser         | 列出当前用户信息                              | dbms.security.showCurrentUser() :: (current_user::STRING)                                                                                                                               |\n\n该部分内容位于文档的“内置procedures完整列表”章节中，具体列出了与用户管理相关的操作命令，包括删除用户、列出所有用户以及显示当前用户信息。这些命令为用户权限管理和信息获取提供了必要的功能。"
            },
            {
                "content": "| dbms.security.showCurrentUser         | 列出当前用户信息                              | dbms.security.showCurrentUser() :: (current_user::STRING)                                                                                                                               |\n| dbms.security.getUserPermissions      | 列出指定用户的权限                             | dbms.security.getUserPermissions(user_name::STRING) :: (user_info::MAP)                                                                                                                 |\n| dbms.graph.createGraph                | 创建子图                                  | dbms.graph.createGraph(graph_name::STRING, description::STRING, max_size_GB::INTEGER) :: (::VOID)                                                                                       |\n\n该块内容位于文档的\"内置procedures完整列表\"部分，主要列出了与用户管理和图数据库操作相关的存储过程，包括当前用户信息、用户权限以及子图的创建。"
            },
            {
                "content": "| dbms.graph.createGraph                | 创建子图                                  | dbms.graph.createGraph(graph_name::STRING, description::STRING, max_size_GB::INTEGER) :: (::VOID)                                                                                       |\n| dbms.graph.modGraph                   | 修改子图属性                                | dbms.graph.modGraph(graph_name::STRING,config::MAP) :: (::VOID)                                                                                                                         |\n| dbms.graph.deleteGraph                | 删除子图                                  | dbms.graph.deleteGraph(graph_name::STRING) :: (::VOID)                                                                                                                                  |\n\n此代码块位于文档的“5.2.内置procedures完整列表”部分，主要列出与图形数据库操作相关的命令，具体包括创建、修改和删除子图的操作。这些命令的签名和描述为用户提供了如何管理子图的详细信息。"
            },
            {
                "content": "| dbms.graph.deleteGraph                | 删除子图                                  | dbms.graph.deleteGraph(graph_name::STRING) :: (::VOID)                                                                                                                                  |\n| dbms.graph.listGraphs                 | 列出所有子图                                | dbms.graph.listGraphs() :: (graph_name::STRING,configuration::MAP)                                                                                                                      |\n| dbms.graph.getGraphInfo               | 列出指定子图的信息                             | dbms.graph.getGraphInfo(graph_name::STRING)::(graph_name::STRING,configuration::MAP)                                                                                                    |\n\n该片段位于文档的“内置procedures完整列表”部分，主要介绍与图数据库相关的操作命令，包括删除子图、列出所有子图以及获取指定子图的信息。这些命令在图数据库管理和数据组织中至关重要。"
            },
            {
                "content": "| dbms.graph.getGraphInfo               | 列出指定子图的信息                             | dbms.graph.getGraphInfo(graph_name::STRING)::(graph_name::STRING,configuration::MAP)                                                                                                    |\n| dbms.security.addAllowedHosts         | 添加ip到信任列表                             | dbms.security.addAllowedHosts(hosts::LIST) :: (num_new::INTEGER)                                                                                                                        |\n| dbms.security.deleteAllowedHosts      | 从信任列表删除ip                             | dbms.security.deleteAllowedHosts(hosts::LIST) :: (record_affected::INTEGER)                                                                                                             |\n\n该段落位于文档的“5.2.内置procedures完整列表”中，主要列出了与图形数据库管理相关的内置过程，包括列出指定子图的信息，以及管理信任主机列表的功能。这些操作便于用户对数据库进行配置和管理，提高了数据库的安全性和可用性。"
            },
            {
                "content": "| dbms.security.deleteAllowedHosts      | 从信任列表删除ip                             | dbms.security.deleteAllowedHosts(hosts::LIST) :: (record_affected::INTEGER)                                                                                                             |\n| dbms.security.listAllowedHosts        | 列出信任列表中的主机ip                          | dbms.security.listAllowedHosts() :: (host::STRING)                                                                                                                                      |\n| dbms.config.update                    | 更新TuGraph配置                           | dbms.config.update(updates::MAP) :: (message::STRING)                                                                                                                                   |\n\n该块内容包括`dbms.security`和`dbms.config`类别下的命令，主要涉及信任列表的管理以及TuGraph配置的更新。这些命令帮助用户管理系统安全性和配置，从而确保数据库的正常运行和安全性。"
            },
            {
                "content": "| dbms.config.update                    | 更新TuGraph配置                           | dbms.config.update(updates::MAP) :: (message::STRING)                                                                                                                                   |\n| dbms.config.list                      | 列出TuGraph配置                           | dbms.config.list() :: (name::STRING,value::ANY)                                                                                                                                         |\n| algo.shortestPath                     | 查询两个点间的最短路径                           | algo.shortestPath(startNode::NODE,endNode::NODE,config::MAP) :: (nodeCount::INTEGER,totalCost::FLOAT)                                                                                   |\n\n该内容块位于文档的“内置procedures完整列表”章节，主要列出了与TuGraph配置管理和最短路径查询相关的数据库操作命令及其使用描述。这些命令包括更新配置、列出当前配置以及查询两个节点之间的最短路径，为用户提供操作数据库的重要功能。"
            },
            {
                "content": "| algo.shortestPath                     | 查询两个点间的最短路径                           | algo.shortestPath(startNode::NODE,endNode::NODE,config::MAP) :: (nodeCount::INTEGER,totalCost::FLOAT)                                                                                   |\n| algo.allShortestPaths                 | 查询两个点间的所有最短路径                         | algo.allShortestPaths(startNode::NODE,endNode::NODE,config::MAP) :: (nodeIds::LIST,relationshipIds::LIST,cost::LIST)                                                                    |\n| algo.native.extract                   | 查询指定VertexId/EdgeUid（列表）指定field的值（列表） | algo.native.extract(id::ANY,config::MAP) :: (value::ANY)                                                                                                                                |\n\n该段落位于文档的第5.2节“内置procedures完整列表”中，主要列出了与图算法相关的内置过程，具体包括查询两个节点间的最短路径、所有最短路径以及提取特定节点或边的字段值。这些过程的描述和签名格式为用户提供了便于调用的具体信息。"
            },
            {
                "content": "| algo.native.extract                   | 查询指定VertexId/EdgeUid（列表）指定field的值（列表） | algo.native.extract(id::ANY,config::MAP) :: (value::ANY)                                                                                                                                |\n| db.flushDB                            | 刷新db                                  | db.flushDB() :: (::VOID)                                                                                                                                                                |\n| dbms.security.listRoles               | 列出所有角色                                | dbms.security.listRoles() :: (role_name::STRING,role_info::MAP)                                                                                                                         |\n\n该段落位于文档的附录部分，具体涵盖了TuGraph中内置的过程和命令，包括获取指定顶点或边的属性值、刷新数据库以及列出所有角色的功能。这些过程为用户提供了关键的数据库操作选项，对数据管理和权限控制具有重要意义。"
            },
            {
                "content": "| dbms.security.listRoles               | 列出所有角色                                | dbms.security.listRoles() :: (role_name::STRING,role_info::MAP)                                                                                                                         |\n| dbms.security.createRole              | 创建角色                                  | dbms.security.createRole(role_name::STRING,desc::STRING) :: (::VOID)                                                                                                                    |\n| dbms.security.deleteRole              | 删除角色                                  | dbms.security.deleteRole(role_name::STRING) :: (::VOID)                                                                                                                                 |\n\n该块内容位于文档的附录部分，专注于数据库的安全管理功能，具体描述了与角色相关的操作命令，包括列出、创建和删除角色的具体语法和功能。"
            },
            {
                "content": "| dbms.security.deleteRole              | 删除角色                                  | dbms.security.deleteRole(role_name::STRING) :: (::VOID)                                                                                                                                 |\n| dbms.security.getRoleInfo             | 获取角色详细信息                              | dbms.security.getRoleInfo(role::STRING) :: (role_info::MAP)                                                                                                                             |\n| dbms.security.disableRole             | 禁用/启用角色                               | dbms.security.disableRole(role::STRING,disable::BOOLEAN) :: (::VOID)                                                                                                                    |\n\n该片段包含了与角色管理相关的数据库操作命令，包括删除角色、获取角色详细信息以及禁用或启用角色的功能。这些命令在文档中属于权限和安全管理部分，用于管理用户在TuGraph数据库中的角色和权限设置。"
            },
            {
                "content": "| dbms.security.disableRole             | 禁用/启用角色                               | dbms.security.disableRole(role::STRING,disable::BOOLEAN) :: (::VOID)                                                                                                                    |\n| dbms.security.modRoleDesc             | 修改角色描述信息                              | dbms.security.modRoleDesc(role::STRING,description::STRING) :: (::VOID)                                                                                                                 |\n| dbms.security.rebuildRoleAccessLevel  | 删除角色权限并重建                             | dbms.security.rebuildRoleAccessLevel(role::STRING,access_level::MAP) :: (::VOID)                                                                                                        |\n\n该区块包含有关TuGraph-Cypher中角色管理的相关过程，包括禁用/启用角色、修改角色描述信息，以及删除角色权限并重建权限的功能。这些功能帮助用户管理系统内的角色及其相关权限，属于文档的安全性与管理部分。"
            },
            {
                "content": "| dbms.security.rebuildRoleAccessLevel  | 删除角色权限并重建                             | dbms.security.rebuildRoleAccessLevel(role::STRING,access_level::MAP) :: (::VOID)                                                                                                        |\n| dbms.security.modRoleAccessLevel      | 修改角色对指定图的访问权限                         | dbms.security.modRoleAccessLevel(role::STRING,access_level::MAP) :: (::VOID)                                                                                                            |\n| dbms.security.modRoleFieldAccessLevel | 修改角色对指定属性的访问权限                        | dbms.security.modRoleFieldAccessLevel(role::STRING,graph::STRING,label::STRING,field::STRING,label_type::STRING,field_access_level::STRING) :: (::VOID)                                 |\n\n该段落位于文档的“内置procedures完整列表”部分，主要介绍与角色权限管理相关的数据库操作命令，包括重建角色权限、修改角色对指定图的访问权限以及修改角色对指定属性的访问权限。这些操作有助于用户灵活地管理数据库中角色的访问级别和权限定义。"
            },
            {
                "content": "| dbms.security.modRoleFieldAccessLevel | 修改角色对指定属性的访问权限                        | dbms.security.modRoleFieldAccessLevel(role::STRING,graph::STRING,label::STRING,field::STRING,label_type::STRING,field_access_level::STRING) :: (::VOID)                                 |\n| dbms.security.getUserInfo             | 获取用户详细信息                              | dbms.security.getUserInfo(user::STRING) :: (user_info::MAP)                                                                                                                             |\n| dbms.security.disableUser             | 禁用/启用用户                               | dbms.security.disableUser(user::STRING,disable::BOOLEAN) :: (::VOID)                                                                                                                    |\n\n此段落位于文档的“5.2.内置procedures完整列表”部分，具体列出了与用户权限管理和用户信息获取相关的内置过程，包括修改角色对属性的访问权限、获取用户详细信息和禁用或启用用户的命令。这些内容为数据库用户管理提供了重要的操作接口。"
            },
            {
                "content": "| dbms.security.disableUser             | 禁用/启用用户                               | dbms.security.disableUser(user::STRING,disable::BOOLEAN) :: (::VOID)                                                                                                                    |\n| dbms.security.setCurrentDesc          | 设置当前用户描述信息                            | dbms.security.setCurrentDesc(description::STRING) :: (::VOID)                                                                                                                           |\n| dbms.security.setUserDesc             | 设置用户描述信息                              | dbms.security.setUserDesc(user::STRING,description::STRING) :: (::VOID)                                                                                                                 |\n\n该块内容位于文档的“内置procedures完整列表”部分，主要列出与用户管理相关的命令，包括禁用用户、设置当前用户描述信息和设置特定用户描述信息的操作。这些命令涉及数据库安全和用户权限管理的功能。"
            },
            {
                "content": "| dbms.security.setUserDesc             | 设置用户描述信息                              | dbms.security.setUserDesc(user::STRING,description::STRING) :: (::VOID)                                                                                                                 |\n| dbms.security.getUserMemoryUsage      | 获取用户内存用量                              | dbms.security.getUserMemoryUsage(user::STRING) :: (memory_usage::INTEGER)                                                                                                               |\n| dbms.security.setUserMemoryLimit      | 设置用户内存限制                              | dbms.security.setUserMemoryLimit(user::STRING,memorylimit::INTEGER) :: (::VOID)                                                                                                         |\n\n该片段位于文档的“内置程序完整列表”部分，列出了与用户权限和内存管理相关的数据库操作命令，包括设置用户描述、获取用户内存使用情况和设置用户内存限制等功能。这些命令主要用于管理用户的角色和资源分配，确保系统的安全性和稳定性。"
            },
            {
                "content": "| dbms.security.setUserMemoryLimit      | 设置用户内存限制                              | dbms.security.setUserMemoryLimit(user::STRING,memorylimit::INTEGER) :: (::VOID)                                                                                                         |\n| dbms.security.deleteUserRoles         | 删除用户与角色的联系                            | dbms.security.deleteUserRoles(user::STRING,roles::LIST) :: (::VOID)                                                                                                                     |\n| dbms.security.rebuildUserRoles        | 清空用户角色的关系并重建                          | dbms.security.rebuildUserRoles(user::STRING,roles::LIST) :: (::VOID)                                                                                                                    |\n\n该片段位于文档的“5.2.内置procedures完整列表”部分，主要描述有关用户角色管理的数据库操作命令，包括设置用户内存限制、删除用户与角色的联系，以及重建用户角色关系的相关过程。"
            },
            {
                "content": "| dbms.security.rebuildUserRoles        | 清空用户角色的关系并重建                          | dbms.security.rebuildUserRoles(user::STRING,roles::LIST) :: (::VOID)                                                                                                                    |\n| dbms.security.addUserRoles            | 新增用户与角色的联系                            | dbms.security.addUserRoles(user::STRING,roles::LIST) :: (::VOID)                                                                                                                        |\n| db.plugin.loadPlugin                  | 装载plugin                              | db.plugin.loadPlugin(plugin_type::STRING,plugin_name::STRING,plugin_content::STRING or MAP,code_type::STRING,plugin_description::STRING,read_only::BOOLEAN,version::STRING) :: (::VOID) |\n\n该部分内容位于文档的“内置procedures完整列表”章节中，具体介绍了与用户角色管理和插件相关的命令，包括清空用户角色关系、添加用户与角色的联系以及装载插件的操作。这些命令为用户在数据库管理和扩展功能方面提供了详细的指导。"
            },
            {
                "content": "| db.plugin.loadPlugin                  | 装载plugin                              | db.plugin.loadPlugin(plugin_type::STRING,plugin_name::STRING,plugin_content::STRING or MAP,code_type::STRING,plugin_description::STRING,read_only::BOOLEAN,version::STRING) :: (::VOID) |\n| db.plugin.deletePlugin                | 删除plugin                              | db.plugin.deletePlugin(plugin_type::STRING,plugin_name::STRING) :: (::VOID)                                                                                                             |\n| db.plugin.listPlugin                  | 列出已装载的plugin                          | db.plugin.listPlugin(plugin_type::STRING,plugin_version::STRING) :: (plugin_description::LIST)                                                                                          |\n\n该段落位于文档的附录部分，具体介绍了数据库操作命令中的插件管理相关功能，包括加载、删除和列出已装载的插件。这些命令有助于用户扩展数据库的功能和管理插件。"
            },
            {
                "content": "| db.plugin.listPlugin                  | 列出已装载的plugin                          | db.plugin.listPlugin(plugin_type::STRING,plugin_version::STRING) :: (plugin_description::LIST)                                                                                          |\n| db.plugin.getPluginInfo               | 获取plugin的详细信息                         | db.plugin.getPluginInfo(plugin_type::STRING,plugin_name::STRING,show_code::BOOLEAN)::(plugin_description::MAP)                                                                          |\n| db.plugin.callPlugin                  | 执行plugin                              | db.plugin.callPlugin(plugin_type::STRING,plugin_name::STRING,param::STRING,timeout::DOUBLE,in_process::BOOLEAN) :: (success::BOOLEAN,result::STRING)                                    |\n\n该段内容位于文档的内置procedures完整列表部分，具体列出了与插件相关的操作命令，包括列出已装载的插件、获取插件详细信息以及执行插件的功能和签名。这些命令有助于用户管理和使用数据库中的插件功能。"
            },
            {
                "content": "| db.plugin.callPlugin                  | 执行plugin                              | db.plugin.callPlugin(plugin_type::STRING,plugin_name::STRING,param::STRING,timeout::DOUBLE,in_process::BOOLEAN) :: (success::BOOLEAN,result::STRING)                                    |\n| db.importor.dataImportor              | 导入点或边数据                               | db.importor.dataImportor(description::STRING,content::STRING,continue_on_error::BOOLEAN,thread_nums::INTEGER,delimiter::STRING) :: (::VOID)                                             |\n| db.importor.schemaImportor            | 导入点或边schema                           | db.importor.schemaImportor(description::STRING) :: (::VOID)                                                                                                                             |\n\n该片段位于文档的“内置procedures完整列表”部分，具体列出了与插件操作和数据导入相关的命令，包括执行插件、导入点或边数据及导入schema的功能及其签名。这些操作对于用户在图数据库中处理和管理数据至关重要。"
            },
            {
                "content": "| db.importor.schemaImportor            | 导入点或边schema                           | db.importor.schemaImportor(description::STRING) :: (::VOID)                                                                                                                             |\n| db.addFullTextIndex                   | 添加全文索引                                | db.addFullTextIndex(is_vertex::BOOLEAN, label_name::STRING, field_name::STRING) :: (::VOID)                                                                                             |\n| db.deleteFullTextIndex                | 删除全文索引                                | db.deleteFullTextIndex(is_vertex::BOOLEAN, label_name::STRING, field_name::STRING) :: (::VOID)                                                                                          |\n\n该片段列出了TuGraph数据库中与全文索引和点或边schema导入相关的操作命令及其描述和签名，属于文档中的内置过程列表部分，用于帮助用户理解如何管理数据库中的索引和导入数据结构。"
            },
            {
                "content": "| db.deleteFullTextIndex                | 删除全文索引                                | db.deleteFullTextIndex(is_vertex::BOOLEAN, label_name::STRING, field_name::STRING) :: (::VOID)                                                                                          |\n| db.rebuildFullTextIndex               | 重建全文索引                                | db.rebuildFullTextIndex(vertex_labels::STRING, edge_labels::STRING) :: (::VOID)                                                                                                         |\n| db.fullTextIndexes                    | 查看全文索引                                | db.fullTextIndexes() :: (is_vertex::BOOLEAN, label::STRING, field::STRING)                                                                                                              |\n\n该块内容位于文档的“内置procedures完整列表”部分，具体描述了与全文索引相关的数据库操作命令，包括删除、重建和查看全文索引的功能及其签名。这部分为用户提供关于全文索引管理的基本操作信息。"
            },
            {
                "content": "| db.fullTextIndexes                    | 查看全文索引                                | db.fullTextIndexes() :: (is_vertex::BOOLEAN, label::STRING, field::STRING)                                                                                                              |\n| dbms.meta.count                       | 查看点边总数                                | db.dbms.meta.count() :: (type::STRING, number::INTEGER)                                                                                                                                 |\n| dbms.meta.countDetail                 | 查看点边总数详情                              | db.dbms.meta.countDetail() :: (is_vertex::BOOLEAN, label::STRING, count::INTEGER)                                                                                                       |\n\n该片段位于文档的第5.2节“内置procedures完整列表”中，列出了与数据库操作相关的命令，包括查看全文索引及统计点边总数的功能，展示了这些命令的具体描述和签名。"
            },
            {
                "content": "| dbms.meta.countDetail                 | 查看点边总数详情                              | db.dbms.meta.countDetail() :: (is_vertex::BOOLEAN, label::STRING, count::INTEGER)                                                                                                       |\n| dbms.meta.refreshCount                | 重新统计点边数量，统计期间停写。                      | db.dbms.meta.refreshCount() :: (::VOID)                                                                                                                                                 |\n| dbms.task.listTasks                   | 查询正在执行的任务                             | dbms.task.listTasks()::(tasks::LIST)                                                                                                                                                    |\n\n该片段位于文档的“内置procedures完整列表”部分，专门列出了与数据库操作相关的命令，涵盖了点和边的计数、统计刷新及查询当前执行任务的功能。这些命令的描述和函数签名有助于用户理解如何管理和监控数据库的状态。"
            },
            {
                "content": "| dbms.task.listTasks                   | 查询正在执行的任务                             | dbms.task.listTasks()::(tasks::LIST)                                                                                                                                                    |\n| dbms.task.terminateTask               | 中止任务                                  | dbms.task.terminateTask(task_id::STRING)::(::VOID)                                                                                                                                      |\n| dbms.ha.clusterInfo                   | HA模式下查看集群状态                           | dbms.ha.clusterInfo() :: (cluster_info::LIST, is_master::BOOLEAN)                                                                                                                       |\n表格内容描述: \n该表格列出了一系列的数据库操作命令及其描述和签名。列名包括“名称”、“描述”和“签名”。\n\n该块内容位于文档的第五部分“附录2. 内置procedures列表”中，具体描述了一些用于查询和管理当前任务及集群状态的数据库操作命令，包括`dbms.task.listTasks`和`dbms.ha.clusterInfo`等，附带了相应的描述和签名。"
            },
            {
                "content": "逐行描述表格中的数据内容如下：\n1. **db.subgraph**：用于列出点的子图，签名为`db.subgraph(vids::LIST) :: (subgraph::STRING)`。\n2. **db.vertexLabels**：列出所有的Vertex Label，签名为`db.vertexLabels() :: (label::STRING)`。\n3. **db.edgeLabels**：列出所有的Edge Label，签名为`db.edgeLabels() :: (edgeLabels::STRING)`。\n4. **db.indexes**：列出所有索引，签名为`db.indexes() :: (label::STRING,field::STRING,label_type:STRING,unique::BOOLEAN,pair_unique::BOOLEAN)`。\n5. **db.listLabelIndexes**：列出所有与某个Label相关的索引，签名为`db.listLabelIndexes(label_name:STRING,label_type:STRING) :: (label::STRING,field::STRING,unique::BOOLEAN,pair_unique::BOOLEAN)`。\n6. **db.warmup**：用于数据预热，签名为`db.warmup() :: (time_used::STRING)`。\n7. **db.createVertexLabel**：创建Vertex Label，签名为`db.createVertexLabel(label_name::STRING,field_specs::LIST) :: (::VOID)`。\n8. **db.createLabel**：创建Vertex/Edge Label，签名为`db.createLabel(label_type::STRING,label_name::STRING,extra::STRING,field_specs::LIST) :: ()`。\n\n该段落位于文档的“5.2.内置procedures完整列表”部分，逐行描述了多个数据库操作命令及其功能，包括如何列出子图、标签和索引，以及创建标签的相关操作。这部分内容旨在提供清晰的命令规范和使用方式，以便用户理解和调用相应的数据库函数。"
            },
            {
                "content": "5. **db.listLabelIndexes**：列出所有与某个Label相关的索引，签名为`db.listLabelIndexes(label_name:STRING,label_type:STRING) :: (label::STRING,field::STRING,unique::BOOLEAN,pair_unique::BOOLEAN)`。\n6. **db.warmup**：用于数据预热，签名为`db.warmup() :: (time_used::STRING)`。\n7. **db.createVertexLabel**：创建Vertex Label，签名为`db.createVertexLabel(label_name::STRING,field_specs::LIST) :: (::VOID)`。\n8. **db.createLabel**：创建Vertex/Edge Label，签名为`db.createLabel(label_type::STRING,label_name::STRING,extra::STRING,field_specs::LIST) :: ()`。\n9. **db.getLabelSchema**：列出标签 schema，签名为`db.getLabelSchema(label_type::STRING,label_name::STRING) :: (name::STRING,type::STRING,optional::BOOLEAN)`。\n10. **db.getVertexSchema**：列出点的 schema，签名为`db.getVertexSchema(label::STRING) :: (schema::MAP)`。\n11. **db.getEdgeSchema**：列出边的 schema，签名为`db.getEdgeSchema(label::STRING) :: (schema::MAP)`。\n12. **db.deleteLabel**：删除Vertex/Edge Label，签名为`db.deleteLabel(label_type::STRING,label_name::STRING) :: (::VOID)`。\n\n该段落是关于TuGraph数据库操作命令的详细说明，具体涵盖了与标签相关的操作，如列出索引、创建标签、获取标签和模式信息等。这些命令及其签名为用户提供了执行数据库相关操作的指南，适用于数据管理和结构定义。"
            },
            {
                "content": "9. **db.getLabelSchema**：列出标签 schema，签名为`db.getLabelSchema(label_type::STRING,label_name::STRING) :: (name::STRING,type::STRING,optional::BOOLEAN)`。\n10. **db.getVertexSchema**：列出点的 schema，签名为`db.getVertexSchema(label::STRING) :: (schema::MAP)`。\n11. **db.getEdgeSchema**：列出边的 schema，签名为`db.getEdgeSchema(label::STRING) :: (schema::MAP)`。\n12. **db.deleteLabel**：删除Vertex/Edge Label，签名为`db.deleteLabel(label_type::STRING,label_name::STRING) :: (::VOID)`。\n13. **db.alterLabelDelFields**：修改label删除属性，签名为`db.alterLabelDelFields(label_type::STRING,label_name::STRING,del_fields::LIST) :: (record_affected::INTEGER)`。\n14. **db.alterLabelAddFields**：修改label并添加字段，签名为`db.alterLabelAddFields(label_type::STRING,label_name::STRING,add_field_spec_values::LIST) :: (record_affected::INTEGER)`。\n15. **db.alterLabelModFields**：修改label字段，签名为`db.alterLabelModFields(label_type::STRING,label_name::STRING,mod_field_specs::LIST) :: (record_affected::INTEGER)`。\n\n该段落位于文档的5.1节“procedures样例”中，具体描述了与标签相关的多种操作命令，包括获取标签的schema、列出点和边的schema、删除标签以及修改标签的字段等。这些命令的签名和功能提供了用户在使用TuGraph时进行标签管理的参考。"
            },
            {
                "content": "13. **db.alterLabelDelFields**：修改label删除属性，签名为`db.alterLabelDelFields(label_type::STRING,label_name::STRING,del_fields::LIST) :: (record_affected::INTEGER)`。\n14. **db.alterLabelAddFields**：修改label并添加字段，签名为`db.alterLabelAddFields(label_type::STRING,label_name::STRING,add_field_spec_values::LIST) :: (record_affected::INTEGER)`。\n15. **db.alterLabelModFields**：修改label字段，签名为`db.alterLabelModFields(label_type::STRING,label_name::STRING,mod_field_specs::LIST) :: (record_affected::INTEGER)`。\n16. **db.createEdgeLabel**：创建Edge Label，签名为`db.createEdgeLabel(type_name::STRING,field_specs::LIST) :: (::VOID)`。\n17. **db.addIndex**：创建索引，签名为`db.addIndex(label_name::STRING,field_name::STRING,unique::BOOLEAN) :: (::VOID)`。\n18. **db.addEdgeIndex**：创建索引，签名为`db.addEdgeIndex(label_name::STRING,field_name::STRING,unique::BOOLEAN,pair_unique::BOOLEAN) :: (::VOID)`。\n19. **db.addVertexCompositeIndex**：创建组合索引，签名为`db.addVertexCompositeIndex(label_name::STRING,field_names::LIST,unique::BOOLEAN) :: (::VOID)`。\n\n该块内容位于文档的“内置procedures完整列表”部分，详细描述了一系列针对标签和索引操作的数据库命令，包括修改标签的字段、创建边标签以及添加索引等功能。这些命令的签名格式提供了使用时所需的参数信息，便于用户在进行数据库操作时查找和理解相关功能。"
            },
            {
                "content": "16. **db.createEdgeLabel**：创建Edge Label，签名为`db.createEdgeLabel(type_name::STRING,field_specs::LIST) :: (::VOID)`。\n17. **db.addIndex**：创建索引，签名为`db.addIndex(label_name::STRING,field_name::STRING,unique::BOOLEAN) :: (::VOID)`。\n18. **db.addEdgeIndex**：创建索引，签名为`db.addEdgeIndex(label_name::STRING,field_name::STRING,unique::BOOLEAN,pair_unique::BOOLEAN) :: (::VOID)`。\n19. **db.addVertexCompositeIndex**：创建组合索引，签名为`db.addVertexCompositeIndex(label_name::STRING,field_names::LIST,unique::BOOLEAN) :: (::VOID)`。\n20. **db.deleteIndex**：删除索引，签名为`db.deleteIndex(label_name::STRING,field_name::STRING) :: (::VOID)`。\n21. **db.deleteCompositeIndex**：删除组合索引，签名为`db.deleteIndex(label_name::STRING,field_names::LIST) :: (::VOID)`。\n22. **db.backup**：备份数据，签名为`db.backup(destination::STRING) :: ()`。\n23. **dbms.procedures**：列出所有procedures，签名为`dbms.procedures() :: (name::STRING,signature::STRING)`。\n24. **dbms.security.changePassword**：更改当前用户的密码，签名为`dbms.security.changePassword(current_password::STRING,new_password::STRING) :: (::VOID)`。\n\n此段落位于文档的“内置procedures完整列表”部分，详细列出了一系列用于数据库操作的命令，包括创建和删除标签、索引，以及备份数据的相关过程。每个命令都附有签名信息，便于用户理解其用法和功能。"
            },
            {
                "content": "21. **db.deleteCompositeIndex**：删除组合索引，签名为`db.deleteIndex(label_name::STRING,field_names::LIST) :: (::VOID)`。\n22. **db.backup**：备份数据，签名为`db.backup(destination::STRING) :: ()`。\n23. **dbms.procedures**：列出所有procedures，签名为`dbms.procedures() :: (name::STRING,signature::STRING)`。\n24. **dbms.security.changePassword**：更改当前用户的密码，签名为`dbms.security.changePassword(current_password::STRING,new_password::STRING) :: (::VOID)`。\n25. **dbms.security.changeUserPassword**：更改指定用户的密码，签名为`dbms.security.changeUserPassword(user_name::STRING,new_password::STRING) :: (::VOID)`。\n26. **dbms.security.createUser**：创建用户，签名为`dbms.security.createUser(user_name::STRING,password::STRING) :: (::VOID)`。\n27. **dbms.security.deleteUser**：删除用户，签名为`dbms.security.deleteUser(user_name::STRING) :: (::VOID)`。\n28. **dbms.security.listUsers**：列出所有用户，签名为`dbms.security.listUsers() :: (user_name::STRING,user_info::MAP)`。\n29. **dbms.security.showCurrentUser**：列出当前用户信息，签名为`dbms.security.showCurrentUser() :: (current_user::STRING)`。\n\n该片段位于文档的最后部分，具体涵盖了数据库管理系统的安全性和用户管理相关的命令，包括用户密码的更改、用户的创建与删除，以及列出所有用户的信息。这些操作命令与数据库的安全及权限管理密切相关，为用户提供了对数据库安全控制的深入了解。"
            },
            {
                "content": "26. **dbms.security.createUser**：创建用户，签名为`dbms.security.createUser(user_name::STRING,password::STRING) :: (::VOID)`。\n27. **dbms.security.deleteUser**：删除用户，签名为`dbms.security.deleteUser(user_name::STRING) :: (::VOID)`。\n28. **dbms.security.listUsers**：列出所有用户，签名为`dbms.security.listUsers() :: (user_name::STRING,user_info::MAP)`。\n29. **dbms.security.showCurrentUser**：列出当前用户信息，签名为`dbms.security.showCurrentUser() :: (current_user::STRING)`。\n30. **dbms.security.getUserPermissions**：列出指定用户的权限，签名为`dbms.security.getUserPermissions(user_name::STRING) :: (user_info::MAP)`。\n31. **dbms.graph.createGraph**：创建子图，签名为`dbms.graph.createGraph(graph_name::STRING, description::STRING, max_size_GB::INTEGER) :: (::VOID)`。\n32. **dbms.graph.modGraph**：修改子图属性，签名为`dbms.graph.modGraph(graph_name::STRING,config::MAP) :: (::VOID)`。\n33. **dbms.graph.deleteGraph**：删除子图，签名为`dbms.graph.deleteGraph(graph_name::STRING) :: (::VOID)`。\n34. **dbms.graph.listGraphs**：列出所有子图，签名为`dbms.graph.listGraphs() :: (graph_name::STRING,configuration::MAP)`。\n\n此段落位于文档的第5.2节，涵盖了与用户管理及子图创建相关的内置过程，包括创建、删除用户，以及列出用户和当前用户信息的功能，此外，还包括创建、修改和删除子图的操作。这部分内容为用户和图形数据库管理提供了重要的指导。"
            },
            {
                "content": "31. **dbms.graph.createGraph**：创建子图，签名为`dbms.graph.createGraph(graph_name::STRING, description::STRING, max_size_GB::INTEGER) :: (::VOID)`。\n32. **dbms.graph.modGraph**：修改子图属性，签名为`dbms.graph.modGraph(graph_name::STRING,config::MAP) :: (::VOID)`。\n33. **dbms.graph.deleteGraph**：删除子图，签名为`dbms.graph.deleteGraph(graph_name::STRING) :: (::VOID)`。\n34. **dbms.graph.listGraphs**：列出所有子图，签名为`dbms.graph.listGraphs() :: (graph_name::STRING,configuration::MAP)`。\n35. **dbms.graph.getGraphInfo**：列出指定子图的信息，签名为`dbms.graph.getGraphInfo(graph_name::STRING)::(graph_name::STRING,configuration::MAP)`。\n36. **dbms.security.addAllowedHosts**：添加IP到信任列表，签名为`dbms.security.addAllowedHosts(hosts::LIST) :: (num_new::INTEGER)`。\n37. **dbms.security.deleteAllowedHosts**：从信任列表删除IP，签名为`dbms.security.deleteAllowedHosts(hosts::LIST) :: (record_affected::INTEGER)`。\n38. **dbms.security.listAllowedHosts**：列出信任列表中的主机IP，签名为`dbms.security.listAllowedHosts() :: (host::STRING)`。\n\n该段落位于文档的第五部分，涉及TuGraph的内置过程（procedures）列表，具体描述了与图操作相关的命令，如创建、修改、删除子图，以及列出图的信息。这部分内容为用户提供了管理图形数据库的基本操作函数，以便于在实际使用中进行数据管理和配置调整。"
            },
            {
                "content": "35. **dbms.graph.getGraphInfo**：列出指定子图的信息，签名为`dbms.graph.getGraphInfo(graph_name::STRING)::(graph_name::STRING,configuration::MAP)`。\n36. **dbms.security.addAllowedHosts**：添加IP到信任列表，签名为`dbms.security.addAllowedHosts(hosts::LIST) :: (num_new::INTEGER)`。\n37. **dbms.security.deleteAllowedHosts**：从信任列表删除IP，签名为`dbms.security.deleteAllowedHosts(hosts::LIST) :: (record_affected::INTEGER)`。\n38. **dbms.security.listAllowedHosts**：列出信任列表中的主机IP，签名为`dbms.security.listAllowedHosts() :: (host::STRING)`。\n39. **dbms.config.update**：更新TuGraph配置，签名为`dbms.config.update(updates::MAP) :: (message::STRING)`。\n40. **dbms.config.list**：列出TuGraph配置，签名为`dbms.config.list() :: (name::STRING,value::ANY)`。\n41. **algo.shortestPath**：查询两个点间的最短路径，签名为`algo.shortestPath(startNode::NODE,endNode::NODE,config::MAP) :: (nodeCount::INTEGER,totalCost::FLOAT)`。\n42. **algo.allShortestPaths**：查询两个点间的所有最短路径，签名为`algo.allShortestPaths(startNode::NODE,endNode::NODE,config::MAP) :: (nodeIds::LIST,relationshipIds::LIST,cost::LIST)`。\n\n该部分内容位于文档的函数章中，详细列出了数据库操作命令及其描述和签名。其中，涵盖了关于获取子图信息、处理IP信任列表、更新和列出TuGraph配置，以及查询最短路径的相关函数。这些函数为用户在操作和管理数据库时提供了必要的支持和指导。"
            },
            {
                "content": "39. **dbms.config.update**：更新TuGraph配置，签名为`dbms.config.update(updates::MAP) :: (message::STRING)`。\n40. **dbms.config.list**：列出TuGraph配置，签名为`dbms.config.list() :: (name::STRING,value::ANY)`。\n41. **algo.shortestPath**：查询两个点间的最短路径，签名为`algo.shortestPath(startNode::NODE,endNode::NODE,config::MAP) :: (nodeCount::INTEGER,totalCost::FLOAT)`。\n42. **algo.allShortestPaths**：查询两个点间的所有最短路径，签名为`algo.allShortestPaths(startNode::NODE,endNode::NODE,config::MAP) :: (nodeIds::LIST,relationshipIds::LIST,cost::LIST)`。\n43. **algo.native.extract**：查询指定VertexId/EdgeUid指定field的值，签名为`algo.native.extract(id::ANY,config::MAP) :: (value::ANY)`。\n44. **db.flushDB**：刷新数据库，签名为`db.flushDB() :: (::VOID)`。\n45. **dbms.security.listRoles**：列出所有角色，签名为`dbms.security.listRoles() :: (role_name::STRING,role_info::MAP)`。\n46. **dbms.security.createRole**：创建角色，签名为`dbms.security.createRole(role_name::STRING,desc::STRING) :: (::VOID)`。\n47. **dbms.security.deleteRole**：删除角色，签名为`dbms.security.deleteRole(role_name::STRING) :: (::VOID)`。\n\n该块内容位于文档的“内置procedures完整列表”部分，列出了TuGraph中可用的数据库操作命令及其签名，包括更新配置、查询最短路径、刷新数据库以及角色管理等功能，便于用户的快速参考和查找。"
            },
            {
                "content": "43. **algo.native.extract**：查询指定VertexId/EdgeUid指定field的值，签名为`algo.native.extract(id::ANY,config::MAP) :: (value::ANY)`。\n44. **db.flushDB**：刷新数据库，签名为`db.flushDB() :: (::VOID)`。\n45. **dbms.security.listRoles**：列出所有角色，签名为`dbms.security.listRoles() :: (role_name::STRING,role_info::MAP)`。\n46. **dbms.security.createRole**：创建角色，签名为`dbms.security.createRole(role_name::STRING,desc::STRING) :: (::VOID)`。\n47. **dbms.security.deleteRole**：删除角色，签名为`dbms.security.deleteRole(role_name::STRING) :: (::VOID)`。\n48. **dbms.security.getRoleInfo**：获取角色详细信息，签名为`dbms.security.getRoleInfo(role::STRING) :: (role_info::MAP)`。\n49. **dbms.security.disableRole**：禁用或启用角色，签名为`dbms.security.disableRole(role::STRING,disable::BOOLEAN) :: (::VOID)`。\n50. **dbms.security.modRoleDesc**：修改角色描述信息，签名为`dbms.security.modRoleDesc(role::STRING,description::STRING) :: (::VOID)`。\n51. **dbms.security.rebuildRoleAccessLevel**：删除角色权限并重建，签名为`dbms.security.rebuildRoleAccessLevel(role::STRING,access_level::MAP) :: (::VOID)`。\n\n该段落位于文档的“内置procedures完整列表”部分，主要介绍了与角色管理相关的命令，包括角色的创建、删除、禁用、描述修改以及角色访问权限的重建等操作。这些命令为用户提供了对角色权限和信息的管理功能，适用于 TuGraph 数据库的安全设置与配置。"
            },
            {
                "content": "48. **dbms.security.getRoleInfo**：获取角色详细信息，签名为`dbms.security.getRoleInfo(role::STRING) :: (role_info::MAP)`。\n49. **dbms.security.disableRole**：禁用或启用角色，签名为`dbms.security.disableRole(role::STRING,disable::BOOLEAN) :: (::VOID)`。\n50. **dbms.security.modRoleDesc**：修改角色描述信息，签名为`dbms.security.modRoleDesc(role::STRING,description::STRING) :: (::VOID)`。\n51. **dbms.security.rebuildRoleAccessLevel**：删除角色权限并重建，签名为`dbms.security.rebuildRoleAccessLevel(role::STRING,access_level::MAP) :: (::VOID)`。\n52. **dbms.security.modRoleAccessLevel**：修改角色对指定图的访问权限，签名为`dbms.security.modRoleAccessLevel(role::STRING,access_level::MAP) :: (::VOID)`。\n53. **dbms.security.modRoleFieldAccessLevel**：修改角色对指定属性的访问权限，签名为`dbms.security.modRoleFieldAccessLevel(role::STRING,graph::STRING,label::STRING,field::STRING,label_type::STRING,field_access_level::STRING) :: (::VOID)`。\n54. **dbms.security.getUserInfo**：获取用户详细信息，签名为`dbms.security.getUserInfo(user::STRING) :: (user_info::MAP)`。\n\n该段落位于文档的“内置procedures完整列表”部分，具体集中于与角色管理和用户信息获取相关的操作命令，包括获取角色详细信息、禁用或启用角色、修改角色描述、重建角色访问权限、修改角色对图的访问权限、以及获取用户详细信息的相关签名。这些命令用于增强数据库的安全性和用户管理功能。"
            },
            {
                "content": "52. **dbms.security.modRoleAccessLevel**：修改角色对指定图的访问权限，签名为`dbms.security.modRoleAccessLevel(role::STRING,access_level::MAP) :: (::VOID)`。\n53. **dbms.security.modRoleFieldAccessLevel**：修改角色对指定属性的访问权限，签名为`dbms.security.modRoleFieldAccessLevel(role::STRING,graph::STRING,label::STRING,field::STRING,label_type::STRING,field_access_level::STRING) :: (::VOID)`。\n54. **dbms.security.getUserInfo**：获取用户详细信息，签名为`dbms.security.getUserInfo(user::STRING) :: (user_info::MAP)`。\n55. **dbms.security.disableUser**：禁用或启用用户，签名为`dbms.security.disableUser(user::STRING,disable::BOOLEAN) :: (::VOID)`。\n56. **dbms.security.setCurrentDesc**：设置当前用户描述信息，签名为`dbms.security.setCurrentDesc(description::STRING) :: (::VOID)`。\n57. **dbms.security.setUserDesc**：设置用户描述信息，签名为`dbms.security.setUserDesc(user::STRING,description::STRING) :: (::VOID)`。\n58. **dbms.security.getUserMemoryUsage**：获取用户内存用量，签名为`dbms.security.getUserMemoryUsage(user::STRING) :: (memory_usage::INTEGER)`。\n\n该块内容位于文档的“内置procedures完整列表”部分，详细介绍了与用户权限和安全管理相关的数据库操作命令，包括修改角色访问权限、获取用户信息、禁用用户、设置用户描述信息及获取用户内存使用情况等功能。"
            },
            {
                "content": "55. **dbms.security.disableUser**：禁用或启用用户，签名为`dbms.security.disableUser(user::STRING,disable::BOOLEAN) :: (::VOID)`。\n56. **dbms.security.setCurrentDesc**：设置当前用户描述信息，签名为`dbms.security.setCurrentDesc(description::STRING) :: (::VOID)`。\n57. **dbms.security.setUserDesc**：设置用户描述信息，签名为`dbms.security.setUserDesc(user::STRING,description::STRING) :: (::VOID)`。\n58. **dbms.security.getUserMemoryUsage**：获取用户内存用量，签名为`dbms.security.getUserMemoryUsage(user::STRING) :: (memory_usage::INTEGER)`。\n59. **dbms.security.setUserMemoryLimit**：设置用户内存限制，签名为`dbms.security.setUserMemoryLimit(user::STRING,memorylimit::INTEGER) :: (::VOID)`。\n60. **dbms.security.deleteUserRoles**：删除用户与角色的关联，签名为`dbms.security.deleteUserRoles(user::STRING,roles::LIST) :: (::VOID)`。\n61. **dbms.security.rebuildUserRoles**：清空用户角色的关系并重建，签名为`dbms.security.rebuildUserRoles(user::STRING,roles::LIST) :: (::VOID)`。\n62. **dbms.security.addUserRoles**：新增用户与角色的关系，签名为`dbms.security.addUserRoles(user::STRING,roles::LIST) :: (::VOID)`。\n\n该段落位于文档的第五部分“内置procedures完整列表”中，具体列出了与用户管理相关的过程，包括禁用用户、设置用户描述、获取用户内存用量、设置用户内存限制及用户角色管理的相关命令。这些命令的签名提供了用户在使用TuGraph时的功能扩展与操作指引。"
            },
            {
                "content": "59. **dbms.security.setUserMemoryLimit**：设置用户内存限制，签名为`dbms.security.setUserMemoryLimit(user::STRING,memorylimit::INTEGER) :: (::VOID)`。\n60. **dbms.security.deleteUserRoles**：删除用户与角色的关联，签名为`dbms.security.deleteUserRoles(user::STRING,roles::LIST) :: (::VOID)`。\n61. **dbms.security.rebuildUserRoles**：清空用户角色的关系并重建，签名为`dbms.security.rebuildUserRoles(user::STRING,roles::LIST) :: (::VOID)`。\n62. **dbms.security.addUserRoles**：新增用户与角色的关系，签名为`dbms.security.addUserRoles(user::STRING,roles::LIST) :: (::VOID)`。\n63. **db.plugin.loadPlugin**：装载plugin，签名为`db.plugin.loadPlugin(plugin_type::STRING,plugin_name::STRING,plugin_content::STRING or MAP,code_type::STRING,plugin_description::STRING,read_only::BOOLEAN,version::STRING) :: (::VOID)`。\n64. **db.plugin.deletePlugin**：删除plugin，签名为`db.plugin.deletePlugin(plugin_type::STRING,plugin_name::STRING) :: (::VOID)`。\n65. **db.plugin.listPlugin**：列出已装载的plugin，签名为`db.plugin.listPlugin(plugin_type::STRING,plugin_version::STRING) :: (plugin_description::LIST)`。\n\n该段落位于文档的“内置procedures完整列表”部分，涉及与用户权限管理和插件操作相关的命令，具体包括设置用户内存限制、管理用户与角色的关系，以及装载和删除插件的操作。"
            },
            {
                "content": "63. **db.plugin.loadPlugin**：装载plugin，签名为`db.plugin.loadPlugin(plugin_type::STRING,plugin_name::STRING,plugin_content::STRING or MAP,code_type::STRING,plugin_description::STRING,read_only::BOOLEAN,version::STRING) :: (::VOID)`。\n64. **db.plugin.deletePlugin**：删除plugin，签名为`db.plugin.deletePlugin(plugin_type::STRING,plugin_name::STRING) :: (::VOID)`。\n65. **db.plugin.listPlugin**：列出已装载的plugin，签名为`db.plugin.listPlugin(plugin_type::STRING,plugin_version::STRING) :: (plugin_description::LIST)`。\n66. **db.plugin.getPluginInfo**：获取plugin的详细信息，签名为`db.plugin.getPluginInfo(plugin_type::STRING,plugin_name::STRING,show_code::BOOLEAN)::(plugin_description::MAP)`。\n67. **db.plugin.callPlugin**：执行plugin，签名为`db.plugin.callPlugin(plugin_type::STRING,plugin_name::STRING,param::STRING,timeout::DOUBLE,in_process::BOOLEAN) :: (success::BOOLEAN,result::STRING)`。\n\n该章节主要介绍了TuGraph数据库中与插件相关的操作命令，包括插件的加载、删除、列出、获取详细信息以及执行插件的方法，提供了相应的函数签名和用途描述。"
            },
            {
                "content": "65. **db.plugin.listPlugin**：列出已装载的plugin，签名为`db.plugin.listPlugin(plugin_type::STRING,plugin_version::STRING) :: (plugin_description::LIST)`。\n66. **db.plugin.getPluginInfo**：获取plugin的详细信息，签名为`db.plugin.getPluginInfo(plugin_type::STRING,plugin_name::STRING,show_code::BOOLEAN)::(plugin_description::MAP)`。\n67. **db.plugin.callPlugin**：执行plugin，签名为`db.plugin.callPlugin(plugin_type::STRING,plugin_name::STRING,param::STRING,timeout::DOUBLE,in_process::BOOLEAN) :: (success::BOOLEAN,result::STRING)`。\n68. **db.importor.dataImportor**：导入点或边数据，签名为`db.importor.dataImportor(description::STRING,content::STRING,continue_on_error::BOOLEAN,thread_nums::INTEGER,delimiter::STRING) :: (::VOID)`。\n69. **db.importor.schemaImportor**：导入点或边schema，签名为`db.importor.schemaImportor(description::STRING) :: (::VOID)`。\n70. **db.addFullTextIndex**：添加全文索引，签名为`db.addFullTextIndex(is_vertex::BOOLEAN, label_name::STRING, field_name::STRING) :: (::VOID)`。\n\n该块内容位于文档的第五章“附录2. 内置procedures列表”中，具体涵盖了与插件操作和数据导入相关的内置过程的概述，包括列出已装载插件、获取插件详细信息、调用插件以及导入数据和schema的功能。这些命令和对应的签名为用户提供了处理插件和数据导入的操作指南。"
            },
            {
                "content": "68. **db.importor.dataImportor**：导入点或边数据，签名为`db.importor.dataImportor(description::STRING,content::STRING,continue_on_error::BOOLEAN,thread_nums::INTEGER,delimiter::STRING) :: (::VOID)`。\n69. **db.importor.schemaImportor**：导入点或边schema，签名为`db.importor.schemaImportor(description::STRING) :: (::VOID)`。\n70. **db.addFullTextIndex**：添加全文索引，签名为`db.addFullTextIndex(is_vertex::BOOLEAN, label_name::STRING, field_name::STRING) :: (::VOID)`。\n71. **db.deleteFullTextIndex**：删除全文索引，签名为`db.deleteFullTextIndex(is_vertex::BOOLEAN, label_name::STRING, field_name::STRING) :: (::VOID)`。\n72. **db.rebuildFullTextIndex**：重建全文索引，签名为`db.rebuildFullTextIndex(vertex_labels::STRING, edge_labels::STRING) :: (::VOID)`。\n73. **db.fullTextIndexes**：查看全文索引，签名为`db.fullTextIndexes() :: (is_vertex::BOOLEAN, label::STRING, field::STRING)`。\n74. **dbms.meta.count**：查看点边总数，签名为`db.dbms.meta.count() :: (type::STRING, number::INTEGER)`。\n\n这一段内容位于文档的最后部分，主要列出了与数据导入及全文索引相关的数据库操作命令，涵盖了如何导入点或边数据、导入schema、添加和删除全文索引、重建全文索引以及查看全文索引的功能，旨在为用户提供在数据管理方面的有效操作指南。"
            },
            {
                "content": "71. **db.deleteFullTextIndex**：删除全文索引，签名为`db.deleteFullTextIndex(is_vertex::BOOLEAN, label_name::STRING, field_name::STRING) :: (::VOID)`。\n72. **db.rebuildFullTextIndex**：重建全文索引，签名为`db.rebuildFullTextIndex(vertex_labels::STRING, edge_labels::STRING) :: (::VOID)`。\n73. **db.fullTextIndexes**：查看全文索引，签名为`db.fullTextIndexes() :: (is_vertex::BOOLEAN, label::STRING, field::STRING)`。\n74. **dbms.meta.count**：查看点边总数，签名为`db.dbms.meta.count() :: (type::STRING, number::INTEGER)`。\n75. **dbms.meta.countDetail**：查看点边总数详情，签名为`db.dbms.meta.countDetail() :: (is_vertex::BOOLEAN, label::STRING, count::INTEGER)`。\n76. **dbms.meta.refreshCount**：重新统计点边数量，统计期间停写，签名为`db.dbms.meta.refreshCount() :: (::VOID)`。\n77. **dbms.task.listTasks**：查询正在执行的任务，签名为`dbms.task.listTasks()::(tasks::LIST)`。\n78. **dbms.task.terminateTask**：中止任务，签名为`dbms.task.terminateTask(task_id::STRING)::(::VOID)`。\n79. **dbms.ha.clusterInfo**：HA模式下查看集群状态，签名为`dbms.ha.clusterInfo() :: (cluster_info::LIST, is_master::BOOLEAN)`。\n\n该段落列出了数据库操作相关的命令，具体涵盖了全文索引的管理、元数据统计以及任务管理等功能。每个命令附带详细的描述和签名格式，便于用户理解和使用。"
            },
            {
                "content": "整体内容概要总结：\n该表格提供了一系列数据库操作命令，涵盖了子图、标签、索引、用户与角色管理、插件操作、数据导入及元数据统计等方面。每个命令都有清晰的描述和对应的签名格式，便于用户理解和使用。\n| db.dropDB                             | 清空数据库                                 | db.dropDB() :: (::VOID)                                                                                                                                                                 |\n\n该段落位于文档的最后部分，概述了文档中列出的数据库操作命令的整体内容，涵盖了子图、标签、索引、用户与角色管理、插件操作、数据导入及元数据统计等方面，为用户提供了每个命令的清晰描述和相应的签名格式，便于理解和使用。"
            }
        ]
    },
    {
        "source": "https://raw.githubusercontent.com/theshi-1128/rag_dataset/refs/heads/master/updated_file_172.md",
        "chunks": [
            {
                "content": "# 外滩大会蚂蚁开源大规模图学习系统AGL\n\nAGL（AntGraphLearning）的GitHub 地址：https://github.com/TuGraph-family/TuGraph-AntGraphLearning\n\n\n\n## 1.图：是一种描述和认知世界的方式\n\n图是一种描述和认知世界的方式，它能够表达万物之间的关联，是事物关系的原生表达。基于图进行学习，可以挖掘出事物的内在属性以及事物之间的联系。图的描述能力很强，能够进行高阶严谨的数据建模。在工业界，图学习技术有广泛的应用，如社交推荐、资金风控、企业授信、药物设计等。从 2016 年以来，图学习在各领域都得到了广泛的应用，图学习也成了当下人工智能领域的研究热点之一。\n\n蚂蚁多元化的业务场景在生产经营、风险防控过程中，围绕商户、用户、企业、产品、风险事件等沉淀了海量的图数据和复杂的动态网络关联，自 2016 年开始，蚂蚁机器智能图学习团队持续深耕复杂、异构、动态网络的图学习应用，实现对复杂关系的拓扑感知和长尾稀薄客群的客户画像和风险防控。图学习技术在蚂蚁的业务中也得到了广泛的应用，并取得了优秀的业务成果。\n\n蚂蚁图学习系统极大地提升了蚂蚁业务的效益和效率，如应用于网商银行数字化供应链“大雁”系统，使供应链识别精度提升 50%，贷款可得率从 30% 提升到 80%；应用于支付宝数字开放平台，帮助生态商家提升其权益、供给分发效率超过 50%。\n\n图学习通过机器学习方法对图数据进行分析和建模的一种方法，TuGraph-AntGraphLearning（以下简称为 AGL）是行业首个通用的工业图学习系统，实现了万亿规模图数据上的信息协同和结构感知，构建了多个行业数字化图智能方案，也沉淀了多个优秀的算法实践，发表 CCF-A/B 类国际期刊会议论文 60 余篇，授权发明专利 40 余项，五项国际榜单/竞赛第一，也是图神经网络国家标准的核心参与单位。\n\n2023年9月7日，AGL 外滩大会开源蚂蚁多年打磨的工业级图学习系统和一系列经过业务实践验证的图学习算法，通过开源这些技术和成果，希望为广大开发者提供一个强大的工具和平台，帮助大家更好地应用图学习技术解决实际业务问题，同时通过社区共建，吸收产研优秀的系统与算法实践，持续降低图学习的应用门槛，促进图学习技术的交流和创新，推动图学习在各行各业更的广泛应用。\n\n\n\n## 2. 图学习要做什么？\n\n该文档主要介绍了蚂蚁公司的大规模图学习系统AGL（AntGraphLearning），涵盖图学习的基本概念、蚂蚁在图学习领域的应用和成果，以及AGL的功能、特点与未来发展方向。当前选取的部分重点阐述了图的定义和特性，以及AGL的开源背景和重要性。"
            },
            {
                "content": "图学习通过机器学习方法对图数据进行分析和建模的一种方法，TuGraph-AntGraphLearning（以下简称为 AGL）是行业首个通用的工业图学习系统，实现了万亿规模图数据上的信息协同和结构感知，构建了多个行业数字化图智能方案，也沉淀了多个优秀的算法实践，发表 CCF-A/B 类国际期刊会议论文 60 余篇，授权发明专利 40 余项，五项国际榜单/竞赛第一，也是图神经网络国家标准的核心参与单位。\n\n2023年9月7日，AGL 外滩大会开源蚂蚁多年打磨的工业级图学习系统和一系列经过业务实践验证的图学习算法，通过开源这些技术和成果，希望为广大开发者提供一个强大的工具和平台，帮助大家更好地应用图学习技术解决实际业务问题，同时通过社区共建，吸收产研优秀的系统与算法实践，持续降低图学习的应用门槛，促进图学习技术的交流和创新，推动图学习在各行各业更的广泛应用。\n\n\n\n## 2. 图学习要做什么？\n\n古人云 “物以类聚，人以群分”。那么反过来根据人的关联关系，以及关联的这些人的特征，大致也能够定义一个人是什么样的人。图学习要做的事便是联合图中的结构信息（边，关联关系）以及特征信息（点/边特征）学习出图（点/边）的内在属性，从而应用在推理预测任务中，典型的有节点分类、链接预测、图预测等。\n\n通常可以通过图神经网络进行图学习任务，基本思想是节点汇集邻居信息，并进行聚合得到当前节点的属性信息。通过嵌套多次这样的处理，节点便能汇聚到更远的邻居的信息。由于通过“边”汇聚邻居的信息，这样的方式可以巧妙的将图的结构信息和属性信息结合起来。\n\n## 3.工业级图学习任务有什么特点？\n\n工业场景的复杂性给图学习任务带来巨大挑战。以蚂蚁的图学习任务为例，其特点概括如下：\n\n图数据复杂：典型的图学习业务场景有数十亿点，数百亿边，复杂的业务场景有千亿条边。而图学习过程中，每个点的信息（embedding）依赖其邻居的信息，需要跨节点的数据交换和聚合传播，这样的数据依赖使得图学习难以像经典 DNN 一样进行并行/分布式训练。此外图数据中可能存在丰富的点/边类型，图也可能具有时序动态性。\n\n任务类型复杂：为满足风险防控的实效性、一致性、计算性能要求，图学习需要提供离线全图学习、近线准事实增量预测、在线毫秒级高性能推理等要求，也给图学习的训练和推理提出了更高的要求。\n\n该chunk位于文档的第一部分和第二部分之间，介绍了图学习的概念及其重要性，重点介绍了TuGraph-AntGraphLearning（AGL）作为行业首个通用的工业图学习系统的功能和成就，同时提到2023年AGL开源的背景及其对开发者的支持，接着引入图学习的具体任务及其方法。"
            },
            {
                "content": "通常可以通过图神经网络进行图学习任务，基本思想是节点汇集邻居信息，并进行聚合得到当前节点的属性信息。通过嵌套多次这样的处理，节点便能汇聚到更远的邻居的信息。由于通过“边”汇聚邻居的信息，这样的方式可以巧妙的将图的结构信息和属性信息结合起来。\n\n## 3.工业级图学习任务有什么特点？\n\n工业场景的复杂性给图学习任务带来巨大挑战。以蚂蚁的图学习任务为例，其特点概括如下：\n\n图数据复杂：典型的图学习业务场景有数十亿点，数百亿边，复杂的业务场景有千亿条边。而图学习过程中，每个点的信息（embedding）依赖其邻居的信息，需要跨节点的数据交换和聚合传播，这样的数据依赖使得图学习难以像经典 DNN 一样进行并行/分布式训练。此外图数据中可能存在丰富的点/边类型，图也可能具有时序动态性。\n\n任务类型复杂：为满足风险防控的实效性、一致性、计算性能要求，图学习需要提供离线全图学习、近线准事实增量预测、在线毫秒级高性能推理等要求，也给图学习的训练和推理提出了更高的要求。\n\n因此工业场景中，需要图学习框架能够适应大规模的图数据，具有良好的扩展性，能够表达丰富类型的图数据；同时能够完善提供训练与推理能力，适应工业场景中稳定性，一致性，资源成本等方面的要求。\n\n## 4. AGL如何应对这些挑战\n\nAGL 为工业级大规模图学习任务提供全链路解决方案，包括支撑大规模图学习的离线批量预处理及在线交互式实时采样学习方案。其中，本次开源的离线批量预处理方案，在图表示及样本生成阶段，为了应对工业级图学习任务中复杂而规模庞大的图数据，AGL 支持了同质、异质、动态等图数据类型，设计了 k 阶邻域生成器，预先抽取目标节点的子图信息，从而把大图转换为一个个数据独立的小图。在抽取过程中，AGL 设计了索引和采样机制，通过配置可以实现数值过滤/逻辑过滤，权重采样/Top K 采样等，支持点/边/图级别的图样本生成。AGL 将这些不同种类的图样本通过统一的结构表达出来，把这个关于图的结构与特征的综合体称为 Graph Feature.\n\n该段落包括图神经网络在图学习任务中的基本原理，以及工业级图学习任务的特点和挑战，紧接着阐述了蚂蚁的AGL如何应对这些挑战。它位于文档的第三部分和第四部分之间，主要讨论图学习的复杂性和AGL系统的全链路解决方案。"
            },
            {
                "content": "因此工业场景中，需要图学习框架能够适应大规模的图数据，具有良好的扩展性，能够表达丰富类型的图数据；同时能够完善提供训练与推理能力，适应工业场景中稳定性，一致性，资源成本等方面的要求。\n\n## 4. AGL如何应对这些挑战\n\nAGL 为工业级大规模图学习任务提供全链路解决方案，包括支撑大规模图学习的离线批量预处理及在线交互式实时采样学习方案。其中，本次开源的离线批量预处理方案，在图表示及样本生成阶段，为了应对工业级图学习任务中复杂而规模庞大的图数据，AGL 支持了同质、异质、动态等图数据类型，设计了 k 阶邻域生成器，预先抽取目标节点的子图信息，从而把大图转换为一个个数据独立的小图。在抽取过程中，AGL 设计了索引和采样机制，通过配置可以实现数值过滤/逻辑过滤，权重采样/Top K 采样等，支持点/边/图级别的图样本生成。AGL 将这些不同种类的图样本通过统一的结构表达出来，把这个关于图的结构与特征的综合体称为 Graph Feature.\n\n在图训练和预测阶段，因预先生成的图样本解决了数据依赖问题，图训练可以复用成熟的 DNN 训练方案（如分布式方案 PS，AllReduce 等）。通过图样本解析工具将统一表达的 Graph Feature 解析成模型所需的 点/边 特征矩阵，邻接矩阵等信息。在建模层，用经典的 Encoder-Decoder 的范式描述建模过程，并进行图卷积层、图算法层、图模型层的划分，方便用户复用。图预测过程可以直接使用图样本生成阶段已经生成好的样本，保证训练和预测阶段图样本的一致性。\n\n在图学习算法层面，本次开源也提供一系列经典的开箱即用且业务实践应用过的算法，涵盖异质/同质/动态图等不同算法，对应节点表征/链接预测/自监督等多种任务。同时我们适配了开源算法库（如 PyG）, 减轻用户开发负担。\n\n## 5. AGL 当前开源版本（v0.1）的主要能力\n\nAGL 当前开源版本已经能够支持较大规模复杂图数据的全链路图学习任务。总结起来，AGL 目前主要提供如下能力：\n\n灵活可扩展的图样本生成：基于 Spark 支持大规模图数据k阶邻域生成，解除图学习任务中的数据依赖问题；支持丰富的图类型，如同质、异质、动态等图数据类型；抽取子图过程，支持灵活丰富的过滤与采样能力；支持点/边/图多个级别的图样本生成，并通过统一的 GraphFeature 进行表达。\n\n该块内容位于文档的第三部分，主要讨论工业场景中对图学习框架的需求，以及 AGL 如何应对这些挑战，包括离线批量预处理、图样本生成、训练与预测流程，以及提供的算法能力，强调了系统的灵活性和可扩展性。"
            },
            {
                "content": "在图学习算法层面，本次开源也提供一系列经典的开箱即用且业务实践应用过的算法，涵盖异质/同质/动态图等不同算法，对应节点表征/链接预测/自监督等多种任务。同时我们适配了开源算法库（如 PyG）, 减轻用户开发负担。\n\n## 5. AGL 当前开源版本（v0.1）的主要能力\n\nAGL 当前开源版本已经能够支持较大规模复杂图数据的全链路图学习任务。总结起来，AGL 目前主要提供如下能力：\n\n灵活可扩展的图样本生成：基于 Spark 支持大规模图数据k阶邻域生成，解除图学习任务中的数据依赖问题；支持丰富的图类型，如同质、异质、动态等图数据类型；抽取子图过程，支持灵活丰富的过滤与采样能力；支持点/边/图多个级别的图样本生成，并通过统一的 GraphFeature 进行表达。\n\n简洁易用的图训练与图预测：因预先生成的图样本解决了数据依赖问题，用户可以使用像使用 DNN 的方式一样训练 GNN ，入门简单；使用统一的数据格式表达和解析不同类型，不同级别的图样本，用户只需简单的配置就能支持读取和解析相应的图样本，获得模型所需的点/边 特征矩阵，邻接矩阵等信息，方便易用；图预测过程可以直接使用图样本生成阶段已经生成好的样本，保证训练和预测阶段图样本的一致性。\n\n丰富的图学习算法：用经典的 Encoder-Decoder 范式描述算法建模过程，并进行图卷积层、图算法层、图模型层的划分，可复用性强；提供提供一系列经典的开箱即用且业务实践应用过的算法，涵盖异质/同质/动态图等不同算法，对应节点表征/链接预测/自监督等多种任务；适配开源算法库，减轻开发负担；\n\n目前 AGL 以 Docker 镜像的形式提供全流程的运行环境。即使是在普通PC电脑上，也能方便的基于 AGL 在一些小型图数据上进行图学习任务。\n\n## 6. 未来工作\n\n该段落主要介绍了AGL（AntGraphLearning）开源版本的算法特点与当前能力，涵盖了多种图学习算法及其应用，并强调了系统在图样本生成、训练与预测方面的灵活性和易用性。紧接着的部分将讨论AGL未来的发展方向。"
            },
            {
                "content": "简洁易用的图训练与图预测：因预先生成的图样本解决了数据依赖问题，用户可以使用像使用 DNN 的方式一样训练 GNN ，入门简单；使用统一的数据格式表达和解析不同类型，不同级别的图样本，用户只需简单的配置就能支持读取和解析相应的图样本，获得模型所需的点/边 特征矩阵，邻接矩阵等信息，方便易用；图预测过程可以直接使用图样本生成阶段已经生成好的样本，保证训练和预测阶段图样本的一致性。\n\n丰富的图学习算法：用经典的 Encoder-Decoder 范式描述算法建模过程，并进行图卷积层、图算法层、图模型层的划分，可复用性强；提供提供一系列经典的开箱即用且业务实践应用过的算法，涵盖异质/同质/动态图等不同算法，对应节点表征/链接预测/自监督等多种任务；适配开源算法库，减轻开发负担；\n\n目前 AGL 以 Docker 镜像的形式提供全流程的运行环境。即使是在普通PC电脑上，也能方便的基于 AGL 在一些小型图数据上进行图学习任务。\n\n## 6. 未来工作\n\nAGL 将持续的系统优化和能力创新，并将优秀的系统和算法实践开放到社区，本次开源为 AGL v0.1 版本。未来，AGL 在系统层面未来会开放交互式采样、TuGraph 多引擎联动、复杂图特征计算等，为用户提供高效易用的图学习系统。在图数据表示层面，通过与新一代图谱语义框架（Semantic-enhanced Programmable Graph, SPG）的联动，将复杂的多主体深度关联显性知识化、稀疏关系稠密化，实现数据知识化增强。在推理学习能力上，驱动逻辑规则与图学习的双向驱动，支撑逻辑规则挖掘、规则引导可解释图学习等。欢迎各界同仁一起建设 AGL，推进图学习的技术创新和各领域落地应用。\n\n该段落位于文档的第5部分，介绍了AGL（AntGraphLearning）当前开源版本的主要能力，具体包括图训练与图预测的简便性、丰富的图学习算法以及AGL的运行环境。这部分内容强调了AGL在图学习任务中的易用性和灵活性，为用户提供了相应的支持和工具。"
            }
        ]
    }
]